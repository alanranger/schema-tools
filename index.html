<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unified Schema Generator v4.3 - Smart Enriched Schema Generator (Event ‚Üî Series Backlinking)</title>
  <!-- Deployment: 2025-01-10 - Fresh deploy after clearing queue -->
  <!--
    CHANGELOG v4.1 Product+Event Hybrid Schema Generator
    ====================================================
    
    Event Schema Generator Updates:
    - Changed @type from "Event" to ["Product", "Event"] hybrid (validates with Schema.org)
    - Always adds offers (Google requirement) - logs error if price = 0 (data issue, not fallback)
    - Added SKU to offers object (required for Product+Event hybrid)
    - Removed invalid Event-only fields: thumbnailUrl, eventType, material, courseMode, isFamilyFriendly, learningResourceType
    - Updated validation function to handle Product+Event hybrid schemas
    - Enhanced UI with clear file upload guidance and workflow diagram
    - Added notes about Product+Event hybrid and SKU requirements
    
    Changes from v4.3:
    - Assigned stable @id to every Event and EventSeries
    - Added Event.superEvent ‚Üí EventSeries(@id)
    - Added EventSeries.subEvent ‚Üí [Event(@id)]
    - Extended Field Verification Summary + console debug for linkage
    - Kept v4.2 detection & enrichment intact; no UI changes
    
    CHANGELOG v4.2 Smart Enriched Schema Generator (EventSeries Optimization)
    =========================================================================
    
    Changes from v4.1:
    - Added detectEventSeries() for repeat workshop patterns
    - Groups multi-instance Bluebell & Batsford workshops into EventSeries
    - Adds eventSchedule + subjectOf ItemList linkage
    - Includes grouping summary in console + UI
    
    Changes from v4:
    - Added intelligent region + geo inference for workshops/lessons
    - Added full PostalAddress reconstruction with region map matching
    - Added availabilityStarts and itemCondition for Merchant Center
    - Added performer.sameAs LinkedIn/YouTube links
    - Added courseMode hybrid logic (InPerson/Online detection)
    - Added location verification summary with coverage stats
    - Added UI toggles for enrichment options (location enrichment, availabilityStarts)
    - Enhanced eventType and material fields for SEO context
    
    Changes from v3.5:
    - Enhanced address parsing with full PostalAddress structure (streetAddress, addressLocality, addressRegion, postalCode, addressCountry)
    - Added toggle options: Include Reviews, Include Performer, Group Repeating Events, Include Merchant Center Fields
    - localStorage persistence for toggle states
    - Enhanced organizer/provider blocks with full address and sameAs (Instagram, Facebook, LinkedIn)
    - Enhanced performer block with sameAs link
    - Enhanced offers with hasMerchantReturnPolicy (when merchant fields enabled)
    - Review injection: top 5 reviews trimmed to 300 chars (toggleable)
    - Event schedule grouping: detects repeating weekly events and creates EventSeries with eventSchedule
    - SEO metadata enhancers: potentialAction, isFamilyFriendly, learningResourceType, typicalAgeRange, courseMode, subjectOf
    - Enhanced keywords: combines tags + category + location + topic words
    - "about" field: auto-generated topic summary
    - identifier field: slug from URL
    - sameAs array: event URL + product URL
    - CSV type detection: auto-detects Lessons vs Workshops
    - Enhanced validation summary with statistics (events with reviews, performer, offers)
    - Merchant Center feed export (Phase 6): JSON feed download when toggle enabled
    - Timezone: scheduleTimezone set to "Europe/London" for eventSchedule
    - EventSeries type for superEvent (not Event)
    
    Technical improvements:
    - All processing remains client-side (no server/API calls)
    - Schema Suppressor v1.3 only in Product Schema tab (removed from Event Schema)
    - Empty/invalid fields are omitted (not emitted as empty strings)
    - Past events automatically skipped
    - Offers always included (even free events with price = 0 logged as data error)
  -->
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      margin: 0;
    }
    .container {
      max-width: 95vw;
      width: 100%;
      margin: 0 auto;
      background: white;
      padding: 2.5rem;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.15);
      position: relative;
    }
    .version-badge {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      z-index: 10;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .version-badge .version {
      display: block;
      font-size: 1rem;
    }
    .version-badge .date {
      display: block;
      font-size: 0.75rem;
      opacity: 0.9;
      margin-top: 0.25rem;
    }
    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      color: #2d3748;
      padding-right: 150px;
      font-weight: 700;
    }
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      border-bottom: 2px solid #e2e8f0;
    }
    .tab {
      padding: 0.875rem 1.75rem;
      background: #f7fafc;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      border-radius: 8px 8px 0 0;
      transition: all 0.3s ease;
      color: #4a5568;
      border-bottom: 3px solid transparent;
    }
    .tab:hover {
      background: #edf2f7;
      color: #2d3748;
    }
    .tab.active {
      background: white;
      color: #667eea;
      border-bottom-color: #667eea;
      font-weight: 600;
    }
    .tab-content {
      display: none !important;
      padding: 20px;
      border-top: none;
    }
    .tab-content.active {
      display: block !important;
    }
    .tab-content h2 {
      color: #2d3748;
      font-size: 1.75rem;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }
    .tab-content h3 {
      color: #4a5568;
      font-size: 1.25rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    .tab-content p {
      color: #4a5568;
      line-height: 1.7;
      margin-bottom: 1rem;
    }
    .tab-content ul {
      color: #4a5568;
      line-height: 1.8;
      margin-bottom: 1.5rem;
      padding-left: 1.5rem;
    }
    .tab-content li {
      margin-bottom: 0.5rem;
    }
    .tab-content code {
      background: #f7fafc;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #667eea;
    }
    .instructions {
      background: linear-gradient(135deg, #f6f8fb 0%, #edeff2 100%);
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 1.5rem;
      line-height: 1.7;
      border-left: 4px solid #667eea;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      color: #4a5568;
    }
    .instructions h2 {
      color: #2d3748;
      font-size: 1.75rem;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }
    .instructions h3 {
      color: #4a5568;
      font-size: 1.25rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    .instructions p {
      color: #4a5568;
      margin-bottom: 1rem;
    }
    .instructions ul {
      color: #4a5568;
      margin-bottom: 1.5rem;
      padding-left: 1.5rem;
    }
    .instructions li {
      margin-bottom: 0.5rem;
    }
    .instructions strong {
      display: block;
      margin-bottom: 0.75rem;
      color: #2d3748;
      font-size: 1.1rem;
    }
    /* Ensure Tab Guide is hidden by default and only shows when active */
    #guideTab.tab-content {
      display: none !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
    }
    #guideTab.tab-content.active {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
    }
    #guideTab .instructions {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    .instructions pre {
      background: #ffffff;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.9rem;
      border: 1px solid #e2e8f0;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }
    input[type="file"], select {
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      width: 100%;
      max-width: 400px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      transition: all 0.2s;
      background: white;
    }
    input[type="file"]:hover, select:hover {
      border-color: #667eea;
    }
    input[type="file"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    button {
      margin-top: 1rem;
      padding: 0.875rem 1.75rem;
      font-size: 1rem;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
    }
    button:active {
      transform: translateY(0);
    }
    button.secondary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      box-shadow: 0 4px 12px rgba(245, 87, 108, 0.3);
      margin-left: 0.5rem;
    }
    button.secondary:hover {
      box-shadow: 0 6px 16px rgba(245, 87, 108, 0.4);
    }
    textarea {
      width: 100%;
      height: 400px;
      margin-top: 1rem;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      padding: 1.25rem;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      transition: all 0.2s;
      background: #fafbfc;
      line-height: 1.6;
    }
    textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      background: white;
    }
    pre {
      background: #fafbfc;
      padding: 1.25rem;
      overflow-x: auto;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.6;
    }
    #categoryFilterContainer {
      margin-top: 1rem;
    }
    .test-url-section {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 2px solid #e2e8f0;
    }
    .test-url-section input {
      width: 100%;
      max-width: 600px;
      padding: 0.75rem 1rem;
      margin-right: 0.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s;
    }
    .test-url-section input:hover {
      border-color: #667eea;
    }
    .test-url-section input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    .test-url-section .button-group {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .warning {
      color: #e53e3e;
      font-weight: 600;
    }
    label {
      display: block;
      margin-top: 1.5rem;
      font-weight: 600;
      color: #2d3748;
      font-size: 0.95rem;
    }
    h3 {
      color: #2d3748;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 0.5rem;
    }
    h4 {
      color: #4a5568;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1.5rem;
      background: white;
      border-radius: 8px;
      overflow: visible;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      table-layout: auto;
    }
    .results-table th {
      background: #f7fafc;
      padding: 1rem;
      text-align: left;
      font-weight: 600;
      color: #2d3748;
      border-bottom: 2px solid #e2e8f0;
      white-space: normal;
      line-height: 1.4;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .results-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #fff;
    }
    .filter-row th {
      background: #f9fafb;
      padding: 0.5rem;
    }
    .filter-input {
      width: 100%;
      padding: 0.375rem 0.5rem;
      font-size: 0.875rem;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      background: #fff;
    }
    .filter-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .sortable-header {
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    .sortable-header:hover {
      color: #667eea;
    }
    .sort-indicator {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-left: 0.25rem;
    }
    .sort-indicator.sorted-asc::after {
      content: ' ‚Üë';
      color: #667eea;
    }
    .sort-indicator.sorted-desc::after {
      content: ' ‚Üì';
      color: #667eea;
    }
    .scrollable-container {
      max-height: calc(100vh - 400px);
      min-height: 600px;
      overflow-y: auto;
    }
    .results-table th:nth-child(1) { min-width: 250px; } /* Page URL */
    .results-table th:nth-child(2) { min-width: 200px; } /* Schema Type */
    .results-table th:nth-child(3) { min-width: 80px; max-width: 100px; width: 100px; } /* Status - narrower */
    .results-table th:nth-child(4) { min-width: 220px; } /* Missing Fields - wider */
    .results-table th:nth-child(5) { min-width: 220px; } /* Warnings - wider */
    .results-table th:nth-child(6) { min-width: 220px; } /* Info - wider */
    .results-table th:nth-child(7) { min-width: 140px; max-width: 160px; } /* Rich Results Status (external) */
    .results-table th:nth-child(8) { min-width: 140px; max-width: 160px; } /* Schema.org Status (external) */
    .results-table th:nth-child(9) { min-width: 200px; } /* Notes */
    .results-table th:nth-child(10) { min-width: 280px; } /* Actions */
    
    th:nth-child(4), td:nth-child(4) { background: #fff8f8; }    /* Missing */
    th:nth-child(5), td:nth-child(5) { background: #fffaf2; }    /* Warnings */
    th:nth-child(6), td:nth-child(6) { background: #f4fff7; }    /* Info */
    
    .missing-entry { color: #c00; font-weight: 500; margin: 0.25rem 0; }
    .warning-entry { 
      color: #b47f00; 
      font-weight: 500; 
      margin: 0.125rem 0; 
      font-size: 0.75rem;
      line-height: 1.3;
      max-height: 3rem;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .warning-entry:hover {
      max-height: none;
      overflow: visible;
      -webkit-line-clamp: unset;
    }
    .info-entry { color: #006b3b; font-weight: 500; margin: 0.25rem 0; }
    .status-badge.no-schema {
      background: #e2e8f0;
      color: #4a5568;
    }
    .status-select {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      background: white;
      min-width: 120px;
    }
    .status-select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .notes-textarea {
      width: 100%;
      min-width: 180px;
      max-width: 220px;
      height: 3rem;
      min-height: 2.5rem;
      max-height: 4rem;
      padding: 0.375rem 0.5rem;
      font-size: 0.75rem;
      line-height: 1.3;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-family: inherit;
      resize: vertical;
      overflow-y: auto;
    }
    .notes-textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .save-btn {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      margin: 0.25rem 0;
      background: #48bb78;
      color: white;
    }
    .save-btn:hover {
      background: #38a169;
    }
    .save-btn:disabled {
      background: #a0aec0;
      cursor: not-allowed;
    }
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 1rem 1.5rem;
      background: #48bb78;
      color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10000;
      animation: slideIn 0.3s ease;
    }
    .toast.error {
      background: #e53e3e;
    }
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    .results-table td {
      padding: 0.75rem 1rem;
      vertical-align: top;
    }
    .results-table td:nth-child(1) { 
      white-space: normal; 
      word-break: break-all;
      min-width: 250px;
      max-width: 350px;
    } /* Page URL */
    .results-table td:nth-child(2) { 
      white-space: normal; 
      min-width: 200px;
      max-width: 300px;
    } /* Schema Type */
    .results-table td:nth-child(3) { 
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 80px;
      max-width: 100px;
      width: 100px;
    } /* Status */
    .results-table td:nth-child(3) .status-explanation {
      display: none; /* Hide explanation text to prevent column expansion */
    }
    .results-table td:nth-child(4) { 
      white-space: normal; 
      min-width: 180px;
      max-width: 250px;
    } /* Missing Fields */
    .results-table td:nth-child(5) { 
      white-space: normal; 
      min-width: 150px;
      max-width: 200px;
      font-size: 0.875rem;
      padding: 0.5rem 0.75rem;
      vertical-align: top;
    } /* Warnings */
    .results-table td:nth-child(6) { 
      white-space: normal; 
      min-width: 180px;
      max-width: 250px;
    } /* Info */
    .results-table td.missing-fields {
      white-space: normal;
      min-width: 180px;
      max-width: 250px;
    }
    .results-table td:last-child {
      white-space: normal;
      min-width: 280px;
      width: auto;
    }
    .results-table td:last-child .enhance-btn,
    .results-table td:last-child .save-btn {
      display: inline-block;
      white-space: nowrap;
      margin: 0.25rem 0;
    }
    .results-table tr:hover {
      background: #f9fafb;
    }
    .status-valid {
      color: #38a169;
      font-weight: 600;
    }
    .status-invalid {
      color: #e53e3e;
      font-weight: 600;
    }
    .status-processing {
      color: #667eea;
      font-weight: 600;
    }
    .enhance-btn {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      margin: 0.25rem 0;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 1rem;
    }
    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
    }
    .missing-fields {
      font-size: 0.875rem;
      color: #e53e3e;
    }
    .scrollable-container {
      max-height: calc(100vh - 400px);
      min-height: 600px;
      overflow-y: auto;
      margin-top: 1rem;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      background: #fafbfc;
    }
    .url-link {
      color: #667eea;
      text-decoration: none;
      word-break: break-all;
    }
    .url-link:hover {
      text-decoration: underline;
    }
    .status-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.875rem;
      font-weight: 600;
    }
    .status-badge.valid {
      background: #c6f6d5;
      color: #22543d;
    }
    .status-badge.issues {
      background: #feebc8;
      color: #744210;
    }
    .status-badge.error {
      background: #fed7d7;
      color: #742a2a;
    }
    .status-badge.no-schema {
      background: #e2e8f0;
      color: #4a5568;
    }
    .single-url-section {
      background: #f7fafc;
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 2rem;
      border: 2px solid #e2e8f0;
    }
    .single-url-section label {
      margin-top: 0;
      font-weight: 600;
      color: #2d3748;
    }
    .single-url-section input {
      width: 100%;
      max-width: 600px;
      padding: 0.75rem 1rem;
      margin-top: 0.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
    }
    .help-block {
      background: #f0f7ff;
      border-left: 4px solid #667eea;
      padding: 1rem 1.5rem;
      margin-top: 1.5rem;
      border-radius: 6px;
      cursor: pointer;
    }
    .help-block-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.5rem;
    }
    .help-block-content {
      display: none;
      margin-top: 1rem;
      color: #4a5568;
      line-height: 1.7;
    }
    .help-block-content.active {
      display: block;
    }
    .help-block-icon {
      transition: transform 0.3s ease;
    }
    .help-block.expanded .help-block-icon {
      transform: rotate(180deg);
    }
    .batch-section {
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 2px solid #e2e8f0;
    }
    .progress-wrap {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .progress {
      width: 160px;
      height: 8px;
      background: #eee;
      border-radius: 999px;
      overflow: hidden;
    }
    .progress > span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #7c4dff, #4fc3f7);
      transition: width 0.25s ease;
    }
    .progress-label {
      font-size: 0.85rem;
      color: #555;
      min-width: 72px;
    }
    
    /* --- Row Progress Bars --- */
    .progress {
      position: relative;
      width: 100%;
      height: 6px;
      background: #f0f0f0;
      border-radius: 3px;
      overflow: hidden;
      margin-top: 4px;
      display: block;
    }
    
    .progress-inner {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00b67a, #e57200);
      border-radius: 3px;
      transition: width 0.3s ease;
      max-height: 6px;
    }
    
    /* === Status Badge Styling === */
    .chip-queued {
      background: linear-gradient(90deg, #cfd9df 0%, #e2ebf0 100%);
      color: #555;
      border-radius: 8px;
      padding: 4px 10px;
      font-size: 13px;
      font-weight: 600;
      display: inline-block;
    }
    
    .chip-fetching {
      background: linear-gradient(90deg, #ffe259 0%, #ffa751 100%);
      color: #333;
      border-radius: 8px;
      padding: 4px 10px;
      font-size: 13px;
      font-weight: 600;
      display: inline-block;
    }
    
    .chip-valid {
      background: #27AE60;
      color: white;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    .chip-valid:hover {
      background: #229954;
    }
    
    .chip-critical {
      background: #E74C3C;
      color: white;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    .chip-critical:hover {
      background: #C0392B;
    }
    
    .status-badge.no-schema {
      background: linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%);
      color: #333;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    
    /* Issues Modal */
    .issues-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(20, 20, 33, 0.45);
      align-items: center;
      justify-content: center;
      z-index: 9999;
      border: none;
      padding: 0;
    }
    .issues-backdrop::backdrop {
      background: rgba(20, 20, 33, 0.45);
    }
    .issues-modal {
      width: min(760px, 94vw);
      max-height: 80vh;
      overflow: auto;
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
      padding: 1.25rem 1.5rem;
    }
    .issues-modal h3 {
      margin: 0.2rem 0 0.8rem 0;
      font-size: 1.15rem;
    }
    .issues-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: #1a202c;
      margin: -1.25rem -1.5rem 1rem -1.5rem;
      border-radius: 14px 14px 0 0;
    }
    .issues-modal-header h3 {
      color: #fff;
      margin: 0;
    }
    .issues-close-x {
      background: #fff;
      border: 2px solid #fff;
      font-size: 1.5rem;
      color: #1a202c;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      border-radius: 6px;
      transition: all 0.2s;
      font-weight: bold;
    }
    .issues-close-x:hover {
      background-color: #ef4444;
      color: #fff;
      border-color: #ef4444;
    }
    .issues-close-x:active {
      background-color: #dc2626;
    }
    .issues-meta {
      font-size: 0.9rem;
      color: #555;
      margin: 0.5rem 0 1rem;
    }
    .issues-list {
      margin: 0.25rem 0 0.75rem 1rem;
    }
    .issues-list li {
      margin: 0.2rem 0;
    }
    .issues-json {
      background: #000000 !important;
      color: #ffffff !important;
      border-radius: 10px;
      padding: 0.75rem;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.82rem;
    }
    .gen-enhanced-modal {
      background: #1e293b;
      color: #e2e8f0;
    }
    .gen-enhanced-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: #0f172a;
      margin: -1.25rem -1.5rem 1rem -1.5rem;
      border-radius: 14px 14px 0 0;
      border-bottom: 2px solid #334155;
    }
    .gen-enhanced-header h3 {
      color: #fff;
      margin: 0;
      font-size: 1.15rem;
      font-weight: 600;
    }
    .gen-enhanced-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #334155;
    }
    .gen-copy-btn {
      background: #3b82f6;
      color: #fff;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gen-copy-btn:hover {
      background: #2563eb;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
    .gen-close-btn {
      background: #64748b;
      color: #fff;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gen-close-btn:hover {
      background: #475569;
      box-shadow: 0 4px 12px rgba(100, 116, 139, 0.4);
    }
    .gen-enhanced-modal .issues-meta {
      color: #94a3b8;
    }
    .severity-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      color: white;
    }
    .severity-badge.passed {
      background-color: #10b981;
    }
    .severity-badge.warning {
      background-color: #f59e0b;
    }
    .severity-badge.critical {
      background-color: #ef4444;
    }
    .summary-card {
      padding: 1rem;
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .summary-card pre {
      white-space: pre-wrap;
      font-size: 0.875rem;
      color: #374151;
      margin: 0;
      font-family: inherit;
    }
    .recommended-fix-card {
      padding: 1rem;
      background: #fffbeb;
      border: 1px solid #fbbf24;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .recommended-fix-card h4 {
      font-size: 1rem;
      font-weight: 600;
      color: #92400e;
      margin: 0 0 0.5rem 0;
    }
    .recommended-fix-card p {
      font-size: 0.875rem;
      color: #374151;
      margin: 0 0 0.75rem 0;
    }
    .recommended-fix-textarea {
      width: 100% !important;
      height: 18rem !important;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
      font-size: 0.75rem !important;
      background: #000000 !important;
      color: #ffffff !important;
      padding: 0.75rem !important;
      border-radius: 6px !important;
      border: 1px solid #333 !important;
      resize: vertical;
      overflow: auto;
    }
    .copy-schema-btn {
      margin-top: 0.75rem;
      background: #d97706;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .copy-schema-btn:hover {
      background: #b45309;
    }
    .system-node {
      opacity: 0.5;
      filter: grayscale(0.6);
    }
    .system-node td:first-child::after {
      content: " (Squarespace auto-schema)";
      font-style: italic;
      color: #888;
      margin-left: 0.5rem;
    }
    .help-link {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.75rem;
    }
    .help-link a {
      color: #2563eb;
      text-decoration: underline;
    }
    .help-link a:hover {
      color: #1d4ed8;
    }
    .chip-issues {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #F5B041;
      color: black;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      border: 1px solid #E67E22;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-issues:hover {
      background: #E67E22;
    }
    .chip-issues::after {
      content: " (non-critical)";
      font-size: 0.8em;
      opacity: 0.7;
    }
    .duplicate-warning {
      color: #b47f00;
      font-weight: 500;
    }
    .chip-critical {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #E74C3C;
      color: white;
      border: 1px solid #C0392B;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-critical:hover {
      background: #C0392B;
    }
    .chip-passed {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-passed:hover {
      background: #229954;
    }
    .status-explanation {
      display: inline-block;
      margin-left: 0.75rem;
      font-size: 0.875rem;
      color: #6b7280;
      font-style: italic;
      vertical-align: middle;
    }
    #statusCell_0, #statusCell_1, #statusCell_2, [id^="statusCell_"] {
      white-space: normal;
      line-height: 1.5;
    }
    .status-legend {
      display: flex;
      gap: 1rem;
      margin-bottom: 0.75rem;
      padding: 0.75rem;
      background: #2d3748;
      border-radius: 8px;
      font-size: 0.875rem;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .status-legend-item {
      color: #fff;
    }
    .status-legend-item span:not(.chip-sample):not(.info-entry) {
      color: #e2e8f0;
    }
    .status-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .status-legend-item .chip-sample {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    .chip-sample.passed {
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
    }
    .chip-sample.issues {
      background: #F5B041;
      color: black;
      border: 1px solid #E67E22;
    }
    .chip-sample.critical {
      background: #E74C3C;
      color: white;
      border: 1px solid #C0392B;
    }
    .chip-sample.info {
      background: #5DADE2;
      color: white;
      border: 1px solid #3498DB;
    }
    .chip-info {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #5DADE2;
      color: white;
      border: 1px solid #3498DB;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-info:hover {
      background: #3498DB;
    }
    .chip-ok {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-ok:hover {
      background: #229954;
    }
    .badge {
      display: inline-block;
      padding: 0.15rem 0.4rem;
      border-radius: 0.5rem;
      background: #fff3cd;
      color: #7a5b00;
      border: 1px solid #ffe08a;
      margin: 0.1rem 0.15rem;
      font-size: 0.8rem;
    }
    /* Debug Console Styles */
    .debug-console {
      margin-top: 1.5rem;
      border: 1px solid #cbd5e0;
      border-radius: 8px;
      background: #f7fafc;
      max-height: 400px;
      overflow-y: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
    }
    .debug-console-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #edf2f7;
      border-bottom: 1px solid #cbd5e0;
      border-radius: 8px 8px 0 0;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .debug-console-actions {
      display: flex;
      gap: 0.5rem;
    }
    .debug-console-content {
      padding: 1rem;
      line-height: 1.6;
      color: #2d3748;
    }
    .debug-log-entry {
      margin: 0.25rem 0;
      padding: 0.25rem 0.5rem;
      border-left: 3px solid #4299e1;
      background: #fff;
    }
    .debug-log-entry.error {
      border-left-color: #f56565;
      background: #fed7d7;
    }
    .debug-log-entry.warn {
      border-left-color: #ed8936;
      background: #feebc8;
    }
    .debug-log-entry.success {
      border-left-color: #48bb78;
      background: #c6f6d5;
    }
    .debug-log-time {
      color: #718096;
      font-size: 0.75rem;
      margin-right: 0.5rem;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Modal styling */
    #detail-modal { position: fixed; inset: 0; z-index: 9999; }
    #detail-modal .modal-backdrop { position:absolute; inset:0; background:rgba(0,0,0,.45); }
    #detail-modal .modal { position: absolute; top: 8%; left: 50%; transform: translateX(-50%); width: min(1100px, 92vw); background:#fff; border-radius:12px; box-shadow: 0 10px 40px rgba(0,0,0,.2); }
    #detail-modal .modal-head { display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid #eee; }
    #detail-modal .modal-body { padding:18px; max-height:70vh; overflow:auto; }
    #detail-modal #modal-close { background:none; border:none; font-size:1.5rem; cursor:pointer; padding:0; width:30px; height:30px; display:flex; align-items:center; justify-content:center; }
    #detail-modal #modal-close:hover { color:#f00; }
    .code-card { border:1px solid #eee; border-radius:10px; margin-bottom:12px; }
    .code-card-head { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; background:#fafafa; border-bottom:1px solid #eee; }
    .code-card pre { margin:0; padding:12px; overflow:auto; background:#000; color:#fff; border-radius:0 0 10px 10px; font-family:'Courier New', monospace; }
    .code-card pre code { color:#fff; }
    .code-card .copy-btn { background:#2563eb; color:#fff; border:none; padding:0.375rem 0.75rem; border-radius:4px; cursor:pointer; font-size:0.875rem; }
    .code-card .copy-btn:hover { background:#1d4ed8; }
    .grid.grid-two { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 768px) {
      .grid.grid-two { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="version-badge">
    <span class="version">v4.3</span>
    <span class="date">Smart Enriched Schema Generator ‚Äî Event ‚Üî Series Backlinking</span>
  </div>
  <h1>Unified Schema Generator - Events & Products</h1>

  <div class="tabs">
    <button class="tab active" onclick="switchTab('event')">Event Schema</button>
    <button class="tab" onclick="switchTab('product')">Product Schema</button>
    <button class="tab" onclick="switchTab('blog')">Blog Index Schema</button>
    <button class="tab" onclick="switchTab('landing')">Landing / Service Pages</button>
    <button class="tab" onclick="switchTab('validator')">Schema Validator</button>
    <button class="tab" onclick="switchTab('guide')">üß† Tab Guide</button>
  </div>

  <!-- Event Tab Content -->
  <div id="eventTab" class="tab-content active">
    <div class="instructions">
      <strong>üìÖ Event Schema Generator v4.1 - Product+Event Hybrid Schema Generator</strong><br>
      <strong>What it does:</strong> Generates Schema.org compliant JSON-LD for workshops and courses using Product+Event hybrid schema (workshops/courses are both products AND events).<br><br>
      
      <strong>üìã Required Files:</strong><br>
      <strong>1. Event CSV File (Required):</strong><br>
      ‚Ä¢ Export from Squarespace Events ‚Üí <code>events_export.csv</code><br>
      ‚Ä¢ Must include: <code>Event_Title</code>, <code>Start_Date</code>, <code>Start_Time</code>, <code>End_Date</code>, <code>End_Time</code>, <code>Event_URL</code>, <code>Event_Image</code>, <code>Location_Business_Name</code>, <code>Location_Address</code>, <code>Location_City_State_ZIP</code>, <code>Excerpt</code>, <code>Category</code>, <code>Workflow_State</code>, <code>Tags</code>, <code>Published_Date</code>.<br><br>
      
      <strong>2. Event-Product Mappings CSV (Required for offers & SKU):</strong><br>
      ‚Ä¢ File: <code>event-product-mappings-*.csv</code> (generated by chat-bot ingest app)<br>
      ‚Ä¢ Maps event URLs to product URLs and includes <code>price_gbp</code> for offers<br>
      ‚Ä¢ Provides SKU extraction (currently from URL slug, will be improved to use products CSV)<br>
      ‚Ä¢ <strong>Without this file:</strong> Events will have price = 0 (data error logged)<br><br>
      
      <strong>3. Reviews CSV (Optional - for review enrichment):</strong><br>
      ‚Ä¢ File: <code>03 ‚Äì combined_product_reviews.csv</code><br>
      ‚Ä¢ Adds aggregateRating and review snippets to events<br>
      ‚Ä¢ Only events with matching product URLs get reviews<br><br>
      
      <strong>‚öôÔ∏è How it works:</strong><br>
      ‚Ä¢ Uses <code>@type: ["Product", "Event"]</code> hybrid schema (validates with Schema.org)<br>
      ‚Ä¢ Always adds offers (Google requirement) - logs error if price = 0<br>
      ‚Ä¢ Adds SKU to offers object (required for Product+Event hybrid)<br>
      ‚Ä¢ Includes organizer, performer, location with parsed address<br>
      ‚Ä¢ Groups repeating events into EventSeries when enabled<br>
      ‚Ä¢ Only includes published events with future start dates<br>
      ‚Ä¢ Validates all required fields and reports errors/warnings<br><br>
      
      <strong>üìÑ Data Workflow Summary:</strong><br>
      <pre>
Step 1: Export events from Squarespace ‚Üí events_export.csv
     ‚Üì
Step 2: Generate event-product mappings (chat-bot ingest app) ‚Üí event-product-mappings-*.csv
     ‚Üì
Step 3: (Optional) Prepare reviews CSV ‚Üí 03 ‚Äì combined_product_reviews.csv
     ‚Üì
Step 4: Upload all files in Event Schema tab
     ‚Üì
Step 5: Configure enrichment options (reviews, performer, merchant fields, etc.)
     ‚Üì
Step 6: Select category filter (or "All Categories")
     ‚Üì
Step 7: Generate JSON-LD schema blocks (Product+Event hybrid)
     ‚Üì
Step 8: Paste schema into Squarespace event page (see instructions below)
      </pre>

      <strong>üìå Squarespace Instructions:</strong><br>
      ‚Ä¢ Open your event page in Squarespace.<br>
      ‚Ä¢ Navigate to <b>Page Settings ‚Üí Advanced ‚Üí Header Code Injection</b><br>
      ‚Ä¢ OR insert a <b>Code Block</b> onto the event page.<br>
      ‚Ä¢ <b>Paste the entire generated schema block</b> (includes both ItemList and Event schemas).<br>
      ‚Ä¢ The schema will include all events matching your selected category filter.<br>
      ‚Ä¢ <span class="warning">‚ö†Ô∏è Best Practice:</span> Paste the schema on a main events listing page (e.g., "All Workshops" or category archive page) rather than individual event pages.<br>
      ‚Ä¢ For individual event pages, you can generate schema for a single category containing just that event.<br>
      ‚Ä¢ Always validate your schema after deployment using the test URL tools below.
    </div>

    <div style="margin-top: 1rem; padding: 1rem; background: #e6f3ff; border-radius: 8px; border: 1px solid #3182ce;">
      <h4 style="margin-top: 0; color: #1e40af;">üìé File Upload Guide</h4>
      <p style="margin: 0.5rem 0; font-weight: 600; color: #1e40af;">Required Files:</p>
      <ol style="margin: 0.5rem 0; padding-left: 1.5rem;">
        <li style="margin-bottom: 0.5rem;"><strong>Event CSV:</strong> Upload your Squarespace events export CSV file</li>
        <li style="margin-bottom: 0.5rem;"><strong>Mappings CSV:</strong> Upload <code>event-product-mappings-*.csv</code> (from chat-bot ingest app)<br>
          <span style="font-size: 0.875rem; color: #64748b;">‚ö†Ô∏è Required for offers and SKU - without it, events will show price = 0 errors</span></li>
      </ol>
      <p style="margin: 0.5rem 0; font-weight: 600; color: #1e40af;">Optional Files:</p>
      <ol style="margin: 0.5rem 0; padding-left: 1.5rem;">
        <li style="margin-bottom: 0.5rem;"><strong>Products Excel:</strong> Upload <code>02 ‚Äì products_cleaned.xlsx</code> for actual SKU values (prevents fallback to URL slug)<br>
          <span style="font-size: 0.875rem; color: #64748b;">‚ö†Ô∏è Without this: SKU will be extracted from URL slug (may exceed 40 chars and cause validation warnings)</span></li>
        <li style="margin-bottom: 0.5rem;"><strong>Reviews CSV:</strong> Upload <code>03 ‚Äì combined_product_reviews.csv</code> for review enrichment</li>
      </ol>
    </div>

    <label for="eventCsvFile">üìÑ Upload Event CSV File (Required):</label>
    <input type="file" id="eventCsvFile" accept=".csv" aria-label="Event CSV file upload">
    <p style="font-size: 0.875rem; color: #64748b; margin-top: 0.25rem;">Export from Squarespace Events ‚Üí Commerce ‚Üí Events ‚Üí Export CSV</p>
    
    <div style="margin-top: 1rem; padding: 1rem; background: #fff3cd; border-radius: 8px; border: 1px solid #ffc107;">
      <h4 style="margin-top: 0; color: #856404;">üìé Enrichment Files</h4>
      <label for="mappingsCsvFile" style="display: block; margin-bottom: 0.75rem;">
        <strong style="color: #dc2626;">‚ö†Ô∏è Event-Product Mappings CSV (Required for offers & SKU):</strong><br>
        <input type="file" id="mappingsCsvFile" accept=".csv" style="margin-top: 0.5rem; margin-left: 0;">
        <span style="display: block; font-size: 0.875rem; color: #856404; margin-top: 0.25rem;">
          File: <code>event-product-mappings-*.csv</code> (from chat-bot ingest app)<br>
          Provides: price_gbp, product_url mapping, SKU extraction<br>
          <strong>Without this:</strong> Events will have price = 0 (logged as data error)
        </span>
      </label>
      <label for="productsExcelFile" style="display: block; margin-bottom: 0.75rem;">
        <strong>Products Excel (Optional - for actual SKU values):</strong><br>
        <input type="file" id="productsExcelFile" accept=".xlsx,.xls" style="margin-top: 0.5rem; margin-left: 0;">
        <span style="display: block; font-size: 0.875rem; color: #856404; margin-top: 0.25rem;">
          File: <code>02 ‚Äì products_cleaned.xlsx</code><br>
          Provides: Actual SKU from <code>main_sku</code> column (prevents fallback to URL slug)<br>
          <strong>Without this:</strong> SKU extracted from URL slug (may exceed 40 chars ‚Üí validation warnings)
        </span>
      </label>
      <label for="reviewsCsvFile" style="display: block;">
        <strong>Reviews CSV (Optional - for review enrichment):</strong><br>
        <input type="file" id="reviewsCsvFile" accept=".csv" style="margin-top: 0.5rem; margin-left: 0;">
        <span style="display: block; font-size: 0.875rem; color: #856404; margin-top: 0.25rem;">
          File: <code>03 ‚Äì combined_product_reviews.csv</code><br>
          Adds: aggregateRating and review snippets to events with matching product URLs
        </span>
      </label>
    </div>
    
    <div id="eventOptionsContainer" style="display:none; margin-top: 1rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
      <h4 style="margin-top: 0;">‚öôÔ∏è Enrichment Options:</h4>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="includeReviews" checked style="margin-right: 0.5rem;">
        <span>Include Reviews (from product mappings)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="includePerformer" checked style="margin-right: 0.5rem;">
        <span>Include Performer (Alan Ranger)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="groupRepeatingEvents" style="margin-right: 0.5rem;">
        <span>Group Repeating Events (EventSchedule)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="includeMerchantFields" style="margin-right: 0.5rem;">
        <span>Include Merchant Center Fields (Phase 6)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="toggleLocationEnrichment" checked style="margin-right: 0.5rem;">
        <span>Auto-Enrich Locations (Geo + Region Fallbacks)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="toggleAvailabilityStarts" style="margin-right: 0.5rem;">
        <span>Include AvailabilityStarts (Merchant+)</span>
      </label>
    </div>
    
    <div id="eventCategoryFilterContainer" style="margin-top: 1rem;">
      <p>Select category to generate schema for:</p>
      <select id="eventCategoryFilter" aria-label="Event category filter" style="display:none;"></select>
      <button onclick="generateEventSchema()" style="background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500;">Generate Event Schema</button>
    </div>

    <h3>Generated JSON-LD Schema:</h3>
    <div id="eventOutputContainer" style="position: relative; z-index: 1; margin-bottom: 1rem;">
      <button id="copySchemaButtonTop" onclick="copyToClipboard('eventOutput')" style="margin-bottom: 0.75rem; background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; position: relative; z-index: 10; display: inline-block; visibility: visible; opacity: 1;">üìã Copy Schema to Clipboard</button>
      <pre id="eventOutput" style="position: relative; z-index: 1; max-height: 600px; overflow-y: auto; margin-bottom: 0.75rem;"></pre>
      <button id="copySchemaButton" onclick="copyToClipboard('eventOutput')" style="margin-top: 0; background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; position: relative; z-index: 10; display: inline-block; visibility: visible; opacity: 1;">üìã Copy Schema to Clipboard</button>
    </div>
    
    <div id="debugLogContainer" style="display:none; margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6; max-height: 400px; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
        <h4 style="margin: 0;">üîç Debug Log:</h4>
        <button onclick="copyDebugLog(this)" style="padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
          üìã Copy Debug Log
        </button>
      </div>
      <pre id="debugLog" style="margin: 0; font-size: 0.875rem; white-space: pre-wrap; word-wrap: break-word;"></pre>
    </div>
    
    <div id="summaryPanel" style="display:none; margin-top: 1rem; padding: 1rem; background: #e8f4f8; border-radius: 8px; border: 1px solid #3182ce;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
        <h4 style="margin: 0; color: #2c5282;">üìä Schema Generation Summary</h4>
        <button onclick="showFieldVerificationModal()" style="padding: 0.5rem 1rem; background: #48bb78; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
          üîç View Field Verification
        </button>
      </div>
      <div id="summaryContent" style="font-size: 0.875rem; line-height: 1.6;"></div>
    </div>
    
    <div id="schemaExportContainer" style="display:none; margin-top: 1rem; padding: 1rem; background: #f0f9ff; border-radius: 8px; border: 1px solid #0ea5e9;">
      <h4 style="margin-top: 0; color: #0369a1;">üì¶ Schema Export & Squarespace Integration</h4>
      <div id="schemaExportContent" style="margin-top: 0.75rem;"></div>
      
      <!-- GitHub Hosting Verification Panel -->
      <div id="githubHostingVerification" style="margin-top: 1.5rem; padding: 1rem; background: white; border-radius: 6px; border: 1px solid #e5e7eb;">
        <h4 style="margin: 0 0 0.75rem 0; font-size: 1rem; font-weight: 600; color: #1f2937;">üîç GitHub Schema Hosting Verification</h4>
        <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f0f9ff; border-radius: 4px; border-left: 3px solid #0369a1;">
          <p style="margin: 0 0 0.5rem 0; font-size: 0.875rem; color: #1e40af; font-weight: 500;"><strong>üìÅ Save Location:</strong></p>
          <p style="margin: 0; font-size: 0.8rem; color: #1e3a8a; font-family: monospace; word-break: break-all;">
            G:\Dropbox\alan ranger photography\Website Code\Schema Tools\alanranger-schema
          </p>
          <p style="margin: 0.5rem 0 0 0; font-size: 0.8rem; color: #475569;">
            Save <code style="background: #e0e7ff; padding: 2px 4px; border-radius: 2px;">lessons-schema.json</code> and <code style="background: #e0e7ff; padding: 2px 4px; border-radius: 2px;">workshops-schema.json</code> to this folder for GitHub Pages hosting.
          </p>
        </div>
        <button id="pingGitHub" style="padding: 0.5rem 1rem; background: #0369a1; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; margin-right: 0.5rem;">
          üöÄ Ping GitHub
        </button>
        <button id="exportToGitHubFolderBtn" onclick="exportUnminifiedToGitHubFolder()" style="padding: 0.5rem 1rem; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500;">
          üì• Export Unminified JSON to GitHub Folder
        </button>
        <div id="pingResults" style="margin-top: 10px; font-family: monospace; font-size: 0.875rem; color: #374151; line-height: 1.6;"></div>
        <div id="schemaLinks" style="margin-top: 15px; display: none;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #1f2937; font-size: 0.875rem;"><strong>Validation Links:</strong></p>
          <ul style="margin: 0; padding-left: 1.5rem; color: #374151; font-size: 0.875rem;">
            <li style="margin-bottom: 0.25rem;"><a href="https://validator.schema.org/#url=https://schema.alanranger.com/lessons-schema.json" target="_blank" style="color: #0369a1; text-decoration: none;">Lessons Schema Validator</a></li>
            <li style="margin-bottom: 0.25rem;"><a href="https://validator.schema.org/#url=https://schema.alanranger.com/workshops-schema.json" target="_blank" style="color: #0369a1; text-decoration: none;">Workshops Schema Validator</a></li>
            <li style="margin-bottom: 0.25rem;"><a href="https://search.google.com/test/rich-results?url=https://www.alanranger.com/beginners-photography-lessons" target="_blank" style="color: #0369a1; text-decoration: none;">Google Rich Results ‚Äì Lessons</a></li>
            <li style="margin-bottom: 0.25rem;"><a href="https://search.google.com/test/rich-results?url=https://www.alanranger.com/photographic-workshops-near-me" target="_blank" style="color: #0369a1; text-decoration: none;">Google Rich Results ‚Äì Workshops</a></li>
          </ul>
        </div>
      </div>
      
      <div style="margin-top: 1rem;">
        <button id="exportSchemaJsonBtn" onclick="exportSchemaToJson()" style="padding: 0.75rem 1.5rem; background: #0ea5e9; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; margin-right: 0.5rem;">
          üì• Export JSON File
        </button>
        <button id="copySquarespaceScriptBtn" onclick="copySquarespaceScript()" style="padding: 0.75rem 1.5rem; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
          üìã Copy Squarespace Script src Tag
        </button>
      </div>
    </div>

    <div style="margin-top: 1rem; padding: 0.75rem; background: #f9fafb; border-radius: 6px; font-size: 0.9em; color: #6b7280;">
      Schema auto-hosted via <a href="https://github.com/alanranger/alanranger-schema" target="_blank" style="color: #0369a1;">GitHub Pages</a> ‚Ä¢ Custom domain: <b>schema.alanranger.com</b> ‚Ä¢ Auto-sync: <b>Enabled</b>
    </div>

    <div id="merchantFeedContainer" style="display:none; margin-top: 1rem;">
      <button id="exportMerchantFeedBtn" onclick="exportMerchantFeed()" style="padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">
        üì• Export Merchant Center Feed (.json)
      </button>
    </div>

    <div class="test-url-section">
      <h4>Test Generated Schema:</h4>
      <p>Paste a URL containing your schema to validate it:</p>
      <label for="eventTestUrl">Test URL:</label>
      <input type="text" id="eventTestUrl" placeholder="https://example.com/page-with-schema" aria-label="Event test URL">
      <div class="button-group">
        <button onclick="testSchemaOrg('eventTestUrl')">Test on Schema.org Validator</button>
        <button onclick="testGoogleRichResults('eventTestUrl')" class="secondary">Test on Google Rich Results</button>
      </div>
    </div>
  </div>

  <!-- Field Verification Modal -->
  <div id="fieldVerificationModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); overflow-y: auto;" onclick="if(event.target.id === 'fieldVerificationModal') closeFieldVerificationModal();">
    <div style="background-color: white; margin: 2% auto; padding: 2rem; border-radius: 12px; width: 90%; max-width: 900px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative;" onclick="event.stopPropagation();">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 2px solid #e2e8f0; padding-bottom: 1rem;">
        <h2 style="margin: 0; color: #2d3748;">üîç Field Verification Summary</h2>
        <button onclick="closeFieldVerificationModal()" style="background: #f56565; color: white; border: none; border-radius: 6px; padding: 0.5rem 1rem; cursor: pointer; font-size: 1rem;">‚úï Close</button>
      </div>
      <div id="fieldVerificationModalContent"></div>
    </div>
  </div>

  <!-- Product Tab Content -->
  <div id="productTab" class="tab-content">
    <div class="instructions">
      <strong>üõ† Product Schema Generator</strong><br><br>
      
      ‚úÖ This tool works entirely offline in your browser.<br>
      ‚úÖ Only includes structured data compliant with Google Rich Results and Merchant Center policies.<br>
      ‚úÖ Automatically includes Schema Suppressor v1.3 to prevent duplicate Squarespace Product schemas.<br><br>

      <!-- Desktop App Launch Button (Web Mode Only) -->
      <div id="desktop-launch" style="display:none; margin-bottom:1rem; padding:1.5rem; border:2px dashed #ccc; border-radius:12px; background:#fffbe6;">
        <h3 style="margin-bottom:0.5rem; color:#2d3748; text-align:center;">üíª Want Automated Steps?</h3>
        <p style="margin-bottom:1rem; color:#4a5568; text-align:center;">This web version runs in read-only mode. The desktop app can automatically chain steps 2‚Üí3a‚Üí3b‚Üí4 after you upload a file.</p>
        
        <div style="background:#f7fafc; padding:1rem; border-radius:8px; margin-bottom:1rem; border:1px solid #e2e8f0;">
          <p style="margin:0 0 0.75rem 0; font-weight:600; color:#2d3748;">üìã How to use the desktop app:</p>
          <ol style="margin:0; padding-left:1.5rem; color:#4a5568; line-height:1.8;">
            <li>Open your project folder in a terminal</li>
            <li>Run: <code style="background:#edf2f7; padding:2px 6px; border-radius:4px; font-family:monospace;">npm run build:desktop</code></li>
            <li>Navigate to: <code style="background:#edf2f7; padding:2px 6px; border-radius:4px; font-family:monospace;" id="exePathDisplay">%LOCALAPPDATA%\SchemaTools\SchemaTools-win32-x64\SchemaTools.exe</code></li>
            <li>Double-click <strong>SchemaTools.exe</strong> to launch</li>
          </ol>
          <p style="margin:0.75rem 0 0 0; padding:0.75rem; background:#e8f4f8; border-radius:6px; font-size:0.875rem; color:#2c5282; border-left:3px solid #3182ce;">
            <strong>‚ÑπÔ∏è Note:</strong> The built app (.exe) is saved to <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">%LOCALAPPDATA%</code> to avoid Dropbox file locks. 
            <strong>All input/output files remain in your Dropbox project folder</strong> (<code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">inputs-files/</code> and <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">outputs/</code>).
          </p>
        </div>
        
        <div style="text-align:center;">
          <button id="copyPathBtn" style="padding:0.75rem 1.5rem; font-size:1rem; border:none; border-radius:8px; background:#0078D4; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-right:0.5rem; margin-bottom:0.5rem;" onmouseover="this.style.background='#005a9e'" onmouseout="this.style.background='#0078D4'">
            üìã Copy Build Command
          </button>
          <button id="openFolderBtn" style="padding:0.75rem 1.5rem; font-size:1rem; border:none; border-radius:8px; background:#27AE60; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-right:0.5rem; margin-bottom:0.5rem;" onmouseover="this.style.background='#229954'" onmouseout="this.style.background='#27AE60'">
            üìÅ Open PowerShell Here
          </button>
          <button id="showInstructionsBtn" style="padding:0.75rem 1.5rem; font-size:1rem; border:1px solid #0078D4; border-radius:8px; background:white; color:#0078D4; cursor:pointer; font-weight:600; transition:background 0.2s; margin-right:0.5rem; margin-bottom:0.5rem;" onmouseover="this.style.background='#f0f7ff'" onmouseout="this.style.background='white'">
            ‚ÑπÔ∏è Show Full Path
          </button>
          <button id="openExeBtnWeb" style="padding:0.75rem 1.5rem; font-size:1rem; border:none; border-radius:8px; background:#9b59b6; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-bottom:0.5rem;" onmouseover="this.style.background='#8e44ad'" onmouseout="this.style.background='#9b59b6'">
            ‚ñ∂Ô∏è Open Electron App (if built)
          </button>
        </div>
      </div>

      <!-- Build Desktop App Section (Electron Mode Only) -->
      <div id="build-desktop-section" style="display:none; margin-bottom:1rem; padding:1.5rem; border:2px solid #27AE60; border-radius:12px; background:#f0fdf4;">
        <h3 style="margin-bottom:0.5rem; color:#2d3748; text-align:center;">üî® Build Desktop App</h3>
        <p style="margin-bottom:1rem; color:#4a5568; text-align:center;">Build the Windows .exe file directly from this app.</p>
        
        <div style="text-align:center; margin-bottom:1rem;">
          <button id="buildDesktopBtn" style="padding:1rem 2rem; font-size:1.2rem; border:none; border-radius:8px; background:#27AE60; color:white; cursor:pointer; font-weight:600; transition:background 0.2s;" onmouseover="this.style.background='#229954'" onmouseout="this.style.background='#27AE60'">
            üî® Build Desktop App (npm run build:desktop)
          </button>
          <button id="openExeBtn" style="display:none; padding:1rem 2rem; font-size:1.2rem; border:none; border-radius:8px; background:#0078D4; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-left:0.5rem;" onmouseover="this.style.background='#005a9e'" onmouseout="this.style.background='#0078D4'">
            ‚ñ∂Ô∏è Open Built App (SchemaTools.exe)
          </button>
        </div>
        
        <div id="buildOutput" style="display:none; margin-top:1rem; padding:1rem; background:#1e1e1e; color:#d4d4d4; border-radius:8px; font-family:'Courier New', monospace; font-size:0.75rem; max-height:300px; overflow-y:auto; white-space:pre-wrap;"></div>
      </div>

      <!-- ===================== COMBINED DEBUG LOG ===================== -->
      <div id="combined-debug-log-section" style="margin-top: 2rem; margin-bottom: 1.5rem; padding: 1.5rem; background: #1e1e1e; border: 2px solid #4a5568; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h3 style="color: #d4d4d4; margin: 0; font-size: 1.25rem; font-weight: 600;">üìã Combined Debug Log (All Steps)</h3>
          <div>
            <button id="clearCombinedLogBtn" onclick="clearCombinedLog()" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #4a5568; border-radius: 6px; background: #2d3748; color: #d4d4d4; cursor: pointer; margin-right: 0.5rem; transition: background 0.2s;" onmouseover="this.style.background='#4a5568'" onmouseout="this.style.background='#2d3748'">
              üóëÔ∏è Clear Log
            </button>
            <button id="copyCombinedLogBtn" onclick="copyCombinedLog()" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: none; border-radius: 6px; background: #667eea; color: white; cursor: pointer; font-weight: 600; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
              üìã Copy All Logs
            </button>
          </div>
        </div>
        <div id="combinedDebugLog" style="padding: 1rem; background: #0d1117; color: #d4d4d4; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 500px; overflow-y: auto; white-space: pre-wrap; border: 1px solid #30363d;">No logs yet. Step outputs will appear here as they run...</div>
      </div>

      <!-- ===================== STATUS DASHBOARD ===================== -->
      <div id="workflow-status-dashboard" style="margin-top: 1rem; margin-bottom: 1.5rem; padding: 1.5rem; background: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
        <h3 style="color: #2d3748; margin: 0 0 1rem 0; font-size: 1.25rem; font-weight: 600;">üìä Workflow Status Dashboard</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem;">
          <div id="step-status-0" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.05); border-radius: 8px; text-align: center; color: #2d3748;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è≥</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 0</div>
            <div id="step-status-text-0" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Initializing</div>
          </div>
          <div id="step-status-1" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 1</div>
            <div id="step-status-text-1" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-2" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 2</div>
            <div id="step-status-text-2" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-3a" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 3a</div>
            <div id="step-status-text-3a" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-3b" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 3b</div>
            <div id="step-status-text-3b" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-4" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 4</div>
            <div id="step-status-text-4" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
        </div>
      </div>

      <!-- ===================== SINGLE URL SCHEMA GENERATOR ===================== -->
      <div style="margin-top: 2rem; margin-bottom: 2rem; padding: 1.5rem; background: #f0f9ff; border: 2px solid #0ea5e9; border-radius: 12px;">
        <h3 style="font-weight: 600; font-size: 1.25rem; color: #0c4a6e; margin: 0 0 0.75rem 0;">üîó Single URL Schema Generator</h3>
        <p style="font-size: 0.875rem; color: #075985; margin: 0.5rem 0; line-height: 1.6;">
          Generate product schema for a single product URL without batch processing. This will fetch product data from the URL and generate a complete schema file with reviews (if available).
        </p>
        
        <div style="margin-top: 1rem;">
          <label for="singleProductUrl" style="display: block; font-weight: 600; color: #0c4a6e; margin-bottom: 0.5rem;">Product URL:</label>
          <input type="text" id="singleProductUrl" placeholder="https://www.alanranger.com/photo-workshops-uk/product-name" 
                 style="width: 100%; padding: 0.75rem; border: 1px solid #bae6fd; border-radius: 6px; font-size: 0.875rem; margin-bottom: 0.75rem;"
                 aria-label="Single product URL input">
          <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; margin-bottom: 0.75rem;">
            Enter the full URL of the product page you want to generate schema for.
          </p>
          
          <div style="margin-top: 0.75rem;">
            <label for="singleUrlReviewsFile" style="display: block; font-weight: 600; color: #0c4a6e; margin-bottom: 0.5rem;">Optional: Upload Reviews CSV (for review enrichment):</label>
            <input type="file" id="singleUrlReviewsFile" accept=".csv" 
                   style="width: 100%; padding: 0.5rem; border: 1px solid #bae6fd; border-radius: 6px; font-size: 0.875rem; margin-bottom: 0.5rem;"
                   aria-label="Reviews CSV file upload for single URL">
            <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">
              Upload <code style="background: #e0f2fe; padding: 2px 4px; border-radius: 3px;">03 ‚Äì combined_product_reviews.csv</code> to include reviews in the schema.
            </p>
          </div>
          
          <div style="margin-top: 1rem; display: flex; gap: 0.75rem; flex-wrap: wrap;">
            <button onclick="generateSingleUrlSchema()" id="generateSingleUrlBtn" 
                    style="background: #0ea5e9; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;"
                    onmouseover="this.style.background='#0284c7'" onmouseout="this.style.background='#0ea5e9'">
              üîó Generate Schema for Single URL
            </button>
            <button onclick="clearSingleUrlForm()" class="secondary" 
                    style="background: #e2e8f0; color: #4a5568; font-size: 0.875rem; font-weight: 500; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer;">
              Clear
            </button>
          </div>
          
          <div id="singleUrlProgress" class="progress" style="display: none; margin-top: 1rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #0ea5e9; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          
          <div id="singleUrlStatus" style="display: none; margin-top: 1rem; padding: 0.75rem; background: #e0f2fe; border: 1px solid #0ea5e9; border-radius: 6px; font-size: 0.875rem; color: #075985;"></div>
          
          <div id="singleUrlOutput" style="display: none; margin-top: 1.5rem;">
            <h4 style="font-weight: 600; color: #0c4a6e; margin-bottom: 0.75rem;">Generated Schema:</h4>
            <textarea id="singleUrlSchemaOutput" readonly 
                      style="min-height: 400px; font-family: 'Courier New', monospace; font-size: 0.85rem; width: 100%; padding: 0.75rem; border: 1px solid #bae6fd; border-radius: 6px; background: #f8fafc;"></textarea>
            <div style="margin-top: 0.75rem; display: flex; gap: 0.75rem; flex-wrap: wrap;">
              <button onclick="copyToClipboard('singleUrlSchemaOutput')" 
                      style="background: #0ea5e9; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
                üìã Copy to Clipboard
              </button>
              <button onclick="downloadSingleUrlSchema()" 
                      style="background: #27AE60; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
                üíæ Download HTML File
              </button>
              <button onclick="testSchemaOrg('singleProductUrl')" 
                      style="background: #667eea; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
                üîç Test on Schema.org
              </button>
              <button onclick="testGoogleRichResults('singleProductUrl')" 
                      style="background: #667eea; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
                üîç Test on Google Rich Results
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- ===================== PRODUCT SCHEMA WORKFLOW ===================== -->
      <section id="product-schema-workflow" style="display: flex; flex-direction: column; gap: 1.5rem; margin-top: 1.5rem;">

        <!-- STEP 0: Initialize Local Executor -->
        <div id="step0-init" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step0-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è≥</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">‚öôÔ∏è Step 0 ‚Äì Setup Check</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Checking your setup and unlocking the workflow. This happens automatically.
          </p>
          <div id="executorStatus" style="margin-top: 0.75rem; padding: 0.75rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; color: #856404; font-size: 0.875rem; font-weight: 500;">
            üîç Checking your setup...
          </div>
          <div id="executorActions" style="margin-top: 0.75rem; display: flex; gap: 0.75rem; flex-wrap: wrap;">
            <button id="startLocalBtn" style="display: none; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
              ‚ö° Start Local Server
            </button>
            <button id="copyCommandBtn" style="display: none; background: #718096; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#4a5568'" onmouseout="this.style.background='#718096'">
              üìã Copy CLI Command
            </button>
          </div>
          <pre id="executorConsole" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 150px; overflow-y: auto; white-space: pre-wrap;"></pre>
        </div>

        <!-- STEP 1 -->
        <div id="step1-container" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step1-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è∏Ô∏è</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">üßæ Step 1 ‚Äì Squarespace Product Export Setup</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What to do:</strong> Export your products from Squarespace ‚Üí <strong>Commerce ‚Üí Products ‚Üí Export CSV</strong>.<br>
            Then upload the CSV file below. <strong>After upload, Step 2 will start automatically.</strong>
          </p>
          <input type="file" id="file-step1" accept=".csv" style="margin-top: 0.75rem; display: block; font-size: 0.875rem; opacity: 0.5; cursor: not-allowed;" disabled />
          <p id="step1LockMessage" style="font-size: 0.75rem; color: #718096; margin-top: 0.5rem; font-style: italic;">
            ‚è≥ Step 0 is checking your setup... this will unlock automatically.
          </p>
          <div id="progress-step1" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step1" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
        </div>

        <!-- STEP 2 -->
        <div id="step2-container" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step2-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è∏Ô∏è</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">üßπ Step 2 ‚Äì Clean and Normalize CSV</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> This step formats your Squarespace export for schema generation.<br>
            <strong>When:</strong> Runs automatically after Step 1 upload completes.<br>
            <strong>You don't need to do anything</strong> - just wait for it to finish. Step 3a will start automatically next.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Triggered automatically after Step 1 upload</li>
            <li>Normalizes column names and trims invalid rows</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">02 ‚Äì products_cleaned.xlsx</code></li>
          </ul>
          <div id="step2WebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Web Mode:</strong> Steps 2-4 require Electron app or local execution.<br>
            <small>Download Electron desktop app for full automation.</small>
          </div>
          <div id="progress-step2" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step2" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="cleanConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3a: Fetch Google Reviews -->
        <div id="step3a-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì• Step 3a ‚Äì Fetch Google Reviews</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> Connects to your Google My Business account and retrieves all customer reviews.<br>
            <strong>When:</strong> Runs automatically after Step 2 completes.<br>
            <strong>First time:</strong> A browser window will open for OAuth authorization - just approve it.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires valid OAuth JSON in <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">/inputs-files/workflow/credentials/</code></li>
            <li>First time: Browser will open for OAuth authorization</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03b ‚Äì google_reviews.csv</code></li>
          </ul>
          <div id="step3aWebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="fetchGoogleReviews" onclick="runGoogleReviewsFetcher()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            üì• Fetch Google Reviews (Local)
          </button>
          <div id="progress-step3a" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3a" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="googleConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3b: Merge Reviews -->
        <div id="step3b-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üîó Step 3b ‚Äì Merge Trustpilot and Google Reviews</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> Combines both review sources into one clean dataset ready for schema generation.<br>
            <strong>When:</strong> Runs automatically after Step 3a completes.<br>
            <strong>You don't need to do anything</strong> - just wait for it to finish. Step 4 will start automatically next.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03a ‚Äì trustpilot_historical_reviews.csv</code> and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03b ‚Äì google_reviews.csv</code></li>
            <li>Filters out reviews below 4‚òÖ</li>
            <li>Automatically maps reviews to product names</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì combined_product_reviews.csv</code></li>
          </ul>
          <div id="step3bWebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="mergeReviewsBtn" onclick="runMergeReviews()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            üîó Merge Reviews
          </button>
          <div id="progress-step3b" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3b" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="mergeConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3c: Upload Merged Dataset (for Step 4) -->
        <div style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì§ Step 3c ‚Äì Upload Merged Dataset</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            After merging reviews, upload the final merged file for schema generation.<br>
            File: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì products_with_review_data_final.xlsx</code>
          </p>
          <input type="file" id="file-step3" accept=".xlsx" style="margin-top: 0.75rem; display: block; font-size: 0.875rem;" />
          <div id="progress-step3" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
        </div>

        <!-- STEP 4 -->
        <div id="step4-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">‚öôÔ∏è Step 4 ‚Äì Generate Product Schema</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> Generates JSON-LD schema files from your merged review data.<br>
            <strong>When:</strong> Runs automatically after Step 3b completes.<br>
            <strong>What you need to do:</strong> Nothing - just wait for it to finish. Your schema files will be ready!
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">02 ‚Äì products_cleaned.xlsx</code> and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì combined_product_reviews.csv</code></li>
            <li>Generates one HTML file per product with embedded reviews</li>
            <li>Includes aggregate ratings and individual review data</li>
            <li>‚úÖ <strong>Automatically includes Schema Suppressor v1.3</strong> - removes duplicate Squarespace Product schemas</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">/outputs/</code> folder (HTML files) and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">04 ‚Äì alanranger_product_schema_FINAL_WITH_REVIEW_RATINGS.csv</code></li>
          </ul>
          <div id="step4WebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="run-step4" onclick="generateProductSchema()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            Generate Schema (Step 4)
          </button>
          <div id="progress-step4" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step4" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="step4MatchStatus" style="display:none; margin-top: 0.75rem; padding: 0.75rem; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px; font-size: 0.875rem; color: #0c4a6e;">
            <strong>üìä Products Matched:</strong> <span id="step4MatchCount">0</span> products have reviews embedded in their schema
          </div>
          <div id="productSchemaSuccess" style="display:none; margin-top: 1rem; padding: 1rem; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; color: #155724;">
            ‚úÖ Schema generation complete.<br>
            Files saved in your project folder: <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">/outputs/</code> (individual JSON/HTML files) and <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">/inputs-files/workflow/</code> (combined CSV).
          </div>
        </div>

        <!-- STEP 5 -->
        <div style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì• Step 5 ‚Äì Insert Schema into Squarespace</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Open your product page ‚Üí <strong>Code Block</strong> ‚Üí paste generated schema.<br>
            Validate using <a href="https://search.google.com/test/rich-results" target="_blank" style="color: #667eea; text-decoration: underline;">Rich Results Test</a>.
          </p>
        </div>

      </section>

    </div>

    <h3 style="margin-top: 2rem;">Generated JSON-LD Schema:</h3>
    <p style="color: #4a5568; font-size: 0.9rem; margin-bottom: 0.5rem;">Preview of JSON-LD schema blocks for each product:</p>
    <textarea id="productOutput" readonly style="min-height: 400px; font-family: 'Courier New', monospace; font-size: 0.85rem; width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px;"></textarea>
    <button onclick="copyToClipboard('productOutput')" style="margin-top: 0.75rem; background: #667eea; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer;">Copy to Clipboard</button>
    
    <!-- Hidden file input for Step 4 (backward compatibility) -->
    <input type="file" id="productCsvFile" accept=".csv,.xlsx" style="display: none;" aria-label="Product CSV/XLSX file upload">

    <div class="test-url-section">
      <h4>Test Generated Schema:</h4>
      <p>Paste a URL containing your schema to validate it:</p>
      <label for="productTestUrl">Test URL:</label>
      <input type="text" id="productTestUrl" placeholder="https://example.com/page-with-schema" aria-label="Product test URL">
      <div class="button-group">
        <button onclick="testSchemaOrg('productTestUrl')">Test on Schema.org Validator</button>
        <button onclick="testGoogleRichResults('productTestUrl')" class="secondary">Test on Google Rich Results</button>
      </div>
    </div>
  </div>

  <!-- Landing / Service Pages Tab Content -->
  <div id="landingTab" class="tab-content">
    <div class="instructions">
      <strong>üåê Landing / Service Pages Schema Generator</strong><br><br>
      
      ‚úÖ Generate structured data for service, category, and informational landing pages.<br>
      ‚úÖ Auto-scan URL for metadata or manual input.<br>
      ‚úÖ Smart schema type detection (Service, ItemList, WebPage, Product).<br>
      ‚úÖ Works entirely offline in your browser.<br>
      ‚úÖ Compliant with Schema.org and Google Rich Results requirements.<br><br>
      
      <strong>What this does:</strong> Creates context-appropriate structured data for pages that aren't products or events, improving E-E-A-T signals and AI Overviews performance. Never includes fake reviews or misleading ratings.
    </div>

    <!-- Step 1: Auto-Scan or Manual Input -->
    <div class="workflow-section" style="margin-top: 1.5rem; padding: 1.5rem; background: #f0f4ff; border: 2px solid #e2e8f0; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
        <div style="background: #667eea; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1rem; flex-shrink: 0;">1</div>
        <div>
          <h3 style="margin: 0; color: #1e293b; font-size: 1.5rem; font-weight: 600;">Auto-Scan Metadata (Optional)</h3>
          <p style="margin: 0.25rem 0 0 0; font-size: 0.95rem; color: #64748b;">ü§ñ Automatic: Fetches title, description, and image from page URL</p>
        </div>
      </div>
      
      <div style="margin-bottom: 1rem;">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
          <label for="landingPageUrl" style="display: block; font-weight: 600; color: #2d3748; margin: 0;">
            Page URL:
          </label>
          <button onclick="clearLandingForm()" 
                  style="background: #e2e8f0; color: #4a5568; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; white-space: nowrap;"
                  onmouseover="this.style.background='#cbd5e0'" onmouseout="this.style.background='#e2e8f0'"
                  title="Clear all fields and reset form">
            üîÑ Reset
          </button>
        </div>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <input type="text" id="landingPageUrl" placeholder="https://www.alanranger.com/service-page" 
                 style="flex: 1; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 0.875rem;"
                 aria-label="Landing page URL input">
          <button onclick="scanLandingPageMetadata()" id="scanMetadataBtn"
                  style="background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; white-space: nowrap;"
                  onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            üîç Auto-Scan Metadata
          </button>
        </div>
        <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">
          Click "Auto-Scan Metadata" to fetch title, description, and image from the page. Or enter fields manually below.
        </p>
        <div id="landingScanProgress" style="display: none; margin-top: 0.5rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
          <div id="landingScanProgressBar" style="height: 8px; background: #667eea; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
        </div>
      </div>

    </div>

    <!-- Step 2: Manual Input Fields -->
    <div class="workflow-section" style="margin-top: 1.5rem; padding: 1.5rem; background: #f0fdf4; border: 2px solid #e2e8f0; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
        <div style="background: #10b981; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1rem; flex-shrink: 0;">2</div>
        <div>
          <h3 style="margin: 0; color: #1e293b; font-size: 1.5rem; font-weight: 600;">Page Information</h3>
          <p style="margin: 0.25rem 0 0 0; font-size: 0.95rem; color: #64748b;">‚úçÔ∏è Manual Input: Enter page details (or use auto-scan above)</p>
        </div>
      </div>

      <div style="margin-top: 1rem;">
        <label for="landingPageTitle" style="display: block; font-weight: 600; color: #2d3748; margin-bottom: 0.5rem;">
          Page Title <span style="color: #dc2626;">*</span>:
        </label>
        <input type="text" id="landingPageTitle" placeholder="e.g., Private Photography Tuition" 
               style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 0.875rem;"
               aria-label="Page title input" maxlength="200">
        <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">
          <strong>Required.</strong> The main title of the page (typically matches your H1 or page title).
        </p>
      </div>

      <div style="margin-top: 1rem;">
        <label for="landingPageDescription" style="display: block; font-weight: 600; color: #2d3748; margin-bottom: 0.5rem;">
          Page Description <span style="color: #64748b;">(Optional - max 170 chars)</span>:
        </label>
        <textarea id="landingPageDescription" placeholder="Enter page description or meta description..." 
                  style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 0.875rem; min-height: 60px; max-height: 80px; font-family: inherit;"
                  aria-label="Page description input" maxlength="170" oninput="updateLandingDescriptionCounter()"></textarea>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.25rem;">
          <p style="font-size: 0.75rem; color: #64748b; margin: 0;">
            Brief description of the page content. Recommended for SEO but not required.
          </p>
          <span id="landingDescriptionCounter" style="font-size: 0.75rem; color: #64748b; font-weight: 600;">0/170</span>
        </div>
      </div>

      <div style="margin-top: 1rem;">
        <label for="landingPageImage" style="display: block; font-weight: 600; color: #2d3748; margin-bottom: 0.5rem;">
          Page Image URL <span style="color: #64748b;">(Optional)</span>:
        </label>
        <input type="text" id="landingPageImage" placeholder="https://example.com/image.jpg" 
               style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 0.875rem;"
               aria-label="Page image URL input">
        <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">
          Full HTTPS URL to the main image for this page. Recommended for better rich results but not required.
        </p>
      </div>

      <div style="margin-top: 1rem;">
        <label for="landingPageUrlFinal" style="display: block; font-weight: 600; color: #2d3748; margin-bottom: 0.5rem;">
          Canonical URL <span style="color: #dc2626;">*</span>:
        </label>
        <input type="text" id="landingPageUrlFinal" placeholder="https://www.alanranger.com/service-page" 
               style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 0.875rem;"
               aria-label="Canonical URL input">
        <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">
          <strong>Required.</strong> The canonical URL for this page (used in schema). Must be a valid HTTPS URL.
        </p>
      </div>

    </div>

    <!-- Step 3: Schema Configuration -->
    <div class="workflow-section" style="margin-top: 1.5rem; padding: 1.5rem; background: #fffbeb; border: 2px solid #e2e8f0; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
        <div style="background: #f59e0b; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1rem; flex-shrink: 0;">3</div>
        <div>
          <h3 style="margin: 0; color: #1e293b; font-size: 1.5rem; font-weight: 600;">Schema Configuration</h3>
          <p style="margin: 0.25rem 0 0 0; font-size: 0.95rem; color: #64748b;">ü§ñ Automatic: Smart detection analyzes content | ‚úçÔ∏è Manual: Override if needed</p>
        </div>
      </div>

      <div style="margin-top: 1rem;">
        <label for="landingSchemaType" style="display: block; font-weight: 600; color: #2d3748; margin-bottom: 0.5rem;">
          Schema Type:
        </label>
        <select id="landingSchemaType" 
                style="width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; font-size: 0.875rem; background: white;"
                aria-label="Schema type selection">
          <option value="auto">Auto-detect (Recommended)</option>
          <option value="Service">Service (for service/course/tuition pages)</option>
          <option value="ItemList">ItemList (for gateway/category pages)</option>
          <option value="WebPage">WebPage (for informational/guide pages)</option>
          <option value="Product">Product (for voucher/bundle pages, no reviews)</option>
        </select>
        <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">
          Auto-detect analyzes page content to suggest the best schema type. You can override manually.
        </p>
      </div>

      <!-- Schema Type Explanation - Show BEFORE generation -->
      <div style="margin-top: 1.5rem; padding: 1rem; background: #fff3cd; border-radius: 8px; border: 1px solid #ffc107;">
        <h4 style="margin-top: 0; color: #856404;">‚ÑπÔ∏è Understanding Schema Types</h4>
        <div style="margin-top: 0.75rem; color: #856404; font-size: 0.875rem; line-height: 1.6;">
          <p style="margin: 0 0 0.75rem 0;"><strong>üìå Important:</strong> A page can have MULTIPLE schema types. This generator creates the PAGE-LEVEL schema (what the page is about). Product blocks on the page can have their own Product schemas separately.</p>
          
          <p style="margin: 0 0 0.5rem 0; font-weight: 600;">üîµ <strong>Service</strong> - Use for:</p>
          <ul style="margin: 0 0 0.75rem 1.5rem; padding: 0;">
            <li>Service pages (photography lessons, tutoring, consulting)</li>
            <li>Course/tuition pages (even if they sell products to book the course)</li>
            <li>Pages describing WHAT you offer (the service itself)</li>
            <li><strong>Example:</strong> "Private Photography Lessons" page - describes the SERVICE, even if there's a product block to purchase it</li>
          </ul>
          
          <p style="margin: 0 0 0.5rem 0; font-weight: 600;">üü¢ <strong>Product</strong> - Use for:</p>
          <ul style="margin: 0 0 0.75rem 1.5rem; padding: 0;">
            <li>Product pages (physical products, vouchers, gift cards)</li>
            <li>Pages where the PRODUCT is the main focus</li>
            <li><strong>Note:</strong> Only use if the page is ABOUT the product, not about a service that happens to sell products</li>
            <li><strong>Example:</strong> "Gift Voucher" page - the product IS the page content</li>
          </ul>
          
          <p style="margin: 0 0 0.5rem 0; font-weight: 600;">üü° <strong>ItemList</strong> - Use for:</p>
          <ul style="margin: 0 0 0.75rem 1.5rem; padding: 0;">
            <li>Category/gateway pages that list multiple items</li>
            <li>Pages that link to multiple products or services</li>
            <li><strong>Example:</strong> "All Photography Courses" page listing multiple courses</li>
          </ul>
          
          <p style="margin: 0 0 0.5rem 0; font-weight: 600;">üü£ <strong>WebPage</strong> - Use for:</p>
          <ul style="margin: 0 0 0.75rem 1.5rem; padding: 0;">
            <li>Informational articles, guides, blog posts</li>
            <li>Pages that are primarily content/information</li>
            <li><strong>Example:</strong> "How to Choose a Photography Tutor" guide page</li>
          </ul>
          
          <p style="margin: 0.75rem 0 0 0; padding-top: 0.75rem; border-top: 1px solid #ffc107; font-weight: 600;">ü§ñ Auto-Detection Logic:</p>
          <p style="margin: 0.5rem 0 0 0;">Keywords like "course", "tuition", "workshop", "lesson" ‚Üí <strong>Service</strong><br>
          Keywords like "guide", "tips", "how to", "article" ‚Üí <strong>WebPage</strong><br>
          Keywords like "voucher", "gift", "buy" ‚Üí <strong>Product</strong><br>
          Category/list pages ‚Üí <strong>ItemList</strong></p>
        </div>
      </div>

      <!-- Additional fields for Service schema -->
      <div id="landingServiceFields" style="display: none; margin-top: 1rem; padding: 1rem; background: #f0f9ff; border-radius: 8px; border: 1px solid #bae6fd;">
        <h4 style="margin-top: 0; color: #0c4a6e; font-size: 1rem;">Service-Specific Fields</h4>
        <div style="margin-top: 0.75rem;">
          <label for="serviceAreaServed" style="display: block; font-weight: 600; color: #0c4a6e; margin-bottom: 0.5rem;">Area Served:</label>
          <input type="text" id="serviceAreaServed" placeholder="e.g., GB, UK, Coventry" 
                 style="width: 100%; padding: 0.75rem; border: 1px solid #bae6fd; border-radius: 6px; font-size: 0.875rem;"
                 aria-label="Area served input">
          <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">
            Geographic area where the service is available (e.g., "GB", "UK", "Coventry").
          </p>
        </div>
        <div style="margin-top: 0.75rem;">
          <label for="servicePrice" style="display: block; font-weight: 600; color: #0c4a6e; margin-bottom: 0.5rem;">Service Price (Optional):</label>
          <input type="number" id="servicePrice" placeholder="e.g., 50" step="0.01" min="0"
                 style="width: 100%; padding: 0.75rem; border: 1px solid #bae6fd; border-radius: 6px; font-size: 0.875rem;"
                 aria-label="Service price input">
          <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">
            Leave empty if service pricing varies or is not applicable.
          </p>
        </div>
      </div>

      <!-- Additional fields for ItemList schema -->
      <div id="landingItemListFields" style="display: none; margin-top: 1rem; padding: 1rem; background: #f0fdf4; border-radius: 8px; border: 1px solid #86efac;">
        <h4 style="margin-top: 0; color: #166534; font-size: 1rem;">ItemList-Specific Fields</h4>
        <div style="margin-top: 0.75rem;">
          <label for="itemListItems" style="display: block; font-weight: 600; color: #166534; margin-bottom: 0.5rem;">List Items (one per line):</label>
          <textarea id="itemListItems" placeholder="https://www.alanranger.com/product-1&#10;https://www.alanranger.com/product-2&#10;https://www.alanranger.com/product-3" 
                    style="width: 100%; padding: 0.75rem; border: 1px solid #86efac; border-radius: 6px; font-size: 0.875rem; min-height: 100px; font-family: monospace;"
                    aria-label="Item list URLs input"></textarea>
          <p style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">
            Enter URLs of items in this list (one per line). Will include first 3-5 items in schema.
          </p>
        </div>
      </div>

    </div>

    <!-- Step 4: Status & Debug -->
    <div class="workflow-section" style="margin-top: 1.5rem; padding: 1.5rem; background: #faf5ff; border: 2px solid #e2e8f0; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
        <div style="background: #8b5cf6; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1rem; flex-shrink: 0;">4</div>
        <div>
          <h3 style="margin: 0; color: #1e293b; font-size: 1.5rem; font-weight: 600;">Status & Debug</h3>
          <p style="margin: 0.25rem 0 0 0; font-size: 0.95rem; color: #64748b;">üìä View progress and debug information</p>
        </div>
      </div>

      <div id="landingScanStatus" style="display: none; margin-top: 1rem; padding: 0.75rem; background: #e0f2fe; border: 1px solid #0ea5e9; border-radius: 6px; font-size: 0.875rem; color: #075985;"></div>

      <!-- Debug Log Section -->
      <div id="landingDebugLogContainer" style="display: none; margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6; max-height: 300px; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <h4 style="margin: 0; font-size: 0.9rem; color: #495057;">üìã Debug Log</h4>
          <button onclick="copyLandingDebugLog()" style="padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500;">üìã Copy Debug Log</button>
        </div>
        <pre id="landingDebugLog" style="margin: 0; font-size: 0.75rem; white-space: pre-wrap; word-wrap: break-word; color: #212529; background: white; padding: 0.5rem; border-radius: 4px;"></pre>
      </div>

      <div id="landingGenerateProgress" style="display: none; margin-top: 1rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
        <div id="landingGenerateProgressBar" style="height: 8px; background: #667eea; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
      </div>
    </div>

    <!-- Step 4.5: Schema Type Selector (shown after scanning, before generation) -->
    <div id="schemaTypeSelectorPanel" class="workflow-section" style="display: none; margin-top: 1.5rem; padding: 1.5rem; background: #f0f9ff; border: 2px solid #0ea5e9; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 2px solid #0ea5e9;">
        <div style="background: #0ea5e9; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1rem; flex-shrink: 0;">4.5</div>
        <div>
          <h3 style="margin: 0; color: #1e293b; font-size: 1.5rem; font-weight: 600;">Schema Types to Include</h3>
          <p style="margin: 0.25rem 0 0 0; font-size: 0.95rem; color: #64748b;">‚úì Select which schema types to include before generating (appears after scanning)</p>
        </div>
      </div>

      <div id="schemaTypeSelectorList" style="margin-top: 1rem;">
        <!-- Schema type checkboxes will be populated here -->
      </div>

      <div style="margin-top: 1rem; padding: 1rem; background: #e0f2fe; border-radius: 8px; border: 1px solid #bae6fd;">
        <p style="margin: 0; font-size: 0.875rem; color: #075985; line-height: 1.6;">
          <strong>üí° Tip:</strong> Only checked schema types will be included in the generated JSON-LD. 
          Uncheck types you want to exclude (e.g., disable Event on finder pages, enable ItemList for collection pages).
        </p>
      </div>
    </div>

    <!-- Step 5: Generate -->
    <div class="workflow-section" style="margin-top: 1.5rem; padding: 1.5rem; background: #fef2f2; border: 2px solid #e2e8f0; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 2px solid #e2e8f0;">
        <div style="background: #ef4444; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1rem; flex-shrink: 0;">5</div>
        <div>
          <h3 style="margin: 0; color: #1e293b; font-size: 1.5rem; font-weight: 600;">Generate Schema</h3>
          <p style="margin: 0.25rem 0 0 0; font-size: 0.95rem; color: #64748b;">‚öôÔ∏è Click to generate your schema (requires Title and URL)</p>
        </div>
      </div>

      <div class="button-group" style="margin-top: 1rem;">
        <button onclick="generateLandingSchema()" id="generateLandingBtn"
                style="background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500;"
                onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
          ‚öôÔ∏è Generate Schema
        </button>
        <button onclick="clearLandingForm()" class="secondary"
                style="background: #e2e8f0; color: #4a5568; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500;">
          Clear
        </button>
      </div>
    </div>

    <!-- Step 6: Output -->
    <div id="landingSchemaOutput" style="display: none; margin-top: 2rem; padding: 1.5rem; background: #f0fdf4; border: 2px solid #10b981; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 2px solid #10b981;">
        <div style="background: #10b981; color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 1rem; flex-shrink: 0;">6</div>
        <div>
          <h3 style="margin: 0; color: #1e293b; font-size: 1.5rem; font-weight: 600;">Generated Schema</h3>
          <p style="margin: 0.25rem 0 0 0; font-size: 0.95rem; color: #64748b;">‚úÖ Your schema is ready! Copy, test, or download below.</p>
        </div>
      </div>
      
      <div class="button-group" style="margin-bottom: 1rem;">
        <button onclick="testLandingSchemaOrg()" class="secondary">üîç Test on Schema.org</button>
        <button onclick="testLandingGoogleRichResults()" class="secondary">üîç Test on Google Rich Results</button>
        <button onclick="downloadLandingSchema()" class="secondary">üíæ Download JSON</button>
        <button onclick="downloadLandingSchemaHtml()" class="secondary">üìÑ Download HTML File</button>
      </div>
      
      <!-- Results Panel: Before/After Schema Types Comparison -->
      <div id="landingSchemaResultsPanel" style="display: none; margin-bottom: 1.5rem; padding: 1.5rem; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 8px;">
        <h4 style="margin: 0 0 1rem 0; color: #1e293b; font-size: 1.125rem; font-weight: 600;">üìä Schema Analysis Results</h4>
        <div style="overflow-x: auto;">
          <table id="landingSchemaResultsTable" style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
            <thead>
              <tr style="background: #e2e8f0;">
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #cbd5e0; font-weight: 600; color: #1e293b;">Schema Type</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #cbd5e0; font-weight: 600; color: #1e293b;">Before</th>
                <th style="padding: 0.75rem; text-align: center; border-bottom: 2px solid #cbd5e0; font-weight: 600; color: #1e293b;">After</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #cbd5e0; font-weight: 600; color: #1e293b;">Status</th>
                <th style="padding: 0.75rem; text-align: left; border-bottom: 2px solid #cbd5e0; font-weight: 600; color: #1e293b;">Enhancement Summary</th>
              </tr>
            </thead>
            <tbody id="landingSchemaResultsTableBody">
              <!-- Results will be populated here -->
            </tbody>
          </table>
        </div>
      </div>
      
      <div class="code-card" style="position: relative;">
        <button onclick="copyLandingSchema()" 
                style="position: absolute; top: 0.75rem; right: 0.75rem; background:#2563eb; color:#fff; border:none; padding:0.5rem 1rem; border-radius:4px; cursor:pointer; font-size:0.875rem; font-weight: 500; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                onmouseover="this.style.background='#1d4ed8'" 
                onmouseout="this.style.background='#2563eb'">
          üìã Copy Schema
        </button>
        <pre id="landingSchemaOutputText" style="margin: 0; padding: 1rem; padding-top: 3rem; background: #ffffff; color: #000000; border: 1px solid #e2e8f0; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.85rem; white-space: pre-wrap; word-wrap: break-word; max-height: 600px; overflow-y: auto;"></pre>
      </div>
    </div>
  </div>

  <!-- Blog Index Schema Tab Content -->
  <div id="blogTab" class="tab-content">
    <div class="instructions">
      <strong>üìù Blog Index Schema Generator</strong><br><br>
      
      ‚úÖ Generate CollectionPage schema for your blog index page.<br>
      ‚úÖ Works entirely offline in your browser.<br>
      ‚úÖ Compliant with Schema.org and Google Rich Results requirements.<br><br>
      
      <strong>What this does:</strong> Creates structured data for your blog listing/index page, helping search engines understand your blog structure and improve visibility in search results.
    </div>

    <div class="workflow-section">
      <h3>Step 1: Upload Blog CSV File</h3>
      <label for="blogCsvFile">Upload Blog CSV File:</label>
      <input type="file" id="blogCsvFile" accept=".csv" aria-label="Blog CSV file upload" onchange="handleBlogCsvUpload(event)">
      <p style="margin-top: 0.75rem; color: #4a5568; font-size: 0.9rem;">
        Expected CSV fields: <code>Title</code>, <code>Url Id</code>, <code>Full Url</code>, <code>Categories</code>, <code>Tags</code>, <code>Image</code>, <code>Publish On</code>
      </p>
      
      <div id="blogCsvInfo" style="display: none; margin-top: 1rem; padding: 1rem; background: #e8f4f8; border-radius: 8px; border-left: 3px solid #3182ce;">
        <p style="margin: 0; color: #2c5282; font-weight: 600;" id="blogCsvInfoText"></p>
      </div>

      <!-- Debug Log Section -->
      <div id="blogDebugLogContainer" style="display: none; margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6; max-height: 300px; overflow-y: auto;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
          <h4 style="margin: 0; font-size: 0.9rem; color: #495057;">üìã Debug Log</h4>
          <button onclick="copyBlogDebugLog()" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border: 1px solid #dee2e6; border-radius: 4px; background: white; cursor: pointer;">Copy Log</button>
        </div>
        <pre id="blogDebugLog" style="margin: 0; font-size: 0.75rem; white-space: pre-wrap; word-wrap: break-word; color: #212529; background: white; padding: 0.5rem; border-radius: 4px;"></pre>
      </div>

      <div class="button-group" style="margin-top: 1.5rem;">
        <button onclick="generateBlogIndexSchema()" id="generateBlogBtn" disabled>Generate Blog Index Schema</button>
        <button onclick="clearBlogForm()" class="secondary">Clear</button>
      </div>
    </div>

    <div id="blogSchemaOutput" style="display: none; margin-top: 2rem;">
      <h3>Generated Schema</h3>
      
      <div class="button-group" style="margin-bottom: 1rem;">
        <button onclick="testBlogSchemaOrg()">Test on Schema.org Validator</button>
        <button onclick="testBlogGoogleRichResults()" class="secondary">Test on Google Rich Results</button>
        <button onclick="saveBlogSchemaToFile()" class="secondary">üíæ Save to alanranger-schema folder</button>
        <button class="copy-btn" onclick="copyBlogSchema()" style="background:#2563eb; color:#fff; border:none; padding:0.5rem 1rem; border-radius:4px; cursor:pointer; font-size:0.875rem;">Copy Schema</button>
      </div>
      
      <div class="code-card">
        <div class="code-card-head">
          <span>JSON-LD Schema</span>
        </div>
        <pre style="background:#000 !important; color:#fff !important; padding:12px; margin:0; overflow:auto; font-family:'Courier New', monospace !important; font-size:14px; line-height:1.5; white-space:pre-wrap; word-wrap:break-word;"><code id="blogSchemaCode" style="background:#000 !important; color:#fff !important;"></code></pre>
      </div>
    </div>

  </div>

  <!-- Schema Validator Tab Content -->
  <div id="validatorTab" class="tab-content">
    <div class="instructions">
      <strong>üîç Schema Validator</strong><br><button class='secondary' style='float:right;margin-top:-0.25rem' onclick='switchTab("guide")'>Open Tab Guide ‚Üí</button>
      Validate schema markup on your pages using industry-standard validators. Choose single URL validation or batch processing from CSV.<br><br>
      
      ‚úÖ Works entirely in your browser (no server required).<br>
      ‚úÖ Validates Product, Event, Organization, and other schema types.<br>
      ‚úÖ Identifies missing fields and provides enhancement suggestions.<br><br>
      
      <strong>‚ö†Ô∏è Note:</strong> Cross-origin restrictions may prevent fetching some URLs. Use URLs from the same domain or enable CORS if testing locally.
    </div>

    <!-- Single URL Validator Section -->
    <div class="single-url-section">
      <label for="singleUrlInput">Validate a Single URL:</label>
      <input type="text" id="singleUrlInput" placeholder="https://www.example.com/page-with-schema" aria-label="Single URL to validate">
      <button onclick="runSingleUrlValidation()" style="margin-top: 0.75rem;">Run Validation</button>
      <p style="margin-top: 0.75rem; color: #4a5568; font-size: 0.9rem;">This will process the URL and display validation results in the table below. Use the validator buttons in the table to open external validators.</p>
      <label style="margin-top: 0.75rem; display: flex; align-items: center; gap: 0.5rem; font-weight: normal;">
        <input type="checkbox" id="autoSaveToSupabase" style="width: auto; margin: 0;" onchange="saveAutoSavePreference()">
        <span>Auto-save to Supabase</span>
      </label>
    </div>

    <!-- Batch CSV Validator Section -->
    <div class="batch-section">
      <label for="validatorCsvFile" style="margin-top: 0;">Upload CSV File with URLs:</label>
      <p style="margin-top: 0.5rem; margin-bottom: 1rem; color: #4a5568; font-size: 0.95rem; font-style: italic;">
        Use this to batch validate multiple URLs from your site for schema health.
      </p>
      <input type="file" id="validatorCsvFile" accept=".csv" aria-label="Validator CSV file upload" onchange="onFileUpload()">
      <button onclick="startValidation()">Validate URLs</button>
      <button onclick="downloadTemplateCSV()" class="secondary" style="margin-left: 0.5rem;">Download Template CSV</button>
      <button id="exportAllBtn" onclick="exportAllEnhanced()" class="secondary" style="margin-left: 0.5rem;" disabled>Export All Enhanced</button>
      <button id="saveAllBtn" onclick="saveAllToSupabase()" class="secondary" style="margin-left: 0.5rem;" disabled>Save All to Supabase</button>

    <div id="validatorProgress" style="display:none; margin-top: 1.5rem;">
      <div class="progress-bar">
        <div id="progressBarFill" class="progress-bar-fill" style="width: 0%;"></div>
      </div>
      <p id="progressText" style="margin-top: 0.75rem; color: #4a5568; font-size: 0.95rem;">Processing...</p>
    </div>

    <div id="validatorResults" style="display:none; margin-top: 2rem;">
      <h3>Validation Results</h3>
      <p style="margin-top: 0.5rem; margin-bottom: 1rem; color: #4a5568; font-size: 0.9rem; font-style: italic;">
        External validators open in a new tab. Due to cross-origin limits, results can't be read automatically ‚Äî set the status after reviewing.
      </p>
      <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
        <button onclick="setAllExternalStatusTo('Passed')" class="secondary" style="font-size: 0.875rem; padding: 0.5rem 1rem;">Set all Not run ‚Üí Passed</button>
        <button onclick="resetAllExternalStatus()" class="secondary" style="font-size: 0.875rem; padding: 0.5rem 1rem;">Reset all to Not run</button>
      </div>
      
      <!-- Status Legend -->
      <div class="status-legend">
        <div class="status-legend-item">
          <span class="chip-sample passed">‚úÖ Passed</span>
          <span>All valid; no missing fields</span>
        </div>
        <div class="status-legend-item">
          <span class="chip-sample issues">‚ö†Ô∏è Warning</span>
          <span>Duplicate or redundant schema nodes (non-critical)</span>
        </div>
        <div class="status-legend-item">
          <span class="info-entry">‚ÑπÔ∏è Info</span>
          <span>Legitimate multi-instance schemas (normal for Events, Products, FAQs)</span>
        </div>
        <div class="status-legend-item">
          <span class="chip-sample critical">‚ùå Critical</span>
          <span>Structural or required field errors</span>
        </div>
        <div class="status-legend-item" style="margin-left: auto;">
          <span style="color: #6b7280;">üí° Click any badge or "View Details" to see full analysis</span>
        </div>
      </div>
      
      <div class="scrollable-container">
        <table class="results-table">
          <thead>
            <tr>
              <th><span class="sortable-header" data-column="0">Page URL</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="1">Schema Type</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="2">Status</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="3">Missing Fields</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="4">Warnings</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="5">Info</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="6">Rich Results<br>Status (external)</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="7">Schema.org<br>Status (external)</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="8">Notes</span><span class="sort-indicator"> ‚Üï</span></th>
              <th>Actions</th>
            </tr>
            <tr class="filter-row">
              <th><input type="text" class="filter-input" data-column="0" placeholder="Filter URL..."></th>
              <th><input type="text" class="filter-input" data-column="1" placeholder="Filter Type..."></th>
              <th><input type="text" class="filter-input" data-column="2" placeholder="Filter Status..."></th>
              <th><input type="text" class="filter-input" data-column="3" placeholder="Filter Missing..."></th>
              <th><input type="text" class="filter-input" data-column="4" placeholder="Filter Warnings..."></th>
              <th><input type="text" class="filter-input" data-column="5" placeholder="Filter Info..."></th>
              <th><input type="text" class="filter-input" data-column="6" placeholder="Filter Rich Results..."></th>
              <th><input type="text" class="filter-input" data-column="7" placeholder="Filter Schema.org..."></th>
              <th><input type="text" class="filter-input" data-column="8" placeholder="Filter Notes..."></th>
              <th></th>
            </tr>
          </thead>
          <tbody id="resultsTableBody">
          </tbody>
        </table>
      </div>
    </div>

    </div>

    <!-- Help Block -->
    <div class="help-section" style="margin-top:1rem;padding:1rem;background:#f9f9f9;border-radius:8px;">
      <strong>‚ÑπÔ∏è How to Read Results:</strong>
      <ul style="margin-top:0.5rem;">
        <li><b>Schema Type</b>: Type(s) detected from JSON-LD (<code>@type</code> values).</li>
        <li><b>Status</b>: "Error" means fetch failed; "OK" means schema was found.</li>
        <li><b>Skipped</b>: Offline mode‚Äîexternal validators not queried.</li>
        <li><b>Schema.org / Google Buttons</b>: Open page in respective validators for manual checks.</li>
        <li><b>Save to Supabase</b>: (Optional) Stores results if DB logging is enabled.</li>
      </ul>
    </div>

    <div class="help-block" onclick="toggleHelpBlock()" onkeydown="if(event.key==='Enter'||event.key===' ')toggleHelpBlock()" role="button" tabindex="0" aria-expanded="false" id="helpBlock">
      <div class="help-block-header">
        <span>‚ÑπÔ∏è About Schema Validators</span>
        <span class="help-block-icon">‚ñº</span>
      </div>
      <div class="help-block-content" id="helpBlockContent">
        <strong>Schema.org Validator:</strong><br>
        Validates that your schema markup follows the Schema.org vocabulary specifications. Checks for correct syntax, required fields, and proper structure. Essential for ensuring your schema is semantically correct.<br><br>
        
        <strong>Google Rich Results Test:</strong><br>
        Tests whether your schema qualifies for Google's rich results (enhanced search listings). Shows which rich result types are detected and any issues that might prevent them from appearing in search results.<br><br>
        
        <strong>Results:</strong><br>
        Validation results are displayed in the table above. For detailed analysis, you'll need to manually review the validator pages opened in new tabs. When Supabase integration is connected, results can be automatically captured and stored for analysis.<br><br>
        
        <strong>Note:</strong> Both validators open in new browser tabs so you can review the detailed results while keeping this tool open.
      </div>
    </div>

    <!-- Debug Console -->
    <div class="debug-console">
      <div class="debug-console-header">
        <span>üîç Debug Console</span>
        <div class="debug-console-actions">
          <button onclick="clearDebugConsole()" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Clear</button>
          <button onclick="copyDebugConsole()" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Copy Logs</button>
        </div>
      </div>
      <div class="debug-console-content" id="debugConsoleContent">
        <div class="debug-log-entry success">
          <span class="debug-log-time"></span>Debug console ready. Logs will appear here when validation runs.
        </div>
      </div>
    </div>
  </div>

  <!-- Tab Guide Tab Content -->
  <div id="guideTab" class="tab-content">
    <div class="instructions" style="max-width: 100%;">
      <h2>üß† Tool Guide: What Each Tab Does</h2>

      <p>This tool contains several tabs, each with a specific use:</p>

      <h3>üü¢ Event Schema</h3>
      <ul>
        <li>Use this tab to generate JSON-LD Event schema from a CSV of your photography workshops.</li>
        <li>Supports <code>location</code>, <code>performer</code>, <code>offers</code>, and <code>organizer</code> fields.</li>
        <li>Paste the resulting schema into a code block on your Squarespace event page.</li>
      </ul>

      <h3>üîµ Product Schema</h3>
      <ul>
        <li>Generates <code>Product</code> schema from a CSV of lessons, vouchers, or services.</li>
        <li>Automatically filters out products with weak or missing reviews.</li>
        <li>‚úÖ <strong>Includes Schema Suppressor v1.3</strong> - automatically removes duplicate Squarespace Product schemas to prevent conflicts.</li>
        <li>Paste the JSON-LD into product pages on Squarespace.</li>
      </ul>

      <h3>üìù Blog Index Schema</h3>
      <ul>
        <li>Generates <code>CollectionPage</code> schema for your blog index/listing page.</li>
        <li>Helps search engines understand your blog structure and improve visibility.</li>
        <li>Includes publisher information and ItemList structure for blog posts.</li>
        <li>Paste the JSON-LD into your blog index page header or code block.</li>
      </ul>

      <h3>üü° Schema Validator</h3>
      <ul>
        <li>Enter one or more live URLs (CSV or single entry support coming).</li>
        <li>Fetches the page content and validates all structured data inside it.</li>
        <li>Flags missing or invalid fields and optionally builds an enhanced schema block you can download.</li>
        <li>Use this to <strong>audit</strong>, <strong>debug</strong>, or <strong>improve</strong> existing Squarespace pages.</li>
      </ul>

      <h3>üìå Best Practices</h3>
      <ul>
        <li>Only insert schema relevant to the page (don't paste every product on every product page).</li>
        <li>Always validate using the <strong>Schema Validator</strong> before and after injecting schema.</li>
        <li>Use <code>&lt;script type="application/ld+json"&gt;</code> inside a code block on Squarespace pages.</li>
      </ul>

      <h3>üîß Upcoming Features</h3>
      <ul>
        <li>Support for validating a single URL directly (no CSV needed).</li>
        <li>Supabase integration to track schema versions and history.</li>
        <li>AI suggestions for schema fixes.</li>
      </ul>
    </div>
  </div>

</div>

<script>
  // Tab switching - MUST be absolutely first, before any other code
  function switchTab(mode) {
    // Clear cache and storage when switching tabs
    try {
      // Clear ResultCache if it exists
      if (typeof ResultCache !== 'undefined') {
        if (ResultCache instanceof Map) {
          ResultCache.clear();
        } else if (ResultCache.clear && typeof ResultCache.clear === 'function') {
          ResultCache.clear();
        }
      }
      // Clear validationResults if it exists
      if (typeof validationResults !== 'undefined' && Array.isArray(validationResults)) {
        validationResults.length = 0;
      }
      // Clear localStorage and sessionStorage
      localStorage.removeItem('schemaValidatorResults');
      localStorage.removeItem('schemaValidatorCache');
      sessionStorage.removeItem('schemaValidatorResults');
      sessionStorage.removeItem('schemaValidatorCache');
    } catch (e) {
      console.warn('Failed to clear storage:', e);
    }
    
    // Clear the results table
    const tableBody = document.getElementById('resultsTableBody');
    if (tableBody) {
      tableBody.innerHTML = '';
    }
    
    // Reset all active tabs and contents
    const tabs = document.querySelectorAll('.tab');
    const contents = document.querySelectorAll('.tab-content');
    
    for (const tab of tabs) {
      tab.classList.remove('active');
    }
    for (const content of contents) {
      content.classList.remove('active');
    }
    
    // Activate correct tab based on mode
    const tabMap = {
      'event': { tabIndex: 0, contentId: 'eventTab' },
      'product': { tabIndex: 1, contentId: 'productTab' },
      'blog': { tabIndex: 2, contentId: 'blogTab' },
      'landing': { tabIndex: 3, contentId: 'landingTab' },
      'validator': { tabIndex: 4, contentId: 'validatorTab' },
      'guide': { tabIndex: 5, contentId: 'guideTab' }
    };
    
    const config = tabMap[mode];
    if (config && tabs[config.tabIndex] && tabs[config.tabIndex] !== null) {
      tabs[config.tabIndex].classList.add('active');
      const content = document.getElementById(config.contentId);
      if (content) {
        content.classList.add('active');
      }
    }
  }
  
  // Make it globally available
  window.switchTab = switchTab;
</script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
  // Override console methods to also log to debug console (MUST be before debugLog)
  const originalConsoleLog = console.log.bind(console);
  const originalConsoleError = console.error.bind(console);
  const originalConsoleWarn = console.warn.bind(console);
  
  // Schema Validator Suppression Configuration
  const SUPPRESSION_CONFIG = {
    suppressions: {
      global: {
        ignoreSchemaTypes: [
          "BreadcrumbList",
          "SearchAction",
          "Person",
          "Event",
          "ItemList",
          "Article",
          "Product"
        ],
        ignoreRecommendedFields: [
          "publisher",
          "telephone",
          "url",
          "description",
          "image",
          "logo",
          "contactPoint"
        ],
        ignoreWarningsContaining: [
          "Duplicate Event",
          "Duplicate BreadcrumbList",
          "Recommended field",
          "Unknown schema type",
          "Missing recommended",
          "normal navigation schema",
          "acceptable for combined schema types"
        ],
        ignoreInfoContaining: [
          "BreadcrumbList detected",
          "Recommended field",
          "Legitimate multi-instance schemas",
          "cached or blocked"
        ],
        ignoreUrlsMatching: [
          "/photographic-workshops-near-me",
          "/photography-classes",
          "/photography-services",
          "/photography-workshops",
          "/shop"
        ],
        downgradeDuplicates: true,
        collapseMultiInstanceEvents: true,
        hideSquarespaceInjectedBlocks: true,
        treatWarningsAsPass: true
      },
      rules: {
        Organization: {
          suppressMissingRecommended: true,
          ignoreExtraNodes: true
        },
        LocalBusiness: {
          suppressMissingRecommended: true,
          ignoreExtraNodes: true
        },
        WebSite: {
          suppressMissingRecommended: true,
          requireOnly: ["url", "name"]
        },
        Person: {
          ignoreUnknownType: true
        },
        BreadcrumbList: {
          collapseDuplicates: true
        },
        Event: {
          allowMultiple: true,
          collapseDuplicates: true
        },
        Product: {
          allowMultiple: true,
          ignoreNoReview: true
        }
      }
    }
  };

  // Multi-instance allowed schema types (expected to appear multiple times on a page)
  const MULTI_INSTANCE_ALLOWED_TYPES = ['Event', 'Product', 'Course', 'Article', 'Review', 'FAQPage', 'ListItem', 'Offer'];

  // Helper: Detect inferred schema types based on patterns in JSON-LD
  function detectInferredTypes(allNodes) {
    const inferredTypes = [];
    const typeCounts = {};
    
    // Count occurrences of each type
    allNodes.forEach(node => {
      const types = asArray(node['@type']);
      types.forEach(type => {
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });
    });
    
    // Rule 1: Carousel inference
    // If ‚â•3 Event items exist ‚Üí infer Carousel
    const eventCount = typeCounts['Event'] || 0;
    if (eventCount >= 3) {
      inferredTypes.push({ type: 'Carousel', reason: `from ${eventCount} Event schemas` });
    }
    
    // Rule 2: Carousel inference from Product/Course
    // If multiple Product or Course schemas exist ‚Üí also infer Carousel
    const productCount = typeCounts['Product'] || 0;
    const courseCount = typeCounts['Course'] || 0;
    if ((productCount + courseCount) >= 3) {
      inferredTypes.push({ type: 'Carousel', reason: `from ${productCount + courseCount} Product/Course schemas` });
    }
    
    // Rule 3: ReviewSnippet inference
    // If any item contains aggregateRating or review ‚Üí infer ReviewSnippet
    const hasReviews = allNodes.some(node => {
      return node.aggregateRating || 
             (node.review && Array.isArray(node.review) && node.review.length > 0) ||
             node.reviews;
    });
    
    if (hasReviews) {
      const reviewCount = allNodes.filter(node => {
        return node.aggregateRating || 
               (node.review && Array.isArray(node.review) && node.review.length > 0) ||
               node.reviews;
      }).length;
      inferredTypes.push({ type: 'ReviewSnippet', reason: `from ${reviewCount} item${reviewCount !== 1 ? 's' : ''} with reviews` });
    }
    
    // Rule 4: MerchantListing (Google) inference
    // If any Product schema contains all Merchant Center fields ‚Üí infer MerchantListing (Google)
    const productNodes = allNodes.filter(node => {
      const types = asArray(node['@type']);
      return types.includes('Product');
    });
    
    console.log(`[MerchantListing] Checking ${productNodes.length} Product node(s) for Merchant Center fields`);
    debugLog(`[MerchantListing] Checking ${productNodes.length} Product node(s) for Merchant Center fields`, 'info');
    
    // Debug: Log Product node details
    productNodes.forEach((node, idx) => {
      console.log(`[MerchantListing] Product node ${idx + 1}:`, {
        '@type': node['@type'],
        hasOffers: !!node.offers,
        offersType: node.offers ? (Array.isArray(node.offers) ? 'array' : 'object') : 'none',
        hasPriceCurrency: !!node.offers?.priceCurrency || !!node.offers?.[0]?.priceCurrency,
        hasPrice: !!node.offers?.price || !!node.offers?.[0]?.price,
        hasAvailability: !!node.offers?.availability || !!node.offers?.[0]?.availability,
        hasMerchantReturnPolicy: !!node.hasMerchantReturnPolicy
      });
    });
    
    const hasMerchantListing = productNodes.some(node => {
      const detected = detectMerchantListing(node);
      if (detected) {
        console.log(`[MerchantListing] ‚úÖ Detected MerchantListing in Product node:`, node);
        debugLog(`[MerchantListing] ‚úÖ Detected MerchantListing in Product node: ${JSON.stringify({ '@type': node['@type'], hasOffers: !!node.offers, hasReturnPolicy: !!node.hasMerchantReturnPolicy })}`, 'success');
      }
      return detected;
    });
    
    if (hasMerchantListing) {
      inferredTypes.push({ type: 'MerchantListing (Google)', reason: 'Product schema contains all Merchant Center fields (offers, price, priceCurrency, availability, hasMerchantReturnPolicy)' });
      console.log(`[MerchantListing] ‚úÖ Added MerchantListing (Google) to inferred types. Total inferred types:`, inferredTypes);
      debugLog(`[MerchantListing] ‚úÖ Added MerchantListing (Google) to inferred types`, 'success');
    } else {
      console.log(`[MerchantListing] ‚ùå No Product schemas found with all Merchant Center fields`);
      debugLog(`[MerchantListing] ‚ùå No Product schemas found with all Merchant Center fields`, 'info');
    }
    
    // Deduplicate inferred types (e.g., if Carousel appears twice)
    const uniqueInferred = [];
    const seenTypes = new Set();
    inferredTypes.forEach(item => {
      if (!seenTypes.has(item.type)) {
        seenTypes.add(item.type);
        uniqueInferred.push(item);
      }
    });
    
    return uniqueInferred;
  }

  // Suppression Filtering Functions
  function shouldSuppressWarning(message, url = '') {
    if (!message) return false;
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing warning by URL pattern: ${message}`, 'info');
      return true;
    }
    
    // Check message content
    if (sup.ignoreWarningsContaining.some(pattern => message.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing warning by pattern: ${message}`, 'info');
      return true;
    }
    
    return false;
  }

  function shouldSuppressInfo(message, url = '') {
    if (!message) return false;
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing info by URL pattern: ${message}`, 'info');
      return true;
    }
    
    // Check message content
    if (sup.ignoreInfoContaining.some(pattern => message.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing info by pattern: ${message}`, 'info');
      return true;
    }
    
    return false;
  }

  function shouldSuppressMissingField(field, schemaType, url = '') {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    const rule = SUPPRESSION_CONFIG.suppressions.rules[schemaType];
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing missing field by URL pattern: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check if schema type should be ignored
    if (sup.ignoreSchemaTypes.includes(schemaType)) {
      debugLog(`[SUPPRESSION] Suppressing missing field by schema type: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check if field is in ignoreRecommendedFields
    if (sup.ignoreRecommendedFields.includes(field)) {
      debugLog(`[SUPPRESSION] Suppressing missing field by recommended field list: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check type-specific rules
    if (rule) {
      if (rule.suppressMissingRecommended && field.toLowerCase().includes('recommended')) {
        debugLog(`[SUPPRESSION] Suppressing missing field by type rule (suppressMissingRecommended): ${schemaType}.${field}`, 'info');
        return true;
      }
      if (rule.requireOnly && !rule.requireOnly.includes(field)) {
        debugLog(`[SUPPRESSION] Suppressing missing field by type rule (requireOnly): ${schemaType}.${field}`, 'info');
        return true;
      }
    }
    
    return false;
  }

  function shouldSuppressSchemaType(schemaType) {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    return sup.ignoreSchemaTypes.includes(schemaType);
  }

  function shouldDowngradeDuplicate(schemaType) {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    const rule = SUPPRESSION_CONFIG.suppressions.rules[schemaType];
    
    if (sup.downgradeDuplicates) {
      return true;
    }
    
    if (rule && rule.collapseDuplicates) {
      return true;
    }
    
    return false;
  }

  function filterSuppressedWarnings(warnings, url = '') {
    if (!warnings || !Array.isArray(warnings)) return [];
    return warnings.filter(w => !shouldSuppressWarning(w, url));
  }

  function filterSuppressedInfo(info, url = '') {
    if (!info || !Array.isArray(info)) return [];
    return info.filter(i => !shouldSuppressInfo(i, url));
  }

  function filterSuppressedMissingFields(missingFields, schemaType, url = '') {
    if (!missingFields || !Array.isArray(missingFields)) return [];
    
    return missingFields.filter(field => {
      // Extract field name from different formats
      const fieldName = typeof field === 'string' 
        ? field.split(':')[1]?.trim().replace(/["\s]/g, '') || field.split('.')[1] || field
        : field.field || field;
      
      return !shouldSuppressMissingField(fieldName, schemaType, url);
    });
  }

  // Debug Console Logging Functions - MUST be first
  function debugLog(message, level = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const prefix = `[${timestamp}]`;
    
    // Console logging - use original methods to avoid recursion
    if (level === 'error') {
      originalConsoleError(`${prefix} ‚ùå ${message}`);
    } else if (level === 'warn') {
      originalConsoleWarn(`${prefix} ‚ö†Ô∏è ${message}`);
    } else if (level === 'success') {
      originalConsoleLog(`${prefix} ‚úÖ ${message}`);
    } else {
      originalConsoleLog(`${prefix} ${message}`);
    }
    
    // Also write to visible debug panel (statusDebugPanel) - REMOVED, using bottom debug console only
    // Remove this section - debug panel above table has been removed
    
    // Also write to existing debug console (debugConsoleContent)
    const consoleContent = document.getElementById('debugConsoleContent');
    if (consoleContent) {
      const entry = document.createElement('div');
      entry.className = `debug-log-entry ${level}`;
      
      const timeSpan = document.createElement('span');
      timeSpan.className = 'debug-log-time';
      timeSpan.textContent = prefix;
      
      const messageSpan = document.createElement('span');
      messageSpan.textContent = typeof message === 'object' ? JSON.stringify(message, null, 2) : message;
      
      entry.appendChild(timeSpan);
      entry.appendChild(messageSpan);
      consoleContent.appendChild(entry);
      
      // Auto-scroll to bottom
      consoleContent.scrollTop = consoleContent.scrollHeight;
      
      // Keep max 100 entries to prevent memory issues
      const entries = consoleContent.querySelectorAll('.debug-log-entry');
      if (entries.length > 100) {
        entries[0].remove();
      }
    }
  }
  
  function clearDebugConsole() {
    const consoleContent = document.getElementById('debugConsoleContent');
    if (consoleContent) {
      consoleContent.innerHTML = '<div class="debug-log-entry success"><span class="debug-log-time"></span>Debug console cleared.</div>';
    }
  }
  
  function copyDebugConsole() {
    const consoleContent = document.getElementById('debugConsoleContent');
    if (!consoleContent) return;
    
    const entries = consoleContent.querySelectorAll('.debug-log-entry');
    const logs = Array.from(entries).map(entry => {
      const time = entry.querySelector('.debug-log-time')?.textContent || '';
      const message = entry.textContent.replace(time, '').trim();
      return `${time} ${message}`;
    }).join('\n');
    
    navigator.clipboard.writeText(logs).then(() => {
      debugLog('‚úÖ Logs copied to clipboard!', 'success');
      setTimeout(() => {
        const lastEntry = consoleContent.querySelector('.debug-log-entry:last-child');
        if (lastEntry && lastEntry.textContent.includes('copied to clipboard')) {
          lastEntry.remove();
        }
      }, 2000);
    }).catch(err => {
      debugLog('‚ùå Failed to copy logs: ' + err.message, 'error');
    });
  }
  
  // Override console methods to also log to debug console (after debugLog is defined)
  // Ensure originalConsole methods are available (they're defined earlier in this script block)
  if (typeof originalConsoleLog !== 'undefined') {
    console.log = function(...args) {
      try {
        originalConsoleLog.apply(console, args);
        const message = args.map(a => {
          if (typeof a === 'object') {
            try {
              return JSON.stringify(a, null, 2);
            } catch (e) {
              return String(a);
            }
          }
          return String(a);
        }).join(' ');
        // Use originalConsoleLog to avoid recursion
        if (message && typeof debugLog === 'function') {
          debugLog(message, 'info');
        }
      } catch (e) {
        // Fallback to native console if override fails
        console.log.apply(console, args);
      }
    };
  }
  
  if (typeof originalConsoleError !== 'undefined') {
    console.error = function(...args) {
      try {
        originalConsoleError.apply(console, args);
        const message = args.map(a => {
          if (typeof a === 'object') {
            try {
              return JSON.stringify(a, null, 2);
            } catch (e) {
              return String(a);
            }
          }
          return String(a);
        }).join(' ');
        // Use originalConsoleError to avoid recursion
        if (message && typeof debugLog === 'function') {
          debugLog(message, 'error');
        }
      } catch (e) {
        // Fallback to native console if override fails
        console.error.apply(console, args);
      }
    };
  }
  
  if (typeof originalConsoleWarn !== 'undefined') {
    console.warn = function(...args) {
      try {
        originalConsoleWarn.apply(console, args);
        const message = args.map(a => {
          if (typeof a === 'object') {
            try {
              return JSON.stringify(a, null, 2);
            } catch (e) {
              return String(a);
            }
          }
          return String(a);
        }).join(' ');
        // Use originalConsoleWarn to avoid recursion
        if (message && typeof debugLog === 'function') {
          debugLog(message, 'warn');
        }
      } catch (e) {
        // Fallback to native console if override fails
        console.warn.apply(console, args);
      }
    };
  }

  // Supabase Configuration
  const SUPABASE_URL = 'https://igzvwbvgvmzvvzoclufx.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnenZ3YnZndm16dnZ6b2NsdWZ4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2Nzc5MjgsImV4cCI6MjA3MzI1MzkyOH0.A9TCmnXKJhDRYBkrO0mAMPiUQeV9enweeyRWKWQ1SZY';
  
  // Initialize Supabase client (wait for library to load)
  let supabase = null;
  let supabaseAvailable = false;
  
  // Wait for Supabase library to load
  function initSupabase() {
    // Check for Supabase library loaded via CDN (UMD build)
    if (typeof window.supabase !== 'undefined' && typeof window.supabase.createClient === 'function') {
      try {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        supabaseAvailable = true;
        console.log('‚úÖ Supabase client initialized successfully');
        
        // Update bulk buttons state when Supabase is available
        updateBulkButtons();
        
        return true;
      } catch (error) {
        console.error('Failed to initialize Supabase client:', error);
      }
    }
    return false;
  }
  
  // Try to initialize when script loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      if (!initSupabase()) {
        // Retry after delays
        setTimeout(initSupabase, 500);
        setTimeout(initSupabase, 1500);
      }
    });
  } else {
    if (!initSupabase()) {
      // Retry after delays
      setTimeout(initSupabase, 500);
      setTimeout(initSupabase, 1500);
    }
  }
  
  // Final retry after all scripts load
  window.addEventListener('load', function() {
    if (!supabaseAvailable) {
      initSupabase();
    }
    // Load auto-run preference
    loadAutoRunPreference();
    // Load auto-save preference
    loadAutoSavePreference();
  });
  
  
  // Progress bar helpers
  function renderProgress(cell) {
    cell.innerHTML = `
      <div class="progress-wrap">
        <div class="progress"><span style="width:0%"></span></div>
        <div class="progress-label">0%</div>
      </div>`;
  }
  
  function setProgress(cell, pct, text) {
    const bar = cell.querySelector('.progress > span');
    const lbl = cell.querySelector('.progress-label');
    if (bar) { bar.style.width = Math.max(0, Math.min(100, pct)) + '%'; }
    if (lbl) { lbl.textContent = (text ? text + ' ¬∑ ' : '') + Math.round(pct) + '%'; }
  }
  
  function markProgressError(cell) {
    const bar = cell.querySelector('.progress > span');
    if (bar) { bar.style.background = 'linear-gradient(90deg,#ff5252,#ff8a80)'; }
  }
  
  // ---- NEW: Modal helpers --------------------------------------
  function openModal(title, html) {
    let modal = document.querySelector('#detail-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'detail-modal';
      modal.innerHTML = `
        <div class="modal-backdrop"></div>
        <div class="modal">
          <div class="modal-head">
            <h3 id="modal-title"></h3>
            <button id="modal-close" aria-label="Close">‚úñ</button>
          </div>
          <div class="modal-body"></div>
        </div>`;
      document.body.appendChild(modal);
      modal.querySelector('#modal-close').onclick = () => modal.remove();
      modal.querySelector('.modal-backdrop').onclick = () => modal.remove();
    }
    modal.querySelector('#modal-title').textContent = title;
    modal.querySelector('.modal-body').innerHTML = html;
  }

  // Step completion modals
  function showStepSuccessModal(stepNumber, stepName, message, nextStepInstructions, fileLocation) {
    const html = `
      <div style="padding: 1.5rem;">
        <div style="text-align: center; margin-bottom: 1.5rem;">
          <div style="font-size: 4rem; margin-bottom: 1rem;">‚úÖ</div>
          <h2 style="color: #27AE60; margin: 0 0 0.5rem 0;">Step ${stepNumber} Complete!</h2>
          <p style="color: #4a5568; font-size: 1.1rem; margin: 0;">${stepName}</p>
        </div>
        
        <div style="background: #f7fafc; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #2d3748;">What happened:</p>
          <p style="margin: 0; color: #4a5568; line-height: 1.6;">${message}</p>
          ${fileLocation ? `<p style="margin: 1rem 0 0 0; color: #2d3748;"><strong>üìÅ File saved:</strong> <code style="background: #e2e8f0; padding: 2px 6px; border-radius: 4px;">${fileLocation}</code></p>` : ''}
        </div>
        
        ${nextStepInstructions ? `
        <div style="background: #e6f3ff; padding: 1rem; border-left: 4px solid #007bff; border-radius: 4px; margin-bottom: 1rem;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #004085;">üí° What's Next:</p>
          <p style="margin: 0; color: #004085; line-height: 1.6;">${nextStepInstructions}</p>
        </div>
        ` : ''}
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="document.querySelector('#detail-modal').remove()" style="padding: 0.75rem 2rem; background: #667eea; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer;">
            Got it!
          </button>
        </div>
      </div>
    `;
    openModal(`‚úÖ Step ${stepNumber} Complete`, html);
  }

  function showStepErrorModal(stepNumber, stepName, errorMessage, troubleshootingSteps) {
    const html = `
      <div style="padding: 1.5rem;">
        <div style="text-align: center; margin-bottom: 1.5rem;">
          <div style="font-size: 4rem; margin-bottom: 1rem;">‚ùå</div>
          <h2 style="color: #E74C3C; margin: 0 0 0.5rem 0;">Step ${stepNumber} Failed</h2>
          <p style="color: #4a5568; font-size: 1.1rem; margin: 0;">${stepName}</p>
        </div>
        
        <div style="background: #fff5f5; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 4px solid #E74C3C;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #c53030;">Error:</p>
          <p style="margin: 0; color: #742a2a; line-height: 1.6; font-family: monospace; background: #fff; padding: 0.5rem; border-radius: 4px;">${escapeHtml(errorMessage)}</p>
        </div>
        
        ${troubleshootingSteps ? `
        <div style="background: #fffbf0; padding: 1rem; border-radius: 8px; border-left: 4px solid #f59e0b;">
          <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: #92400e;">üîß Troubleshooting:</p>
          <ul style="margin: 0; padding-left: 1.5rem; color: #78350f; line-height: 1.8;">
            ${troubleshootingSteps.map(step => `<li>${step}</li>`).join('')}
          </ul>
        </div>
        ` : ''}
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="document.querySelector('#detail-modal').remove()" style="padding: 0.75rem 2rem; background: #E74C3C; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer;">
            Close
          </button>
        </div>
      </div>
    `;
    openModal(`‚ùå Step ${stepNumber} Failed`, html);
  }

  function showFinalCompletionModal() {
    if (!window.completedSteps) {
      return;
    }
    
    const steps = window.completedSteps;
    const stepNames = {
      2: 'Step 2 - Clean and Normalize CSV',
      '3a': 'Step 3a - Fetch Google Reviews',
      '3b': 'Step 3b - Merge Reviews',
      4: 'Step 4 - Generate Product Schema'
    };
    
    let summaryHtml = '<div style="padding: 1.5rem;">';
    summaryHtml += '<div style="text-align: center; margin-bottom: 1.5rem;">';
    summaryHtml += '<div style="font-size: 4rem; margin-bottom: 1rem;">üéâ</div>';
    summaryHtml += '<h2 style="color: #27AE60; margin: 0 0 0.5rem 0;">All Steps Complete!</h2>';
    summaryHtml += '<p style="color: #4a5568; font-size: 1.1rem; margin: 0;">Your product schemas are ready</p>';
    summaryHtml += '</div>';
    
    summaryHtml += '<div style="background: #f7fafc; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">';
    summaryHtml += '<p style="margin: 0 0 1rem 0; font-weight: 600; color: #2d3748;">üìä Step Summary:</p>';
    
    const stepOrder = [2, '3a', '3b', 4];
    let allSuccess = true;
    
    for (const stepId of stepOrder) {
      const step = steps[stepId];
      const stepName = stepNames[stepId] || `Step ${stepId}`;
      
      if (step) {
        summaryHtml += `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: #d4edda; border-left: 4px solid #27AE60; border-radius: 4px;">`;
        summaryHtml += `<p style="margin: 0; font-weight: 600; color: #155724;">‚úÖ ${stepName}</p>`;
        summaryHtml += `<p style="margin: 0.25rem 0 0 0; color: #155724; font-size: 0.9rem;">${step.message}</p>`;
        if (step.file) {
          summaryHtml += `<p style="margin: 0.25rem 0 0 0; color: #155724; font-size: 0.85rem;"><code style="background: #c3e6cb; padding: 2px 6px; border-radius: 3px;">${step.file}</code></p>`;
        }
        summaryHtml += `</div>`;
      } else {
        allSuccess = false;
        summaryHtml += `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">`;
        summaryHtml += `<p style="margin: 0; font-weight: 600; color: #856404;">‚ö†Ô∏è ${stepName}</p>`;
        summaryHtml += `<p style="margin: 0.25rem 0 0 0; color: #856404; font-size: 0.9rem;">Status unknown</p>`;
        summaryHtml += `</div>`;
      }
    }
    
    summaryHtml += '</div>';
    
    // Add Schema Generation Summary if Step 4 data is available
    const step4 = steps[4];
    if (step4 && (step4.totalProducts !== null || step4.matchCount !== null || step4.mappedGoogleCount !== null)) {
      summaryHtml += '<div style="background: #fff9e6; padding: 1rem; border-left: 4px solid #ff9800; border-radius: 4px; margin-bottom: 1rem;">';
      summaryHtml += '<p style="margin: 0 0 0.75rem 0; font-weight: 600; color: #e65100; font-size: 1rem;">üìä Schema Generation Summary:</p>';
      summaryHtml += '<div style="font-size: 0.9rem; color: #5d4037;">';
      
      // Product counts
      summaryHtml += '<div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #ffe0b2;">';
      if (step4.totalProducts !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Total products:</strong> ${step4.totalProducts}</div>`;
      }
      if (step4.matchCount !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Products with reviews:</strong> <span style="color: #27AE60; font-weight: 600;">${step4.matchCount}</span></div>`;
      }
      if (step4.productsWithoutReviews !== null) {
        summaryHtml += `<div><strong>Products without reviews:</strong> ${step4.productsWithoutReviews}</div>`;
      }
      summaryHtml += '</div>';
      
      // Schema types section
      if (step4 && (step4.schemaTypeProduct !== null || step4.schemaTypeCourse !== null || step4.schemaTypeEvent !== null)) {
        summaryHtml += '<div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #ffe0b2;">';
        summaryHtml += '<div style="font-weight: 600; margin-bottom: 0.5rem; color: #e65100;">üìã Schema Types Generated:</div>';
        if (step4.schemaTypeProduct !== null) {
          summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Product only:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.schemaTypeProduct}</span></div>`;
        }
        if (step4.schemaTypeCourse !== null) {
          summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Product + Course:</strong> <span style="color: #388e3c; font-weight: 600;">${step4.schemaTypeCourse}</span></div>`;
        }
        if (step4.schemaTypeEvent !== null) {
          summaryHtml += `<div><strong>Product + Event:</strong> <span style="color: #f57c00; font-weight: 600;">${step4.schemaTypeEvent}</span></div>`;
        }
        summaryHtml += '</div>';
      }
      
      // Mapped reviews section
      summaryHtml += '<div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #ffe0b2;">';
      summaryHtml += '<div style="font-weight: 600; margin-bottom: 0.5rem; color: #e65100;">üìä Mapped Reviews:</div>';
      
      // Google reviews
      if (step4.mappedGoogleCount !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;">`;
        summaryHtml += `<strong>Google reviews mapped:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.mappedGoogleCount}</span>`;
        if (step4.googleReviewsCount !== null && step4.googleReviewsCount !== step4.mappedGoogleCount) {
          summaryHtml += ` <span style="color: #757575; font-size: 0.85em;">(of ${step4.googleReviewsCount} total)</span>`;
        }
        summaryHtml += `</div>`;
        if (step4.latestGoogleDate) {
          summaryHtml += `<div style="margin-left: 1.5rem; margin-bottom: 0.25rem; color: #757575; font-size: 0.85em;">Latest: ${step4.latestGoogleDate}</div>`;
        }
      } else if (step4.googleReviewsCount !== null) {
        // Fallback to old format
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Google reviews:</strong> ${step4.googleReviewsCount}</div>`;
      }
      
      // Trustpilot reviews
      if (step4.mappedTrustpilotCount !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;">`;
        summaryHtml += `<strong>Trustpilot reviews mapped:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.mappedTrustpilotCount}</span>`;
        if (step4.trustpilotReviewsCount !== null && step4.trustpilotReviewsCount !== step4.mappedTrustpilotCount) {
          summaryHtml += ` <span style="color: #757575; font-size: 0.85em;">(of ${step4.trustpilotReviewsCount} total)</span>`;
        }
        summaryHtml += `</div>`;
        if (step4.latestTrustpilotDate) {
          summaryHtml += `<div style="margin-left: 1.5rem; margin-bottom: 0.25rem; color: #757575; font-size: 0.85em;">Latest: ${step4.latestTrustpilotDate}</div>`;
        }
      } else if (step4.trustpilotReviewsCount !== null) {
        // Fallback to old format
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Trustpilot reviews:</strong> ${step4.trustpilotReviewsCount}</div>`;
      }
      
      // Total mapped reviews
      if (step4.totalMappedReviews !== null) {
        summaryHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ffe0b2;"><strong>Total mapped reviews:</strong> <span style="color: #27AE60; font-weight: 600;">${step4.totalMappedReviews}</span></div>`;
      }
      
      // Overall latest review date (if available and different from individual dates)
      if (step4.latestReviewDate && (!step4.latestGoogleDate || !step4.latestTrustpilotDate || step4.latestReviewDate !== step4.latestGoogleDate || step4.latestReviewDate !== step4.latestTrustpilotDate)) {
        summaryHtml += `<div style="margin-top: 0.25rem; color: #757575; font-size: 0.85em;">Overall latest review: ${step4.latestReviewDate}</div>`;
      }
      
      summaryHtml += '</div>';
      
      // Reviews included in schema section
      if (step4.includedGoogleCount !== null || step4.includedTrustpilotCount !== null || step4.totalExcludedReviews !== null) {
        summaryHtml += '<div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #ffe0b2;">';
        summaryHtml += '<div style="font-weight: 600; margin-bottom: 0.5rem; color: #e65100;">üì¶ Reviews Included in Schema:</div>';
        summaryHtml += '<div style="font-size: 0.85em; color: #757575; margin-bottom: 0.5rem;">(Capped at 25 reviews per product for optimal schema performance)</div>';
        
        if (step4.includedGoogleCount !== null) {
          summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Google reviews included:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.includedGoogleCount}</span></div>`;
        }
        if (step4.includedTrustpilotCount !== null) {
          summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Trustpilot reviews included:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.includedTrustpilotCount}</span></div>`;
        }
        if (step4.totalIncludedReviews !== null) {
          summaryHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ffe0b2;"><strong>Total included:</strong> <span style="color: #27AE60; font-weight: 600;">${step4.totalIncludedReviews}</span></div>`;
        }
        if (step4.totalExcludedReviews !== null && step4.totalExcludedReviews > 0) {
          summaryHtml += `<div style="margin-top: 0.25rem; color: #f57c00; font-weight: 500;">Reviews excluded due to 25-review cap: <span style="color: #e65100;">${step4.totalExcludedReviews}</span></div>`;
        }
        if (step4.newestReviewDateIncluded) {
          summaryHtml += `<div style="margin-top: 0.25rem; color: #757575; font-size: 0.85em;">Newest review date included: <strong>${step4.newestReviewDateIncluded}</strong></div>`;
        }
        
        summaryHtml += '</div>';
      }
      summaryHtml += '</div>';
      summaryHtml += '</div>';
    }
    
    summaryHtml += '<div style="background: #e6f3ff; padding: 1rem; border-left: 4px solid #007bff; border-radius: 4px; margin-bottom: 1rem;">';
    summaryHtml += '<p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #004085;">üí° Next Steps:</p>';
    summaryHtml += '<ul style="margin: 0; padding-left: 1.5rem; color: #004085; line-height: 1.8;">';
    summaryHtml += '<li>Find your schema files in the <code style="background: #cbd5e0; padding: 2px 4px; border-radius: 3px;">outputs/</code> folder</li>';
    summaryHtml += '<li>Each product has a Squarespace-ready HTML file</li>';
    summaryHtml += '<li>Copy-paste the HTML into Squarespace Code Blocks</li>';
    summaryHtml += '<li>Validate with <a href="https://search.google.com/test/rich-results" target="_blank" style="color: #007bff; text-decoration: underline;">Google Rich Results Test</a></li>';
    summaryHtml += '</ul>';
    summaryHtml += '</div>';
    
    summaryHtml += '<div style="text-align: center; margin-top: 1.5rem;">';
    summaryHtml += '<button onclick="document.querySelector(\'#detail-modal\').remove()" style="padding: 0.75rem 2rem; background: #27AE60; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer;">';
    summaryHtml += 'Got it!';
    summaryHtml += '</button>';
    summaryHtml += '</div>';
    summaryHtml += '</div>';
    
    openModal('üéâ Workflow Complete!', summaryHtml);
  }

  function codeBlock(label, code) {
    return `
      <div class="code-card">
        <div class="code-card-head">
          <strong>${label}</strong>
          <button class="copy-btn" data-code="${encodeURIComponent(code)}">Copy</button>
        </div>
        <pre><code>${escapeHtml(code)}</code></pre>
      </div>`;
  }

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }

  // Copy button handler
  document.addEventListener('click', (e) => {
    const copy = e.target.closest('.copy-btn');
    if (!copy) return;
    const code = decodeURIComponent(copy.dataset.code || '');
    navigator.clipboard.writeText(code).then(() => { 
      copy.textContent = 'Copied'; 
      setTimeout(() => copy.textContent = 'Copy', 1200); 
    });
  });

  // Minimal extractor: same logic you use in the scanner, but HTML-in
  function extractJsonLdBlocksFromHtml(html) {
    const blocks = [];
    const re = /<script[^>]+type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi;
    let m;
    while ((m = re.exec(html))) {
      try {
        const jsonText = m[1].trim();
        if (!jsonText) continue;
        
        const json = JSON.parse(jsonText);
        
        // Handle @graph structure
        if (json['@graph'] && Array.isArray(json['@graph'])) {
          json['@graph'].forEach(j => {
            if (j && j['@type']) {
              blocks.push(j);
            }
          });
        }
        // Handle array of schemas
        else if (Array.isArray(json)) {
          json.forEach(j => {
            if (j && j['@type']) {
              blocks.push(j);
            }
          });
        }
        // Handle single schema object
        else if (json && json['@type']) {
          blocks.push(json);
        }
      } catch (e) {
        // Try to extract even if JSON parsing fails partially
        console.warn('Failed to parse JSON-LD block:', e);
      }
    }
    
    // Also try to find schemas in noscript tags (Squarespace sometimes puts them there)
    const noscriptRe = /<noscript[^>]*>([\s\S]*?)<\/noscript>/gi;
    let noscriptMatch;
    while ((noscriptMatch = noscriptRe.exec(html))) {
      const noscriptContent = noscriptMatch[1];
      const scriptRe = /<script[^>]+type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi;
      let scriptMatch;
      while ((scriptMatch = scriptRe.exec(noscriptContent))) {
        try {
          const jsonText = scriptMatch[1].trim();
          if (!jsonText) continue;
          
          const json = JSON.parse(jsonText);
          
          if (json['@graph'] && Array.isArray(json['@graph'])) {
            json['@graph'].forEach(j => {
              if (j && j['@type']) {
                blocks.push(j);
              }
            });
          } else if (Array.isArray(json)) {
            json.forEach(j => {
              if (j && j['@type']) {
                blocks.push(j);
              }
            });
          } else if (json && json['@type']) {
            blocks.push(json);
          }
        } catch (e) {
          console.warn('Failed to parse JSON-LD from noscript:', e);
        }
      }
    }
    
    return blocks;
  }

  // Build a single, cleaned-up, recommended schema graph
  function buildEnhancedSchema(blocks, selectedTypes = []) {
    const graph = [];
    const types = t => Array.isArray(t) ? t : [t].filter(Boolean);
    const seen = new Set();
    const add = (node) => {
      const key = JSON.stringify([types(node['@type']).sort(), node['@id'] || node.url || node.name]);
      if (seen.has(key)) return;
      seen.add(key);
      graph.push(node);
    };

    // Helper to check if schema matches selected types
    const matchesSelectedTypes = (node) => {
      if (selectedTypes.length === 0) return true; // Include all if none selected
      const nodeTypes = types(node['@type']);
      return nodeTypes.some(t => selectedTypes.includes(t));
    };

    // Merge Organization/LocalBusiness (only if selected)
    const org = {
      '@type': ['Organization','LocalBusiness'],
      '@id': 'https://www.alanranger.com/#org',
      name: 'Alan Ranger Photography',
      url: 'https://www.alanranger.com/',
      telephone: '+44 7817 017994',
      image: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w'
    };

    // Keep existing ItemList/Event/etc., but ensure @id where missing
    blocks.forEach(b => {
      const ts = types(b['@type']);
      if (ts.includes('Organization') || ts.includes('LocalBusiness')) {
        // prefer our canonical org baseline merged
        return;
      }
      if (!b['@id'] && (b.url || b.name)) b['@id'] = (b.url || `#${(b.name||'node').toLowerCase().replace(/\s+/g,'-')}`);
      
      // Only add if matches selected types
      if (matchesSelectedTypes(b)) {
        add(b);
      }
    });

    // Only add org if Organization or LocalBusiness is selected
    if (selectedTypes.length === 0 || selectedTypes.includes('Organization') || selectedTypes.includes('LocalBusiness')) {
      add(org);
    }

    return { '@context': 'https://schema.org', '@graph': graph };
  }

  // Event delegation for View Details and Generate Enhanced buttons
  document.addEventListener('click', async (e) => {
      // View Details - use new improved modal
      const view = e.target.closest('.btn-view-details, [data-action="view-details"], .view-details-btn');
      if (view) {
        const row = view.closest('tr');
        if (!row) return;
        const rowData = getRowDataFromTr(row);
        openIssuesModal(rowData);
        return;
      }

    // Generate Enhanced
    const gen = e.target.closest('.btn-generate-enhanced, [data-action="generate-enhanced"], .enhance-btn');
    if (gen && (gen.textContent.includes('Generate Enhanced') || gen.id?.includes('genBtn'))) {
      const row = gen.closest('tr');
      const url = row?.dataset?.url || row?.querySelector('a.url-link')?.href;
      if (!url) {
        alert('Could not determine URL for this row.');
        return;
      }
      
      try {
        // Update button state
        const originalText = gen.textContent;
        gen.disabled = true;
        gen.textContent = 'Fetching...';
        
        // Server-side fetch (avoids CORS)
        const res = await fetch(`/api/fetch-html?url=${encodeURIComponent(url)}`, { method: 'GET' });
        if (!res.ok) throw new Error(`Server fetch failed: ${res.status}`);
        const html = await res.text();

        // Extract JSON-LD blocks from HTML
        const blocks = extractJsonLdBlocksFromHtml(html);
        // Build an enhanced consolidated schema suggestion
        const enhanced = buildEnhancedSchema(blocks);

        gen.textContent = originalText;
        gen.disabled = false;
        
        // Use the proper Enhanced Schema modal instead of openModal
        const backdrop = document.getElementById('genBackdrop');
        const metaEl = document.getElementById('genMeta');
        const jsonEl = document.getElementById('genJson');
        const titleEl = document.getElementById('genTitle');
        if (backdrop && metaEl && jsonEl && titleEl) {
          titleEl.textContent = 'Enhanced Schema (suggestion)';
          metaEl.textContent = url;
          jsonEl.textContent = JSON.stringify(enhanced, null, 2);
          // Store URL and JSON for save function
          backdrop.dataset.url = url;
          backdrop.dataset.json = JSON.stringify(enhanced, null, 2);
          backdrop.style.display = 'flex';
          setupCopyButton();
          setupSaveButton();
        } else {
          openModal('Enhanced Schema (suggestion)', codeBlock('Paste this in a single <script type="application/ld+json">', JSON.stringify(enhanced, null, 2)));
        }
      } catch (err) {
        gen.textContent = originalText;
        gen.disabled = false;
        alert(`Enhanced Schema Error: ${escapeHtml(err.message)}\n\nTip: server route must exist at /api/fetch-html.`);
      }
    }
  });
  
  // Helper: Collect existing schema types from the page
  function collectExistingSchemaTypes(jsonLdBlocks) {
    const types = new Set();
    
    if (!jsonLdBlocks || !Array.isArray(jsonLdBlocks)) {
      return [];
    }
    
    jsonLdBlocks.forEach(block => {
      try {
        // Handle @graph structure
        if (block['@graph'] && Array.isArray(block['@graph'])) {
          block['@graph'].forEach(item => {
            if (item['@type']) {
              const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
              itemTypes.forEach(t => types.add(t));
            }
          });
        }
        // Handle array of schemas
        else if (Array.isArray(block)) {
          block.forEach(item => {
            if (item['@type']) {
              const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
              itemTypes.forEach(t => types.add(t));
            }
          });
        }
        // Handle single schema object
        else if (block['@type']) {
          const blockTypes = Array.isArray(block['@type']) ? block['@type'] : [block['@type']];
          blockTypes.forEach(t => types.add(t));
        }
      } catch (e) {
        console.warn('Invalid JSON-LD block ignored:', e);
      }
    });
    
    return Array.from(types);
  }

  // Helper: Determine required schema types based on missing fields
  function determineRequiredSchemaTypes(missingFields, missingRecommended, existingTypes = []) {
    const globalTypes = ['Organization', 'LocalBusiness', 'Person', 'Service', 'WebSite', 'BreadcrumbList'];
    
    // Check which global types already exist
    const existingGlobalTypes = existingTypes.filter(t => globalTypes.includes(t));
    
    const needsOrg = missingFields.some(f => f.includes('Organization')) || 
                    missingRecommended.some(f => f.includes('Organization') || f.includes('url') || f.includes('logo'));
    const needsLocal = missingFields.some(f => f.includes('LocalBusiness')) || 
                       missingRecommended.some(f => f.includes('LocalBusiness') || f.includes('address') || f.includes('telephone'));
    const needsWebSite = missingFields.some(f => f.includes('WebSite')) || 
                         missingRecommended.some(f => f.includes('WebSite'));
    
    const types = [];
    
    // Only add Organization if it doesn't already exist
    if ((needsOrg || needsLocal) && !existingGlobalTypes.includes('Organization')) {
      types.push('Organization');
    }
    
    // Only add LocalBusiness if it doesn't already exist
    if (needsLocal && !existingGlobalTypes.includes('LocalBusiness')) {
      types.push('LocalBusiness');
    }
    
    // Only add WebSite if it doesn't already exist
    if (needsWebSite && !existingGlobalTypes.includes('WebSite')) {
      types.push('WebSite');
    }
    
    // Don't add default types if global schemas already exist
    if (types.length === 0 && existingGlobalTypes.length === 0) {
      types.push('Organization', 'LocalBusiness');
    }
    
    return types;
  }

  // Helper: Add recommended fields to fix object
  function addRecommendedFieldsToFix(fix, missingRecommended, baseUrl) {
    if (missingRecommended.includes('url')) {
      fix["url"] = baseUrl;
    }
    if (missingRecommended.includes('logo')) {
      fix["logo"] = "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w";
    }
    if (missingRecommended.includes('image')) {
      fix["image"] = fix["logo"] || "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w";
    }
    if (missingRecommended.includes('description')) {
      fix["description"] = "UK Landscape Photography Workshops, Private Tuition, and Online Classes by Alan Ranger, Qualified Tutor and Professional Photographer.";
    }
    if (missingRecommended.includes('address')) {
      fix["address"] = {
        "@type": "PostalAddress",
        "streetAddress": "45 Hathaway Road, Tile Hill Village",
        "addressLocality": "Coventry",
        "addressRegion": "West Midlands",
        "postalCode": "CV4 9HW",
        "addressCountry": "GB"
      };
    }
    if (missingRecommended.includes('telephone')) {
      fix["telephone"] = "+44 7817 017994";
    }
    if (missingRecommended.includes('sameAs')) {
      fix["sameAs"] = [
        "https://www.facebook.com/alanrangerphotography",
        "https://www.instagram.com/alanrangerphoto",
        "https://www.youtube.com/@alanrangerphotography"
      ];
    }
  }

  // Helper: Build recommended fix based on missing fields
  function buildRecommendedFix(url, missingFields = [], missingRecommended = [], existingTypes = []) {
    const baseUrl = url.split('#')[0];
    
    const types = determineRequiredSchemaTypes(missingFields, missingRecommended, existingTypes);
    
    // If no types to add (all global types already exist), return null
    if (types.length === 0) {
      return null;
    }
    
    const fix = {
      "@context": "https://schema.org"
    };
    
    fix["@type"] = types.length === 1 ? types[0] : types;
    fix["@id"] = `${baseUrl}#org`;
    fix["name"] = "Alan Ranger Photography";
    
    // Add url if missing
    if (missingRecommended.includes('url') || missingFields.some(f => f.includes('url'))) {
      fix["url"] = baseUrl;
    }
    
    // Add recommended fields
    addRecommendedFieldsToFix(fix, missingRecommended, baseUrl);
    
    // Add address if missing (for LocalBusiness)
    const needsLocal = types.includes('LocalBusiness');
    if (needsLocal && (missingRecommended.includes('address') || missingFields.some(f => f.includes('address')))) {
      if (!fix["address"]) {
        fix["address"] = {
          "@type": "PostalAddress",
          "streetAddress": "45 Hathaway Road, Tile Hill Village",
          "addressLocality": "Coventry",
          "addressRegion": "West Midlands",
          "postalCode": "CV4 9HW",
          "addressCountry": "GB"
        };
      }
    }
    
    return JSON.stringify(fix, null, 2);
  }

  function getRecommendedSchema(url, existingTypes = []) {
    // Use the new buildRecommendedFix function for consistency
    return buildRecommendedFix(url, [], [], existingTypes);
  }

  // Helper: Parse issues list from rowData
  function parseIssuesList(rowData) {
    let issuesList = [];
    try {
      if (rowData.tr && rowData.tr.dataset.issuesList) {
        issuesList = JSON.parse(rowData.tr.dataset.issuesList);
      } else if (rowData.issuesList) {
        issuesList = rowData.issuesList;
      } else if (rowData.tr && rowData.tr.dataset.missingDetail) {
        const missing = JSON.parse(rowData.tr.dataset.missingDetail);
        issuesList = missing.map(m => ({ message: m, type: 'Unknown' }));
      } else if (rowData.missingFields) {
        const missing = Array.isArray(rowData.missingFields) ? rowData.missingFields : String(rowData.missingFields).split(',').map(s => s.trim()).filter(Boolean);
        issuesList = missing.map(m => ({ message: m, type: 'Unknown' }));
      }
    } catch (err) {
      console.warn('Failed to parse issues data:', err);
    }
    return issuesList;
  }

  // Helper: Determine severity badge from issues
  function determineSeverityBadge(issueCount, duplicates) {
    if (duplicates.length > 2 || issueCount > 3) {
      return { severity: 'critical', badgeColor: 'severity-badge critical', badgeLabel: '‚ùå Critical' };
    }
    if (issueCount > 0 || duplicates.length > 0) {
      return { severity: 'warning', badgeColor: 'severity-badge warning', badgeLabel: '‚ö†Ô∏è Issues' };
    }
    return { severity: 'passed', badgeColor: 'severity-badge passed', badgeLabel: '‚úÖ Passed' };
  }

  // Helper: Build human-readable summary for modal
  function buildHumanReadableSummary(blockCount, schemaTypes, duplicates, missingFieldsBadges) {
    const parts = [];
    
    if (blockCount > 0) {
      parts.push(`Found ${blockCount} JSON-LD block${blockCount !== 1 ? 's' : ''}`);
    }
    
    if (schemaTypes && schemaTypes.length > 0) {
      const typesList = Array.isArray(schemaTypes) ? schemaTypes.join(', ') : schemaTypes;
      const uniqueTypesCount = Array.isArray(schemaTypes) ? schemaTypes.length : (schemaTypes.split(',').map(t => t.trim()).filter(Boolean).length);
      parts.push(`${uniqueTypesCount} unique schema type${uniqueTypesCount !== 1 ? 's' : ''}: ${typesList}`);
    }
    
    // Only show duplicate count for non-multi-instance types
    if (duplicates && duplicates.length > 0) {
      const nonMultiInstanceDuplicates = duplicates.filter(d => !MULTI_INSTANCE_ALLOWED_TYPES.includes(d));
      if (nonMultiInstanceDuplicates.length > 0) {
        parts.push(`${nonMultiInstanceDuplicates.length} duplicate${nonMultiInstanceDuplicates.length !== 1 ? 's' : ''} detected`);
      }
    }
    
    if (missingFieldsBadges && missingFieldsBadges.length > 0) {
      parts.push(`${missingFieldsBadges.length} missing field${missingFieldsBadges.length !== 1 ? 's' : ''}`);
    }
    
    return parts.length > 0 ? parts.join('. ') : 'No schema data available.';
  }

  // Helper: Build schema table HTML for modal
  function buildSchemaTableHtml(result) {
    if (!result || !result.schemas || result.schemas.length === 0) {
      return '';
    }
    
    let tableHtml = `
      <div style="margin-top: 1.5rem;">
        <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 600;">Detected Schema Nodes</h4>
        <table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
          <thead>
            <tr style="background: #f3f4f6; border-bottom: 2px solid #d1d5db;">
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Type</th>
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">@id</th>
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Name</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    for (const s of result.schemas) {
      const schema = s.schema || {};
      const isSystem = s.systemInjected ? 'system-node' : '';
      const typeDisplay = Array.isArray(s.type) ? s.type.join(', ') : s.type;
      const idDisplay = schema['@id'] || '‚Äî';
      const nameDisplay = schema.name || '‚Äî';
      
      tableHtml += `
        <tr class="${isSystem}" style="border-bottom: 1px solid #e5e7eb;">
          <td style="padding: 0.5rem;">${typeDisplay}</td>
          <td style="padding: 0.5rem;">${idDisplay}</td>
          <td style="padding: 0.5rem;">${nameDisplay}</td>
        </tr>
      `;
    }
    
    tableHtml += `
          </tbody>
        </table>
      </div>
    `;
    
    return tableHtml;
  }

  // Helper: Check if Organization nodes need recommended fix
  function checkOrganizationNodesForFix(result, missingFieldsBadges, existingTypes = []) {
    const globalTypes = ['Organization', 'LocalBusiness', 'Person', 'Service', 'WebSite', 'BreadcrumbList'];
    const existingGlobalTypes = existingTypes.filter(t => globalTypes.includes(t));
    
    // If global types already exist, don't show recommended fix
    if (existingGlobalTypes.length > 0) {
      return { shouldShowRecommendedFix: false, hasValidOrgNode: true, existingGlobalTypes };
    }
    
    let shouldShowRecommendedFix = false;
    let hasValidOrgNode = false;
    
    if (result && result.schemas) {
      const orgSchemas = result.schemas.filter(s => s.type === 'Organization' || (Array.isArray(s.type) && s.type.includes('Organization')));
      if (orgSchemas.length > 0) {
        const allMissingRequired = orgSchemas.every(s => {
          const schema = s.schema || {};
          const hasName = schema.name && schema.name.trim();
          const hasUrl = schema.url && schema.url.trim();
          const hasId = schema['@id'] && schema['@id'].trim();
          return !hasName && !hasUrl && !hasId;
        });
        hasValidOrgNode = orgSchemas.some(s => {
          const schema = s.schema || {};
          return schema.name && schema.name.trim();
        });
        shouldShowRecommendedFix = allMissingRequired && !hasValidOrgNode;
      } else {
        shouldShowRecommendedFix = true;
      }
    } else {
      const orgMissingFields = missingFieldsBadges.filter(m => m.type === 'Organization');
      const orgMissingRequired = orgMissingFields.some(m => ['name', 'url'].includes(m.field));
      shouldShowRecommendedFix = orgMissingRequired && orgMissingFields.length > 0;
    }
    
    return { shouldShowRecommendedFix, hasValidOrgNode, existingGlobalTypes: [] };
  }

  // Helper: Build recommended fix HTML
  function buildRecommendedFixHtml(shouldShowRecommendedFix, hasValidOrgNode, recommendedFix, existingGlobalTypes = []) {
    if (shouldShowRecommendedFix && recommendedFix) {
      return `
        <div class="recommended-fix-card">
          <h4>Recommended Fix (for Squarespace footer injection)</h4>
          <p>Copy and paste the following schema block into your Squarespace <strong>Settings ‚Üí Advanced ‚Üí Code Injection ‚Üí Footer</strong> section.</p>
          <textarea class="recommended-fix-textarea" readonly id="recommendedSchemaText">${recommendedFix}</textarea>
          <button class="copy-schema-btn" id="copySchemaBtn">üìã Copy Recommended Schema</button>
        </div>
      `;
    }
    if (hasValidOrgNode || existingGlobalTypes.length > 0) {
      const globalTypesList = existingGlobalTypes.length > 0 
        ? existingGlobalTypes.join(', ')
        : 'Organization';
      return `
        <div class="recommended-fix-card" style="background: #f0fdf4; border-color: #10b981;">
          <h4 style="color: #065f46;">‚úÖ Detected global schema types ‚Äî no extra injection required</h4>
          <p style="color: #047857;">Found existing ${globalTypesList} schema${existingGlobalTypes.length > 1 ? 's' : ''} on this page. Your global schema structure is correct. Recommendations will only appear for missing page-specific types (Product, Event, Article, Course, etc.).</p>
        </div>
      `;
    }
    return '';
  }

  // Helper: Setup modal button handlers
  function setupModalButtonHandlers(recommendedFix, json, jsonDetails, rowData) {
    const copyBtn = document.getElementById('copySchemaBtn');
    if (copyBtn) {
      copyBtn.onclick = () => {
        const textarea = document.getElementById('recommendedSchemaText');
        textarea.select();
        navigator.clipboard.writeText(recommendedFix).then(() => {
          copyBtn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            copyBtn.textContent = 'üìã Copy Recommended Schema';
          }, 2000);
        }).catch(err => {
          console.error('Failed to copy:', err);
          copyBtn.textContent = '‚ùå Copy Failed';
          setTimeout(() => {
            copyBtn.textContent = 'üìã Copy Recommended Schema';
          }, 2000);
        });
      };
    }
    
    json.textContent = (rowData.firstJsonLd || '').trim();
    jsonDetails.style.display = rowData.firstJsonLd ? 'block' : 'none';
    
    const copyJsonBtn = document.getElementById('issuesCopyJsonBtn');
    if (copyJsonBtn) {
      copyJsonBtn.onclick = async () => {
        const jsonText = json.textContent.trim();
        if (!jsonText) {
          alert('No JSON-LD content to copy');
          return;
        }
        try {
          await navigator.clipboard.writeText(jsonText);
          copyJsonBtn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            copyJsonBtn.textContent = 'Copy JSON-LD';
          }, 2000);
        } catch (err) {
          const textarea = document.createElement('textarea');
          textarea.value = jsonText;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
            copyJsonBtn.textContent = '‚úÖ Copied!';
            setTimeout(() => {
              copyJsonBtn.textContent = 'Copy JSON-LD';
            }, 2000);
          } catch (e) {
            alert('Failed to copy. Please select and copy manually.');
          }
          textarea.remove();
        }
      };
    }
  }

  // ---- Issues modal helpers ----
  function openIssuesModal(rowData) {
    const backdrop = document.getElementById('issuesBackdrop');
    const meta = document.getElementById('issuesMeta');
    const content = document.getElementById('issuesContent');
    const list = document.getElementById('issuesList');
    const json = document.getElementById('issuesJson');
    const jsonDetails = document.getElementById('issuesJsonDetails');
    const btnSchema = document.getElementById('issuesSchemaOrgBtn');
    const btnGoogle = document.getElementById('issuesGoogleBtn');
    const closeBtn = document.getElementById('issuesCloseBtn');
    const closeXBtn = document.getElementById('issuesCloseXBtn');
    
    // Get cached result data
    const cachedData = ResultCache.get(rowData.url) || {};
    const rowIndex = rowData.tr ? Array.from(rowData.tr.parentNode.children).indexOf(rowData.tr) : -1;
    const result = rowIndex >= 0 ? validationResults[rowIndex] : null;
    
    // Merge cached data with validation result
    const blocks = cachedData.blocks || result?.schemas?.map(s => s.schema).filter(Boolean) || [];
    const issuesList = parseIssuesList(rowData);
    const missingFields = result?.missingFields || cachedData.warnings?.filter(w => w.includes('missing')) || [];
    const warnings = result?.warnings || cachedData.warnings || [];
    const info = result?.info || cachedData.info || [];
    
    meta.textContent = `${rowData.url} ¬∑ Types: ${rowData.schemaType || 'None'}`;
    content.innerHTML = '';
    list.innerHTML = '';
    
    const missingFieldsBadges = result?.missingFieldsBadges || [];
    // Filter duplicates to exclude multi-instance allowed types
    const duplicates = issuesList
      .filter(i => i.message && i.message.includes('DUPLICATE'))
      .map(i => i.type)
      .filter(type => !MULTI_INSTANCE_ALLOWED_TYPES.includes(type));
    const schemaTypes = rowData.schemaType ? rowData.schemaType.split(', ') : (cachedData.schemaTypes || []);
    const issueCount = issuesList.filter(i => i.message && i.message.includes('missing')).length;
    // Use actual block count from result or cached data
    const blockCount = result?.blockCount || blocks.length || result?.schemas?.length || 0;
    
    // Get inferred types from result
    const inferredTypes = result?.inferredTypes || [];
    
    // Collect existing schema types from blocks
    const existingTypes = collectExistingSchemaTypes(blocks);
    
    const severityBadge = determineSeverityBadge(issueCount, duplicates);
    const humanReadableSummary = buildHumanReadableSummary(blockCount, schemaTypes, duplicates, missingFieldsBadges);
    const orgFixCheck = checkOrganizationNodesForFix(result, missingFieldsBadges, existingTypes);
    
    // Build inferred types HTML section
    let inferredTypesHtml = '';
    if (inferredTypes.length > 0) {
      inferredTypesHtml = `
        <div style="margin-top: 1.5rem; padding: 1rem; background: #f9fafb; border-radius: 8px; border-left: 4px solid #6b7280;">
          <h4 style="margin: 0 0 0.75rem 0; font-size: 1rem; font-weight: 600; color: #374151;">Inferred Structured Data Types</h4>
          <p style="margin: 0 0 0.75rem 0; font-size: 0.875rem; color: #6b7280;">Based on schema relationships and patterns:</p>
          <ul style="margin: 0; padding-left: 1.5rem; list-style: disc;">
            ${inferredTypes.map(item => `<li style="margin-bottom: 0.5rem;"><strong>${item.type}</strong> (${item.reason})</li>`).join('')}
          </ul>
        </div>
      `;
    }
    
    // Extract missing recommended fields from warnings
    const missingRecommended = warnings.filter(w => w.includes('Missing recommended:')).map(w => {
      const match = w.match(/Missing recommended: (\w+)/);
      return match ? match[1] : null;
    }).filter(Boolean);
    
    // Extract missing required fields
    const missingRequiredFields = missingFields.filter(f => typeof f === 'string' && f.includes('missing')).map(f => {
      const match = f.match(/(\w+):\s*"(\w+)"\s*missing/);
      return match ? `${match[1]}.${match[2]}` : null;
    }).filter(Boolean);
    
    // Build recommended fix using the new function with existing types
    const recommendedFix = buildRecommendedFix(rowData.url, missingRequiredFields, missingRecommended, existingTypes);
    const recommendedFixHtml = buildRecommendedFixHtml(
      orgFixCheck.shouldShowRecommendedFix || (missingRecommended.length > 0 && recommendedFix !== null), 
      orgFixCheck.hasValidOrgNode, 
      recommendedFix,
      orgFixCheck.existingGlobalTypes || []
    );
    const schemaTableHtml = buildSchemaTableHtml(result);
    
    // Build issues list HTML
    let issuesHtml = '';
    if (issuesList.length === 0 && missingFields.length === 0 && warnings.length === 0) {
      issuesHtml = '<li>None</li>';
    } else {
      if (missingFields.length > 0) {
        issuesHtml += missingFields.map(f => `<li class="missing-entry">‚ùå ${f}</li>`).join('');
      }
      if (warnings.length > 0) {
        issuesHtml += warnings.map(w => `<li class="warning-entry">‚ö†Ô∏è ${w}</li>`).join('');
      }
      if (info.length > 0) {
        issuesHtml += info.map(i => `<li class="info-entry">${i}</li>`).join('');
      }
    }
    
    // Show JSON-LD blocks if available
    let jsonLdHtml = '';
    if (blocks.length > 0) {
      jsonDetails.style.display = 'none'; // Hide the old single block display
      const blocksHtml = blocks.map((block, idx) => {
        const blockJson = JSON.stringify(block, null, 2);
        return `
          <div class="json-block-card" style="margin-bottom: 1rem; border: 1px solid #e2e8f0; border-radius: 8px; overflow: hidden;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem; background: #f7fafc; border-bottom: 1px solid #e2e8f0;">
              <h5 style="margin: 0; font-size: 0.9rem; font-weight: 600;">JSON-LD Block #${idx + 1}</h5>
              <button class="copy-block-btn secondary" data-block-index="${idx}" style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: #2563eb; color: white; border-color: #2563eb; cursor: pointer; border-radius: 4px;">üìã Copy Block ${idx + 1}</button>
            </div>
            <pre style="margin: 0; padding: 1rem; background: #000; color: #fff; overflow-x: auto; font-size: 0.85rem; max-height: 400px; overflow-y: auto;">${escapeHtml(blockJson)}</pre>
          </div>
        `;
      }).join('');
      
      jsonLdHtml = `
        <div style="margin-top: 1.5rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <h4 style="margin: 0; font-size: 1rem; font-weight: 600;">JSON-LD Blocks (${blocks.length})</h4>
            <button class="copy-all-blocks-btn secondary" style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: #2563eb; color: white; border-color: #2563eb; cursor: pointer;">üìã Copy All Blocks</button>
          </div>
          ${blocksHtml}
        </div>
      `;
      
      // Store blocks data for copy functionality
      backdrop.dataset.blocksJson = JSON.stringify(blocks);
    } else {
      jsonDetails.style.display = 'none';
      jsonLdHtml = '<p style="color: #6b7280; font-style: italic; margin-top: 1.5rem;">No JSON-LD blocks captured.</p>';
    }
    
    content.innerHTML = `
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem;">
        <h3 style="margin: 0; font-size: 1.25rem; font-weight: 600;">Schema Analysis Summary</h3>
        <span class="${severityBadge.badgeColor}">${severityBadge.badgeLabel}</span>
      </div>
      
      <div class="summary-card">
        <pre>${humanReadableSummary.trim()}</pre>
      </div>
      
      <div style="margin-top: 1.5rem;">
        <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 600;">Issues</h4>
        <ul class="issues-list" style="list-style: none; padding: 0; margin: 0;">
          ${issuesHtml || '<li>None</li>'}
        </ul>
      </div>
      
      ${recommendedFixHtml}
      
      ${inferredTypesHtml}
      
      ${schemaTableHtml}
      
      ${jsonLdHtml}
      
      <div class="help-link">
        ${orgFixCheck.shouldShowRecommendedFix ? '<p>Need help implementing this? ' : ''}
        ${orgFixCheck.shouldShowRecommendedFix ? '<a href="https://support.squarespace.com/hc/en-us/articles/206543167" target="_blank">View Squarespace injection guide</a></p>' : ''}
        <p style="margin-top: 0.5rem; font-style: italic; color: #6b7280;">
          Diagnostic: ${issueCount} missing field${issueCount !== 1 ? 's' : ''}${duplicates.length > 0 ? `, ${duplicates.length} duplicate type${duplicates.length !== 1 ? 's' : ''} detected` : ''}${result?.multiInstanceCounts && Object.keys(result.multiInstanceCounts).length > 0 ? `. ${Object.entries(result.multiInstanceCounts).map(([type, count]) => `${count} ${type}${count !== 1 ? 's' : ''}`).join(', ')} detected (expected)` : ''}.
        </p>
      </div>
    `;
    
    setupModalButtonHandlers(recommendedFix, json, jsonDetails, rowData);
    
    btnSchema.onclick = () => globalThis.open('https://validator.schema.org/?url=' + encodeURIComponent(rowData.url), '_blank');
    btnGoogle.onclick = () => globalThis.open('https://search.google.com/test/rich-results?url=' + encodeURIComponent(rowData.url), '_blank');
    
    function close() {
      backdrop.close();
      document.removeEventListener('keydown', esc);
    }
    function esc(e) {
      if (e.key === 'Escape') close();
    }
    closeBtn.onclick = close;
    if (closeXBtn) {
      closeXBtn.onclick = close;
    }
    backdrop.onclick = (e) => {
      if (e.target === backdrop) close();
    };
    backdrop.showModal();
    
    // Setup copy button handlers after modal is opened and content is rendered
    setTimeout(() => {
      // Copy individual block buttons
      const copyBlockBtns = backdrop.querySelectorAll('.copy-block-btn');
      console.log(`Found ${copyBlockBtns.length} copy block buttons`);
      copyBlockBtns.forEach(btn => {
        btn.onclick = () => {
          const blockIndex = parseInt(btn.dataset.blockIndex);
          const blocksData = JSON.parse(backdrop.dataset.blocksJson || '[]');
          if (blocksData[blockIndex]) {
            const blockJson = JSON.stringify(blocksData[blockIndex], null, 2);
            navigator.clipboard.writeText(blockJson).then(() => {
              btn.textContent = '‚úÖ Copied!';
              setTimeout(() => {
                btn.textContent = `üìã Copy Block ${blockIndex + 1}`;
              }, 2000);
            }).catch(() => {
              alert('Failed to copy. Please select and copy manually.');
            });
          }
        };
      });
      
      // Copy all blocks button
      const copyAllBtn = backdrop.querySelector('.copy-all-blocks-btn');
      console.log(`Copy all blocks button found: ${!!copyAllBtn}`);
      if (copyAllBtn) {
        copyAllBtn.onclick = () => {
          const blocksData = JSON.parse(backdrop.dataset.blocksJson || '[]');
          const allBlocksJson = JSON.stringify(blocksData, null, 2);
          navigator.clipboard.writeText(allBlocksJson).then(() => {
            copyAllBtn.textContent = '‚úÖ All Copied!';
            setTimeout(() => {
              copyAllBtn.textContent = 'üìã Copy All Blocks';
            }, 2000);
          }).catch(() => {
            alert('Failed to copy. Please select and copy manually.');
          });
        };
      } else {
        console.warn('Copy all blocks button not found in modal');
      }
    }, 300);
  }
  
  // Build a minimal rowData snapshot from a <tr>
  function getRowDataFromTr(tr) {
    const tds = tr.querySelectorAll('td');
    const url = tds[0]?.querySelector('a')?.href || tds[0]?.textContent?.trim() || '';
    // keep a handle to <tr> so we can read dataset fields
    const trRef = tr;
    const schemaType = tds[1]?.textContent?.trim() || '';
    const missing = tds[3]?.textContent?.trim() || '';
    // store first JSON-LD snippet in a dataset if available when row was computed
    const firstJson = tr.dataset.firstJsonld || '';
    // Get index from row to find validation result
    const rowIndex = Array.from(tr.parentNode.children).indexOf(tr);
    const result = validationResults[rowIndex];
    
    let issuesList = [];
    if (result && result.issuesList) {
      issuesList = result.issuesList;
    } else if (tr.dataset.issuesList) {
      try {
        issuesList = JSON.parse(tr.dataset.issuesList);
      } catch (e) {
        console.warn('Failed to parse issuesList:', e);
      }
    }
    
    let missingFields;
    if (result && result.missingFields) {
      missingFields = result.missingFields;
    } else if (missing) {
      missingFields = missing.split(',').map(s => s.trim()).filter(Boolean);
    } else {
      missingFields = [];
    }
    
    return { 
      url, 
      schemaType, 
      missingFields: missingFields, 
      firstJsonLd: firstJson, 
      tr: trRef, 
      issuesList,
      schemaSummary: result && result.schemaSummary ? result.schemaSummary : null
    };
  }
  
  // ---- Schema core fields (minimal, safe set) ----
  const CORE_REQUIRED = {
    WebSite:      ["name", "url"],
    Organization: ["name"],
    LocalBusiness:["name"]   // keep minimal; address/telephone vary a lot
  };
  
  // Flatten any JSON-LD object/array/@graph into a list of typed nodes
  function flattenJsonLd(node, out = []) {
    if (!node) return out;
    if (Array.isArray(node)) { node.forEach(n=>flattenJsonLd(n, out)); return out; }
    if (node['@graph']) { flattenJsonLd(node['@graph'], out); }
    if (node['@type']) out.push(node);
    return out;
  }
  
  // Build a map: type -> array of nodes for that type
  function indexByType(nodes) {
    const idx = {};
    nodes.forEach(n => {
      const types = Array.isArray(n['@type']) ? n['@type'] : [n['@type']];
      types.forEach(t => {
        (idx[t] ||= []).push(n);
      });
    });
    return idx;
  }
  
  // Helper: Check if field is missing for a node
  function isFieldMissing(node, field) {
    return !node.hasOwnProperty(field) || !node[field];
  }

  // Helper: Check if message already exists for this type+field+key combination
  function isAlreadyFlagged(messages, type, field, key) {
    return messages.some(m => m.type === type && m.field === field && m.key === key);
  }

  // Helper: Check if node is system-injected (Squarespace auto-generated)
  function isSystemInjectedNode(type, node) {
    return type === 'Organization' && 
      !node['@id'] && 
      (!node.name || !node.name.trim()) && 
      (!node.url || !node.url.trim());
  }

  // Helper: Process required fields for a node group
  function processRequiredFieldsForNode(messages, type, field, key, firstNode, instances) {
    if (isFieldMissing(firstNode, field) && !isAlreadyFlagged(messages, type, field, key)) {
      messages.push({ 
        type: type, 
        field: field, 
        nodeIndex: instances[0].index,
        key: key,
        instances: instances.length,
        hasId: !!firstNode['@id'],
        systemInjected: isSystemInjectedNode(type, firstNode)
      });
    }
  }

  // Inspect which types are present and which required fields are missing per type
  function computeMissingFields(allNodes) {
    const idx = indexByType(allNodes);
    const messages = [];
    
    Object.keys(idx).forEach(t => {
      if (!CORE_REQUIRED[t]) return;
      
      const required = CORE_REQUIRED[t];
      const nodesByKey = {};
      
      idx[t].forEach((n, nodeIndex) => {
        const key = n['@id'] || JSON.stringify([n['@type'], n.url, n.name]).slice(0, 100);
        if (!nodesByKey[key]) nodesByKey[key] = [];
        nodesByKey[key].push({ node: n, index: nodeIndex });
      });
      
      Object.keys(nodesByKey).forEach(key => {
        const instances = nodesByKey[key];
        const firstNode = instances[0].node;
        
        if (isSystemInjectedNode(t, firstNode)) {
          return;
        }
        
        required.forEach(req => {
          processRequiredFieldsForNode(messages, t, req, key, firstNode, instances);
        });
      });
    });
    
    return messages;
  }
  
  // Try to find a candidate value for a field in OTHER types (so we can suggest)
  function findFieldElsewhere(allNodes, field, exceptType) {
    for (const n of allNodes) {
      const types = Array.isArray(n['@type']) ? n['@type'] : [n['@type']];
      if (types.includes(exceptType)) continue;
      if (n[field]) return { fromType: types.join(','), value: (''+n[field]).slice(0,120) };
    }
    return null;
  }
  
  // ---------- Enhanced Schema Builder ----------
  const asArray = v => Array.isArray(v) ? v : (v ? [v] : []);
  const uniq = arr => [...new Set(arr)];
  function firstNonEmpty(...vals){ for(const v of vals){ if(typeof v==='string' && v.trim()) return v.trim(); } return ''; }
  
  function pageMeta(doc, url){
    const get = s => doc.querySelector(s)?.getAttribute('content') || '';
    return {
      url,
      title: doc.querySelector('h1')?.textContent?.trim() || doc.title || '',
      ogTitle: get('meta[property="og:title"]'),
      ogDesc: get('meta[property="og:description"]'),
      ogImage: get('meta[property="og:image"]'),
      logo: get('meta[itemprop="logo"]') || get('meta[property="og:logo"]') || '',
      siteName: get('meta[property="og:site_name"]')
    };
  }
  
  function ensureId(node, baseUrl, suffix){
    if (!node['@id']) node['@id'] = baseUrl.replace(/#.*$/,'') + '#' + suffix;
    return node;
  }
  
  function dedupeById(nodes){
    const map = new Map();
    nodes.forEach(n=>{
      const key = n['@id'] || JSON.stringify([n['@type'], n.name, n.url]);
      if (!map.has(key)) map.set(key, n);
    });
    return [...map.values()];
  }
  
  function prettyScript(json){
    return `<script type="application/ld+json">\n${JSON.stringify(json, null, 2)}\n<\/script>`;
  }
  
  function buildBreadcrumbs(doc, url){
    // 1) Try semantic breadcrumbs in DOM
    let items = [];
    const nav = doc.querySelector('nav[aria-label="breadcrumb"], .breadcrumbs, ol.breadcrumb, ul.breadcrumb');
    if (nav){
      const links = nav.querySelectorAll('a, [itemprop="item"]');
      let pos=1;
      links.forEach(a=>{
        const href = a.getAttribute('href') || a.getAttribute('content') || '';
        const name = a.textContent?.trim() || a.getAttribute('title') || '';
        if (name) items.push({ "@type":"ListItem", position: pos++, name, item: href.startsWith('http') ? href : new URL(href, url).href });
      });
    }
    // 2) Fallback to URL path
    if (!items.length){
      const u = new URL(url);
      const segs = u.pathname.split('/').filter(Boolean);
      let path=u.origin, pos=1;
      items.push({ "@type":"ListItem", position: pos++, name: "Home", item: u.origin });
      for(const s of segs){
        path += '/' + s;
        items.push({ "@type":"ListItem", position: pos++, name: decodeURIComponent(s.replace(/-/g,' ')).replace(/\b\w/g,m=>m.toUpperCase()), item: path });
      }
    }
    return {
      "@type":"BreadcrumbList",
      "@id": url.replace(/#.*$/,'') + "#breadcrumbs",
      "itemListElement": items
    };
  }
  
  // Helper: Detect global schema patterns
  function detectGlobalPatterns(nodes, baseUrl) {
    const existingIds = new Set();
    for (const n of nodes) {
      if (n['@id']) existingIds.add(n['@id']);
    }
    
    const hasGlobalWebsite = existingIds.has(baseUrl + '#website') || 
                             nodes.some(n => n['@type'] === 'WebSite' && n['@id'] && n['@id'].includes('#website'));
    const hasGlobalOrg = existingIds.has(baseUrl + '#org') ||
                        nodes.some(n => {
                          const types = asArray(n['@type']);
                          return (types.includes('Organization') || types.includes('LocalBusiness')) && 
                                 n['@id'] && n['@id'].includes('#org');
                        });
    const hasGlobalLocal = existingIds.has(baseUrl + '#local') ||
                          nodes.some(n => n['@type'] === 'LocalBusiness' && n['@id'] && n['@id'].includes('#local'));
    
    return { hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal };
  }

  // Helper: Build website node
  function buildWebsiteNode(idx, siteName, meta) {
    const website = (idx.WebSite && idx.WebSite[0]) ? structuredClone(idx.WebSite[0]) : {"@type":"WebSite"};
    website.name = website.name || siteName || "Alan Ranger Photography";
    website.url = website.url || meta.url;
    return website;
  }

  // Helper: Build organization node
  function buildOrgNode(idx, siteName, meta) {
    const org = (idx.Organization && idx.Organization[0]) ? structuredClone(idx.Organization[0]) : {"@type":"Organization"};
    org.name = org.name || siteName || "Alan Ranger Photography";
    org.url = org.url || meta.url;
    if (!org.logo && meta.logo) org.logo = meta.logo;
    if (!org.image && meta.ogImage) org.image = meta.ogImage;
    return org;
  }

  // Helper: Build local business node
  function buildLocalNode(idx, org, siteName, meta) {
    let local = (idx.LocalBusiness && idx.LocalBusiness[0]) ? structuredClone(idx.LocalBusiness[0]) : 
                (idx.Organization && idx.Organization[0] ? structuredClone(idx.Organization[0]) : null);
    
    if (local) {
      local.name = local.name || org.name || siteName;
      local.url = local.url || meta.url;
      if (!local.image && meta.ogImage) local.image = meta.ogImage;
      if (!local['@type']) local['@type'] = 'LocalBusiness';
    }
    
    return local;
  }

  // Helper: Build core schema nodes
  function buildCoreSchemaNodes(idx, meta, url) {
    const siteName = firstNonEmpty(null, meta.siteName, meta.title, "Alan Ranger Photography");
    const website = buildWebsiteNode(idx, siteName, meta);
    const org = buildOrgNode(idx, siteName, meta);
    const local = buildLocalNode(idx, org, siteName, meta);
    return { website, org, local };
  }

  // Helper: Build final schema graph
  function buildSchemaGraph(hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal, website, org, local, breadcrumbs, extras) {
    const graph = [];
    
    if (!hasGlobalWebsite) {
      graph.push(website);
    }
    
    if (!hasGlobalOrg) {
      graph.push(org);
    }
    
    if (local && !hasGlobalLocal) {
      graph.push(local);
    }
    
    if (breadcrumbs.itemListElement && breadcrumbs.itemListElement.length > 0) {
      graph.push(breadcrumbs);
    }
    
    graph.push(...extras);
    
    return dedupeById(graph);
  }

  // Helper: Process schema with fallback (check for existing Product before generating)
  async function processSchemaWithFallback(url, doc, nodes) {
    const meta = pageMeta(doc, url);
    const idx = indexByType(nodes);
    
    // Check for existing Product schema
    const hasExistingProduct = nodes.some(n => {
      const types = asArray(n['@type']);
      return types.includes('Product') || types.includes('Course');
    });
    
    if (hasExistingProduct) {
      debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî skipping Product generation to prevent duplicates`, 'info');
    }
    
    let { website, org, local } = buildCoreSchemaNodes(idx, meta, url);
    
    const baseUrl = url.replace(/#.*$/,'');
    const { hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal } = detectGlobalPatterns(nodes, baseUrl);
    
    if (!hasGlobalWebsite) website = ensureId(website, url, 'website');
    if (!hasGlobalOrg) org = ensureId(org, url, 'org');
    if (local && !hasGlobalLocal) local = ensureId(local, url, 'local');
    
    const breadcrumbs = buildBreadcrumbs(doc, url);
    const keepTypes = ['Product','Event','ItemList','FAQPage','Article','BlogPosting','Course'];
    
    // Only include Product/Course if they don't already exist
    const extras = nodes.filter(n => {
      const types = asArray(n['@type']);
      const hasKeepType = types.some(t => keepTypes.includes(t));
      
      // Skip Product/Course if already exists to prevent duplicates
      if ((types.includes('Product') || types.includes('Course')) && hasExistingProduct) {
        return false; // Don't include Product/Course nodes if we detected existing ones
      }
      
      return hasKeepType;
    });
    
    const finalGraph = buildSchemaGraph(hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal, website, org, local, breadcrumbs, extras);
    
    return { "@context":"https://schema.org", "@graph": finalGraph };
  }

  async function generateEnhancedFor(url){
    const apiBaseUrl = getApiBaseUrl();
    const apiUrl = `${apiBaseUrl}/api/fetch?url=${encodeURIComponent(url)}`;
    
    debugLog(`[Generate Enhanced] Fetching via API: ${apiUrl}`, 'info');
    
    try {
      // Use API proxy for Squarespace pages
      const res = await fetch(apiUrl);
      
      if (!res.ok) {
        const errorText = await res.text().catch(() => 'Unknown error');
        throw new Error(`API returned ${res.status}: ${errorText.substring(0, 100)}`);
      }
      
      const html = await res.text();
      
      if (!html || html.length === 0) {
        throw new Error('API returned empty response');
      }
      
      debugLog(`[Generate Enhanced] Received ${html.length} bytes of HTML`, 'success');
      
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      
      // Find all script tags with JSON-LD (including Squarespace patterns)
      const scripts = findAllJsonLdScripts(doc);
      
      let nodes = [];
      for (const s of scripts) {
        try {
          // Decode HTML entities before parsing
          const decodedText = decodeHTML(s.textContent);
          nodes = flattenJsonLd(JSON.parse(decodedText.trim()), nodes);
        } catch(e) {
          debugLog(`[Generate Enhanced] Failed to parse JSON-LD block: ${e.message}`, 'warning');
        }
      }
      
      // Check for existing Product schema before generating
      const hasExistingProduct = nodes.some(n => {
        const types = asArray(n['@type']);
        return types.includes('Product') || types.includes('Course');
      });
      
      if (hasExistingProduct) {
        debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî will not generate duplicate`, 'info');
      }
      
      debugLog(`[Generate Enhanced] Found ${nodes.length} schema nodes`, 'info');
      
      return await processSchemaWithFallback(url, doc, nodes);
    } catch (error) {
      debugLog(`[Generate Enhanced] API fetch failed: ${error.message}`, 'error');
      
      // Fallback to direct fetch if API fails (will likely fail due to CORS)
      debugLog(`[Generate Enhanced] Attempting direct fetch fallback...`, 'warning');
      
      try {
        const res = await fetch(url, {mode:'cors'});
        if (!res.ok) {
          throw new Error(`Direct fetch returned ${res.status}`);
        }
        const html = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Find all script tags with JSON-LD (including Squarespace patterns)
        const scripts = findAllJsonLdScripts(doc);
        
        let nodes = [];
        for (const s of scripts) {
          try {
            // Decode HTML entities before parsing
            const decodedText = decodeHTML(s.textContent);
            nodes = flattenJsonLd(JSON.parse(decodedText.trim()), nodes);
          } catch(_) {}
        }
        
        // Check for existing Product schema
        const hasExistingProduct = nodes.some(n => {
          const types = asArray(n['@type']);
          return types.includes('Product') || types.includes('Course');
        });
        
        if (hasExistingProduct) {
          debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî will not generate duplicate`, 'info');
        }
        
        return await processSchemaWithFallback(url, doc, nodes);
      } catch (err) {
        const errorMsg = err.message || 'Unknown error';
        debugLog(`[Generate Enhanced] Direct fetch also failed: ${errorMsg}`, 'error');
        throw new Error(`Failed to fetch page: ${errorMsg}. API endpoint: ${apiUrl}`);
      }
    }
  }
  
  // Modal plumbing
  (function initGenModal(){
    // Function to setup save button handler
    function setupSaveButton() {
      const saveBtn = document.getElementById('genSaveBtn');
      const backdrop = document.getElementById('genBackdrop');
      if (saveBtn && backdrop) {
        saveBtn.onclick = async () => {
          try {
            const url = backdrop.dataset.url || '';
            const json = backdrop.dataset.json || document.getElementById('genJson')?.textContent || '';
            
            if (!json || json.trim().length === 0) {
              alert('No content to save');
              return;
            }
            
            // Generate filename from URL
            let filename = 'schema';
            if (url) {
              try {
                const urlObj = new URL(url);
                // Extract pathname and convert to filename-safe string
                const pathParts = urlObj.pathname.split('/').filter(p => p);
                if (pathParts.length > 0) {
                  filename = pathParts[pathParts.length - 1].replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                  // Limit filename length
                  if (filename.length > 50) {
                    filename = filename.substring(0, 50);
                  }
                } else {
                  filename = urlObj.hostname.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                }
              } catch (e) {
                console.warn('Failed to parse URL for filename:', e);
              }
            }
            
            // Add timestamp to ensure uniqueness
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
            const fullFilename = `${filename}-${timestamp}.json`;
            
            // Create blob and download
            const blob = new Blob([json], { type: 'application/json' });
            const blobUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = fullFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(blobUrl);
            
            // Update button feedback
            const originalText = saveBtn.textContent;
            saveBtn.textContent = '‚úÖ Saved!';
            saveBtn.style.background = '#10b981';
            setTimeout(() => {
              saveBtn.textContent = originalText;
              saveBtn.style.background = '#10b981';
            }, 2000);
            
            console.log(`Saved schema to: ${fullFilename}`);
          } catch (err) {
            console.error('Failed to save file:', err);
            alert('Failed to save file: ' + err.message);
          }
        };
      }
    }
    
    // Function to setup copy button handler
    function setupCopyButton() {
      const copyBtn = document.getElementById('genCopyBtn');
      const jsonEl = document.getElementById('genJson');
      if (copyBtn && jsonEl) {
        copyBtn.onclick = async () => {
          try {
            const text = jsonEl.textContent || jsonEl.innerText;
            if (!text || text.trim().length === 0) {
              alert('No content to copy');
              return;
            }
            
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
              copyBtn.textContent = '‚úÖ Copied!';
              setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
            } else {
              // Fallback: use textarea method for older browsers
              const textarea = document.createElement('textarea');
              textarea.value = text;
              textarea.style.position = 'fixed';
              textarea.style.left = '-999999px';
              document.body.appendChild(textarea);
              textarea.select();
              textarea.setSelectionRange(0, 99999); // For mobile devices
              
              try {
                document.execCommand('copy');
                copyBtn.textContent = '‚úÖ Copied!';
                setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
              } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
                debugLog('Copy failed: ' + err.message, 'error');
              } finally {
                document.body.removeChild(textarea);
              }
            }
          } catch (err) {
            alert('Failed to copy to clipboard: ' + err.message);
            debugLog('Copy error: ' + err.message, 'error');
          }
        };
      }
    }
    
    // Setup close button and backdrop
    function setupCloseButton() {
      const backdrop = document.getElementById('genBackdrop');
      const closeBtn = document.getElementById('genCloseBtn');
      if (backdrop && closeBtn) {
        closeBtn.onclick = () => {
          if (backdrop.close) {
            backdrop.close();
          } else {
            backdrop.style.display = 'none';
          }
        };
        backdrop.onclick = (e) => {
          if (e.target === backdrop) {
            if (backdrop.close) {
              backdrop.close();
            } else {
              backdrop.style.display = 'none';
            }
          }
        };
      }
    }
    
    // Try to setup immediately if DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setupCopyButton();
        setupSaveButton();
        setupCloseButton();
      });
    } else {
      setupCopyButton();
      setupSaveButton();
      setupCloseButton();
    }
    
    // Also setup when modal is opened (in case elements weren't ready earlier)
    window.__openGenModal = (url, json)=>{
      const backdropEl = document.getElementById('genBackdrop');
      const metaEl = document.getElementById('genMeta');
      const jsonEl = document.getElementById('genJson');
      if (!backdropEl) {
        alert('Error: Modal element not found. Please refresh the page.');
        return;
      }
      if (metaEl) metaEl.textContent = url;
      if (jsonEl) jsonEl.textContent = prettyScript(json);
      
      // Store URL and JSON for save function
      backdropEl.dataset.url = url;
      backdropEl.dataset.json = json;
      
      // Re-attach copy and save button handlers in case they weren't set up earlier
      setupCopyButton();
      setupSaveButton();
      
      // Use dialog API if available
      if (backdropEl.showModal) {
        backdropEl.showModal();
      } else {
        backdropEl.style.display='flex';
      }
    };
  })();
  
  // Copy to clipboard
  // Combined Debug Log Functions
  function addToCombinedLog(msg, stepId, task) {
    const combinedLog = document.getElementById('combinedDebugLog');
    if (!combinedLog) return;
    
    // Get step name
    const stepNames = {
      '0': 'Step 0 - Setup Check',
      2: 'Step 2 - Clean',
      '3a': 'Step 3a - Fetch Google Reviews',
      '3b': 'Step 3b - Merge Reviews',
      4: 'Step 4 - Generate Schema'
    };
    const stepName = stepNames[stepId] || `Step ${stepId}`;
    
    // Add timestamp and step header if this is a new step
    const currentText = combinedLog.textContent;
    const stepHeader = `\n${'='.repeat(60)}\n${stepName} (${task})\n${'='.repeat(60)}\n`;
    
    // Check if we need to add step header
    if (currentText === 'No logs yet. Step outputs will appear here as they run...') {
      combinedLog.textContent = stepHeader;
    } else if (msg.includes('üöÄ Starting') && !currentText.includes(`${stepName} (${task})`)) {
      combinedLog.textContent += stepHeader;
    } else if (stepId === '0' && (msg.includes('Running in Electron') || msg.includes('[Server]')) && !currentText.includes('Step 0')) {
      // Add Step 0 header on first message
      combinedLog.textContent = stepHeader;
    }
    
    // Add the message with timestamp for important events
    if (msg.includes('üöÄ Starting') || msg.includes('‚ùå') || msg.includes('‚úÖ Task') || msg.includes('Error:') || msg.includes('[Server]')) {
      const now = new Date();
      const timestamp = `[${now.toTimeString().substring(0, 8)}]`;
      combinedLog.textContent += `${timestamp} ${msg}`;
    } else {
      combinedLog.textContent += msg;
    }
    combinedLog.scrollTop = combinedLog.scrollHeight;
  }
  
  function copyCombinedLog() {
    const combinedLog = document.getElementById('combinedDebugLog');
    if (!combinedLog) return;
    
    const text = combinedLog.textContent || 'No logs available';
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(() => {
        const btn = document.getElementById('copyCombinedLogBtn');
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '‚úÖ Copied!';
          btn.style.background = '#27AE60';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '#667eea';
          }, 2000);
        }
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy to clipboard. Please select and copy manually.');
      });
    } else {
      // Fallback for older browsers
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand('copy');
        const btn = document.getElementById('copyCombinedLogBtn');
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '‚úÖ Copied!';
          btn.style.background = '#27AE60';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '#667eea';
          }, 2000);
        }
      } catch (err) {
        alert('Failed to copy. Please select and copy manually.');
      }
      document.body.removeChild(textarea);
    }
  }
  
  function clearCombinedLog() {
    const combinedLog = document.getElementById('combinedDebugLog');
    if (combinedLog) {
      combinedLog.textContent = 'No logs yet. Step outputs will appear here as they run...';
    }
  }

  function copyToClipboard(outputId) {
    const element = document.getElementById(outputId);
    if (!element) {
      console.error(`Element with id "${outputId}" not found`);
      showToast('‚ùå Error: Output element not found', 'error');
      return;
    }
    
    const text = element.tagName === 'TEXTAREA' ? element.value : element.textContent;
    
    if (!text || text.trim() === '') {
      showToast('‚ö†Ô∏è Nothing to copy. Please generate schema first.', 'warning');
      return;
    }
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(function() {
        showToast('‚úÖ Schema copied to clipboard!', 'success');
      }, function(err) {
        console.error('Clipboard write failed:', err);
        showToast('‚ùå Failed to copy. Please try selecting and copying manually.', 'error');
      });
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      try {
        document.execCommand('copy');
        showToast('‚úÖ Schema copied to clipboard!', 'success');
      } catch (err) {
        console.error('Fallback copy failed:', err);
        showToast('‚ùå Failed to copy. Please try selecting and copying manually.', 'error');
      }
      document.body.removeChild(textArea);
    }
  }
  
  function showToast(message, type = 'success') {
    const toast = document.createElement('div');
    toast.textContent = message;
    const bgColor = type === 'success' ? '#27AE60' : type === 'error' ? '#E74C3C' : '#E57200';
    toast.style.cssText = `position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white; padding: 14px 24px; border-radius: 8px; z-index: 10000; font-size: 0.875rem; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: slideIn 0.3s ease-out;`;
    document.body.appendChild(toast);
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }

  // Test URL functions
  function testSchemaOrg(inputId) {
    const url = document.getElementById(inputId).value;
    if (!url) {
      alert('Please enter a URL to test');
      return;
    }
    window.open('https://validator.schema.org/#url=' + encodeURIComponent(url), '_blank');
  }

  function testGoogleRichResults(inputId) {
    const url = document.getElementById(inputId).value;
    if (!url) {
      alert('Please enter a URL to test');
      return;
    }
    window.open('https://search.google.com/test/rich-results?url=' + encodeURIComponent(url), '_blank');
  }

  // Blog CSV data storage
  let blogPosts = [];
  let blogDebugLog = [];

  function blogLog(message, level = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${message}`;
    blogDebugLog.push(logEntry);
    
    // Update debug log display
    const debugLogElement = document.getElementById('blogDebugLog');
    const debugLogContainer = document.getElementById('blogDebugLogContainer');
    if (debugLogElement) {
      debugLogElement.textContent = blogDebugLog.join('\n');
      if (debugLogContainer) {
        debugLogContainer.style.display = 'block';
        debugLogElement.scrollTop = debugLogElement.scrollHeight;
      }
    }
    console.log(logEntry);
  }

  function copyBlogDebugLog() {
    if (!blogDebugLog || blogDebugLog.length === 0) {
      alert('No debug log available to copy.');
      return;
    }
    const logText = blogDebugLog.join('\n');
    navigator.clipboard.writeText(logText).then(() => {
      alert('‚úÖ Debug log copied to clipboard!');
    }).catch(() => {
      alert('Failed to copy debug log. Please select the debug log text and copy manually (Ctrl+C).');
    });
  }

  // Blog Index Schema Generation Functions
  function handleBlogCsvUpload(event) {
    const file = event.target.files[0];
    if (!file) {
      document.getElementById('generateBlogBtn').disabled = true;
      document.getElementById('blogCsvInfo').style.display = 'none';
      blogDebugLog = [];
      document.getElementById('blogDebugLogContainer').style.display = 'none';
      return;
    }

    blogDebugLog = [];
    blogLog(`üìÑ Loading blog CSV file: ${file.name}`);

    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: function(results) {
        if (!results.data || results.data.length === 0) {
          blogLog('‚ùå CSV file is empty or could not be parsed', 'error');
          alert('CSV file is empty or could not be parsed. Please check the file format.');
          document.getElementById('generateBlogBtn').disabled = true;
          return;
        }

        blogPosts = results.data;
        blogLog(`‚úÖ Loaded ${blogPosts.length} blog posts from CSV`);
        blogLog(`   Columns found: ${results.meta.fields ? results.meta.fields.join(', ') : 'unknown'}`);
        
        if (blogPosts.length > 0) {
          blogLog(`   Sample row keys: ${Object.keys(blogPosts[0]).join(', ')}`);
        }
        
        // Show info
        const infoDiv = document.getElementById('blogCsvInfo');
        const infoText = document.getElementById('blogCsvInfoText');
        infoText.textContent = `‚úÖ Loaded ${blogPosts.length} blog posts. Ready to generate schema.`;
        infoDiv.style.display = 'block';
        document.getElementById('generateBlogBtn').disabled = false;
      },
      error: function(error) {
        blogLog(`‚ùå Error parsing CSV file: ${error.message}`, 'error');
        alert('Error parsing CSV file: ' + error.message);
        document.getElementById('generateBlogBtn').disabled = true;
      }
    });
  }

  function formatDate(dateStr) {
    if (!dateStr) return null;
    // Handle YYYY-MM-DD format - convert to ISO-8601 with timezone
    const dateMatch = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})/);
    if (dateMatch) {
      // Return ISO-8601 format with timezone: YYYY-MM-DDTHH:MM:SS+00:00
      return `${dateMatch[0]}T00:00:00+00:00`;
    }
    // Try to parse other formats
    try {
      const date = new Date(dateStr);
      if (!isNaN(date.getTime())) {
        // Convert to ISO-8601 with timezone
        const isoString = date.toISOString();
        // Replace Z with +00:00 for explicit timezone
        return isoString.replace('Z', '+00:00');
      }
    } catch (e) {
      console.warn('Could not parse date:', dateStr);
    }
    return null;
  }

  function truncate(text, maxLength) {
    if (!text) return '';
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }

  function getSchemaType(categories) {
    if (!categories) return 'BlogPosting';
    const cats = categories.toLowerCase();
    if (cats.includes('news')) {
      return 'NewsArticle';
    }
    return 'BlogPosting';
  }

  function generateBlogIndexSchema() {
    if (!blogPosts || blogPosts.length === 0) {
      alert('Please upload a blog CSV file first.');
      return;
    }

    blogLog('üî® Starting blog schema generation...');
    blogLog(`   Processing ${blogPosts.length} blog posts`);

    const BLOG_URL = 'https://www.alanranger.com/blog-on-photography';
    const BLOG_NAME = 'Alan Ranger Blog on Photography ‚Äì Tips, Offers & News';
    const BLOG_DESCRIPTION = 'Photography tips, creative projects, case studies, and news by Alan Ranger. Covering composition, exposure, field techniques, editing, and real workshop insights.';

    blogLog(`   Blog URL: ${BLOG_URL}`);
    blogLog(`   Blog Name: ${BLOG_NAME}`);

    const PUBLISHER = {
      "@type": "Organization",
      "name": "Alan Ranger Photography",
      "url": "https://www.alanranger.com",
      "logo": {
        "@type": "ImageObject",
        "url": "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w",
        "width": 800,
        "height": 800
      },
      "sameAs": [
        "https://www.facebook.com/alanrangerphotography",
        "https://www.instagram.com/alanrangerphoto",
        "https://www.youtube.com/@AlanRangerPhotography",
        "https://www.threads.net/@alanrangerphoto"
      ]
    };

    const AUTHOR = {
      "@type": "Person",
      "name": "Alan Ranger",
      "url": "https://www.alanranger.com/about-alan-ranger",
      "jobTitle": "Photographer & Educator",
      "affiliation": {
        "@type": "Organization",
        "name": "Alan Ranger Photography"
      },
      "sameAs": [
        "https://www.alanranger.com",
        "https://www.linkedin.com/in/alanrangerphotography"
      ]
    };

    // Generate blog postings
    const blogPostings = [];
    const seenUrls = new Set();
    let skippedCount = 0;
    let newsArticleCount = 0;
    let blogPostingCount = 0;

    blogLog('üìù Generating blog postings...');

    for (let i = 0; i < blogPosts.length; i++) {
      const row = blogPosts[i];
      const headline = (row['Title'] || '').trim();
      const url = (row['Full Url'] || '').trim();
      const image = (row['Image'] || '').trim();
      const datePublished = formatDate(row['Publish On'] || '');
      const categories = (row['Categories'] || '').trim();
      const tags = (row['Tags'] || '').trim();

      // Skip duplicates
      if (url && seenUrls.has(url)) {
        blogLog(`   ‚ö†Ô∏è Skipping duplicate URL: ${url}`);
        skippedCount++;
        continue;
      }

      if (!headline || !url) {
        blogLog(`   ‚ö†Ô∏è Skipping row ${i + 1}: missing headline or URL`);
        skippedCount++;
        continue; // Skip rows without required fields
      }

      if (url) {
        seenUrls.add(url);
      }

      // Extract first category as articleSection
      const articleSection = categories ? categories.split(';')[0].trim() : '';
      
      // Join tags as keywords
      const keywords = tags ? tags.split(';').map(t => t.trim()).join(', ') : '';
      
      // Generate description (truncate title if needed)
      const description = truncate(headline, 110);
      
      const schemaType = getSchemaType(categories);
      if (schemaType === 'NewsArticle') {
        newsArticleCount++;
      } else {
        blogPostingCount++;
      }
      
      const blogPosting = {
        "@type": schemaType,
        "headline": headline,
        "url": url,
        "datePublished": datePublished || new Date().toISOString().replace('Z', '+00:00'),
        "dateModified": datePublished || new Date().toISOString().replace('Z', '+00:00'),
        "description": description,
        "author": {
          "@type": "Person",
          "name": "Alan Ranger",
          "url": "https://www.alanranger.com/about-alan-ranger"
        },
        "publisher": {
          "@type": "Organization",
          "name": "Alan Ranger Photography"
        },
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": url
        },
        "isPartOf": BLOG_URL,
        "inLanguage": "en-GB",
        "copyrightHolder": {
          "@type": "Organization",
          "name": "Alan Ranger Photography"
        }
      };
      
      // Add image if available
      if (image) {
        blogPosting.image = {
          "@type": "ImageObject",
          "url": image,
          "caption": headline
        };
        blogPosting.thumbnailUrl = image;
      }
      
      // Add articleSection if available
      if (articleSection) {
        blogPosting.articleSection = articleSection;
      }
      
      // Add keywords if available
      if (keywords) {
        blogPosting.keywords = keywords;
      }
      
      blogPostings.push({
        "@type": "ListItem",
        "position": blogPostings.length + 1,
        "item": blogPosting
      });
    }

    blogLog(`‚úÖ Generated ${blogPostings.length} blog postings`);
    blogLog(`   - BlogPosting: ${blogPostingCount}`);
    blogLog(`   - NewsArticle: ${newsArticleCount}`);
    if (skippedCount > 0) {
      blogLog(`   - Skipped: ${skippedCount}`);
    }

    // Generate main Blog schema
    blogLog('üî® Building Blog schema structure...');
    const blogSchema = {
      "@context": "https://schema.org",
      "@type": "Blog",
      "@id": `${BLOG_URL}#blog`,
      "url": BLOG_URL,
      "name": BLOG_NAME,
      "description": BLOG_DESCRIPTION,
      "publisher": PUBLISHER,
      "author": AUTHOR,
      "inLanguage": "en-GB",
      "mainEntity": {
        "@type": "ItemList",
        "itemListOrder": "Descending",
        "itemListElement": blogPostings
      }
    };

    // Display the schema
    const schemaCode = JSON.stringify(blogSchema, null, 2);
    const fileSizeKB = (new Blob([schemaCode]).size / 1024).toFixed(2);
    
    // Wrap in script tag for easy pasting
    const scriptWrapped = `<script type="application/ld+json">\n${schemaCode}\n<\/script>`;
    
    blogLog(`‚úÖ Schema generation complete!`);
    blogLog(`   - Total posts in schema: ${blogPostings.length}`);
    blogLog(`   - Schema size: ${fileSizeKB} KB`);
    
    // Display the script-wrapped version
    const codeElement = document.getElementById('blogSchemaCode');
    if (codeElement) {
      codeElement.textContent = scriptWrapped;
      // Set styles only when content is present
      codeElement.style.color = '#fff';
      codeElement.style.backgroundColor = '#000';
      
      // Also ensure parent pre has correct styles
      const preElement = codeElement.parentElement;
      if (preElement && preElement.tagName === 'PRE') {
        preElement.style.color = '#fff';
        preElement.style.backgroundColor = '#000';
      }
    }
    document.getElementById('blogSchemaOutput').style.display = 'block';
    
    // Scroll to output
    document.getElementById('blogSchemaOutput').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    
    console.log(`‚úÖ Generated Blog schema with ${blogPostings.length} posts`);
  }

  function copyBlogSchema() {
    const codeElement = document.getElementById('blogSchemaCode');
    if (!codeElement) {
      alert('Schema code element not found.');
      return;
    }

    const schemaCode = codeElement.textContent || codeElement.innerText || '';
    
    if (!schemaCode || schemaCode.trim().length === 0) {
      alert('No schema code to copy. Please generate the schema first.');
      return;
    }

    // Try modern clipboard API first
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(schemaCode).then(() => {
        const btn = document.querySelector('#blogSchemaOutput .copy-btn');
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            btn.textContent = originalText;
          }, 2000);
        }
        blogLog('‚úÖ Schema copied to clipboard');
      }).catch((err) => {
        console.error('Clipboard API failed:', err);
        // Fallback to execCommand
        fallbackCopy(schemaCode);
      });
    } else {
      // Fallback for older browsers
      fallbackCopy(schemaCode);
    }
  }

  function fallbackCopy(text) {
    // Create a temporary textarea element
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.left = '-999999px';
    textarea.style.top = '-999999px';
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    
    try {
      const successful = document.execCommand('copy');
      if (successful) {
        const btn = document.querySelector('#blogSchemaOutput .copy-btn');
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            btn.textContent = originalText;
          }, 2000);
        }
        blogLog('‚úÖ Schema copied to clipboard (fallback method)');
      } else {
        throw new Error('execCommand copy failed');
      }
    } catch (err) {
      console.error('Fallback copy failed:', err);
      alert('Failed to copy. Please select the code and copy manually (Ctrl+C).');
      blogLog(`‚ùå Copy failed: ${err.message}`, 'error');
    } finally {
      document.body.removeChild(textarea);
    }
  }

  function clearBlogForm() {
    document.getElementById('blogCsvFile').value = '';
    blogPosts = [];
    blogDebugLog = [];
    document.getElementById('generateBlogBtn').disabled = true;
    document.getElementById('blogCsvInfo').style.display = 'none';
    document.getElementById('blogDebugLogContainer').style.display = 'none';
    document.getElementById('blogSchemaOutput').style.display = 'none';
  }

  function testBlogSchemaOrg() {
    const blogUrl = 'https://www.alanranger.com/blog-on-photography';
    window.open('https://validator.schema.org/#url=' + encodeURIComponent(blogUrl), '_blank');
  }

  function testBlogGoogleRichResults() {
    const blogUrl = 'https://www.alanranger.com/blog-on-photography';
    window.open('https://search.google.com/test/rich-results?url=' + encodeURIComponent(blogUrl), '_blank');
  }

  function saveBlogSchemaToFile() {
    const scriptWrapped = document.getElementById('blogSchemaCode').textContent;
    if (!scriptWrapped || scriptWrapped.trim().length === 0) {
      alert('No schema generated yet. Please generate the schema first.');
      return;
    }

    // Extract JSON from script tags (remove <script> wrapper)
    let schemaCode = scriptWrapped.trim();
    if (schemaCode.startsWith('<script')) {
      // Remove script tag wrapper - escape forward slash in regex
      schemaCode = schemaCode.replace(/^<script[^>]*>/, '').replace(/<\/script>$/, '').trim();
    }

    const fileName = 'blog-schema.json';
    const githubFolderPath = 'G:\\Dropbox\\alan ranger photography\\Website Code\\Schema Tools\\alanranger-schema';

    try {
      // Validate JSON
      JSON.parse(schemaCode);

      // Check if we're in Electron mode (can write directly to file system)
      if (typeof window.require !== 'undefined' || typeof require !== 'undefined') {
        try {
          const fs = typeof window.require !== 'undefined' ? window.require('fs') : require('fs');
          const path = typeof window.require !== 'undefined' ? window.require('path') : require('path');
          const { shell } = typeof window.require !== 'undefined' ? window.require('electron') : require('electron');

          // Ensure directory exists
          const repoDir = path.join(githubFolderPath);
          if (!fs.existsSync(repoDir)) {
            fs.mkdirSync(repoDir, { recursive: true });
          }

          // Write file directly to root of repository (JSON only, no script tags)
          const filePath = path.join(repoDir, fileName);
          fs.writeFileSync(filePath, schemaCode, 'utf-8');

          // Open folder in file explorer
          shell.showItemInFolder(filePath);

          blogLog(`üíæ Saved blog schema to: ${filePath}`);
          blogLog(`üìÅ Folder opened in Explorer`);

          alert(`‚úÖ Successfully saved ${fileName} to alanranger-schema folder!\n\nFolder opened in Explorer.`);
          return;
        } catch (electronError) {
          console.warn('Electron file system access failed, falling back to download:', electronError);
          blogLog(`‚ö†Ô∏è Electron file system access failed: ${electronError.message}`);
        }
      }

      // Fallback: Download file (JSON only, no script tags)
      const blob = new Blob([schemaCode], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      blogLog(`üíæ Downloaded ${fileName} (fallback mode)`);
      alert(`‚úÖ Downloaded ${fileName}\n\nIn browser mode, files are downloaded to your Downloads folder.\n\nTo save directly to the alanranger-schema folder, use the Electron app.`);
    } catch (error) {
      blogLog(`‚ùå Error saving file: ${error.message}`, 'error');
      alert(`Error saving file: ${error.message}`);
    }
  }

  // Helper: Validate URL input
  function validateUrlInput() {
    const urlInput = document.getElementById('singleUrlInput');
    if (!urlInput) {
      console.error('singleUrlInput element not found');
      alert('Error: Input field not found. Please refresh the page.');
      return null;
    }
    
    const url = urlInput.value.trim();
    console.log('URL input:', url);
    
    if (!url) {
      alert('Please enter a URL to validate');
      return null;
    }
    
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      alert('Please enter a valid URL starting with http:// or https://');
      return null;
    }
    
    return { urlInput, url };
  }

  // Helper: Show results table
  function showResultsTable() {
    const resultsDiv = document.getElementById('validatorResults');
    if (resultsDiv) {
      resultsDiv.style.display = 'block';
      return resultsDiv;
    }
    console.error('validatorResults element not found');
    alert('Error: Results table not found. Please refresh the page.');
    return null;
  }

  // Helper: Find or create result index
  function findOrCreateResultIndex(url) {
    if (typeof validationResults === 'undefined') {
      console.error('validationResults array not defined');
      alert('Error: Validation system not initialized. Please refresh the page.');
      return null;
    }
    
    const existingIndex = validationResults.findIndex(r => r.url === url);
    if (existingIndex >= 0) {
      console.log('Updating existing row at index:', existingIndex);
      return existingIndex;
    }
    
    console.log('Creating new row, current length:', validationResults.length);
    const index = validationResults.length;
    
    const placeholderResult = {
      url: url,
      row: index,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null,
      validatorGoogleStatus: 'Not run',
      validatorSchemaOrgStatus: 'Not run',
      notes: '',
      issuesList: []
    };
    
    validationResults.push(placeholderResult);
    console.log('Added placeholder result, new length:', validationResults.length);
    return index;
  }

  // Helper: Initialize validation row UI
  function initializeValidationRow(index, url) {
    if (typeof updateTableRow === 'undefined') {
      console.error('updateTableRow function not defined');
      alert('Error: updateTableRow function not found. Please refresh the page.');
      return false;
    }
    
    updateTableRow(index, {
      url: url,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null,
      validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
      validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
      notes: validationResults[index]?.notes || '',
      issuesList: []
    });
    
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    if (schemaTypeCell) {
      if (typeof renderProgress === 'undefined' || typeof setProgress === 'undefined') {
        console.error('renderProgress or setProgress not defined');
      } else {
        renderProgress(schemaTypeCell);
        setProgress(schemaTypeCell, 5, 'Queued');
      }
    }
    
    return true;
  }

  // Helper: Run external validators if enabled
  async function runExternalValidatorsIfEnabled(index, url) {
    const autoRunCheckbox = document.getElementById('autoRunExternalChecks');
    const shouldAutoRun = autoRunCheckbox ? autoRunCheckbox.checked : true;
    
    if (!shouldAutoRun) {
      return;
    }
    
    // Wait longer for DOM to be fully updated and select elements to be created
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Retry logic - try multiple times if elements aren't found
    let retries = 3;
    let schemaOrgRan = false;
    let richResultsRan = false;
    
    while (retries > 0 && (!schemaOrgRan || !richResultsRan)) {
      try {
        const schemaOrgStatusSelect = document.getElementById(`schemaOrgStatus_${index}`);
        if (schemaOrgStatusSelect && schemaOrgStatusSelect.value === 'Not run' && !schemaOrgRan) {
          if (typeof runSchemaOrgValidator === 'function') {
            try {
              await runSchemaOrgValidator(index, url);
              schemaOrgRan = true;
            } catch (err) {
              console.error(`Schema.org validation failed for ${url}:`, err);
              debugLog(`Schema.org validation failed for ${url}: ${err.message}`, 'error');
              schemaOrgRan = true; // Mark as attempted to prevent retry loop
            }
          } else {
            console.warn(`runSchemaOrgValidator function not found for index ${index}`);
            schemaOrgRan = true;
          }
        } else if (schemaOrgStatusSelect && schemaOrgStatusSelect.value !== 'Not run') {
          schemaOrgRan = true; // Already run
        }
        
        const googleStatusSelect = document.getElementById(`googleStatus_${index}`);
        if (googleStatusSelect && googleStatusSelect.value === 'Not run' && !richResultsRan) {
          if (typeof runRichResultsValidator === 'function') {
            try {
              await runRichResultsValidator(index, url);
              richResultsRan = true;
            } catch (err) {
              console.error(`Rich Results validation failed for ${url}:`, err);
              debugLog(`Rich Results validation failed for ${url}: ${err.message}`, 'error');
              richResultsRan = true; // Mark as attempted to prevent retry loop
            }
          } else {
            console.warn(`runRichResultsValidator function not found for index ${index}`);
            richResultsRan = true;
          }
        } else if (googleStatusSelect && googleStatusSelect.value !== 'Not run') {
          richResultsRan = true; // Already run
        }
        
        // If both ran or both select elements don't exist, break
        if (schemaOrgRan && richResultsRan) {
          break;
        }
        
        // If elements still don't exist after waiting, wait a bit more
        if (retries > 1 && (!schemaOrgStatusSelect || !googleStatusSelect)) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
        
      } catch (error) {
        console.error(`External validation error for ${url}:`, error);
        debugLog(`External validation error for ${url}: ${error.message}`, 'error');
      }
      
      retries--;
      if (retries > 0 && (!schemaOrgRan || !richResultsRan)) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
    
    if (!schemaOrgRan || !richResultsRan) {
      console.warn(`External validations may not have completed for index ${index}, URL: ${url}`);
      debugLog(`External validations may not have completed for index ${index}, URL: ${url}`, 'warning');
    }
  }

  // Helper: Auto-save to Supabase if enabled
  function autoSaveToSupabaseIfEnabled(index, url) {
    const autoSaveCheckbox = document.getElementById('autoSaveToSupabase');
    const shouldAutoSave = autoSaveCheckbox ? autoSaveCheckbox.checked : false;
    
    if (shouldAutoSave && supabaseAvailable && supabase && typeof saveToSupabase === 'function') {
      setTimeout(async () => {
        try {
          await saveToSupabase(index, true);
          debugLog(`Auto-saved to Supabase: ${url}`, 'success');
        } catch (error) {
          debugLog(`Auto-save failed for ${url}: ${error.message}`, 'error');
        }
      }, 2000);
    }
  }

  // Helper: Handle validation error
  function handleValidationError(error, index, url) {
    console.error('Error validating URL:', error);
    console.error('Error stack:', error.stack);
    alert('Error validating URL: ' + error.message + '\n\nCheck console for details.');
    
    if (typeof index !== 'undefined' && validationResults && validationResults[index]) {
      validationResults[index] = {
        url: url || 'Unknown',
        row: index || 0,
        schemaType: null,
        valid: false,
        schemaFound: false,
        missingFields: [],
        warnings: [],
        schemas: [],
        error: error.message,
        validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
        validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
        notes: validationResults[index]?.notes || '',
        issuesList: []
      };
      
      if (typeof updateTableRow === 'function') {
        updateTableRow(index, validationResults[index]);
      }
    }
    
    if (typeof updateBulkButtons === 'function') {
      updateBulkButtons();
    }
  }

  // Single URL validation
  async function runSingleUrlValidation() {
    console.log('runSingleUrlValidation called');
    
    try {
      const urlInputData = validateUrlInput();
      if (!urlInputData) return;
      
      const resultsDiv = showResultsTable();
      if (!resultsDiv) return;
      
      const index = findOrCreateResultIndex(urlInputData.url);
      if (index === null) return;
      
      if (!initializeValidationRow(index, urlInputData.url)) return;
      
      console.log('Starting processUrl...');
      if (typeof processUrl === 'undefined') {
        console.error('processUrl function not defined');
        alert('Error: processUrl function not found. Please refresh the page.');
        return;
      }
      
      const urlData = { url: urlInputData.url, row: index };
      const result = await processUrl(urlData);
      console.log('processUrl completed:', result);
      
      validationResults[index] = {
        ...result,
        validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
        validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
        notes: validationResults[index]?.notes || ''
      };
      
      console.log('Updating table row with results...');
      updateTableRow(index, validationResults[index]);
      
      if (typeof updateBulkButtons === 'function') {
        updateBulkButtons();
      }
      
      await runExternalValidatorsIfEnabled(index, urlInputData.url);
      autoSaveToSupabaseIfEnabled(index, urlInputData.url);
      
      urlInputData.urlInput.value = '';
      
      if (resultsDiv) {
        resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      
    } catch (error) {
      let errorUrl = '';
      try {
        const urlInputData = validateUrlInput();
        errorUrl = urlInputData?.url || '';
      } catch {
        errorUrl = '';
      }
      handleValidationError(error, typeof index !== 'undefined' ? index : undefined, errorUrl);
    }
  }
  
  // Make it globally accessible
  window.runSingleUrlValidation = runSingleUrlValidation;

  // Toggle help block
  function toggleHelpBlock() {
    const helpBlock = document.getElementById('helpBlock');
    const content = document.getElementById('helpBlockContent');
    
    helpBlock.classList.toggle('expanded');
    content.classList.toggle('active');
    helpBlock.setAttribute('aria-expanded', helpBlock.classList.contains('expanded'));
  }

  // Event Schema Generation v4 - Smart Enriched Schema Generator
  let events = [];
  let reviewsData = null;
  let mappingsData = null;

  // Schema Suppressor v1.3 block (Code-Block Safe)
  const SCHEMA_SUPPRESSOR_BLOCK = `<!-- Squarespace Product Schema Suppressor v1.3 (Code-Block Safe) -->

<script>
(function(){
  const removeSquarespaceProduct = () => {
    document.querySelectorAll('script[type="application/ld+json"]').forEach(el => {
      const txt = el.textContent.trim();
      if (txt.includes('"@type":"Product"')) {
        try {
          const j = JSON.parse(txt);
          const looksLikeSquarespace =
            txt.length < 1500 &&
            !j.aggregateRating &&
            !j.review &&
            j.offers &&
            j.name &&
            !txt.includes('"hasMerchantReturnPolicy"');
          if (looksLikeSquarespace) el.remove();
        } catch(e){}
      }
    });
  };
  removeSquarespaceProduct();
  document.addEventListener('DOMContentLoaded', removeSquarespaceProduct);
  window.addEventListener('load', () => setTimeout(removeSquarespaceProduct, 1000));
  const obs = new MutationObserver(removeSquarespaceProduct);
  obs.observe(document.documentElement, { childList: true, subtree: true });
})();
<\/script>

`;

  // Helper functions for stable ID generation (v4.3)
  function slugifyId(s) {
    return String(s || "")
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
  }

  // Use a stable base for @id (page canonical if available, else window.location)
  function getBaseId() {
    const canonical = document.querySelector('link[rel="canonical"]');
    return (canonical?.href || window.location.href || "").split("#")[0];
  }

  function seriesIdFromName(name) {
    return `${getBaseId()}#series-${slugifyId(name)}`;
  }

  function eventIdFromUrl(url) {
    // Fall back to hashing the name/identifier if URL missing
    if (!url) return `${getBaseId()}#event-${Math.random().toString(36).slice(2)}`;
    const clean = url.split("#")[0];
    return `${clean}#event`;
  }

  // Detect EventSeries groups for recurring workshops (v4.2 + v4.3)
  function detectEventSeries(events) {
    const grouped = {};
    
    // Use flexible keyword patterns that match variations
    const keywordPatterns = [
      { pattern: /bluebell.*photography.*workshop/i, key: "bluebell photography workshop" },
      { pattern: /batsford.*arboretum.*autumn.*photography.*workshop/i, key: "batsford arboretum autumn photography workshop" },
      { pattern: /camera.*course.*for.*beginners|camera.*courses.*for.*beginners/i, key: "camera course for beginners" },
      { pattern: /lightroom.*photo.*editing|lightroom.*classic.*photo.*editing/i, key: "lightroom photo editing" }
    ];
    
    for (const e of events) {
      const title = (e.name || e.Event_Title || "").toLowerCase();
      
      // Try to match against patterns
      for (const { pattern, key } of keywordPatterns) {
        if (pattern.test(title)) {
          if (!grouped[key]) grouped[key] = [];
          grouped[key].push(e);
          break; // Only match one pattern per event
        }
      }
    }
    
    // Filter out groups with fewer than 2 events
    Object.keys(grouped).forEach(k => {
      if (grouped[k].length < 2) delete grouped[k];
    });
    
    return grouped;
  }

  // Detect CSV type (Lessons vs Workshops) - v4
  function detectCsvType(fileName, headers) {
    const fileNameLower = (fileName || '').toLowerCase();
    const headersStr = (headers || []).join(' ').toLowerCase();
    
    if (fileNameLower.includes('beginners-photography-lessons') || 
        fileNameLower.includes('lesson') ||
        headersStr.includes('beginners-photography-lessons')) {
      return 'lessons';
    } else if (fileNameLower.includes('photographic-workshops') ||
               fileNameLower.includes('workshop') ||
               headersStr.includes('photographic-workshops')) {
      return 'workshops';
    }
    return 'unknown';
  }

  document.getElementById('eventCsvFile').addEventListener('change', function(e) {
    if (!e.target.files || !e.target.files[0]) {
      console.error('No file selected');
      return;
    }
    
    Papa.parse(e.target.files[0], {
      header: true,
      skipEmptyLines: true,
      complete: function(results) {
        if (!results.data || results.data.length === 0) {
          alert('CSV file is empty or could not be parsed. Please check the file format.');
          return;
        }
        
        events = results.data;
        console.log('‚úÖ Loaded', events.length, 'events from CSV');
        
        // Detect CSV type
        const csvType = detectCsvType(e.target.files[0].name, results.meta.fields || []);
        console.log('üìã CSV Type detected:', csvType);
        
        const categories = [...new Set(
          events.map(e => {
            const cat = e['Category'] || e['category'] || e['CATEGORY'] || '';
            return cat.split(',')[0].trim();
          }).filter(Boolean)
        )];
        
        const filterSelect = document.getElementById('eventCategoryFilter');
        filterSelect.innerHTML = '<option value="__ALL__">All Categories</option>';
        categories.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          filterSelect.appendChild(opt);
        });
        
        // Show the category filter dropdown now that categories are loaded
        filterSelect.style.display = 'block';
        
        // Ensure container stays visible
        document.getElementById('eventCategoryFilterContainer').style.display = 'block';
        document.getElementById('eventOptionsContainer').style.display = 'block';
        
        // Load toggle states from localStorage
        const includeReviews = localStorage.getItem('eventSchema.includeReviews');
        const includePerformer = localStorage.getItem('eventSchema.includePerformer');
        const groupRepeatingEvents = localStorage.getItem('eventSchema.groupRepeatingEvents');
        const includeMerchantFields = localStorage.getItem('eventSchema.includeMerchantFields');
        const enrichLocations = localStorage.getItem('eventSchema.enrichLocations');
        const includeAvailabilityStarts = localStorage.getItem('eventSchema.includeAvailabilityStarts');
        
        if (includeReviews !== null) document.getElementById('includeReviews').checked = includeReviews === 'true';
        if (includePerformer !== null) document.getElementById('includePerformer').checked = includePerformer === 'true';
        if (groupRepeatingEvents !== null) document.getElementById('groupRepeatingEvents').checked = groupRepeatingEvents === 'true';
        if (includeMerchantFields !== null) {
          document.getElementById('includeMerchantFields').checked = includeMerchantFields === 'true';
          document.getElementById('merchantFeedContainer').style.display = includeMerchantFields === 'true' ? 'block' : 'none';
        }
        if (enrichLocations !== null) document.getElementById('toggleLocationEnrichment').checked = enrichLocations === 'true';
        if (includeAvailabilityStarts !== null) document.getElementById('toggleAvailabilityStarts').checked = includeAvailabilityStarts === 'true';
        
        // Save toggle states on change
        document.getElementById('includeReviews').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includeReviews', this.checked);
        });
        document.getElementById('includePerformer').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includePerformer', this.checked);
        });
        document.getElementById('groupRepeatingEvents').addEventListener('change', function() {
          localStorage.setItem('eventSchema.groupRepeatingEvents', this.checked);
        });
        document.getElementById('includeMerchantFields').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includeMerchantFields', this.checked);
          document.getElementById('merchantFeedContainer').style.display = this.checked ? 'block' : 'none';
        });
        document.getElementById('toggleLocationEnrichment').addEventListener('change', function() {
          localStorage.setItem('eventSchema.enrichLocations', this.checked);
        });
        document.getElementById('toggleAvailabilityStarts').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includeAvailabilityStarts', this.checked);
        });
        
        console.log('‚úÖ Category filter and Generate button displayed');
      },
      error: function(error) {
        console.error('Error parsing CSV:', error);
        alert('Error parsing CSV file: ' + (error.message || 'Unknown error') + '\n\nPlease check that the file is a valid CSV.');
      }
    });
  });

  // Global variable to store products data
  window.productsData = [];
  
  // Load products Excel file (optional, for actual SKU values)
  async function loadProductsData() {
    const debugLog = [];
    const productsFileInput = document.getElementById('productsExcelFile');
    
    if (productsFileInput && productsFileInput.files && productsFileInput.files[0]) {
      debugLog.push(`üìÑ Loading products Excel: ${productsFileInput.files[0].name}`);
      try {
        const file = productsFileInput.files[0];
        const arrayBuffer = await file.arrayBuffer();
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        const products = XLSX.utils.sheet_to_json(worksheet);
        
        window.productsData = products.map(p => ({
          url: normalizeUrl(p.url || ''),
          main_sku: p.main_sku || p.Main_SKU || p['main_sku'] || null,
          sku: p.sku || p.SKU || p['sku'] || null,
          name: p.name || p.Name || p['name'] || ''
        }));
        
        debugLog.push(`‚úÖ Loaded ${window.productsData.length} products from Excel`);
        if (products.length > 0) {
          debugLog.push(`   Columns found: ${Object.keys(products[0]).join(', ')}`);
        }
        const productsWithSku = window.productsData.filter(p => p.main_sku || p.sku).length;
        debugLog.push(`   Products with SKU: ${productsWithSku}`);
        
        window.debugLog = window.debugLog || [];
        window.debugLog.push(...debugLog);
        updateDebugLog();
      } catch (e) {
        debugLog.push(`‚ùå Error reading products Excel: ${e.message}`);
        window.debugLog = window.debugLog || [];
        window.debugLog.push(...debugLog);
        updateDebugLog();
      }
    } else {
      debugLog.push('‚ö†Ô∏è No products Excel file uploaded (optional - SKU will use URL slug fallback)');
      window.debugLog = window.debugLog || [];
      window.debugLog.push(...debugLog);
      updateDebugLog();
    }
  }

  // Load reviews and mappings CSVs from file inputs (optional, for review enrichment)
  async function loadReviewData() {
    const debugLog = [];
    
    // Load products Excel first (for SKU lookup)
    await loadProductsData();
    
    // Load reviews CSV from file input
    const reviewsFileInput = document.getElementById('reviewsCsvFile');
    if (reviewsFileInput && reviewsFileInput.files && reviewsFileInput.files[0]) {
      debugLog.push(`üìÑ Loading reviews CSV: ${reviewsFileInput.files[0].name}`);
      try {
        const file = reviewsFileInput.files[0];
        const text = await file.text();
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            reviewsData = results.data;
            debugLog.push(`‚úÖ Loaded ${reviewsData.length} reviews from CSV`);
            debugLog.push(`   Columns found: ${results.meta.fields ? results.meta.fields.join(', ') : 'unknown'}`);
            if (reviewsData.length > 0) {
              debugLog.push(`   Sample review keys: ${Object.keys(reviewsData[0]).join(', ')}`);
            }
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          },
          error: function(error) {
            debugLog.push(`‚ùå Error parsing reviews CSV: ${error.message}`);
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          }
        });
      } catch (e) {
        debugLog.push(`‚ùå Error reading reviews file: ${e.message}`);
        window.debugLog = window.debugLog || [];
        window.debugLog.push(...debugLog);
        updateDebugLog();
      }
    } else {
      debugLog.push('‚ö†Ô∏è No reviews CSV file uploaded (optional)');
      window.debugLog = window.debugLog || [];
      window.debugLog.push(...debugLog);
      updateDebugLog();
    }

    // Load mappings CSV from file input
    const mappingsFileInput = document.getElementById('mappingsCsvFile');
    if (mappingsFileInput && mappingsFileInput.files && mappingsFileInput.files[0]) {
      debugLog.push(`üìÑ Loading mappings CSV: ${mappingsFileInput.files[0].name}`);
      try {
        const file = mappingsFileInput.files[0];
        const text = await file.text();
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            mappingsData = results.data;
            debugLog.push(`‚úÖ Loaded ${mappingsData.length} mappings from CSV`);
            debugLog.push(`   Columns found: ${results.meta.fields ? results.meta.fields.join(', ') : 'unknown'}`);
            if (mappingsData.length > 0) {
              debugLog.push(`   Sample mapping keys: ${Object.keys(mappingsData[0]).join(', ')}`);
            }
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          },
          error: function(error) {
            debugLog.push(`‚ùå Error parsing mappings CSV: ${error.message}`);
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          }
        });
      } catch (e) {
        debugLog.push(`‚ùå Error reading mappings file: ${e.message}`);
        window.debugLog = window.debugLog || [];
        window.debugLog.push(...debugLog);
        updateDebugLog();
      }
    } else {
      debugLog.push('‚ö†Ô∏è No mappings CSV file uploaded (optional)');
      window.debugLog = window.debugLog || [];
      window.debugLog.push(...debugLog);
      updateDebugLog();
    }
  }
  
  // Add debug log entry
  function addDebugLog(message) {
    window.debugLog = window.debugLog || [];
    window.debugLog.push(message);
    updateDebugLog();
  }
  
  // Copy debug log to clipboard
  function copyDebugLog(btnElement) {
    const debugLogElement = document.getElementById('debugLog');
    if (!debugLogElement || !window.debugLog || window.debugLog.length === 0) {
      alert('No debug log available to copy.');
      return;
    }
    
    const logText = window.debugLog.join('\n');
    
    // Try modern clipboard API first
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(logText).then(() => {
        if (btnElement) {
          const originalText = btnElement.textContent;
          btnElement.textContent = '‚úÖ Copied!';
          btnElement.style.background = '#48bb78';
          setTimeout(() => {
            btnElement.textContent = originalText;
            btnElement.style.background = '#667eea';
          }, 2000);
        }
      }).catch(err => {
        console.error('Failed to copy debug log:', err);
        // Fallback to textarea method
        fallbackCopyToClipboard(logText, btnElement);
      });
    } else {
      // Fallback for browsers without clipboard API
      fallbackCopyToClipboard(logText, btnElement);
    }
  }
  
  // Fallback copy method using textarea
  function fallbackCopyToClipboard(text, btnElement) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      const successful = document.execCommand('copy');
      if (successful) {
        if (btnElement) {
          const originalText = btnElement.textContent;
          btnElement.textContent = '‚úÖ Copied!';
          btnElement.style.background = '#48bb78';
          setTimeout(() => {
            btnElement.textContent = originalText;
            btnElement.style.background = '#667eea';
          }, 2000);
        }
      } else {
        throw new Error('execCommand failed');
      }
    } catch (err) {
      console.error('Fallback copy failed:', err);
      alert('Failed to copy debug log. Please select the debug log text and copy manually (Ctrl+C).');
    } finally {
      document.body.removeChild(textArea);
    }
  }
  
  // Show field verification modal
  function showFieldVerificationModal() {
    if (!window.fieldVerificationStats) {
      alert('Field verification data not available. Please generate schema first.');
      return;
    }
    
    const modal = document.getElementById('fieldVerificationModal');
    if (modal) {
      modal.style.display = 'block';
      updateFieldVerificationModal();
    }
  }
  
  // Close field verification modal
  function closeFieldVerificationModal() {
    const modal = document.getElementById('fieldVerificationModal');
    if (modal) {
      modal.style.display = 'none';
      // Ensure copy buttons are visible after modal closes
      const copyButton = document.getElementById('copySchemaButton');
      const copyButtonTop = document.getElementById('copySchemaButtonTop');
      if (copyButton) {
        copyButton.style.display = 'inline-block';
        copyButton.style.visibility = 'visible';
        copyButton.style.opacity = '1';
      }
      if (copyButtonTop) {
        copyButtonTop.style.display = 'inline-block';
        copyButtonTop.style.visibility = 'visible';
        copyButtonTop.style.opacity = '1';
      }
    }
  }
  
  // Update field verification modal content
  function updateFieldVerificationModal() {
    const content = document.getElementById('fieldVerificationModalContent');
    if (!content || !window.fieldVerificationStats) return;
    
    const stats = window.fieldVerificationStats;
    let html = '<div style="max-height: 70vh; overflow-y: auto;">';
    
    // Event Core Fields
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #667eea;">';
    html += '<h3 style="margin-top: 0; color: #667eea;">üß© Event Core Fields</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>@context</td><td style="text-align: center;">${stats.coreFields?.context || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>@type</td><td style="text-align: center;">${stats.coreFields?.type || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>name</td><td style="text-align: center;">${stats.coreFields?.name || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>startDate</td><td style="text-align: center;">${stats.coreFields?.startDate || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>endDate</td><td style="text-align: center;">${stats.coreFields?.endDate || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>duration</td><td style="text-align: center;">${stats.coreFields?.duration || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>identifier</td><td style="text-align: center;">${stats.coreFields?.identifier || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += '</table></div>';
    
    // Location/Address Fields
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #38b2ac;">';
    html += '<h3 style="margin-top: 0; color: #38b2ac;">üèõ Location / Address Fields</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>location.@type</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>location.name</td><td style="text-align: center;">${stats.locationFields?.name || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.streetAddress</td><td style="text-align: center;">${stats.locationFields?.streetAddress || '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.locationFields?.streetAddressCount || 0} / ${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.addressLocality</td><td style="text-align: center;">${stats.locationFields?.locality || '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.locationFields?.localityCount || 0} / ${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.addressRegion</td><td style="text-align: center;">${stats.locationFields?.region || '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.locationFields?.regionCount || 0} / ${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.postalCode</td><td style="text-align: center;">${stats.locationFields?.postalCode || '‚úÖ'}</td><td style="text-align: right;">${stats.locationFields?.postalCodeCount || stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.addressCountry</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += '</table></div>';
    
    // Offers & Merchant Fields
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #ed8936;">';
    html += '<h3 style="margin-top: 0; color: #ed8936;">üí∞ Offers & Merchant Fields</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>offers.@type</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.price</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.priceCurrency</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.seller.name</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.hasMerchantReturnPolicy</td><td style="text-align: center;">${stats.merchantFields ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.merchantFields ? stats.offersBlocks : 0}</td></tr>`;
    html += `<tr><td>sku</td><td style="text-align: center;">${stats.merchantFields ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.merchantFields ? stats.eventsWithMappings : 0}</td></tr>`;
    html += `<tr><td>brand</td><td style="text-align: center;">${stats.merchantFields ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.merchantFields ? stats.eventsWithMappings : 0}</td></tr>`;
    html += '</table></div>';
    
    // Reviews & Ratings
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #48bb78;">';
    html += '<h3 style="margin-top: 0; color: #48bb78;">‚≠ê Reviews & Ratings</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>aggregateRating.@type</td><td style="text-align: center;">${stats.aggregateRatingsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.aggregateRatingsAdded || 0}</td></tr>`;
    html += `<tr><td>aggregateRating.ratingValue</td><td style="text-align: center;">${stats.aggregateRatingsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.aggregateRatingsAdded || 0}</td></tr>`;
    html += `<tr><td>aggregateRating.reviewCount</td><td style="text-align: center;">${stats.aggregateRatingsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.aggregateRatingsAdded || 0}</td></tr>`;
    html += `<tr><td>review array</td><td style="text-align: center;">${stats.reviewSnippetsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.reviewSnippetsAdded || 0}</td></tr>`;
    html += '</table></div>';
    
    // Organizer/Provider/Performer
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #9f7aea;">';
    html += '<h3 style="margin-top: 0; color: #9f7aea;">üë• Organizer / Provider / Performer</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>organizer.@type</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>organizer.name</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>organizer.logo</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>organizer.sameAs</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>performer</td><td style="text-align: center;">${stats.performerToggled ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.performerToggled ? stats.eventsGenerated : 0}</td></tr>`;
    html += `<tr><td>provider</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += '</table></div>';
    
    // Event ‚Üî Series Linkage (v4.3)
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #f56565;">';
    html += '<h3 style="margin-top: 0; color: #f56565;">üîó Event ‚Üî Series Linkage</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>Event.@id</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.linkageStats?.eventId || stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>Event.superEvent.@id</td><td style="text-align: center;">${stats.linkageStats?.superEventId > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.linkageStats?.superEventId || 0}</td></tr>`;
    html += `<tr><td>EventSeries.@id</td><td style="text-align: center;">${stats.linkageStats?.seriesId > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.linkageStats?.seriesId || 0}</td></tr>`;
    html += `<tr><td>EventSeries.subEvent (sum)</td><td style="text-align: center;">${stats.linkageStats?.seriesSubEventTotal > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.linkageStats?.seriesSubEventTotal || 0}</td></tr>`;
    html += `<tr><td>eventSchedule.repeatFrequency</td><td style="text-align: center;">${stats.linkageStats?.seriesWithScheduleRF > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.linkageStats?.seriesWithScheduleRF || 0}</td></tr>`;
    html += '</table></div>';
    
    html += '</div>';
    content.innerHTML = html;
  }
  
  // Update debug log display
  function updateDebugLog() {
    const debugLogElement = document.getElementById('debugLog');
    const debugLogContainer = document.getElementById('debugLogContainer');
    if (debugLogElement && window.debugLog) {
      debugLogElement.textContent = window.debugLog.join('\n');
      if (debugLogContainer) {
        debugLogContainer.style.display = 'block';
      }
    }
  }
  
  // Update summary panel
  function updateSummaryPanel(summary) {
    const summaryPanel = document.getElementById('summaryPanel');
    const summaryContent = document.getElementById('summaryContent');
    if (summaryPanel && summaryContent) {
      summaryPanel.style.display = 'block';
      summaryContent.innerHTML = summary;
    }
  }
  
  // Build summary HTML
  function buildSummaryHTML(stats) {
    let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">';
    
    // CSV & Events Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #667eea;">';
    html += '<strong style="color: #667eea;">üìã CSV & Events</strong><br>';
    html += `CSV Type: ${stats.csvType || 'Unknown'}<br>`;
    html += `Total rows parsed: ${stats.totalRows || 0}<br>`;
    html += `Future events included: ${stats.futureEvents || 0}<br>`;
    html += `Events generated: ${stats.eventsGenerated || 0}<br>`;
    html += `Repeating groups: ${stats.eventSeriesGroups || 0}<br>`;
    html += `EventSeries created: ${stats.eventSeriesCreated || 0}<br>`;
    if (stats.superEventLinks && stats.superEventLinks > 0) {
      html += `Events with superEvent: ${stats.superEventLinks}`;
    }
    html += '</div>';
    
    // Reviews & Ratings Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #48bb78;">';
    html += '<strong style="color: #48bb78;">‚≠ê Reviews & Ratings</strong><br>';
    html += `Reviews loaded: ${stats.reviewsLoaded || 0}<br>`;
    html += `Products with reviews: ${stats.productsWithReviews || 0}<br>`;
    html += `Aggregate ratings added: ${stats.aggregateRatingsAdded || 0}<br>`;
    html += `Review snippets added: ${stats.reviewSnippetsAdded || 0}`;
    html += '</div>';
    
    // Offers & Merchant Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #ed8936;">';
    html += '<strong style="color: #ed8936;">üí∞ Offers & Merchant</strong><br>';
    html += `Offers blocks: ${stats.offersBlocks || 0}<br>`;
    html += `Performer toggled: ${stats.performerToggled ? 'ON' : 'OFF'}<br>`;
    html += `Merchant fields: ${stats.merchantFields ? 'ON' : 'OFF'}<br>`;
    html += `Merchant feed items: ${stats.merchantFeedItems || 0}`;
    html += '</div>';
    
    // Mappings Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #9f7aea;">';
    html += '<strong style="color: #9f7aea;">üîó Mappings</strong><br>';
    html += `Event mappings loaded: ${stats.mappingsLoaded || 0}<br>`;
    html += `Events with mappings: ${stats.eventsWithMappings || 0}<br>`;
    html += `Events with product URLs: ${stats.eventsWithProductUrls || 0}`;
    html += '</div>';
    
    // Structure Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #38b2ac;">';
    html += '<strong style="color: #38b2ac;">üß≠ Structure</strong><br>';
    html += `Breadcrumb chains: ${stats.breadcrumbChains || 0}<br>`;
    html += `ItemList items: ${stats.itemListItems || 0}<br>`;
    html += `EventSeries groups: ${stats.eventSeriesGroups || 0}<br>`;
    if (stats.eventSeriesCreated && stats.eventSeriesCreated > 0) {
      html += `üîÅ EventSeries Created: ${stats.eventSeriesCreated}<br>`;
    }
    if (stats.linkageStats && stats.linkageStats.seriesSubEventTotal > 0) {
      html += `Total subEvent links: ${stats.linkageStats.seriesSubEventTotal}`;
    }
    html += '</div>';
    
    // Validation Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid ' + (stats.validationStatus === 'Valid' ? '#48bb78' : stats.validationStatus === 'Warnings' ? '#ed8936' : '#f56565') + ';">';
    html += '<strong style="color: ' + (stats.validationStatus === 'Valid' ? '#48bb78' : stats.validationStatus === 'Warnings' ? '#ed8936' : '#f56565') + ';">‚úÖ Validation</strong><br>';
    html += `Status: ${stats.validationStatus || 'Unknown'}<br>`;
    html += `Errors: ${stats.validationErrors || 0}<br>`;
    html += `Warnings: ${stats.validationWarnings || 0}`;
    html += '</div>';
    
    html += '</div>';
    return html;
  }

  // Normalize URL for matching (lowercase, strip trailing /)
  function normalizeUrl(url) {
    if (!url) return '';
    return url.toLowerCase().replace(/\/$/, '');
  }
  
  // Match product URLs even when one has path prefix (e.g., /photography-services-near-me/)
  function matchProductUrl(mappingUrl, reviewUrl) {
    if (!mappingUrl || !reviewUrl) return false;
    
    const normMapping = normalizeUrl(mappingUrl);
    const normReview = normalizeUrl(reviewUrl);
    
    // Exact match
    if (normMapping === normReview) return true;
    
    // Extract final slug from both URLs
    const mappingSlug = normMapping.split('/').pop() || '';
    const reviewSlug = normReview.split('/').pop() || '';
    
    // Match if final slugs are the same
    if (mappingSlug && reviewSlug && mappingSlug === reviewSlug) return true;
    
    // Also check if one URL contains the other's slug
    if (mappingSlug && normReview.includes(mappingSlug)) return true;
    if (reviewSlug && normMapping.includes(reviewSlug)) return true;
    
    return false;
  }
  
  // Find review data for a product URL (handles path prefix differences)
  // Enhanced matching: tries multiple strategies to find reviews
  function findReviewData(productUrl, reviewsDict) {
    if (!productUrl || !reviewsDict) return null;
    
    const normProductUrl = normalizeUrl(productUrl);
    
    // Try exact match first
    if (reviewsDict[normProductUrl]) {
      return reviewsDict[normProductUrl];
    }
    
    // Extract slug from product URL (handles /photo-workshops-uk/ prefix)
    const productSlug = normProductUrl.split('/').pop() || '';
    if (productSlug) {
      // Strategy 1: Try using matchProductUrl function (handles prefix differences)
      for (const reviewUrl in reviewsDict) {
        if (matchProductUrl(productUrl, reviewUrl)) {
          return reviewsDict[reviewUrl];
        }
      }
      
      // Strategy 2: Try direct slug matching on all review URLs
      for (const reviewUrl in reviewsDict) {
        const reviewSlug = normalizeUrl(reviewUrl).split('/').pop() || '';
        if (reviewSlug === productSlug) {
          return reviewsDict[reviewUrl];
        }
      }
      
      // Strategy 3: Try matching against review URLs that might have different prefixes
      // This handles cases where review URL is https://www.alanranger.com/{slug}
      // but mapping URL is https://www.alanranger.com/photo-workshops-uk/{slug}
      for (const reviewUrl in reviewsDict) {
        const normReviewUrl = normalizeUrl(reviewUrl);
        // Check if the slug appears anywhere in the review URL
        if (normReviewUrl.includes(productSlug) || normProductUrl.includes(normReviewUrl.split('/').pop() || '')) {
          return reviewsDict[reviewUrl];
        }
      }
    }
    
    return null;
  }

  // Build reviews dictionary: { product_url: { ratingValue, reviewCount } }
  function buildReviewsDict() {
    addDebugLog('üîç Building reviews dictionary...');
    if (!reviewsData) {
      addDebugLog('‚ö†Ô∏è No reviews data available');
      return {};
    }
    addDebugLog(`üìä Processing ${reviewsData.length} reviews...`);
    
    const dict = {};
    const productReviews = {};
    
    reviewsData.forEach((review, idx) => {
      // Try multiple ways to get product URL
      let productUrl = normalizeUrl(review.product_url || review.url || '');
      
      // If no product_url, try to construct from product_slug + domain_url
      if (!productUrl && review.product_slug) {
        const domain = review.domain_url || 'https://www.alanranger.com';
        // Remove trailing slash from domain and leading slash from slug
        const cleanDomain = domain.replace(/\/$/, '');
        const cleanSlug = review.product_slug.replace(/^\//, '');
        productUrl = normalizeUrl(`${cleanDomain}/${cleanSlug}`);
        
        if (idx < 3) {
          addDebugLog(`   Review ${idx + 1}: Constructed URL from slug: ${productUrl}`);
        }
      }
      
      if (!productUrl) {
        if (idx < 3) {
          addDebugLog(`   Review ${idx + 1}: No product_url or product_slug found (keys: ${Object.keys(review).join(', ')})`);
        }
        return;
      }
      
      if (!productReviews[productUrl]) {
        productReviews[productUrl] = [];
      }
      productReviews[productUrl].push(review);
    });
    
    addDebugLog(`üì¶ Found ${Object.keys(productReviews).length} unique product URLs`);
    
    // Aggregate reviews per product
    Object.keys(productReviews).forEach((productUrl, idx) => {
      const reviews = productReviews[productUrl];
      const validReviews = reviews.filter(r => {
        // Try multiple rating fields (note: CSV has ratingValue with capital V)
        const rating = parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 0);
        return rating >= 4 && rating <= 5;
      });
      
      if (idx < 3) {
        addDebugLog(`   Product ${idx + 1}: ${productUrl} - ${reviews.length} total reviews, ${validReviews.length} valid (‚â•4‚òÖ)`);
      }
      
      if (validReviews.length >= 1) {  // Changed from >= 3 to >= 1 to include all products with reviews
        const totalRating = validReviews.reduce((sum, r) => {
          return sum + parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 0);
        }, 0);
        const avgRating = totalRating / validReviews.length;
        const reviewCount = Math.min(validReviews.length, 999);
        
        dict[productUrl] = {
          ratingValue: Math.round(avgRating * 10) / 10,
          reviewCount: reviewCount
        };
      }
    });
    
    addDebugLog(`‚úÖ Reviews dictionary built: ${Object.keys(dict).length} products with valid reviews`);
    
    // Show sample product URLs that have reviews
    const sampleProducts = Object.keys(dict).slice(0, 3);
    if (sampleProducts.length > 0) {
      addDebugLog(`   Sample products with reviews:`);
      sampleProducts.forEach(url => {
        const data = dict[url];
        addDebugLog(`     ${url} ‚Üí Rating: ${data.ratingValue}, Count: ${data.reviewCount}`);
      });
    }
    
    return dict;
  }

  // Build mappings dictionary: { event_url: { product_url, sku, brand, price, availability } }
  function buildMappingsDict() {
    addDebugLog('üîç Building mappings dictionary...');
    if (!mappingsData) {
      addDebugLog('‚ö†Ô∏è No mappings data available');
      return {};
    }
    addDebugLog(`üìä Processing ${mappingsData.length} mappings...`);
    
    const dict = {};
    let successCount = 0;
    let failCount = 0;
    
    mappingsData.forEach((mapping, idx) => {
      const eventUrl = normalizeUrl(mapping.event_url || '');
      const productUrl = normalizeUrl(mapping.product_url || '');
      
      if (idx < 3) {
        addDebugLog(`   Mapping ${idx + 1}: event_url="${eventUrl}", product_url="${productUrl}"`);
      }
      
      if (eventUrl && productUrl) {
        // Extract SKU - try products data first, then fallback to URL slug (truncated to 40 chars)
        let sku = null;
        
        // Try to get SKU from products data (if loaded)
        if (window.productsData && window.productsData.length > 0) {
          const normProductUrl = normalizeUrl(productUrl);
          const productMatch = window.productsData.find(p => {
            const pUrl = normalizeUrl(p.url || '');
            return pUrl === normProductUrl || matchProductUrl(productUrl, pUrl);
          });
          
          if (productMatch) {
            // Try main_sku first
            if (productMatch.main_sku) {
              const skuVal = String(productMatch.main_sku).trim();
              if (skuVal && skuVal.toLowerCase() !== 'nan' && skuVal.toLowerCase() !== 'none' && skuVal !== '') {
                sku = skuVal.substring(0, 40); // Truncate to 40 chars for Merchant Center
              }
            }
            
            // Fallback to 'sku' column if main_sku not available
            if (!sku && productMatch.sku) {
              const skuVal = String(productMatch.sku).trim();
              if (skuVal && skuVal.toLowerCase() !== 'nan' && skuVal.toLowerCase() !== 'none' && skuVal !== '') {
                sku = skuVal.substring(0, 40);
              }
            }
          }
        }
        
        // Fallback: Extract from URL slug (always truncated to 40 chars to avoid validation errors)
        if (!sku) {
          const urlParts = productUrl.split('/');
          const productSlug = urlParts[urlParts.length - 1] || '';
          const slugSku = productSlug.toUpperCase().replace(/-/g, '-').replace(/[^A-Z0-9-]/g, '');
          sku = slugSku ? slugSku.substring(0, 40) : null; // Always truncate to 40 chars
        }
        
        dict[eventUrl] = {
          product_url: productUrl,
          sku: sku,
          brand: {
            "@type": "Brand",
            "name": "Alan Ranger Photography"
          },
          price: mapping.price_gbp || mapping.json_price || null,
          availability: mapping.availability || mapping.json_availability || "https://schema.org/InStock",
          product_title: mapping.product_title || null
        };
        successCount++;
      } else {
        failCount++;
        if (idx < 3) {
          addDebugLog(`   ‚ö†Ô∏è Mapping ${idx + 1} skipped: missing event_url or product_url`);
        }
      }
    });
    
    addDebugLog(`‚úÖ Mappings dictionary built: ${successCount} successful, ${failCount} skipped`);
    return dict;
  }

  // Parse location with intelligent region inference and geo coordinates (v4.1)
  function parseLocation(locationAddress = '', locationName = '', eventTitle = '') {
    const result = {
      streetAddress: '',
      addressLocality: '',
      addressRegion: '',
      postalCode: '',
      addressCountry: 'GB',
      geo: null,
      regionMatched: false
    };

    const regionMap = {
      "Wales": { region: "Wales", lat: 52.1307, lon: -3.7837 },
      "Scotland": { region: "Scotland", lat: 56.4907, lon: -4.2026 },
      "Cumbria": { region: "North West England", lat: 54.5772, lon: -2.7975 },
      "Yorkshire": { region: "Yorkshire and the Humber", lat: 53.9586, lon: -1.0803 },
      "Norfolk": { region: "East of England", lat: 52.6309, lon: 1.2974 },
      "Devon": { region: "South West England", lat: 50.7156, lon: -3.5309 },
      "Dorset": { region: "South West England", lat: 50.7090, lon: -2.0846 },
      "Warwickshire": { region: "West Midlands", lat: 52.2819, lon: -1.5845 },
      "Coventry": { region: "West Midlands", lat: 52.4068, lon: -1.5197 },
      "Peak District": { region: "East Midlands", lat: 53.3430, lon: -1.7770 },
      "Anglesey": { region: "Wales", lat: 53.2559, lon: -4.3424 },
      "Lake District": { region: "North West England", lat: 54.4609, lon: -3.0886 },
      "Gloucestershire": { region: "South West England", lat: 51.8642, lon: -2.2382 },
      "Northumberland": { region: "North East England", lat: 55.2088, lon: -2.0783 },
      "Somerset": { region: "South West England", lat: 51.1051, lon: -2.9262 },
      "Exmoor": { region: "South West England", lat: 51.1314, lon: -3.6897 },
      "Suffolk": { region: "East of England", lat: 52.1872, lon: 0.9708 },
      "Dartmoor": { region: "South West England", lat: 50.5610, lon: -3.9336 },
      "Snowdonia": { region: "Wales", lat: 52.8311, lon: -4.0840 },
      "Gower": { region: "Wales", lat: 51.5694, lon: -4.1289 },
      "Kerry": { region: "Ireland", lat: 52.1609, lon: -9.5250 },
      "Shropshire": { region: "West Midlands", lat: 52.7073, lon: -2.7553 },
      "Worcestershire": { region: "West Midlands", lat: 52.1920, lon: -2.2237 }
    };

    // Parse address parts
    const parts = locationAddress.split(',').map(p => p.trim()).filter(Boolean);
    for (const p of parts) {
      // Match UK postcode pattern
      if (/\b[A-Z]{1,2}\d{1,2}\s?\d[A-Z]{2}\b/i.test(p)) {
        result.postalCode = p.toUpperCase().replace(/\s+/g, ' ');
      } else if (!result.streetAddress && p) {
        result.streetAddress = p;
      } else if (!result.addressLocality && p && p !== result.streetAddress) {
        result.addressLocality = p;
      }
    }

    // Try to infer region and geo from keywords
    for (const [key, val] of Object.entries(regionMap)) {
      const searchText = `${locationAddress} ${locationName} ${eventTitle}`.toLowerCase();
      if (searchText.includes(key.toLowerCase())) {
        result.addressRegion = val.region;
        result.geo = {
          "@type": "GeoCoordinates",
          "latitude": val.lat,
          "longitude": val.lon
        };
        result.regionMatched = true;
        break;
      }
    }

    // Fallback: use location name or default
    if (!result.addressLocality && locationName) {
      result.addressLocality = locationName.split(' ')[0];
    }
    if (!result.addressRegion) {
      result.addressRegion = "West Midlands"; // Default fallback
    }

    return result;
  }

  // Enhanced address parsing - v4 Smart Enriched
  function parseAddress(locationAddressRaw, locationCityStateZip) {
    const address = { "@type": "PostalAddress" };
    
    if (!locationAddressRaw && !locationCityStateZip) {
      address.addressCountry = "GB";
      return address;
    }

    // Don't combine fields - Location_Address already has everything, Location_City_State_ZIP is just postcode
    let fullAddress = locationAddressRaw || '';
    
    // If Location_City_State_ZIP exists and doesn't duplicate postcode, append it
    if (locationCityStateZip && !fullAddress.includes(locationCityStateZip)) {
      fullAddress = fullAddress ? `${fullAddress}, ${locationCityStateZip}` : locationCityStateZip;
    }
    
    // Clean up the address string
    fullAddress = fullAddress.replace(/\s+/g, ' ').trim();
    
    // Split by comma and process
    const parts = fullAddress.split(",").map(p => p.trim()).filter(Boolean);
    
    // UK postcode pattern
    const ukPostcodePattern = /^[A-Z]{1,2}\d[A-Z\d]?\s*\d[A-Z]{2}$/i;
    
    // UK county/region patterns
    const ukRegions = ['West Midlands', 'Warwickshire', 'Worcestershire', 'Gloucestershire', 'Herefordshire', 'Shropshire', 'Staffordshire', 'Derbyshire', 'Nottinghamshire', 'Leicestershire', 'Northamptonshire', 'Oxfordshire', 'Buckinghamshire', 'Berkshire', 'Hampshire', 'Surrey', 'Kent', 'Essex', 'Suffolk', 'Norfolk', 'Cambridgeshire', 'Lincolnshire', 'Yorkshire', 'Lancashire', 'Cheshire', 'Cumbria', 'Northumberland', 'Durham', 'North Yorkshire', 'South Yorkshire', 'West Yorkshire', 'East Yorkshire'];
    
    // Process parts from end to beginning (postcode, region, city, street)
    for (let i = parts.length - 1; i >= 0; i--) {
      const part = parts[i];
      const partUpper = part.toUpperCase();

      // Country (skip "England" - it's not a region)
      if (!address.addressCountry && /^(United Kingdom|UK|Scotland|Wales|Northern Ireland)$/i.test(part)) {
        address.addressCountry = "GB";
      }
      // Postal code
      else if (!address.postalCode && ukPostcodePattern.test(part)) {
        address.postalCode = part.toUpperCase().replace(/\s+/g, ' ');
      }
      // Region/County (check against known UK regions, skip "England")
      else if (!address.addressRegion && !/^(United Kingdom|UK|England)$/i.test(part)) {
        const matchedRegion = ukRegions.find(r => partUpper.includes(r.toUpperCase()) || partUpper === r.toUpperCase());
        if (matchedRegion) {
          address.addressRegion = matchedRegion;
        }
      }
    }
    
    // Now process from beginning to end for street and locality
    // UK addresses typically: street, city, county/region, postcode, country
    const streetParts = [];
    let localityFound = false;
    
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const partUpper = part.toUpperCase();
      
      // Skip if already processed (postcode, country, region)
      if (ukPostcodePattern.test(part)) continue;
      if (/^(United Kingdom|UK|England|Scotland|Wales|Northern Ireland)$/i.test(part)) continue;
      if (address.addressRegion && (partUpper.includes(address.addressRegion.toUpperCase()) || partUpper === address.addressRegion.toUpperCase())) continue;
      
      // Check if it's a known UK region (should have been caught in first loop, but double-check)
      const isRegion = ukRegions.some(r => partUpper.includes(r.toUpperCase()));
      if (isRegion) continue;
      
      // First part(s) are street address, then comes locality (city)
      if (!localityFound && part.length > 2) {
        // If we already have street parts, this is likely the locality
        if (streetParts.length > 0) {
          address.addressLocality = part;
          localityFound = true;
        } else {
          // First part is street address
          streetParts.push(part);
        }
      } else if (!localityFound) {
        // Still collecting street address parts
        streetParts.push(part);
      }
    }
    
    // Assign street address (combine all street parts)
    if (streetParts.length > 0) {
      address.streetAddress = streetParts.join(', ');
    }
    
    // Default country if not found
    if (!address.addressCountry) {
      address.addressCountry = "GB";
    }
    
    // Only return fields that have values (omit empty fields)
    const cleanAddress = {};
    if (address["@type"]) cleanAddress["@type"] = address["@type"];
    if (address.streetAddress) cleanAddress.streetAddress = address.streetAddress;
    if (address.addressLocality) cleanAddress.addressLocality = address.addressLocality;
    if (address.addressRegion) cleanAddress.addressRegion = address.addressRegion;
    if (address.postalCode) cleanAddress.postalCode = address.postalCode;
    if (address.addressCountry) cleanAddress.addressCountry = address.addressCountry;
    
    return cleanAddress;
  }

  // Combine date and time into ISO 8601 format
  function combineDateTime(dateStr, timeStr) {
    if (!dateStr) return null;
    if (!timeStr) return dateStr; // Return date only if no time
    
    // Normalize time format (handle HH:MM:SS or HH:MM)
    const timeMatch = timeStr.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?/);
    if (!timeMatch) return dateStr;
    
    const hours = timeMatch[1].padStart(2, '0');
    const minutes = timeMatch[2].padStart(2, '0');
    const seconds = timeMatch[3] ? timeMatch[3].padStart(2, '0') : '00';
    
    return `${dateStr}T${hours}:${minutes}:${seconds}`;
  }

  // Compute duration in ISO 8601 format (PT120M default)
  function computeDuration(startDate, endDate, startTime, endTime) {
    if (!startDate || !endDate) return "PT120M";
    
    try {
      const start = combineDateTime(startDate, startTime);
      const end = combineDateTime(endDate, endTime);
      
      if (!start || !end) return "PT120M";
      
      const startDateObj = new Date(start);
      const endDateObj = new Date(end);
      const diffMs = endDateObj - startDateObj;
      
      if (diffMs <= 0) return "PT120M";
      
      const diffMins = Math.round(diffMs / (1000 * 60));
      return `PT${diffMins}M`;
    } catch (e) {
      return "PT120M";
    }
  }

  // Detect if location is virtual (Zoom/Online)
  function isVirtualLocation(locationName, locationAddress) {
    const virtualKeywords = ['zoom', 'online', 'virtual', 'webinar'];
    const locationStr = (locationName || '').toLowerCase() + ' ' + (locationAddress || '').toLowerCase();
    return virtualKeywords.some(keyword => locationStr.includes(keyword));
  }

  // Detect audience type from keywords - returns simple text string for Event schema
  function detectAudience(eventTitle, description, tags) {
    const text = ((eventTitle || '') + ' ' + (description || '') + ' ' + (tags || '')).toLowerCase();
    
    if (text.includes('beginner') || text.includes('beginners')) {
      return "Beginner photographers";
    }
    if (text.includes('advanced') || text.includes('professional')) {
      return "Advanced photographers";
    }
    if (text.includes('intermediate')) {
      return "Intermediate photographers";
    }
    return null;
  }

  // Extract keywords from Tags
  function extractKeywords(tags) {
    if (!tags) return [];
    return tags.split(/[,;|]/).map(t => t.trim()).filter(Boolean);
  }

  // Trim description if too long
  function trimDescription(description, maxLength = 5000) {
    if (!description) return '';
    if (description.length <= maxLength) return description;
    return description.substring(0, maxLength - 3) + '...';
  }

  // Validate Event schema structure
  function validateEventSchema(schema) {
    const errors = [];
    const warnings = [];
    
    if (!schema || !schema['@graph']) {
      return { isValid: false, message: 'Invalid schema structure: missing @graph', errors: ['Missing @graph'] };
    }
    
    const graph = schema['@graph'] || [];
    // Check for Product+Event hybrid schemas (array) or pure Event schemas
    const events = graph.filter(item => {
      const itemType = item['@type'];
      return (Array.isArray(itemType) && itemType.includes('Event')) || itemType === 'Event';
    });
    
    if (events.length === 0) {
      return { isValid: false, message: 'No Event schemas found', errors: ['No events in @graph'] };
    }
    
    events.forEach((event, idx) => {
      // Required fields for Event schema
      const required = ['name', 'startDate', 'eventStatus', 'eventAttendanceMode'];
      required.forEach(field => {
        if (!event[field]) {
          errors.push(`Event ${idx + 1}: Missing required field "${field}"`);
        }
      });
      
      // Validate dates
      if (event.startDate && !/^\d{4}-\d{2}-\d{2}/.test(event.startDate)) {
        warnings.push(`Event ${idx + 1}: startDate format may be invalid`);
      }
      
      // Validate offers
      if (event.offers) {
        if (!event.offers.price || !event.offers.priceCurrency) {
          warnings.push(`Event ${idx + 1}: Offers missing price or priceCurrency`);
        }
      }
      
      // Validate location
      if (!event.location) {
        warnings.push(`Event ${idx + 1}: Missing location`);
      }
    });
    
    const isValid = errors.length === 0;
    const message = isValid 
      ? `Schema.org compliant (${events.length} event${events.length !== 1 ? 's' : ''})`
      : `${errors.length} error${errors.length !== 1 ? 's' : ''} found`;
    
    return { isValid, message, errors, warnings };
  }

  async function generateEventSchema() {
    try {
      // Initialize debug log and statistics
      window.debugLog = [];
      const stats = {
        csvType: 'Unknown',
        totalRows: 0,
        futureEvents: 0,
        eventsGenerated: 0,
        repeatingGroups: 0,
        reviewsLoaded: 0,
        productsWithReviews: 0,
        aggregateRatingsAdded: 0,
        reviewSnippetsAdded: 0,
        offersBlocks: 0,
        performerToggled: false,
        merchantFields: false,
        merchantFeedItems: 0,
        mappingsLoaded: 0,
        eventsWithMappings: 0,
        eventsWithProductUrls: 0,
        breadcrumbChains: 0,
        itemListItems: 0,
        eventSeriesGroups: 0,
        validationStatus: 'Unknown',
        validationErrors: 0,
        validationWarnings: 0
      };
      
      addDebugLog('üöÄ Starting event schema generation...');
      addDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      
      // Check if events are loaded
      if (!events || events.length === 0) {
        addDebugLog('‚ùå No events loaded');
        alert('Please upload a CSV file first.');
        return;
      }
      
      stats.totalRows = events.length;
      addDebugLog(`üìã CSV & Events Section:`);
      addDebugLog(`   ‚úÖ Total rows parsed: ${stats.totalRows}`);
      
      // Detect CSV type
      const eventFileInput = document.getElementById('eventCsvFile');
      if (eventFileInput && eventFileInput.files && eventFileInput.files[0]) {
        const csvType = detectCsvType(eventFileInput.files[0].name, []);
        stats.csvType = csvType;
        addDebugLog(`   ‚úÖ CSV Type detected: ${csvType}`);
      }
      
      // Load review data if available
      await loadReviewData();
      
      // Get toggle options
      const includeReviews = document.getElementById('includeReviews')?.checked !== false;
      const includePerformer = document.getElementById('includePerformer')?.checked !== false;
      const groupRepeatingEvents = document.getElementById('groupRepeatingEvents')?.checked === true;
      const includeMerchantFields = document.getElementById('includeMerchantFields')?.checked === true;
      const enrichLocations = document.getElementById('toggleLocationEnrichment')?.checked !== false;
      const includeAvailabilityStarts = document.getElementById('toggleAvailabilityStarts')?.checked === true;
      
      stats.performerToggled = includePerformer;
      stats.merchantFields = includeMerchantFields;
      stats.enrichLocations = enrichLocations;
      
      addDebugLog(`‚öôÔ∏è Toggle states: Reviews=${includeReviews}, Performer=${includePerformer}, GroupRepeating=${groupRepeatingEvents}, MerchantFields=${includeMerchantFields}, EnrichLocations=${enrichLocations}, AvailabilityStarts=${includeAvailabilityStarts}`);
      
      const selectedCategory = document.getElementById('eventCategoryFilter').value;
      const today = new Date().toISOString().split('T')[0];
      const filtered = events.filter(e =>
        (selectedCategory === "__ALL__" || (e['Category'] || e['category'] || e['CATEGORY'] || '').split(',')[0].trim() === selectedCategory) &&
        e['Start_Date'] >= today &&
        e['Workflow_State'] === 'Published'
      );
      
      stats.futureEvents = filtered.length;
      addDebugLog(`   ‚úÖ Future events included: ${stats.futureEvents} (filtered from ${stats.totalRows} total)`);
      
      if (filtered.length === 0) {
        addDebugLog('‚ùå No events match criteria');
        alert('No events found matching the selected category and date criteria.');
        return;
      }

    // Build dictionaries for review enrichment
    addDebugLog('\n‚≠ê Reviews & Ratings Section:');
    const reviewsDict = buildReviewsDict();
    const mappingsDict = buildMappingsDict();
    
    stats.reviewsLoaded = reviewsData ? reviewsData.length : 0;
    stats.productsWithReviews = Object.keys(reviewsDict).length;
    stats.mappingsLoaded = mappingsData ? mappingsData.length : 0;
    
    addDebugLog(`   ‚úÖ Reviews loaded: ${stats.reviewsLoaded}`);
    addDebugLog(`   ‚úÖ Products with reviews: ${stats.productsWithReviews}`);
    addDebugLog(`   ‚úÖ Event mappings loaded: ${stats.mappingsLoaded}`);
    
    // Show sample mappings
    const sampleMappings = Object.keys(mappingsDict).slice(0, 3);
    if (sampleMappings.length > 0) {
      addDebugLog(`   Sample mappings:`);
      sampleMappings.forEach(eventUrl => {
        const mapping = mappingsDict[eventUrl];
        addDebugLog(`     ${eventUrl} ‚Üí ${mapping.product_url}`);
      });
    }

    const itemList = {
      "@type": "ItemList",
      "name": selectedCategory === "__ALL__" ? "Events" : selectedCategory + " Events",
      "itemListElement": filtered.map((event, i) => ({
        "@type": "ListItem",
        "position": i + 1,
        "url": event['Event_URL']
      }))
    };

    // Enhanced organizer block with full address and sameAs
    const organizerAddress = parseAddress("45 Hathaway Road", "Coventry, West Midlands, CV4 9HW");
    const organizerBlock = {
      "@type": "Organization",
      "name": "Alan Ranger Photography",
      "url": "https://www.alanranger.com",
      "logo": "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w",
      "address": organizerAddress,
      "sameAs": [
        "https://www.instagram.com/alanrangerphoto",
        "https://www.facebook.com/alanrangerphotography",
        "https://www.linkedin.com/in/alanranger"
      ]
    };

    // Track series membership for backlinking (v4.3)
    const seriesMembership = new Map(); // eventId -> seriesId
    
    const eventSchemas = filtered.map((event, index) => {
      const eventUrl = normalizeUrl(event['Event_URL'] || '');
      const mappingData = mappingsDict[eventUrl];
      const productUrl = mappingData ? mappingData.product_url : null;
      const reviewData = productUrl ? findReviewData(productUrl, reviewsDict) : null;
      
      // Enhanced debugging for review matching (for events like Burnham on Sea)
      // Check first 10 events without reviews, or specific problematic event titles
      const eventTitle = (event['Event_Title'] || '').toLowerCase();
      const isProblematicEvent = eventTitle.includes('burnham') || 
                                 eventTitle.includes('fairy glen') || 
                                 eventTitle.includes('exmoor') || 
                                 eventTitle.includes('dartmoor') || 
                                 eventTitle.includes('ireland') || 
                                 eventTitle.includes('peak district');
      
      if ((index < 10 || isProblematicEvent) && includeReviews && productUrl && !reviewData) {
        addDebugLog(`\n   üîç Review Matching Debug for "${event['Event_Title']}":`);
        addDebugLog(`      Product URL: ${productUrl}`);
        addDebugLog(`      Reviews dict size: ${Object.keys(reviewsDict).length}`);
        const productSlug = normalizeUrl(productUrl).split('/').pop() || '';
        addDebugLog(`      Product slug: ${productSlug}`);
        
        // Find potential matches
        const matchingUrls = Object.keys(reviewsDict).filter(url => {
          const reviewSlug = normalizeUrl(url).split('/').pop() || '';
          return reviewSlug === productSlug || matchProductUrl(productUrl, url) || url.includes(productSlug);
        });
        
        if (matchingUrls.length > 0) {
          addDebugLog(`      ‚ö†Ô∏è Found ${matchingUrls.length} potential matches but findReviewData returned null`);
          addDebugLog(`      Potential matches: ${matchingUrls.join(', ')}`);
        } else {
          addDebugLog(`      ‚ö†Ô∏è No matching URLs found in reviews dict`);
          // Show sample review URLs for comparison
          const sampleReviewUrls = Object.keys(reviewsDict).slice(0, 5);
          if (sampleReviewUrls.length > 0) {
            addDebugLog(`      Sample review URLs in dict: ${sampleReviewUrls.join(', ')}`);
          }
        }
      }
      
      // Assign stable @id to Event (v4.3)
      const eventId = eventIdFromUrl(eventUrl);
      
      // Check if this event belongs to a series (v4.3) - use same patterns as detectEventSeries
      const title = (event['Event_Title'] || "").toLowerCase();
      const keywordPatterns = [
        { pattern: /bluebell.*photography.*workshop/i, key: "bluebell photography workshop" },
        { pattern: /batsford.*arboretum.*autumn.*photography.*workshop/i, key: "batsford arboretum autumn photography workshop" },
        { pattern: /camera.*course.*for.*beginners|camera.*courses.*for.*beginners/i, key: "camera course for beginners" },
        { pattern: /lightroom.*photo.*editing|lightroom.*classic.*photo.*editing/i, key: "lightroom photo editing" }
      ];
      
      for (const { pattern, key } of keywordPatterns) {
        if (pattern.test(title)) {
          const seriesId = seriesIdFromName(key);
          seriesMembership.set(eventId, seriesId);
          break; // Only match one pattern per event
        }
      }
      
      // Track statistics
      if (mappingData) stats.eventsWithMappings++;
      if (productUrl) stats.eventsWithProductUrls++;
      
      // Debug logging for first 3 events
      if (index < 3) {
        addDebugLog(`\nüìÖ Event ${index + 1}: ${event['Event_Title']}`);
        addDebugLog(`   Event URL: ${eventUrl}`);
        addDebugLog(`   Mapping found: ${mappingData ? 'YES' : 'NO'}`);
        if (mappingData) {
          addDebugLog(`   Product URL: ${productUrl}`);
          addDebugLog(`   Mapping Price: ${mappingData.price || 'none'}`);
          addDebugLog(`   CSV Price: ${event['Price'] || 'none'}`);
          addDebugLog(`   Mapping Availability: ${mappingData.availability || 'none'}`);
        }
        addDebugLog(`   Review data found: ${reviewData ? 'YES' : 'NO'}`);
        if (reviewData) {
          addDebugLog(`   Rating: ${reviewData.ratingValue}, Count: ${reviewData.reviewCount}`);
        } else if (productUrl) {
          addDebugLog(`   ‚ö†Ô∏è Product URL exists but no reviews found in reviews dict`);
          // Try to find matching review URL
          const productSlug = normalizeUrl(productUrl).split('/').pop();
          const matchingReviewUrls = Object.keys(reviewsDict).filter(url => {
            const reviewSlug = normalizeUrl(url).split('/').pop();
            return reviewSlug === productSlug;
          });
          if (matchingReviewUrls.length > 0) {
            addDebugLog(`   üí° Found ${matchingReviewUrls.length} review URL(s) with matching slug: ${matchingReviewUrls[0]}`);
          }
        } else {
          addDebugLog(`   ‚ö†Ô∏è No product URL (no mapping found)`);
        }
      }
      
      // üß© Event Core Fields Verification
      const startDate = combineDateTime(event['Start_Date'], event['Start_Time']);
      const endDate = combineDateTime(event['End_Date'], event['End_Time']);
      const duration = computeDuration(event['Start_Date'], event['End_Date'], event['Start_Time'], event['End_Time']);
      
      if (index < 3) {
        addDebugLog(`\n   üß© Event Core Fields:`);
        addDebugLog(`      ‚úÖ @context: https://schema.org`);
        addDebugLog(`      ‚úÖ @type: Event`);
        addDebugLog(`      ‚úÖ name: ${event['Event_Title'] ? 'Present' : 'MISSING'}`);
        addDebugLog(`      ‚úÖ startDate: ${startDate ? startDate.substring(0, 16) : 'MISSING'}`);
        addDebugLog(`      ‚úÖ endDate: ${endDate ? endDate.substring(0, 16) : 'MISSING'}`);
        addDebugLog(`      ‚úÖ duration: ${duration || 'MISSING'}`);
        addDebugLog(`      ‚úÖ eventStatus: EventScheduled`);
        addDebugLog(`      ‚úÖ identifier: ${eventUrl.split('/').pop() || 'MISSING'}`);
      }
      
      const address = enrichLocations 
        ? parseLocation(event['Location_Address'], event['Location_Business_Name'], event['Event_Title'])
        : parseAddress(event['Location_Address'], event['Location_City_State_ZIP']);
      const isVirtual = isVirtualLocation(event['Location_Business_Name'], event['Location_Address']);
      
      // Track address field statistics
      if (!isVirtual && address) {
        if (!stats.locationStats) {
          stats.locationStats = {
            streetAddress: { valid: 0, total: 0 },
            addressLocality: { valid: 0, total: 0 },
            addressRegion: { valid: 0, total: 0 },
            postalCode: { valid: 0, total: 0 },
            geoCoordinates: { valid: 0, total: 0 },
            fallbackApplied: 0,
            regionMapMatches: 0
          };
        }
        stats.locationStats.total++;
        if (address.streetAddress) {
          stats.locationStats.streetAddress.valid++;
          stats.addressFieldsWithStreetAddress = (stats.addressFieldsWithStreetAddress || 0) + 1;
        }
        if (address.addressLocality) {
          stats.locationStats.addressLocality.valid++;
          stats.addressFieldsWithLocality = (stats.addressFieldsWithLocality || 0) + 1;
        }
        if (address.addressRegion) {
          stats.locationStats.addressRegion.valid++;
          stats.addressFieldsWithRegion = (stats.addressFieldsWithRegion || 0) + 1;
          if (enrichLocations && address.regionMatched) {
            stats.locationStats.regionMapMatches++;
          }
        }
        if (address.postalCode) {
          stats.locationStats.postalCode.valid++;
          stats.addressFieldsWithPostalCode = (stats.addressFieldsWithPostalCode || 0) + 1;
        }
        if (enrichLocations && address.geo) {
          stats.locationStats.geoCoordinates.valid++;
        }
        if (!address.addressRegion || !address.addressLocality) {
          stats.locationStats.fallbackApplied++;
        }
      }
      
      // üèõ Location / Address Fields Verification
      if (index < 3) {
        addDebugLog(`\n   üèõ Location / Address Fields:`);
        addDebugLog(`      ‚úÖ location.@type: ${isVirtual ? 'VirtualLocation' : 'Place'}`);
        addDebugLog(`      ‚úÖ location.name: ${event['Location_Business_Name'] || 'MISSING'}`);
        if (!isVirtual && address) {
          addDebugLog(`      ‚úÖ address.streetAddress: ${address.streetAddress || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.addressLocality: ${address.addressLocality || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.addressRegion: ${address.addressRegion || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.postalCode: ${address.postalCode || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.addressCountry: ${address.addressCountry || 'MISSING'}`);
          // Debug: show what CSV fields contain (only for first 3 events)
          addDebugLog(`      üìã CSV Location_Address: "${event['Location_Address'] || 'empty'}"`);
          addDebugLog(`      üìã CSV Location_City_State_ZIP: "${event['Location_City_State_ZIP'] || 'empty'}"`);
        } else if (isVirtual) {
          addDebugLog(`      ‚úÖ OnlineEventAttendanceMode override applied`);
        }
      }
      
      // üë• Organizer / Provider / Performer Verification
      if (index < 3) {
        addDebugLog(`\n   üë• Organizer / Provider / Performer:`);
        addDebugLog(`      ‚úÖ organizer.@type: Organization`);
        addDebugLog(`      ‚úÖ organizer.name: Alan Ranger Photography`);
        addDebugLog(`      ‚úÖ organizer.logo: ${organizerBlock.logo ? 'Present' : 'MISSING'}`);
        addDebugLog(`      ‚úÖ organizer.sameAs: ${organizerBlock.sameAs ? organizerBlock.sameAs.length + ' links' : 'MISSING'}`);
        addDebugLog(`      ‚úÖ performer: ${includePerformer ? 'ON (will be added)' : 'OFF'}`);
        const category = (event['Category'] || event['category'] || '').split(',')[0].trim();
        const titleLower = (event['Event_Title'] || '').toLowerCase();
        // Note: provider removed - not valid for Event schema, organizer already provides this info
      }
      
      const audience = detectAudience(event['Event_Title'], event['Excerpt'], event['Tags']);
      const keywords = extractKeywords(event['Tags']);
      const description = trimDescription(event['Excerpt'] || event['Description'], 5000);
      const validFrom = event['Published_Date'] || event['Start_Date'];
      
      // Extract identifier (slug from URL)
      const urlParts = eventUrl.split('/');
      const identifier = urlParts[urlParts.length - 1] || '';
      
      // Build enhanced keywords array (combine tags, category, location, and topic words)
      const category = (event['Category'] || event['category'] || '').split(',')[0].trim();
      const locationName = event['Location_Business_Name'] || '';
      const titleLower = (event['Event_Title'] || '').toLowerCase();
      const topicKeywords = [];
      if (titleLower.includes('photography')) topicKeywords.push('photography course', 'photography workshop');
      if (titleLower.includes('lightroom')) topicKeywords.push('Lightroom', 'photo editing');
      if (titleLower.includes('beginner')) topicKeywords.push('beginner photography', 'photography for beginners');
      if (titleLower.includes('landscape')) topicKeywords.push('landscape photography');
      if (titleLower.includes('portrait')) topicKeywords.push('portrait photography');
      if (titleLower.includes('macro')) topicKeywords.push('macro photography');
      const allKeywords = [...keywords, ...topicKeywords, category, locationName].filter(Boolean);
      
      // Generate "about" field (short phrase summarizing topic)
      let about = '';
      if (titleLower.includes('beginner')) about = 'Photography fundamentals and camera basics';
      else if (titleLower.includes('lightroom')) about = 'Photo editing and post-processing';
      else if (titleLower.includes('landscape')) about = 'Landscape photography techniques';
      else if (titleLower.includes('portrait')) about = 'Portrait photography skills';
      else if (titleLower.includes('macro')) about = 'Macro and close-up photography';
      else about = 'Photography education and training';
      
      // Build location (virtual or physical)
      let location;
      if (isVirtual) {
        location = {
          "@type": "VirtualLocation",
          "url": event['Event_URL'] || "https://www.alanranger.com"
        };
      } else {
        // Build PostalAddress object
        const postalAddress = {
          "@type": "PostalAddress",
          "streetAddress": address.streetAddress || undefined,
          "addressLocality": address.addressLocality || undefined,
          "addressRegion": address.addressRegion || undefined,
          "postalCode": address.postalCode || undefined,
          "addressCountry": address.addressCountry || "GB"
        };
        // Remove undefined fields
        Object.keys(postalAddress).forEach(key => {
          if (postalAddress[key] === undefined) delete postalAddress[key];
        });
        
        location = {
          "@type": "Place",
          "name": event['Location_Business_Name'] || "Alan Ranger Photography",
          "address": postalAddress
        };
        
        // Add geo coordinates if available (v4.1)
        if (enrichLocations && address.geo) {
          location.geo = address.geo;
        }
      }

      // Phase 3: Extract product data from mappings
      const useMappingPrice = mappingData && mappingData.price;
      const useMappingAvailability = mappingData && mappingData.availability;
      const eventPrice = useMappingPrice ? parseFloat(mappingData.price) : parseFloat(event['Price'] || 0);
      
      // Normalize availability to Schema.org URL format
      let normalizedAvailability = "https://schema.org/InStock"; // Default
      if (useMappingAvailability && mappingData.availability) {
        const avail = String(mappingData.availability).trim();
        if (avail === 'https://schema.org/InStock' || avail === 'InStock' || avail.toLowerCase() === 'in stock') {
          normalizedAvailability = "https://schema.org/InStock";
        } else if (avail === 'https://schema.org/OutOfStock' || avail === 'OutOfStock' || avail.toLowerCase() === 'out of stock') {
          normalizedAvailability = "https://schema.org/OutOfStock";
        } else if (avail === 'https://schema.org/PreOrder' || avail === 'PreOrder' || avail.toLowerCase() === 'preorder') {
          normalizedAvailability = "https://schema.org/PreOrder";
        } else {
          // Default to InStock if unrecognized format
          normalizedAvailability = "https://schema.org/InStock";
          console.warn(`‚ö†Ô∏è Unrecognized availability format "${avail}" for ${event['Event_Title']}, defaulting to InStock`);
        }
      }
      
      // Build event schema - v4 Smart Enriched
      // Use Product+Event hybrid schema (workshops/courses are both products AND events)
      const eventSchema = {
        "@context": "https://schema.org",
        "@type": ["Product", "Event"],
        "@id": eventId, // v4.3: Use stable ID from helper
        "identifier": identifier,
        "name": event['Event_Title'],
        "description": description,
        "url": eventUrl,
        "image": event['Event_Image'],
        "startDate": startDate,
        "endDate": endDate,
        "duration": duration,
        "eventAttendanceMode": isVirtual 
          ? "https://schema.org/OnlineEventAttendanceMode" 
          : "https://schema.org/OfflineEventAttendanceMode",
        "eventStatus": "https://schema.org/EventScheduled",
        "isAccessibleForFree": false,
        "inLanguage": "en-GB",
        "organizer": organizerBlock,
        "location": location,
        "about": about,
        "keywords": allKeywords.join(', '),
        "sameAs": [eventUrl, productUrl].filter(Boolean),
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": eventUrl
        }
      };
      
      // Add performer if enabled (v4.1: enhanced with LinkedIn/YouTube)
      if (includePerformer) {
        eventSchema.performer = {
          "@type": "Person",
          "name": "Alan Ranger",
          "sameAs": [
            "https://www.linkedin.com/in/alanranger",
            "https://www.youtube.com/@alanrangerphotography",
            "https://www.alanranger.com/about-alan-ranger"
          ]
        };
      }
      
      // Note: provider is not valid for Event schema - use organizer instead
      // Removed provider property as it's not recognized by Schema.org for Event type
      // organizer already provides the same information and is valid for Event schema
      
      // Build offers with enhanced merchant fields
      // Always add offers (Google requirement) - if price = 0, log error as data issue
      if (eventPrice <= 0) {
        addDebugLog(`\n   ‚ö†Ô∏è DATA ERROR: Event "${event['Event_Title']}" has price = ${eventPrice}`);
        addDebugLog(`      This indicates a data issue - all events should have prices.`);
        addDebugLog(`      Check mappings CSV for missing price_gbp or event CSV for Price column.`);
        stats.validationErrors++;
      }
      
      stats.offersBlocks++;
      
      // Calculate priceValidUntil (+12 months from today)
      const today = new Date();
      const priceValidUntilDate = new Date(today);
      priceValidUntilDate.setMonth(priceValidUntilDate.getMonth() + 12);
      const priceValidUntil = priceValidUntilDate.toISOString().split('T')[0]; // YYYY-MM-DD format
      
      eventSchema.offers = {
        "@type": "Offer",
        "price": eventPrice > 0 ? eventPrice.toFixed(2) : "0.00",
        "priceCurrency": event['Currency'] || "GBP",
        "availability": normalizedAvailability,
        "url": eventUrl,
        "validFrom": validFrom,
        "priceValidUntil": priceValidUntil,
        "seller": {
          "@type": "Organization",
          "name": "Alan Ranger Photography",
          "url": "https://www.alanranger.com"
        }
      };
      
      // Add shippingDetails (required for Product+Event hybrid)
      eventSchema.offers.shippingDetails = {
        "@type": "OfferShippingDetails",
        "doesNotShip": "http://schema.org/True",
        "shippingDestination": {
          "@type": "DefinedRegion",
          "addressCountry": "GB"
        }
      };
      
      // Add SKU to offers if available (required for Product+Event hybrid)
      if (includeMerchantFields && mappingData && mappingData.sku) {
        eventSchema.offers.sku = mappingData.sku.substring(0, 40); // Max 40 chars for Merchant Center
      }
      
      // Add availabilityStarts and itemCondition (v4.1)
      if (includeAvailabilityStarts && event['Start_Date']) {
        try {
          eventSchema.offers.availabilityStarts = new Date(event['Start_Date']).toISOString();
        } catch (e) {
          console.warn('Failed to parse Start_Date for availabilityStarts:', e);
        }
      }
      if (includeMerchantFields) {
        eventSchema.offers.itemCondition = "https://schema.org/NewCondition";
      }
      
      // Set isAccessibleForFree for free events (data error case)
      if (eventPrice <= 0) {
        eventSchema.isAccessibleForFree = true;
      }
      
      // Add merchant return policy if merchant fields enabled (full object structure)
      if (includeMerchantFields) {
        const returnPolicy = {
          "@type": "MerchantReturnPolicy",
          "returnPolicyCategory": "http://schema.org/MerchantReturnFiniteReturnWindow",
          "merchantReturnDays": 28,
          "refundType": "http://schema.org/FullRefund",
          "applicableCountry": "GB",
          "returnMethod": "http://schema.org/ReturnByMail",
          "returnFees": "https://schema.org/ReturnShippingFees"
        };
        
        // Add returnShippingFeesAmount when returnFees is ReturnShippingFees (required by Schema.org)
        if (returnPolicy.returnFees === "https://schema.org/ReturnShippingFees") {
          returnPolicy.returnShippingFeesAmount = {
            "@type": "MonetaryAmount",
            "value": "50.00",
            "currency": "GBP"
          };
        }
        
        eventSchema.offers.hasMerchantReturnPolicy = returnPolicy;
      }
      
      if (index < 3) {
        addDebugLog(`\n   üí∞ Offers & Merchant Fields:`);
        addDebugLog(`      ‚úÖ offers.@type: Offer`);
        addDebugLog(`      ‚úÖ offers.price: ${eventSchema.offers.price} ${eventSchema.offers.priceCurrency}`);
        addDebugLog(`      ‚úÖ offers.availability: ${normalizedAvailability}`);
        addDebugLog(`      ‚úÖ offers.priceValidUntil: ${priceValidUntil}`);
        addDebugLog(`      ‚úÖ offers.shippingDetails: Present`);
        if (eventSchema.offers.sku) {
          addDebugLog(`      ‚úÖ offers.sku: ${eventSchema.offers.sku}`);
        }
        addDebugLog(`      ‚úÖ offers.seller.name: Alan Ranger Photography`);
        if (includeMerchantFields) {
          addDebugLog(`      ‚úÖ offers.hasMerchantReturnPolicy: Present (full object)`);
        }
      }
      
      // Phase 3: Add SKU and brand from mappings (if merchant fields enabled)
      if (includeMerchantFields) {
        if (mappingData && mappingData.sku) {
          eventSchema.sku = mappingData.sku;
        }
        if (mappingData && mappingData.brand) {
          eventSchema.brand = mappingData.brand;
        }
      }

      // Phase 4: Review Enrichment (if enabled)
      // Always add reviews if available (user confirmed: "there should be reviews for everything")
      if (includeReviews && reviewData && reviewData.reviewCount >= 1) {
        stats.aggregateRatingsAdded++;
        eventSchema.aggregateRating = {
          "@type": "AggregateRating",
          "ratingValue": reviewData.ratingValue.toString(),
          "reviewCount": reviewData.reviewCount.toString(),
          "bestRating": "5",
          "worstRating": "1"
        };
        
        if (index < 3) {
          addDebugLog(`\n   ‚≠ê Reviews & Ratings:`);
          addDebugLog(`      ‚úÖ aggregateRating.@type: AggregateRating`);
          addDebugLog(`      ‚úÖ aggregateRating.ratingValue: ${reviewData.ratingValue}`);
          addDebugLog(`      ‚úÖ aggregateRating.reviewCount: ${reviewData.reviewCount}`);
        }
        
        // Add individual review snippets (top 5 reviews, trimmed to 300 chars)
        // Enhanced matching: use same logic as findReviewData for consistency
        if (reviewsData && productUrl) {
          const productSlug = normalizeUrl(productUrl).split('/').pop() || '';
          const productReviews = reviewsData.filter(r => {
            // Try multiple ways to match product URL (same logic as buildReviewsDict and findReviewData)
            let rUrl = normalizeUrl(r.product_url || r.url || '');
            if (!rUrl && r.product_slug) {
              const domain = r.domain_url || 'https://www.alanranger.com';
              const cleanDomain = domain.replace(/\/$/, '');
              const cleanSlug = r.product_slug.replace(/^\//, '');
              rUrl = normalizeUrl(`${cleanDomain}/${cleanSlug}`);
            }
            
            // Match by exact URL
            if (rUrl === normalizeUrl(productUrl)) return true;
            
            // Match by slug
            const rSlug = rUrl.split('/').pop() || '';
            if (rSlug && productSlug && rSlug === productSlug) return true;
            
            // Try matchProductUrl function for fuzzy matching
            if (matchProductUrl(productUrl, rUrl)) return true;
            
            return false;
          }).filter(r => {
            const rating = parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 0);
            return rating >= 4 && rating <= 5;
          }).sort((a, b) => {
            const dateA = a.date || a.review_created_utc || '';
            const dateB = b.date || b.review_created_utc || '';
            return dateB.localeCompare(dateA);
          }).slice(0, 5);
          
          if (productReviews.length > 0) {
            eventSchema.review = productReviews.map(r => {
              let reviewText = r.reviewBody || r.reviewbody || r.review_content || r.review || '';
              // Trim to 300 chars for v4
              if (reviewText.length > 300) {
                reviewText = reviewText.substring(0, 297) + '...';
              }
              const reviewerName = r.author || r.reviewer || r.review_username || 'Anonymous';
              const rating = parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 5);
              const reviewDate = r.date || r.review_created_utc || '';
              
              return {
                "@type": "Review",
                "author": {
                  "@type": "Person",
                  "name": reviewerName
                },
                "reviewRating": {
                  "@type": "Rating",
                  "ratingValue": rating.toString(),
                  "bestRating": "5",
                  "worstRating": "1"
                },
                "reviewBody": reviewText,
                "datePublished": reviewDate
              };
            }).filter(r => r.reviewBody && r.reviewBody.trim().length > 0);
            
            stats.reviewSnippetsAdded += eventSchema.review.length;
            if (index < 3) {
              addDebugLog(`      ‚úÖ review array: ${eventSchema.review.length} snippets (trimmed ‚â§300 chars)`);
              addDebugLog(`      ‚úÖ review.author.name: Present`);
              addDebugLog(`      ‚úÖ review.reviewRating.ratingValue: 4-5`);
            }
          }
        }
      } else if (includeReviews && index < 3) {
        addDebugLog(`\n   ‚≠ê Reviews & Ratings:`);
        if (!reviewData) {
          addDebugLog(`      ‚ö†Ô∏è Reviews toggle ON but no reviewData (mapping: ${mappingData ? 'YES' : 'NO'}, productUrl: ${productUrl || 'none'})`);
        } else if (reviewData.reviewCount < 1) {
          addDebugLog(`      ‚ö†Ô∏è Reviews toggle ON but reviewCount (${reviewData.reviewCount}) < 1`);
        }
      }

      // Remove audience field - causing validation warnings (optional field, not critical)
      // Schema.org validators are strict about audience format for Event schema
      // Commented out to avoid validation warnings
      // if (audience) {
      //   eventSchema.audience = audience;
      // }

      // SEO Metadata Enhancers
      eventSchema.potentialAction = {
        "@type": "RegisterAction",
        "target": eventUrl
      };
      // Note: isFamilyFriendly, learningResourceType, courseMode are Course fields, not Event fields
      // These are only valid for Course schema, not Event or Product+Event hybrid
      // Removed to avoid Schema.org validation errors
      eventSchema.subjectOf = {
        "@type": "WebPage",
        "url": eventUrl
      };
      
      if (index < 3) {
        addDebugLog(`\n   üß† SEO Enhancers:`);
        addDebugLog(`      ‚úÖ potentialAction.@type: RegisterAction`);
        addDebugLog(`      ‚úÖ subjectOf.@type: WebPage`);
      }

      // Phase 5: Generate breadcrumbs
      const eventName = event['Event_Title'] || 'Event';
      const urlPath = eventUrl.replace('https://www.alanranger.com', '').replace('http://www.alanranger.com', '').trim('/');
      const pathParts = urlPath.split('/').filter(Boolean);
      
      let parentCategoryName = "Photo Workshops UK";
      let parentCategoryUrl = "https://www.alanranger.com/photo-workshops-uk";
      
      if (pathParts.length > 0) {
        const parentSlug = pathParts[0];
        if (parentSlug === 'beginners-photography-lessons') {
          parentCategoryName = "Photography Services Near Me";
          parentCategoryUrl = "https://www.alanranger.com/photography-services-near-me";
        } else if (parentSlug === 'photographic-workshops-near-me' || parentSlug === 'photo-workshops-uk') {
          parentCategoryName = "Photo Workshops UK";
          parentCategoryUrl = "https://www.alanranger.com/photo-workshops-uk";
        }
      }
      
      const breadcrumb = {
        "@type": "BreadcrumbList",
        "@id": `${eventUrl}#breadcrumbs`,
        "itemListElement": [
          {
            "@type": "ListItem",
            "position": 1,
            "name": "Home",
            "item": "https://www.alanranger.com"
          },
          {
            "@type": "ListItem",
            "position": 2,
            "name": parentCategoryName,
            "item": parentCategoryUrl
          },
          {
            "@type": "ListItem",
            "position": 3,
            "name": eventName,
            "item": eventUrl
          }
        ]
      };
      
      if (index < 3) {
        addDebugLog(`\n   üß≠ Breadcrumbs & ItemList:`);
        addDebugLog(`      ‚úÖ BreadcrumbList.@type: BreadcrumbList`);
        addDebugLog(`      ‚úÖ BreadcrumbList.itemListElement: 3 items (Home > ${parentCategoryName} > ${eventName.substring(0, 30)}...)`);
      }

      return { eventSchema, breadcrumb };
    });
    
    // Phase 3.6: Event Schedule Grouping (DISABLED - using v4.2/v4.3 EventSeries system instead)
    // The old grouping system replaced individual events with EventSeries, which conflicts
    // with the new v4.2/v4.3 system that keeps individual events and adds superEvent backlinks.
    let finalEventList = eventSchemas.map(item => item.eventSchema);
    let finalBreadcrumbs = eventSchemas.map(item => item.breadcrumb);
    
    addDebugLog(`\nüîÅ EventSeries / Grouping Section:`);
    addDebugLog(`   Toggle state: ${groupRepeatingEvents ? 'ON' : 'OFF'}`);
    addDebugLog(`   Note: Using v4.2/v4.3 EventSeries system (keeps individual events + adds backlinks)`);
    
    // OLD GROUPING SYSTEM DISABLED - conflicts with v4.2/v4.3 EventSeries backlinking
    // Skip the old grouping logic entirely - new system handles it below
    // (Old code removed - EventSeries detection happens later in the flow)
    if (false) {
      // Group events by base title (remove week numbers, dates, etc.)
      const eventGroups = {};
      filtered.forEach((event, idx) => {
        const title = event['Event_Title'] || '';
        // Enhanced title normalization: remove week numbers, session numbers, dates, and common variations
        let baseTitle = title
          .replace(/\s*-\s*Week\s+\d+\s+of\s+\d+/i, '')
          .replace(/\s*-\s*Week\s+\d+/i, '')
          .replace(/\s*-\s*Session\s+\d+/i, '')
          .replace(/\s*-\s*\d+\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*/i, '')
          .replace(/\s*-\s*\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/g, '') // Remove dates like 01/15/2026
          .replace(/\s*\(.*?\)/g, '') // Remove parenthetical content
          .replace(/\s*\d+\s+Weekly\s+Evening\s+Classes?/i, '')
          .replace(/\s*\d+\s+Week\s+Course/i, '')
          .replace(/\s*3\s+Weekly/i, '')
          .trim();
        
        // Also try grouping by location if titles are very similar
        const location = event['Location_Business_Name'] || '';
        const groupKey = `${baseTitle}|${location}`;
        
        if (!eventGroups[groupKey]) {
          eventGroups[groupKey] = [];
        }
        eventGroups[groupKey].push({ event, schema: eventSchemas[idx].eventSchema, baseTitle });
      });
      
      addDebugLog(`   Found ${Object.keys(eventGroups).length} potential groups`);
      Object.keys(eventGroups).forEach(key => {
        const group = eventGroups[key];
        addDebugLog(`   Group "${key.split('|')[0]}": ${group.length} events`);
      });
      
      // For groups with 2+ events, create superEvent with eventSchedule
      Object.keys(eventGroups).forEach(groupKey => {
        const group = eventGroups[groupKey];
        if (group.length >= 2) {
          // Sort by start date
          group.sort((a, b) => {
            const dateA = a.event['Start_Date'] || '';
            const dateB = b.event['Start_Date'] || '';
            return dateA.localeCompare(dateB);
          });
          
          const firstEvent = group[0];
          const lastEvent = group[group.length - 1];
          const firstStart = combineDateTime(firstEvent.event['Start_Date'], firstEvent.event['Start_Time']);
          const lastEnd = combineDateTime(lastEvent.event['End_Date'], lastEvent.event['End_Time']);
          
          // Calculate date differences between consecutive events
          const dateDiffs = [];
          for (let i = 1; i < group.length; i++) {
            const prevDate = new Date(group[i-1].event['Start_Date']);
            const currDate = new Date(group[i].event['Start_Date']);
            const diffDays = Math.round((currDate - prevDate) / (1000 * 60 * 60 * 24));
            dateDiffs.push(diffDays);
          }
          
          // Check if events are weekly (6-8 days apart)
          const isWeekly = dateDiffs.length > 0 && dateDiffs.every(diff => diff >= 6 && diff <= 8);
          
          // Check if events are monthly (25-35 days apart, for 1-2 times per month)
          const isMonthly = dateDiffs.length > 0 && dateDiffs.every(diff => diff >= 25 && diff <= 35);
          
          // Check if events are roughly monthly but irregular (14-45 days apart)
          const isIrregularMonthly = dateDiffs.length > 0 && dateDiffs.every(diff => diff >= 14 && diff <= 45);
          
          if (isWeekly || isMonthly || isIrregularMonthly) {
            const pattern = isWeekly ? 'weekly' : (isMonthly ? 'monthly' : 'irregular monthly');
            const repeatFreq = isWeekly ? 'P1W' : 'P1M';
            
            stats.repeatingGroups++;
            stats.eventSeriesGroups++;
            addDebugLog(`   ‚úÖ Created EventSeries: "${group[0].baseTitle}" (${group.length} events, ${pattern} pattern)`);
            addDebugLog(`      Date differences: ${dateDiffs.join(', ')} days`);
            
            // Create superEvent with eventSchedule
            const superEvent = {
              "@context": "https://schema.org",
              "@type": "EventSeries",
              "@id": `${firstEvent.schema.url}#superEvent`,
              "name": group[0].baseTitle,
              "description": firstEvent.schema.description,
              "startDate": firstStart,
              "endDate": lastEnd,
              "eventSchedule": {
                "@type": "Schedule",
                "startDate": firstStart,
                "endDate": lastEnd,
                "repeatFrequency": repeatFreq,
                "scheduleTimezone": "Europe/London"
              },
              "organizer": organizerBlock,
              "location": firstEvent.schema.location,
              "offers": firstEvent.schema.offers
            };
            
            // Add subEvents
            superEvent.subEvent = group.map(g => g.schema);
            
            // Replace individual events with superEvent
            const groupIndices = group.map((_, i) => {
              const eventUrl = normalizeUrl(group[i].event['Event_URL'] || '');
              return finalEventList.findIndex(e => e.url === eventUrl);
            }).filter(idx => idx !== -1);
            
            // Remove individual events and add superEvent
            groupIndices.forEach(idx => {
              finalEventList[idx] = null;
            });
            finalEventList = finalEventList.filter(e => e !== null);
            finalEventList.unshift(superEvent);
          } else {
            addDebugLog(`   ‚ö†Ô∏è Skipped group "${group[0].baseTitle}": ${group.length} events, but date pattern doesn't match (diffs: ${dateDiffs.join(', ')} days)`);
          }
        } else {
          addDebugLog(`   ‚ö†Ô∏è Skipped group "${groupKey.split('|')[0]}": only ${group.length} event(s), need 2+`);
        }
      });
    }
    // Note: Old grouping system disabled - EventSeries detection happens later
    
    stats.eventsGenerated = finalEventList.length;
    stats.breadcrumbChains = finalBreadcrumbs.length;
    stats.itemListItems = itemList.itemListElement.length;
    
    // Location Verification Summary (v4.1)
    if (stats.locationStats && stats.locationStats.total > 0) {
      addDebugLog(`\nüè† Location Verification:`);
      const loc = stats.locationStats;
      addDebugLog(`   streetAddress: ‚úÖ ${loc.streetAddress.valid}/${loc.total}`);
      addDebugLog(`   addressLocality: ‚úÖ ${loc.addressLocality.valid}/${loc.total}`);
      addDebugLog(`   addressRegion: ‚úÖ ${loc.addressRegion.valid}/${loc.total}`);
      addDebugLog(`   postalCode: ‚úÖ ${loc.postalCode.valid}/${loc.total}`);
      addDebugLog(`   geoCoordinates: ‚úÖ ${loc.geoCoordinates.valid}/${loc.total}`);
      addDebugLog(`   fallbackApplied: ${loc.fallbackApplied}`);
      addDebugLog(`   regionMap matches: ${loc.regionMapMatches}`);
    }

    const eventList = finalEventList;
    const breadcrumbs = finalBreadcrumbs;
    
    // Detect and create EventSeries for recurring workshops (v4.2 + v4.3 backlinks)
    addDebugLog(`\nüîÅ EventSeries Detection (v4.2/v4.3):`);
    addDebugLog(`   Checking ${eventList.length} events for series patterns...`);
    
    const seriesGroups = detectEventSeries(eventList);
    const eventSeriesArray = [];
    
    if (Object.keys(seriesGroups).length === 0) {
      addDebugLog(`   ‚ö†Ô∏è No EventSeries groups detected (check keyword patterns match event titles)`);
      // Debug: show sample event titles
      if (eventList.length > 0) {
        addDebugLog(`   Sample event titles: ${eventList.slice(0, 3).map(e => e.name || e.Event_Title || 'N/A').join(', ')}`);
      }
    } else {
      addDebugLog(`   ‚úÖ Found ${Object.keys(seriesGroups).length} EventSeries group(s)`);
      Object.entries(seriesGroups).forEach(([k, v]) => {
        addDebugLog(`   ‚Ä¢ ${k}: ${v.length} events`);
      });
    }
    
    for (const [groupName, groupEvents] of Object.entries(seriesGroups)) {
      // Sort events by start date
      groupEvents.sort((a, b) => {
        const dateA = a.startDate || '';
        const dateB = b.startDate || '';
        return dateA.localeCompare(dateB);
      });
      
      const sample = groupEvents[0];
      const firstEvent = groupEvents[0];
      const lastEvent = groupEvents[groupEvents.length - 1];
      
      // Generate stable series ID (v4.3)
      const seriesId = seriesIdFromName(groupName);
      
      // Collect child event @ids for subEvent array (v4.3)
      const childEventIds = groupEvents
        .map(e => e["@id"] || eventIdFromUrl(e.url))
        .filter(Boolean);
      
      const eventSchedule = {
        "@type": "Schedule",
        "repeatFrequency": "P1Y",
        "startDate": firstEvent.startDate,
        "endDate": lastEvent.endDate,
        "scheduleTimezone": "Europe/London"
      };
      
      // Build keywords array from event titles and regions
      const keywords = [];
      groupEvents.forEach(e => {
        if (e.name) keywords.push(e.name);
        if (e.location && e.location.address && e.location.address.addressRegion) {
          keywords.push(e.location.address.addressRegion);
        }
      });
      const uniqueKeywords = [...new Set(keywords)].join(', ');
      
      const eventSeries = {
        "@context": "https://schema.org",
        "@type": "EventSeries",
        "@id": seriesId, // v4.3: Use stable ID from helper
        "name": groupName.charAt(0).toUpperCase() + groupName.slice(1) + " (Annual Series)",
        "description": sample.description || `${groupName} ‚Äî recurring annual workshops.`,
        "eventAttendanceMode": sample.eventAttendanceMode,
        "eventStatus": "https://schema.org/EventScheduled",
        "location": sample.location,
        "organizer": sample.organizer,
        "eventSchedule": eventSchedule,
        "keywords": uniqueKeywords,
        // Forward links: subEvent array (v4.3)
        "subEvent": childEventIds.map(id => ({ "@id": id })),
        // Keep subjectOf ItemList from v4.2
        "subjectOf": {
          "@type": "ItemList",
          "numberOfItems": groupEvents.length,
          "itemListElement": groupEvents.map((e, i) => ({
            "@type": "ListItem",
            "position": i + 1,
            "url": e.url,
            "name": e.name
          }))
        }
      };
      
      // Add performer if present in sample
      if (sample.performer) {
        eventSeries.performer = sample.performer;
      }
      
      // Note: provider removed - not valid for Event schema, organizer already provides this info
      
      // Add about field
      eventSeries.about = {
        "@type": "Thing",
        "name": groupName,
        "url": sample.url
      };
      
      eventSeriesArray.push(eventSeries);
    }
    
    // Add EventSeries grouping summary to debug log (v4.2 + v4.3)
    if (Object.keys(seriesGroups).length > 0) {
      addDebugLog(`\nüîÅ EventSeries Grouping Summary:`);
      addDebugLog(`   Detected series groups: ${Object.keys(seriesGroups).length}`);
      Object.entries(seriesGroups).forEach(([k, v]) => {
        addDebugLog(`   ‚Ä¢ ${k}: ${v.length} events`);
      });
      addDebugLog(`   EventSeries objects generated: ${eventSeriesArray.length}`);
    }
    
    stats.eventSeriesCreated = eventSeriesArray.length;
    stats.eventSeriesGroups = Object.keys(seriesGroups).length;
    stats.eventSeriesNames = Object.keys(seriesGroups).map(k => k.charAt(0).toUpperCase() + k.slice(1));
    
    // Log Structure Section now that EventSeries stats are updated
    addDebugLog(`\nüß≠ Structure Section:`);
    addDebugLog(`   ‚úÖ Breadcrumb chains: ${stats.breadcrumbChains} (should match events)`);
    addDebugLog(`   ‚úÖ ItemList items: ${stats.itemListItems} (should match events)`);
    addDebugLog(`   ‚úÖ EventSeries groups: ${stats.eventSeriesGroups}`);
    
    // Add superEvent backlinks to Events (v4.3)
    // Build seriesMembership from detected groups to ensure consistency
    const seriesMembershipFromGroups = new Map();
    for (const [groupName, groupEvents] of Object.entries(seriesGroups)) {
      const seriesId = seriesIdFromName(groupName);
      for (const event of groupEvents) {
        const eventId = event["@id"] || eventIdFromUrl(event.url);
        if (eventId) {
          seriesMembershipFromGroups.set(eventId, seriesId);
        }
      }
    }
    
    // Merge with pre-populated seriesMembership (for backwards compatibility)
    seriesMembershipFromGroups.forEach((sid, eid) => {
      seriesMembership.set(eid, sid);
    });
    
    let superEventLinks = 0;
    for (const e of eventList) {
      // Skip if this is already an EventSeries (shouldn't happen, but safety check)
      if (e["@type"] === "EventSeries") continue;
      
      const eid = e["@id"];
      if (!eid) {
        addDebugLog(`   ‚ö†Ô∏è Event missing @id: ${e.name || 'Unknown'}`);
        continue;
      }
      
      const sid = seriesMembership.get(eid);
      if (!sid) continue;
      
      // Avoid duplicates if re-run
      if (!e.superEvent) {
        e.superEvent = { "@type": "EventSeries", "@id": sid };
        superEventLinks++;
      }
    }
    
    stats.superEventLinks = superEventLinks;
    
    // Add EventSeries backlinking summary (v4.3)
    addDebugLog(`\nüîÅ EventSeries Backlinking:`);
    addDebugLog(`   Events with superEvent: ${superEventLinks}`);
    addDebugLog(`   EventSeries emitted: ${eventSeriesArray.length}`);
    const totalSubEvents = eventSeriesArray.reduce((sum, series) => {
      return sum + (Array.isArray(series.subEvent) ? series.subEvent.length : 0);
    }, 0);
    addDebugLog(`   Total subEvent links: ${totalSubEvents}`);

    // Emit order: Events first, then EventSeries (v4.3)
    const outputJsonLd = [
      ...eventList,
      ...eventSeriesArray
    ];

    // Calculate linkage verification stats (v4.3)
    const verify = {
      eventId: 0,
      superEventId: 0,
      seriesId: 0,
      seriesSubEventTotal: 0,
      seriesWithScheduleRF: 0
    };
    
    for (const node of outputJsonLd) {
      if (node["@type"] === "Event") {
        if (node["@id"]) verify.eventId++;
        if (node.superEvent?.["@id"]) verify.superEventId++;
      } else if (node["@type"] === "EventSeries") {
        if (node["@id"]) verify.seriesId++;
        if (Array.isArray(node.subEvent)) verify.seriesSubEventTotal += node.subEvent.length;
        if (node.eventSchedule?.repeatFrequency) verify.seriesWithScheduleRF++;
      }
    }
    
    stats.linkageStats = verify;

    const fullSchema = {
      "@context": "https://schema.org",
      "@graph": [itemList, ...breadcrumbs, ...outputJsonLd]
    };

    const json = JSON.stringify(fullSchema, null, 2);
    const scriptEl = document.createElement('script');
    scriptEl.type = 'application/ld+json';
    scriptEl.textContent = json;
    
    // Phase 4: Event Schema - NO Schema Suppressor (only for Product Schema)
    const output = scriptEl.outerHTML;
    
    // Set output - use textContent to preserve HTML structure
    const outputElement = document.getElementById('eventOutput');
    if (!outputElement) {
      console.error('‚ùå Output element not found');
      alert('Error: Output element not found. Please refresh the page.');
      return;
    }
    
    // Clear any previous content and set the new output
    outputElement.textContent = '';
    outputElement.textContent = output;
    
    // Ensure copy button is visible after generation
    const copyButton = document.getElementById('copySchemaButton');
    const copyButtonTop = document.getElementById('copySchemaButtonTop');
    if (copyButton) {
      copyButton.style.display = 'inline-block';
      copyButton.style.visibility = 'visible';
      copyButton.style.opacity = '1';
    }
    if (copyButtonTop) {
      copyButtonTop.style.display = 'inline-block';
      copyButtonTop.style.visibility = 'visible';
      copyButtonTop.style.opacity = '1';
    }
    
    console.log('‚úÖ Event schema generated:', filtered.length, 'events');
    console.log('‚úÖ Output length:', output.length, 'characters');
    
    // Phase 5: Enhanced validation results with statistics
    try {
      const validationResults = validateEventSchema(fullSchema);
      stats.validationStatus = validationResults.isValid ? 'Valid' : (validationResults.warnings && validationResults.warnings.length > 0 ? 'Warnings' : 'Invalid');
      stats.validationErrors = validationResults.errors ? validationResults.errors.length : 0;
      stats.validationWarnings = validationResults.warnings ? validationResults.warnings.length : 0;
      
      addDebugLog(`\n‚úÖ Validation Section:`);
      addDebugLog(`   Status: ${stats.validationStatus}`);
      addDebugLog(`   Errors: ${stats.validationErrors}`);
      addDebugLog(`   Warnings: ${stats.validationWarnings}`);
      
      const validationStatus = validationResults.isValid ? '‚úÖ Valid' : '‚ùå Invalid';
      const eventsWithReviews = eventList.filter(e => e.aggregateRating).length;
      const eventsWithPerformer = eventList.filter(e => e.performer).length;
      const eventsWithOffers = eventList.filter(e => e.offers && parseFloat(e.offers.price) > 0).length;
      
      // Count lessons vs workshops (v4.1)
      const lessonsCount = eventList.filter(e => e.eventType === "Lesson").length;
      const workshopsCount = eventList.filter(e => e.eventType === "Workshop").length;
      
      // Calculate region coverage (v4.1)
      const regionCoverage = stats.locationStats && stats.locationStats.total > 0
        ? Math.round((stats.locationStats.addressRegion.valid / stats.locationStats.total) * 100)
        : 100;
      
      let statsMsg = `\n\nüìä Generation Summary:\n` +
        `   ‚Ä¢ ${filtered.length} event${filtered.length !== 1 ? 's' : ''} generated\n` +
        `   ‚Ä¢ Lessons: ${lessonsCount} valid / Workshops: ${workshopsCount} valid\n` +
        `   ‚Ä¢ ${eventsWithReviews} event${eventsWithReviews !== 1 ? 's' : ''} with reviews\n` +
        `   ‚Ä¢ ${eventsWithPerformer} event${eventsWithPerformer !== 1 ? 's' : ''} with performer\n` +
        `   ‚Ä¢ ${eventsWithOffers} event${eventsWithOffers !== 1 ? 's' : ''} with offers\n` +
        `   ‚Ä¢ Region coverage: ${regionCoverage}%\n`;
      
      // Add EventSeries summary (v4.2)
      if (stats.eventSeriesCreated && stats.eventSeriesCreated > 0 && stats.eventSeriesNames) {
        const seriesNames = stats.eventSeriesNames.join(', ');
        statsMsg += `   ‚Ä¢ üîÅ EventSeries Created: ${stats.eventSeriesCreated} (${seriesNames})\n`;
      }
      
      statsMsg += `\n${validationStatus} - ${validationResults.message}`;
      
      // Add location enrichment status (v4.1)
      if (enrichLocations) {
        statsMsg += `\nüìç Location Enrichment Active ‚Äî Regions and Geo auto-filled via keyword inference.`;
      }
      
      if (validationResults.warnings && validationResults.warnings.length > 0) {
        statsMsg += `\n‚ö†Ô∏è Warnings: ${validationResults.warnings.length}`;
      }
      
      // Final summary (v4.3)
      addDebugLog(`\n‚úÖ v4.3 Schema generation complete.`);
      addDebugLog(`   Lessons: ${lessonsCount} valid / Workshops: ${workshopsCount} valid`);
      addDebugLog(`   Region coverage: ${regionCoverage}%`);
      if (stats.eventSeriesCreated && stats.eventSeriesCreated > 0) {
        addDebugLog(`   EventSeries created: ${stats.eventSeriesCreated}`);
      }
      addDebugLog(`   Validation: ${validationResults.errors ? validationResults.errors.length : 0} errors / ${validationResults.warnings ? validationResults.warnings.length : 0} warnings`);
      addDebugLog(`\nüåê GitHub Hosting Status:`);
      addDebugLog(`   ‚úÖ Repository: alanranger-schema (public)`);
      addDebugLog(`   üåê Hosted via GitHub Pages at https://schema.alanranger.com/`);
      addDebugLog(`   üìÅ Files synced: lessons-schema.json, workshops-schema.json`);
      addDebugLog(`   ‚öôÔ∏è Auto-sync enabled via GitHub Actions`);
      addDebugLog(`   üí° Tip: Update via 'Export JSON' to push new schema automatically`);
      
      outputElement.textContent = output + statsMsg;
      
      // Show/hide merchant feed button based on toggle
      const merchantFeedContainer = document.getElementById('merchantFeedContainer');
      if (merchantFeedContainer) {
        merchantFeedContainer.style.display = includeMerchantFields ? 'block' : 'none';
      }
      
      // Store current schema for export
      window.currentEventSchema = fullSchema;
      window.currentEventList = eventList;
      window.currentMappingsDict = mappingsDict;
      window.currentEventSchemaCsvType = stats.csvType;
      
      // Show export container and prepare export
      const exportContainer = document.getElementById('schemaExportContainer');
      if (exportContainer) {
        exportContainer.style.display = 'block';
        prepareSchemaExport(fullSchema, stats.csvType, stats);
      }
      
      // Calculate merchant feed items
      if (includeMerchantFields) {
        stats.merchantFeedItems = eventList.filter(e => e['@type'] === 'Event' && e.offers && parseFloat(e.offers.price) > 0).length;
      }
      
      // Store field verification stats for modal
      window.fieldVerificationStats = {
        ...stats,
        coreFields: {
          context: '‚úÖ',
          type: '‚úÖ',
          name: '‚úÖ',
          startDate: '‚úÖ',
          endDate: '‚úÖ',
          duration: '‚úÖ',
          identifier: '‚úÖ'
        },
        locationFields: {
          name: '‚úÖ',
          streetAddress: stats.addressFieldsWithStreetAddress > 0 ? '‚úÖ' : '‚ö†Ô∏è',
          streetAddressCount: stats.addressFieldsWithStreetAddress || 0,
          locality: stats.addressFieldsWithLocality > 0 ? '‚úÖ' : '‚ö†Ô∏è',
          localityCount: stats.addressFieldsWithLocality || 0,
          region: stats.addressFieldsWithRegion > 0 ? '‚úÖ' : '‚ö†Ô∏è',
          regionCount: stats.addressFieldsWithRegion || 0,
          postalCode: stats.addressFieldsWithPostalCode > 0 ? '‚úÖ' : '‚ö†Ô∏è',
          postalCodeCount: stats.addressFieldsWithPostalCode || stats.eventsGenerated || 0
        }
      };
      
      // Update summary panel
      updateSummaryPanel(buildSummaryHTML(stats));
      
      // Auto-show field verification modal after generation
      setTimeout(() => {
        if (window.fieldVerificationStats) {
          showFieldVerificationModal();
        }
      }, 500);
      
      if (!validationResults.isValid && validationResults.errors.length > 0) {
        console.warn('‚ö†Ô∏è Schema validation issues:', validationResults.errors);
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è Validation check failed:', e);
      // Keep the original output even if validation fails
      if (typeof outputElement !== 'undefined') {
        outputElement.textContent = output;
      }
      updateSummaryPanel(buildSummaryHTML(stats));
    }
  } catch (error) {
    console.error('‚ùå Error generating event schema:', error);
    alert('Error generating schema: ' + error.message + '\n\nPlease check the browser console for details.');
    const outputElement = document.getElementById('eventOutput');
    if (outputElement) {
      outputElement.textContent = 'Error: ' + error.message;
    }
  }
}

  // GitHub Hosting Verification - Ping GitHub function
  function initGitHubVerification() {
    const pingButton = document.getElementById('pingGitHub');
    if (pingButton && !pingButton.dataset.initialized) {
      pingButton.dataset.initialized = 'true';
      pingButton.addEventListener('click', async function() {
        const resultsDiv = document.getElementById('pingResults');
        const linksDiv = document.getElementById('schemaLinks');
        
        if (!resultsDiv) return;
        
        resultsDiv.textContent = 'üîÑ Pinging schema URLs...';
        resultsDiv.style.color = '#6b7280';
        
        const urls = [
          { name: 'Lessons Schema', url: 'https://schema.alanranger.com/lessons-schema.json' },
          { name: 'Workshops Schema', url: 'https://schema.alanranger.com/workshops-schema.json' }
        ];
        
        const checks = await Promise.all(urls.map(async (item) => {
          const start = performance.now();
          try {
            const res = await fetch(item.url, { 
              cache: 'no-cache',
              method: 'HEAD' // Use HEAD to avoid downloading full file
            });
            const time = (performance.now() - start).toFixed(0);
            const statusIcon = res.status === 200 ? '‚úÖ' : '‚ö†Ô∏è';
            const statusColor = res.status === 200 ? '#10b981' : '#f59e0b';
            return `<div style="margin-bottom: 0.5rem;"><span style="color: ${statusColor};">${statusIcon}</span> <strong>${item.name}:</strong> ${res.status} ${res.statusText} <span style="color: #6b7280;">(${time} ms)</span></div>`;
          } catch (err) {
            const time = (performance.now() - start).toFixed(0);
            return `<div style="margin-bottom: 0.5rem;"><span style="color: #ef4444;">‚ùå</span> <strong>${item.name}:</strong> ERROR - ${err.message} <span style="color: #6b7280;">(${time} ms)</span></div>`;
          }
        }));
        
        resultsDiv.innerHTML = checks.join('');
        resultsDiv.style.color = '#374151';
        
        // Show validation links
        if (linksDiv) {
          linksDiv.style.display = 'block';
        }
        
        // Log to debug console
        addDebugLog('\nüîç GitHub Hosting Verification:');
        checks.forEach(check => {
          addDebugLog(`   ${check.replace(/<[^>]*>/g, '')}`);
        });
      });
    }
  }
  
  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGitHubVerification);
  } else {
    initGitHubVerification();
  }

  // Prepare Schema Export UI (v4.4)
  function prepareSchemaExport(schema, csvType, stats) {
    // Initialize GitHub verification when export container is shown
    setTimeout(function() {
      initGitHubVerification();
    }, 100);
    
    const fileName = csvType === 'workshops' ? 'workshops-schema.json' : 
                     csvType === 'lessons' ? 'lessons-schema.json' : 
                     'event-schema.json';
    
    try {
      // Validate JSON structure first
      const jsonString = JSON.stringify(schema, null, 2);
      JSON.parse(jsonString); // Validate syntax
      
      // Safe minification using JSON.stringify (lossless, no regex)
      // Note: JSON.stringify(obj, null, 0) produces minified JSON (no indentation)
      // This is equivalent to JSON.stringify(obj) but more explicit
      let minifiedJson;
      let minificationSuccess = false;
      let minificationWarning = '';
      
      try {
        // Validate schema structure before minification
        if (!schema || typeof schema !== 'object') {
          throw new Error('Invalid schema: not an object');
        }
        if (!schema['@graph'] || !Array.isArray(schema['@graph'])) {
          throw new Error('Invalid schema: @graph is not an array');
        }
        
        // Safe minification: use JSON.stringify (lossless, no regex manipulation)
        minifiedJson = JSON.stringify(schema, null, 0);
        
        // Validate minified version parses correctly (catches syntax errors)
        JSON.parse(minifiedJson);
        
        // Verify it ends correctly (should end with ]} for @graph array)
        // Valid JSON-LD schema should end with: ]} (closing @graph array, then root object)
        const trimmed = minifiedJson.trim();
        if (!trimmed.endsWith(']}')) {
          // If it doesn't end with ]}, check if it's valid JSON structure
          // This catches issues like extra commas, wrong brackets, etc.
          try {
            const testParse = JSON.parse(minifiedJson);
            // If it parses but doesn't end correctly, it might have trailing whitespace
            // But if it ends with }}}, that's a structural issue
            if (trimmed.endsWith('}}}') || trimmed.endsWith(',]}') || trimmed.endsWith(',}')) {
              throw new Error('Invalid JSON structure: incorrect ending (extra brackets or commas)');
            }
          } catch (parseErr) {
            throw new Error('Invalid JSON structure: ' + parseErr.message);
          }
        }
        
        minificationSuccess = true;
      } catch (minifyError) {
        // Fallback: use unminified version if minification fails
        console.warn('‚ö†Ô∏è Minify validation failed. Using unminified version:', minifyError);
        minifiedJson = jsonString;
        minificationWarning = '‚ö†Ô∏è Minification failed - using unminified version';
      }
      
      const sizeReduction = Math.round((1 - minifiedJson.length/jsonString.length) * 100);
      
      const exportContent = document.getElementById('schemaExportContent');
      if (exportContent) {
        const warningBadge = minificationWarning ? `<span style="color: #f59e0b; font-size: 0.875rem;">${minificationWarning}</span><br>` : '';
        exportContent.innerHTML = `
          <div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #0ea5e9;">
            <strong style="color: #0369a1;">üì¶ Export Ready</strong><br>
            <span style="color: #075985; font-size: 0.875rem;">File: <code>${fileName}</code></span><br>
            <span style="color: #075985; font-size: 0.875rem;">‚úÖ Validated: JSON.parse successful</span><br>
            ${warningBadge}
            <span style="color: #075985; font-size: 0.875rem;">üìä Size: ${(minifiedJson.length / 1024).toFixed(2)} KB ${minificationSuccess ? `(minified, ${sizeReduction}% reduction)` : '(unminified)'}</span><br>
            <span style="color: #075985; font-size: 0.875rem;">‚úÖ Structure: @context=${schema['@context'] === 'https://schema.org' ? '‚úÖ' : '‚ùå'}, @graph=${Array.isArray(schema['@graph']) ? '‚úÖ' : '‚ùå'}</span><br>
            <span style="color: #075985; font-size: 0.875rem;">üåê GitHub Pages: <a href="https://schema.alanranger.com/${fileName}" target="_blank" style="color: #0369a1;">https://schema.alanranger.com/${fileName}</a></span><br>
            <span style="color: #075985; font-size: 0.875rem;">üìã Script src tag ready for Squarespace</span>
          </div>
        `;
      }
      
      addDebugLog(`\nüì¶ Schema Export Ready:`);
      addDebugLog(`   File: ${fileName}`);
      addDebugLog(`   ‚úÖ Validated: JSON.parse successful`);
      
      // Quality checks
      const hasContext = schema['@context'] === 'https://schema.org';
      const hasGraph = Array.isArray(schema['@graph']);
      const fileSizeKB = minifiedJson.length / 1024;
      const isValid = hasContext && hasGraph && fileSizeKB < 250;
      
      addDebugLog(`   üìä Size: ${fileSizeKB.toFixed(2)} KB ${minificationSuccess ? `(minified, ${sizeReduction}% reduction)` : '(unminified - minification failed)'} ${fileSizeKB < 250 ? '‚úÖ' : '‚ö†Ô∏è (exceeds 250 KB)'}`);
      addDebugLog(`   ‚úÖ Structure: @context=${hasContext ? '‚úÖ' : '‚ùå'}, @graph=${hasGraph ? '‚úÖ' : '‚ùå'}`);
      if (minificationWarning) {
        addDebugLog(`   ${minificationWarning}`);
      }
      addDebugLog(`\nüåê GitHub Hosting Status:`);
      addDebugLog(`   ‚úÖ Repository: alanranger-schema (public)`);
      addDebugLog(`   üåê Hosted via GitHub Pages: https://schema.alanranger.com/`);
      addDebugLog(`   üìÅ Files synced: lessons-schema.json, workshops-schema.json`);
      addDebugLog(`   ‚öôÔ∏è Auto-sync: Enabled via GitHub Actions`);
      addDebugLog(`   üí° Tip: Use export buttons below to download JSON or copy GitHub Pages script src tag`);
    } catch (error) {
      console.error('‚ùå Error preparing export:', error);
      addDebugLog(`\nüì¶ Schema Export:`);
      addDebugLog(`   ‚ùå Validation error: ${error.message}`);
    }
  }

// Export Merchant Center Feed (Phase 6)
  function exportMerchantFeed() {
    if (!window.currentEventList || !window.currentMappingsDict) {
      alert('Please generate event schema first.');
      return;
    }
    
    const feed = [];
    window.currentEventList.forEach(event => {
      if (event['@type'] === 'Event' && event.offers && parseFloat(event.offers.price) > 0) {
        const eventUrl = event.url || '';
        const mappingData = window.currentMappingsDict[normalizeUrl(eventUrl)];
        
        const feedItem = {
          id: event.identifier || eventUrl.split('/').pop() || '',
          title: event.name || '',
          description: event.description || '',
          link: eventUrl,
          image_link: event.image || '',
          price: event.offers.price + ' ' + (event.offers.priceCurrency || 'GBP'),
          availability: (event.offers.availability === 'https://schema.org/InStock' || 
                         event.offers.availability === 'InStock' || 
                         String(event.offers.availability).toLowerCase() === 'in stock') 
                         ? 'in stock' : 'out of stock',
          brand: 'Alan Ranger Photography'
        };
        
        if (mappingData && mappingData.sku) {
          feedItem.gtin = mappingData.sku; // Using gtin field for SKU
        }
        
        feed.push(feedItem);
      }
    });
    
    if (feed.length === 0) {
      alert('No events with valid offers found for feed export.');
      return;
    }
    
    const feedJson = JSON.stringify(feed, null, 2);
    const blob = new Blob([feedJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `merchant-center-feed-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('‚úÖ Merchant Center feed exported:', feed.length, 'items');
  }

  // Export Schema to JSON File (v4.4) - Safe minification with validation and fallback
  function exportSchemaToJson() {
    if (!window.currentEventSchema) {
      alert('Please generate event schema first.');
      return;
    }

    const csvType = window.currentEventSchemaCsvType || 'unknown';
    const fileName = csvType === 'workshops' ? 'workshops-schema.json' : 
                     csvType === 'lessons' ? 'lessons-schema.json' : 
                     'event-schema.json';

    try {
      // Step 1: Validate JSON structure (check for trailing commas, etc.)
      const jsonString = JSON.stringify(window.currentEventSchema, null, 2);
      JSON.parse(jsonString); // Validate it parses correctly
      
      // Step 2: Safe minification using JSON.stringify (lossless, no regex)
      // Note: JSON.stringify(obj, null, 0) produces minified JSON (no indentation)
      // This is equivalent to JSON.stringify(obj) but more explicit
      let minifiedJson;
      let minificationSuccess = false;
      let minificationWarning = '';
      
      try {
        // Validate schema structure before minification
        if (!window.currentEventSchema || typeof window.currentEventSchema !== 'object') {
          throw new Error('Invalid schema: not an object');
        }
        if (!window.currentEventSchema['@graph'] || !Array.isArray(window.currentEventSchema['@graph'])) {
          throw new Error('Invalid schema: @graph is not an array');
        }
        
        // Safe minification: use JSON.stringify (lossless, no regex manipulation)
        minifiedJson = JSON.stringify(window.currentEventSchema, null, 0);
        
        // Validate minified version parses correctly (catches syntax errors)
        JSON.parse(minifiedJson);
        
        // Verify it ends correctly (should end with ]} for @graph array)
        if (!minifiedJson.trim().endsWith(']}') && !minifiedJson.trim().endsWith('}}')) {
          throw new Error('Invalid JSON structure: incorrect ending');
        }
        
        minificationSuccess = true;
      } catch (minifyError) {
        // Fallback: use unminified version if minification fails
        console.warn('‚ö†Ô∏è Minify validation failed. Saving unminified version instead:', minifyError);
        minifiedJson = jsonString;
        minificationSuccess = false;
        minificationWarning = '‚ö†Ô∏è Minification failed - saved unminified version';
      }
      
      // Step 3: Create blob and download
      const blob = new Blob([minifiedJson], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Step 4: Log to debug
      addDebugLog(`\nüì¶ Schema Export:`);
      addDebugLog(`   ‚úÖ Exported: ${fileName}`);
      addDebugLog(`   ‚úÖ Validated: JSON.parse successful`);
      
      // Quality checks
      const hasContext = window.currentEventSchema['@context'] === 'https://schema.org';
      const hasGraph = Array.isArray(window.currentEventSchema['@graph']);
      const fileSizeKB = minifiedJson.length / 1024;
      const sizeCheck = fileSizeKB < 250 ? '‚úÖ' : '‚ö†Ô∏è';
      
      if (minificationSuccess) {
        addDebugLog(`   ‚úÖ Minified: ${jsonString.length} ‚Üí ${minifiedJson.length} bytes (${Math.round((1 - minifiedJson.length/jsonString.length) * 100)}% reduction)`);
      } else {
        addDebugLog(`   ${minificationWarning}`);
      }
      addDebugLog(`   üìä File size: ${fileSizeKB.toFixed(2)} KB ${sizeCheck} ${fileSizeKB < 250 ? '(under 250 KB limit)' : '(exceeds 250 KB - consider splitting)'}`);
      addDebugLog(`   ‚úÖ Structure: @context=${hasContext ? '‚úÖ' : '‚ùå'}, @graph=${hasGraph ? '‚úÖ' : '‚ùå'}`);
      
      // GitHub Pages hosting info
      addDebugLog(`\nüåê GitHub Hosting:`);
      addDebugLog(`   ‚úÖ Repository: alanranger-schema (public)`);
      addDebugLog(`   üåê Hosted via GitHub Pages: https://schema.alanranger.com/`);
      addDebugLog(`   üìÅ File URL: https://schema.alanranger.com/${fileName}`);
      addDebugLog(`   ‚öôÔ∏è Auto-sync: Enabled via GitHub Actions`);
      addDebugLog(`   üí° Tip: Copy script src tag below for Squarespace integration`);
      
      // Update UI
      const exportContent = document.getElementById('schemaExportContent');
      if (exportContent) {
        let statusColor = (hasContext && hasGraph && fileSizeKB < 250) ? '#10b981' : '#f59e0b';
        let statusBg = (hasContext && hasGraph && fileSizeKB < 250) ? '#d1fae5' : '#fef3c7';
        const warningBadge = minificationWarning ? `<span style="color: #f59e0b; font-size: 0.875rem;">${minificationWarning}</span><br>` : '';
        
        exportContent.innerHTML = `
          <div style="background: ${statusBg}; padding: 0.75rem; border-radius: 6px; border-left: 3px solid ${statusColor}; margin-bottom: 0.75rem;">
            <strong style="color: ${(hasContext && hasGraph && fileSizeKB < 250) ? '#065f46' : '#92400e'};">‚úÖ Exported Successfully</strong><br>
            ${warningBadge}
            <span style="color: ${(hasContext && hasGraph && fileSizeKB < 250) ? '#047857' : '#78350f'}; font-size: 0.875rem;">File: <code>${fileName}</code></span><br>
            <span style="color: ${(hasContext && hasGraph && fileSizeKB < 250) ? '#047857' : '#78350f'}; font-size: 0.875rem;">Size: ${fileSizeKB.toFixed(2)} KB ${minificationSuccess ? '(minified)' : '(unminified)'} ${sizeCheck}</span><br>
            <span style="color: ${(hasContext && hasGraph && fileSizeKB < 250) ? '#047857' : '#78350f'}; font-size: 0.875rem;">Structure: @context=${hasContext ? '‚úÖ' : '‚ùå'}, @graph=${hasGraph ? '‚úÖ' : '‚ùå'}</span>
          </div>
        `;
      }
      
      console.log('‚úÖ Schema exported:', fileName, minificationSuccess ? '(minified)' : '(unminified - minification failed)');
    } catch (error) {
      console.error('‚ùå Error exporting schema:', error);
      alert('Error exporting schema: ' + error.message + '\n\nPlease check the browser console for details.');
      addDebugLog(`\nüì¶ Schema Export:`);
      addDebugLog(`   ‚ùå Export error: ${error.message}`);
    }
  }

  // Copy Squarespace Script Tag (v4.4) - External src version with safe minification
  function copySquarespaceScript() {
    if (!window.currentEventSchema) {
      alert('Please generate event schema first.');
      return;
    }

    const csvType = window.currentEventSchemaCsvType || 'unknown';
    const fileName = csvType === 'workshops' ? 'workshops-schema.json' : 
                     csvType === 'lessons' ? 'lessons-schema.json' : 
                     'event-schema.json';
    const schemaType = csvType === 'workshops' ? 'Workshops' : 
                       csvType === 'lessons' ? 'Lessons' : 
                       'Event';

    try {
      // Step 1: Validate JSON structure
      const jsonString = JSON.stringify(window.currentEventSchema, null, 2);
      const parsed = JSON.parse(jsonString);

      const hasContext = parsed['@context'] === 'https://schema.org';
      const hasGraph = Array.isArray(parsed['@graph']);
      
      // Step 2: Safe minification with validation and fallback
      // Note: JSON.stringify(obj, null, 0) produces minified JSON (no indentation)
      // This is equivalent to JSON.stringify(obj) but more explicit
      let minifiedJson;
      let minificationSuccess = false;
      let minificationWarning = '';
      
      try {
        // Validate schema structure before minification
        if (!window.currentEventSchema || typeof window.currentEventSchema !== 'object') {
          throw new Error('Invalid schema: not an object');
        }
        if (!window.currentEventSchema['@graph'] || !Array.isArray(window.currentEventSchema['@graph'])) {
          throw new Error('Invalid schema: @graph is not an array');
        }
        
        // Safe minification: use JSON.stringify (lossless, no regex manipulation)
        minifiedJson = JSON.stringify(window.currentEventSchema, null, 0);
        
        // Validate minified version parses correctly (catches syntax errors)
        JSON.parse(minifiedJson);
        
        // Verify it ends correctly (should end with ]} for @graph array)
        if (!minifiedJson.trim().endsWith(']}') && !minifiedJson.trim().endsWith('}}')) {
          throw new Error('Invalid JSON structure: incorrect ending');
        }
        
        minificationSuccess = true;
      } catch (minifyError) {
        // Fallback: use unminified version if minification fails
        console.warn('‚ö†Ô∏è Minify validation failed. Using unminified version for script tag:', minifyError);
        minifiedJson = jsonString;
        minificationSuccess = false;
        minificationWarning = '‚ö†Ô∏è Minification failed - using unminified version';
      }
      
      const fileSizeKB = minifiedJson.length / 1024;
      const isValid = hasContext && hasGraph && fileSizeKB < 250;

      const scriptSrcTag = `<!-- ${schemaType} Schema -->
<script type="application/ld+json"
        src="https://schema.alanranger.com/${fileName}">
<\/script>`;

      const inlineScriptTag = `<!-- ${schemaType} Schema (Inline) -->
<script type="application/ld+json">
${minifiedJson}
<\/script>`;

      navigator.clipboard.writeText(scriptSrcTag).then(() => {
        const exportContent = document.getElementById('schemaExportContent');
        if (exportContent) {
          let statusColor = isValid ? '#10b981' : '#f59e0b';
          let statusBg = isValid ? '#d1fae5' : '#fef3c7';
          let statusText = isValid ? '‚úÖ Ready for Production' : '‚ö†Ô∏è Review Required';
          const warningBadge = minificationWarning ? `<div style="color: #f59e0b; font-size: 0.875rem; margin-bottom: 0.5rem;">${minificationWarning}</div>` : '';

          exportContent.innerHTML = `
            <div style="background: ${statusBg}; padding: 0.75rem; border-radius: 6px; border-left: 3px solid ${statusColor}; margin-bottom: 0.75rem;">
              <strong style="color: ${isValid ? '#065f46' : '#92400e'};">${statusText}</strong><br>
              ${warningBadge}
              <span style="color: #047857; font-size: 0.875rem;">File: <code>${fileName}</code></span><br>
              <span style="color: #047857; font-size: 0.875rem;">Size: ${fileSizeKB.toFixed(2)} KB ${fileSizeKB < 250 ? '‚úÖ' : '‚ö†Ô∏è (exceeds 250 KB)'} ${minificationSuccess ? '(minified)' : '(unminified)'}</span><br>
              <span style="color: #047857; font-size: 0.875rem;">Structure: ${hasContext ? '‚úÖ' : '‚ùå'} @context, ${hasGraph ? '‚úÖ' : '‚ùå'} @graph</span>
            </div>
            <div style="background: #f3f4f6; padding: 0.75rem; border-radius: 6px; font-family: monospace; font-size: 0.75rem; overflow-x: auto; margin-bottom: 0.75rem;">
              <div style="color: #6b7280; margin-bottom: 0.5rem;">üìã External Script Tag (Copied):</div>
              <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word; color: #374151;">${scriptSrcTag}</pre>
              <div style="color: #6b7280; margin-top: 0.5rem; font-size: 0.7rem;">üí° Hosted on GitHub Pages at <a href="https://schema.alanranger.com/${fileName}" target="_blank" style="color: #0369a1;">https://schema.alanranger.com/${fileName}</a></div>
            </div>
            <div style="background: #f3f4f6; padding: 0.75rem; border-radius: 6px; font-family: monospace; font-size: 0.75rem; overflow-x: auto;">
              <div style="color: #6b7280; margin-bottom: 0.5rem;">üìã Inline Script Tag (Alternative):</div>
              <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word; color: #374151; max-height: 200px; overflow-y: auto;">${inlineScriptTag.substring(0, 500)}...</pre>
            </div>
          `;
        }

        addDebugLog(`\nüìã Squarespace Script Tag (GitHub Pages):`);
        addDebugLog(`   ‚úÖ Copied to clipboard`);
        addDebugLog(`   üìù File: ${fileName}`);
        addDebugLog(`   üåê URL: https://schema.alanranger.com/${fileName}`);
        addDebugLog(`   üìä Size: ${fileSizeKB.toFixed(2)} KB ${fileSizeKB < 250 ? '‚úÖ' : '‚ö†Ô∏è (exceeds 250 KB)'} ${minificationSuccess ? '(minified)' : '(unminified)'}`);
        addDebugLog(`   ‚úÖ Structure: @context=${hasContext ? '‚úÖ' : '‚ùå'}, @graph=${hasGraph ? '‚úÖ' : '‚ùå'}`);
        if (minificationWarning) {
          addDebugLog(`   ${minificationWarning}`);
        }
        addDebugLog(`   üí° Hosted on GitHub Pages - ready to use in Squarespace`);
        addDebugLog(`\n   Script tag:`);
        addDebugLog(`   ${scriptSrcTag.split('\n').join('\n   ')}`);

        console.log('‚úÖ Squarespace script src tag copied to clipboard');
      }).catch(err => {
        console.error('‚ùå Error copying to clipboard:', err);
        alert('Error copying to clipboard. Please copy manually from the output above.');
      });
    } catch (error) {
      console.error('‚ùå Error generating script tag:', error);
      alert('Error generating script tag: ' + error.message);
      addDebugLog(`\nüìã Squarespace Script Tag:`);
      addDebugLog(`   ‚ùå Error: ${error.message}`);
    }
  }

  // Export Unminified JSON to GitHub Folder
  async function exportUnminifiedToGitHubFolder() {
    if (!window.currentEventSchema) {
      alert('Please generate event schema first.');
      return;
    }

    const csvType = window.currentEventSchemaCsvType || 'unknown';
    const fileName = csvType === 'workshops' ? 'workshops-schema.json' : 
                     csvType === 'lessons' ? 'lessons-schema.json' : 
                     'event-schema.json';

    try {
      // Generate unminified JSON (with indentation)
      const jsonString = JSON.stringify(window.currentEventSchema, null, 2);
      
      // Validate JSON
      JSON.parse(jsonString);
      
      const githubFolderPath = 'G:\\Dropbox\\alan ranger photography\\Website Code\\Schema Tools\\alanranger-schema';
      
      // Check if we're in Electron mode (can write directly to file system)
      if (typeof window.require !== 'undefined' || typeof require !== 'undefined') {
        try {
          const fs = typeof window.require !== 'undefined' ? window.require('fs') : require('fs');
          const path = typeof window.require !== 'undefined' ? window.require('path') : require('path');
          
          // Ensure directory exists
          const repoDir = path.join(githubFolderPath);
          if (!fs.existsSync(repoDir)) {
            fs.mkdirSync(repoDir, { recursive: true });
          }
          
          // Write file directly to root of repository (GitHub Pages serves from root)
          const filePath = path.join(repoDir, fileName);
          fs.writeFileSync(filePath, jsonString, 'utf-8');
          
          // Open folder in file explorer
          const { shell } = typeof window.require !== 'undefined' ? window.require('electron') : require('electron');
          shell.showItemInFolder(filePath);
          
          addDebugLog(`\nüì• Export to GitHub Folder:`);
          addDebugLog(`   ‚úÖ Saved: ${filePath}`);
          addDebugLog(`   üìÅ Folder opened in Explorer`);
          
          alert(`‚úÖ Successfully saved ${fileName} to GitHub folder!\n\nFolder opened in Explorer.`);
          return;
        } catch (electronError) {
          console.warn('Electron file system access failed, falling back to download:', electronError);
        }
      }
      
      // Fallback: Download file and open folder
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Try to open folder (Windows)
      try {
        // Use PowerShell to open folder
        const openFolderScript = `powershell -Command "Start-Process explorer.exe -ArgumentList '${githubFolderPath.replace(/'/g, "''")}'"`;
        // Note: This won't work in browser, but we can show instructions
        alert(`‚úÖ File downloaded!\n\nPlease save it to:\n${githubFolderPath}\n\nFile name: ${fileName}`);
      } catch (e) {
        alert(`‚úÖ File downloaded!\n\nPlease save it to:\n${githubFolderPath}\n\nFile name: ${fileName}`);
      }
      
      addDebugLog(`\nüì• Export to GitHub Folder:`);
      addDebugLog(`   ‚úÖ Downloaded: ${fileName}`);
      addDebugLog(`   üìÅ Save location: ${githubFolderPath}`);
      
    } catch (error) {
      console.error('‚ùå Error exporting to GitHub folder:', error);
      alert('Error exporting to GitHub folder: ' + error.message);
      addDebugLog(`\nüì• Export to GitHub Folder:`);
      addDebugLog(`   ‚ùå Error: ${error.message}`);
    }
  }

  // Single URL Schema Generation
  let singleUrlReviewsData = null;
  let singleUrlProductData = null;

  async function generateSingleUrlSchema() {
    const urlInput = document.getElementById('singleProductUrl');
    const reviewsFileInput = document.getElementById('singleUrlReviewsFile');
    const output = document.getElementById('singleUrlSchemaOutput');
    const statusDiv = document.getElementById('singleUrlStatus');
    const progressDiv = document.getElementById('singleUrlProgress');
    const outputDiv = document.getElementById('singleUrlOutput');
    const generateBtn = document.getElementById('generateSingleUrlBtn');

    const productUrl = urlInput.value.trim();
    if (!productUrl) {
      alert('Please enter a product URL');
      return;
    }

    // Validate URL format
    try {
      new URL(productUrl);
    } catch (e) {
      alert('Please enter a valid URL (e.g., https://www.alanranger.com/photo-workshops-uk/product-name)');
      return;
    }

    // Show progress
    generateBtn.disabled = true;
    progressDiv.style.display = 'block';
    statusDiv.style.display = 'block';
    statusDiv.textContent = 'üîÑ Fetching product data...';
    updateProgress(progressDiv, 20);

    try {
      // Step 1: Fetch product page HTML
      const html = await fetchProductPage(productUrl);
      updateProgress(progressDiv, 40);
      statusDiv.textContent = 'üìÑ Extracting product data...';

      // Step 2: Extract product data from HTML
      const productData = extractProductDataFromHtml(html, productUrl);
      singleUrlProductData = productData;
      updateProgress(progressDiv, 60);
      statusDiv.textContent = '‚≠ê Loading reviews...';

      // Step 3: Load reviews CSV if provided
      if (reviewsFileInput.files.length > 0) {
        await loadReviewsForSingleUrl(reviewsFileInput.files[0]);
        updateProgress(progressDiv, 80);
        statusDiv.textContent = 'üîó Matching reviews...';
      }

      // Step 4: Match reviews to product
      const matchedReviews = matchReviewsToProduct(productUrl, productData);

      // Step 5: Generate schema
      updateProgress(progressDiv, 90);
      statusDiv.textContent = '‚öôÔ∏è Generating schema...';
      const schema = generateProductSchemaForSingleUrl(productData, matchedReviews);

      // Step 6: Output schema
      const htmlOutput = schemaToHtml(schema, productData.name);
      output.value = htmlOutput;
      outputDiv.style.display = 'block';
      updateProgress(progressDiv, 100);
      statusDiv.textContent = '‚úÖ Schema generated successfully!';
      statusDiv.style.background = '#d4edda';
      statusDiv.style.borderColor = '#c3e6cb';
      statusDiv.style.color = '#155724';

      // Scroll to output
      outputDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    } catch (error) {
      console.error('Error generating schema:', error);
      statusDiv.textContent = `‚ùå Error: ${error.message}`;
      statusDiv.style.background = '#f8d7da';
      statusDiv.style.borderColor = '#f5c6cb';
      statusDiv.style.color = '#721c24';
    } finally {
      generateBtn.disabled = false;
    }
  }

  async function fetchProductPage(url) {
    const log = typeof addLandingDebugLog === 'function' ? addLandingDebugLog : (msg) => console.log(msg);
    
    // List of CORS proxies to try in order
    const corsProxies = [
      { name: 'allorigins.win', url: `https://api.allorigins.win/get?url=${encodeURIComponent(url)}` },
      { name: 'corsproxy.io', url: `https://corsproxy.io/?${encodeURIComponent(url)}` },
      { name: 'codetabs.com', url: `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}` }
    ];
    
    // Try each CORS proxy
    for (const proxy of corsProxies) {
      try {
        log(`   Trying CORS proxy (${proxy.name})...`);
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout per proxy
        
        try {
          const response = await fetch(proxy.url, { 
            signal: controller.signal,
            headers: {
              'Accept': 'application/json'
            }
          });
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`Proxy returned ${response.status}: ${response.statusText}`);
          }
          
          let data;
          if (proxy.name === 'allorigins.win') {
            data = await response.json();
            if (data.contents) {
              log(`   ‚úÖ Successfully fetched via ${proxy.name} (${data.contents.length} characters)`);
              return data.contents;
            } else {
              throw new Error('Proxy returned empty contents');
            }
          } else if (proxy.name === 'corsproxy.io') {
            const html = await response.text();
            if (html && html.length > 100) {
              log(`   ‚úÖ Successfully fetched via ${proxy.name} (${html.length} characters)`);
              return html;
            } else {
              throw new Error('Proxy returned empty or invalid content');
            }
          } else if (proxy.name === 'codetabs.com') {
            const html = await response.text();
            if (html && html.length > 100) {
              log(`   ‚úÖ Successfully fetched via ${proxy.name} (${html.length} characters)`);
              return html;
            } else {
              throw new Error('Proxy returned empty or invalid content');
            }
          }
        } catch (proxyError) {
          clearTimeout(timeoutId);
          if (proxyError.name === 'AbortError') {
            log(`   ‚ö†Ô∏è ${proxy.name} timed out after 20 seconds`);
            continue; // Try next proxy
          }
          log(`   ‚ö†Ô∏è ${proxy.name} failed: ${proxyError.message}`);
          continue; // Try next proxy
        }
      } catch (error) {
        log(`   ‚ö†Ô∏è ${proxy.name} error: ${error.message}`);
        continue; // Try next proxy
      }
    }
    
    // All proxies failed, try direct fetch as last resort
    log(`   ‚ö†Ô∏è All CORS proxies failed, trying direct fetch...`);
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const response = await fetch(url, { 
        mode: 'cors',
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`Direct fetch returned ${response.status}: ${response.statusText}`);
      }
      
      const html = await response.text();
      log(`   ‚úÖ Successfully fetched via direct fetch (${html.length} characters)`);
      return html;
    } catch (directError) {
      log(`   ‚ùå Direct fetch also failed: ${directError.message}`);
      throw new Error(`Failed to fetch page. All CORS proxies timed out and direct fetch failed. Error: ${directError.message}`);
    }
  }

  function extractProductDataFromHtml(html, url) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');

    // Extract product name
    let name = '';
    const nameSelectors = [
      'h1.product-title',
      'h1[data-testid="product-title"]',
      'h1',
      'meta[property="og:title"]',
      'title'
    ];
    for (const selector of nameSelectors) {
      const element = doc.querySelector(selector);
      if (element) {
        name = element.getAttribute('content') || element.textContent.trim();
        if (name) break;
      }
    }

    // Extract description
    let description = '';
    const descSelectors = [
      'meta[name="description"]',
      'meta[property="og:description"]',
      '.product-description',
      '[data-testid="product-description"]'
    ];
    for (const selector of descSelectors) {
      const element = doc.querySelector(selector);
      if (element) {
        description = element.getAttribute('content') || element.textContent.trim();
        if (description) break;
      }
    }

    // Extract image - try multiple strategies
    let image = '';
    
    // Strategy 1: Check meta tags (og:image, twitter:image)
    const metaImageSelectors = [
      'meta[property="og:image"]',
      'meta[name="twitter:image"]',
      'meta[property="og:image:secure_url"]',
      'link[rel="image_src"]'
    ];
    for (const selector of metaImageSelectors) {
      const element = doc.querySelector(selector);
      if (element) {
        image = element.getAttribute('content') || element.getAttribute('href');
        if (image) break;
      }
    }
    
    // Strategy 2: Check existing JSON-LD schema for image
    if (!image) {
      const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
      for (const script of jsonLdScripts) {
        try {
          const jsonLd = JSON.parse(script.textContent);
          const schemas = jsonLd['@graph'] || (Array.isArray(jsonLd) ? jsonLd : [jsonLd]);
          
          for (const schema of schemas) {
            if (schema['@type'] && (schema['@type'].includes('Product') || schema['@type'] === 'Product' || schema['@type'].includes('Course'))) {
              if (schema.image) {
                image = Array.isArray(schema.image) ? schema.image[0] : schema.image;
                if (image) break;
              }
            }
          }
          if (image) break;
        } catch (e) {
          // Skip invalid JSON-LD
        }
      }
    }
    
    // Strategy 3: Check Squarespace-specific selectors
    if (!image) {
      const squarespaceSelectors = [
        '.product-image img',
        '.product-gallery img',
        '[data-testid="product-image"] img',
        '.sqs-image img',
        '.sqs-block-image img',
        'img[itemprop="image"]',
        '.ProductItem-gallery img',
        '.ProductItem-image img'
      ];
      for (const selector of squarespaceSelectors) {
        const element = doc.querySelector(selector);
        if (element) {
          // Check data-src (lazy loading), srcset, or src
          image = element.getAttribute('data-src') || 
                  element.getAttribute('data-image-src') ||
                  element.getAttribute('srcset')?.split(',')[0]?.trim().split(' ')[0] ||
                  element.getAttribute('src');
          if (image) break;
        }
      }
    }
    
    // Strategy 4: Find first large image on page (fallback)
    if (!image) {
      const allImages = doc.querySelectorAll('img');
      for (const img of allImages) {
        const src = img.getAttribute('data-src') || 
                   img.getAttribute('data-image-src') ||
                   img.getAttribute('srcset')?.split(',')[0]?.trim().split(' ')[0] ||
                   img.getAttribute('src');
        if (src) {
          // Skip small images (likely icons/logos)
          const width = parseInt(img.getAttribute('width') || img.getAttribute('data-width') || '0');
          const height = parseInt(img.getAttribute('height') || img.getAttribute('data-height') || '0');
          // If dimensions suggest it's a product image (at least 200x200), use it
          if ((width >= 200 && height >= 200) || (!width && !height)) {
            image = src;
            break;
          }
        }
      }
    }
    
    // Normalize image URL
    if (image) {
      // Remove query parameters that might resize the image
      image = image.split('?')[0];
      
      // Ensure HTTPS and full URL
      if (image.startsWith('//')) {
        image = 'https:' + image;
      } else if (image.startsWith('/')) {
        const urlObj = new URL(url);
        image = urlObj.origin + image;
      } else if (!image.startsWith('http')) {
        const urlObj = new URL(url);
        image = urlObj.origin + '/' + image;
      }
      
      // Ensure HTTPS
      if (image.startsWith('http://')) {
        image = image.replace('http://', 'https://');
      }
    }

    // Extract price
    let price = '';
    const priceSelectors = [
      '.product-price',
      '[data-testid="product-price"]',
      '[itemprop="price"]',
      'meta[property="product:price:amount"]'
    ];
    for (const selector of priceSelectors) {
      const element = doc.querySelector(selector);
      if (element) {
        price = element.getAttribute('content') || element.textContent.trim();
        if (price) {
          // Extract numeric value
          const match = price.match(/[\d.]+/);
          if (match) price = match[0];
          break;
        }
      }
    }

    // Extract SKU
    let sku = '';
    const skuSelectors = [
      '[itemprop="sku"]',
      '.product-sku',
      '[data-testid="product-sku"]',
      'meta[property="product:retailer_item_id"]'
    ];
    for (const selector of skuSelectors) {
      const element = doc.querySelector(selector);
      if (element) {
        sku = element.getAttribute('content') || element.textContent.trim();
        if (sku) break;
      }
    }

    // Extract from existing JSON-LD if present
    const jsonLdScripts = doc.querySelectorAll('script[type="application/ld+json"]');
    for (const script of jsonLdScripts) {
      try {
        const jsonLd = JSON.parse(script.textContent);
        const schemas = jsonLd['@graph'] || (Array.isArray(jsonLd) ? jsonLd : [jsonLd]);
        
        for (const schema of schemas) {
          if (schema['@type'] && (schema['@type'].includes('Product') || schema['@type'] === 'Product')) {
            if (!name && schema.name) name = schema.name;
            if (!description && schema.description) description = schema.description;
            if (!image && schema.image) {
              image = Array.isArray(schema.image) ? schema.image[0] : schema.image;
            }
            if (!sku && schema.sku) sku = schema.sku;
            if (!price && schema.offers && schema.offers.price) {
              price = schema.offers.price;
            }
          }
        }
      } catch (e) {
        // Skip invalid JSON-LD
      }
    }

    // Generate SKU from URL slug if not found
    if (!sku) {
      const urlParts = url.split('/');
      const slug = urlParts[urlParts.length - 1] || urlParts[urlParts.length - 2];
      if (slug) {
        sku = slug.toUpperCase().replace(/[^A-Z0-9-]/g, '').substring(0, 40);
      }
    }

    return {
      name: name || 'Product Name',
      description: description || '',
      image: image || '',
      price: price || '0.00',
      sku: sku || '',
      url: url
    };
  }

  async function loadReviewsForSingleUrl(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => {
        Papa.parse(e.target.result, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            singleUrlReviewsData = results.data;
            resolve(results.data);
          },
          error: (error) => {
            reject(new Error(`Failed to parse reviews CSV: ${error.message}`));
          }
        });
      };
      reader.onerror = () => reject(new Error('Failed to read reviews file'));
      reader.readAsText(file);
    });
  }

  function matchReviewsToProduct(productUrl, productData) {
    if (!singleUrlReviewsData || singleUrlReviewsData.length === 0) {
      return [];
    }

    const matchedReviews = [];
    const urlSlug = productUrl.split('/').pop().toLowerCase();
    const productNameLower = productData.name.toLowerCase();

    for (const review of singleUrlReviewsData) {
      let match = false;

      // Match by URL slug
      if (review.product_slug) {
        const reviewSlug = review.product_slug.toLowerCase();
        if (reviewSlug === urlSlug || reviewSlug.includes(urlSlug) || urlSlug.includes(reviewSlug)) {
          match = true;
        }
      }

      // Match by product name
      if (!match && review.product_name) {
        const reviewName = review.product_name.toLowerCase();
        if (reviewName === productNameLower || reviewName.includes(productNameLower) || productNameLower.includes(reviewName)) {
          match = true;
        }
      }

      // Match by URL
      if (!match && review.product_url) {
        const reviewUrl = review.product_url.toLowerCase();
        if (reviewUrl === productUrl.toLowerCase() || reviewUrl.includes(urlSlug)) {
          match = true;
        }
      }

      if (match) {
        // Filter reviews >= 4 stars
        const rating = parseFloat(review.rating_numeric || review.rating || review.review_stars || 0);
        if (rating >= 4) {
          matchedReviews.push({
            author: review.reviewer || review.review_username || 'Anonymous',
            datePublished: review.date || review.review_created_utc || new Date().toISOString(),
            reviewBody: review.reviewBody || review.review_content || review.review || '',
            reviewRating: {
              '@type': 'Rating',
              ratingValue: rating
            }
          });
        }
      }
    }

    return matchedReviews;
  }

  function generateProductSchemaForSingleUrl(productData, reviews) {
    // Determine schema type (Product or Product+Course)
    const isCourse = productData.url.includes('/beginners-photography-lessons/') || 
                     productData.url.includes('/photo-workshops-uk/') ||
                     productData.name.toLowerCase().includes('course') ||
                     productData.name.toLowerCase().includes('workshop');
    
    const schemaType = isCourse ? ['Product', 'Course'] : ['Product'];

    // Build product schema
    const productSchema = {
      '@type': schemaType,
      '@id': `${productData.url}#schema`,
      name: productData.name,
      sku: productData.sku || '',
      brand: {
        '@type': 'Brand',
        name: 'Alan Ranger Photography'
      },
      url: productData.url
    };

    if (productData.description) {
      const desc = productData.description.substring(0, 600);
      productSchema.description = desc;
    }

    if (productData.image && productData.image.startsWith('https://')) {
      productSchema.image = productData.image;
    }

    // Add provider for Course
    if (isCourse) {
      productSchema.provider = {
        '@type': 'Organization',
        name: 'Alan Ranger Photography',
        sameAs: 'https://www.alanranger.com'
      };
    }

    // Add offers with all merchant fields (matching batch generation)
    const price = parseFloat(productData.price) || 0;
    
    // Calculate priceValidUntil (+12 months from today)
    const today = new Date();
    const priceValidUntilDate = new Date(today);
    priceValidUntilDate.setMonth(priceValidUntilDate.getMonth() + 12);
    const priceValidUntil = priceValidUntilDate.toISOString().split('T')[0]; // YYYY-MM-DD format
    
    productSchema.offers = {
      '@type': 'Offer',
      price: price.toFixed(2),
      priceCurrency: 'GBP',
      availability: 'https://schema.org/InStock',
      url: productData.url,
      priceValidUntil: priceValidUntil,
      seller: {
        '@type': 'Organization',
        name: 'Alan Ranger Photography',
        url: 'https://www.alanranger.com'
      }
    };
    
    // Add shippingDetails (required for Product+Event hybrid, matching batch generation)
    productSchema.offers.shippingDetails = {
      '@type': 'OfferShippingDetails',
      doesNotShip: 'http://schema.org/True',
      shippingDestination: {
        '@type': 'DefinedRegion',
        addressCountry: 'GB'
      }
    };
    
    // Add SKU to offers if available
    if (productData.sku) {
      productSchema.offers.sku = productData.sku.substring(0, 40); // Max 40 chars
    }
    
    // Add hasMerchantReturnPolicy (full object, matching batch generation)
    const returnPolicy = {
      '@type': 'MerchantReturnPolicy',
      returnPolicyCategory: 'http://schema.org/MerchantReturnFiniteReturnWindow',
      merchantReturnDays: 28,
      refundType: 'http://schema.org/FullRefund',
      applicableCountry: 'GB',
      returnMethod: 'http://schema.org/ReturnByMail',
      returnFees: 'https://schema.org/ReturnShippingFees',
      returnShippingFeesAmount: {
        '@type': 'MonetaryAmount',
        value: '50.00',
        currency: 'GBP'
      }
    };
    productSchema.offers.hasMerchantReturnPolicy = returnPolicy;

    // Add reviews if available
    if (reviews.length > 0) {
      // Calculate aggregate rating
      const totalRating = reviews.reduce((sum, r) => sum + parseFloat(r.reviewRating.ratingValue || 0), 0);
      const avgRating = totalRating / reviews.length;

      productSchema.aggregateRating = {
        '@type': 'AggregateRating',
        ratingValue: avgRating.toFixed(1),
        reviewCount: reviews.length
      };

      // Add review snippets (max 5)
      productSchema.review = reviews.slice(0, 5).map(r => ({
        '@type': 'Review',
        author: {
          '@type': 'Person',
          name: r.author
        },
        datePublished: r.datePublished,
        reviewBody: r.reviewBody.substring(0, 300),
        reviewRating: r.reviewRating
      }));
    }

    // Build breadcrumbs
    const urlParts = productData.url.replace('https://www.alanranger.com', '').split('/').filter(p => p);
    const breadcrumbItems = [
      { name: 'Home', position: 1, item: 'https://www.alanranger.com' }
    ];

    let currentPath = 'https://www.alanranger.com';
    urlParts.forEach((part, index) => {
      currentPath += '/' + part;
      const name = part.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
      breadcrumbItems.push({
        name: name,
        position: index + 2,
        item: currentPath
      });
    });

    const breadcrumbList = {
      '@type': 'BreadcrumbList',
      itemListElement: breadcrumbItems.map(item => ({
        '@type': 'ListItem',
        position: item.position,
        name: item.name,
        item: item.item
      }))
    };

    // LocalBusiness (matching batch generation exactly)
    const localBusiness = {
      '@type': 'LocalBusiness',
      name: 'Alan Ranger Photography',
      url: 'https://www.alanranger.com',
      logo: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w',
      image: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w',
      priceRange: '¬£50‚Äì¬£500',
      email: 'info@alanranger.com',
      telephone: '+44 781 701 7994',
      address: {
        '@type': 'PostalAddress',
        streetAddress: '45 Hathaway Road',
        addressLocality: 'Coventry',
        addressRegion: 'West Midlands',
        postalCode: 'CV4 9HW',
        addressCountry: 'GB'
      }
    };

    return {
      '@context': 'https://schema.org',
      '@graph': [localBusiness, breadcrumbList, productSchema]
    };
  }

  function schemaToHtml(schema, productName) {
    const schemaJson = JSON.stringify(schema, null, 2);
    const slug = productName.toLowerCase().replace(/[^a-z0-9]+/g, '-').substring(0, 50);
    const escapedProductName = productName.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    
    const htmlContent = '<!DOCTYPE html>\n' +
      '<html lang="en">\n' +
      '<head>\n' +
      '  <meta charset="UTF-8">\n' +
      '  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n' +
      '  <title>Product Schema - ' + escapedProductName + '</title>\n' +
      '</head>\n' +
      '<body>\n' +
      '  <!-- Squarespace Product Schema Suppressor v1.3 (Code-Block Safe) -->\n' +
      '  <script>\n' +
      '    (function() {\n' +
      '      function suppressSquarespaceSchemas() {\n' +
      '        const scripts = document.querySelectorAll("script[type=\\"application/ld+json\\"]");\n' +
      '        scripts.forEach(function(script) {\n' +
      '          try {\n' +
      '            const data = JSON.parse(script.textContent);\n' +
      '            const schemas = data["@graph"] || (Array.isArray(data) ? data : [data]);\n' +
      '            \n' +
      '            schemas.forEach(function(schema) {\n' +
      '              const types = Array.isArray(schema["@type"]) ? schema["@type"] : [schema["@type"]];\n' +
      '              if (types.includes("Product")) {\n' +
      '                const hasRating = schema.aggregateRating || schema.review;\n' +
      '                const hasOffers = schema.offers;\n' +
      '                const hasReturnPolicy = schema.hasMerchantReturnPolicy;\n' +
      '                const isShort = script.textContent.length < 1500;\n' +
      '                \n' +
      '                if (isShort && !hasRating && hasOffers && !hasReturnPolicy) {\n' +
      '                  script.remove();\n' +
      '                }\n' +
      '              }\n' +
      '            });\n' +
      '          } catch(e) {\n' +
      '            // Skip invalid JSON\n' +
      '          }\n' +
      '        });\n' +
      '      }\n' +
      '      \n' +
      '      suppressSquarespaceSchemas();\n' +
      '      if (document.readyState === "loading") {\n' +
      '        document.addEventListener("DOMContentLoaded", suppressSquarespaceSchemas);\n' +
      '      }\n' +
      '      window.addEventListener("load", suppressSquarespaceSchemas);\n' +
      '      \n' +
      '      const observer = new MutationObserver(suppressSquarespaceSchemas);\n' +
      '      observer.observe(document.body, { childList: true, subtree: true });\n' +
      '    })();\n' +
      '  </' + 'script>\n' +
      '\n' +
      '  <!-- Product Schema -->\n' +
      '  <script type="application/ld+json">\n' +
      schemaJson + '\n' +
      '  </' + 'script>\n' +
      '</body>\n' +
      '</html>';
    
    return htmlContent;
  }

  function updateProgress(progressDiv, percent) {
    const progressBar = progressDiv.querySelector('.progress-bar');
    if (progressBar) {
      progressBar.style.width = percent + '%';
    }
  }

  function clearSingleUrlForm() {
    document.getElementById('singleProductUrl').value = '';
    document.getElementById('singleUrlReviewsFile').value = '';
    document.getElementById('singleUrlSchemaOutput').value = '';
    document.getElementById('singleUrlOutput').style.display = 'none';
    document.getElementById('singleUrlStatus').style.display = 'none';
    document.getElementById('singleUrlProgress').style.display = 'none';
    singleUrlReviewsData = null;
    singleUrlProductData = null;
  }

  function downloadSingleUrlSchema() {
    const output = document.getElementById('singleUrlSchemaOutput');
    const productName = singleUrlProductData ? singleUrlProductData.name : 'product';
    const slug = productName.toLowerCase().replace(/[^a-z0-9]+/g, '-').substring(0, 50);
    const filename = `${slug}_schema_squarespace_ready.html`;
    
    const blob = new Blob([output.value], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Landing / Service Pages Schema Generator
  let landingPageMetadata = null;
  let landingDebugLog = '';

  function addLandingDebugLog(message) {
    const timestamp = new Date().toLocaleTimeString();
    landingDebugLog += `[${timestamp}] ${message}\n`;
    const logContainer = document.getElementById('landingDebugLogContainer');
    const logText = document.getElementById('landingDebugLog');
    if (logContainer && logText) {
      logContainer.style.display = 'block';
      logText.textContent = landingDebugLog;
      // Scroll to bottom
      logContainer.scrollTop = logContainer.scrollHeight;
    }
    console.log(`[Landing Schema] ${message}`);
  }

  function copyLandingDebugLog() {
    if (!landingDebugLog || landingDebugLog.trim() === '') {
      alert('No debug log to copy');
      return;
    }
    
    // Try modern clipboard API first
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(landingDebugLog).then(() => {
        alert('Debug log copied to clipboard!');
      }).catch(err => {
        console.error('Clipboard API failed:', err);
        // Fallback to execCommand
        fallbackCopyDebugLog(landingDebugLog);
      });
    } else {
      // Fallback for older browsers
      fallbackCopyDebugLog(landingDebugLog);
    }
  }
  
  function fallbackCopyDebugLog(text) {
    // Create a temporary textarea
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.left = '-999999px';
    textarea.style.top = '-999999px';
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    
    try {
      const successful = document.execCommand('copy');
      if (successful) {
        alert('Debug log copied to clipboard!');
      } else {
        alert('Failed to copy. Please select and copy manually.');
      }
    } catch (err) {
      console.error('Fallback copy failed:', err);
      alert('Failed to copy. Please select and copy manually.');
    } finally {
      document.body.removeChild(textarea);
    }
  }

  function updateLandingDescriptionCounter() {
    const desc = document.getElementById('landingPageDescription');
    const counter = document.getElementById('landingDescriptionCounter');
    if (desc && counter) {
      const length = desc.value.length;
      counter.textContent = `${length}/170`;
      if (length > 170) {
        counter.style.color = '#dc2626';
      } else if (length > 150) {
        counter.style.color = '#f59e0b';
      } else {
        counter.style.color = '#64748b';
      }
    }
  }

  // Update conditional fields visibility when schema type changes
  document.addEventListener('DOMContentLoaded', function() {
    const schemaTypeSelect = document.getElementById('landingSchemaType');
    if (schemaTypeSelect) {
      schemaTypeSelect.addEventListener('change', function() {
        updateLandingSchemaFields();
      });
    }
    // Initialize description counter
    const desc = document.getElementById('landingPageDescription');
    if (desc) {
      desc.addEventListener('input', updateLandingDescriptionCounter);
      updateLandingDescriptionCounter();
    }
  });

  function updateLandingSchemaFields() {
    const schemaType = document.getElementById('landingSchemaType').value;
    const serviceFields = document.getElementById('landingServiceFields');
    const itemListFields = document.getElementById('landingItemListFields');
    
    if (serviceFields) {
      serviceFields.style.display = (schemaType === 'Service') ? 'block' : 'none';
    }
    if (itemListFields) {
      itemListFields.style.display = (schemaType === 'ItemList') ? 'block' : 'none';
    }
  }

  async function scanLandingPageMetadata() {
    const urlInput = document.getElementById('landingPageUrl');
    const statusDiv = document.getElementById('landingScanStatus');
    const scanBtn = document.getElementById('scanMetadataBtn');
    const progressDiv = document.getElementById('landingScanProgress');
    const progressBar = document.getElementById('landingScanProgressBar');
    
    landingDebugLog = '';
    addLandingDebugLog('üöÄ Starting metadata scan...');
    
    const url = urlInput.value.trim();
    if (!url) {
      alert('Please enter a page URL first');
      addLandingDebugLog('‚ùå Error: No URL provided');
      return;
    }

    // Validate URL format
    try {
      new URL(url);
      addLandingDebugLog(`‚úÖ URL validated: ${url}`);
    } catch (e) {
      alert('Please enter a valid URL');
      addLandingDebugLog(`‚ùå Error: Invalid URL format - ${e.message}`);
      return;
    }

    scanBtn.disabled = true;
    scanBtn.textContent = 'üîÑ Scanning...';
    statusDiv.style.display = 'block';
    statusDiv.textContent = 'üîÑ Fetching page metadata...';
    statusDiv.style.background = '#e0f2fe';
    statusDiv.style.borderColor = '#0ea5e9';
    statusDiv.style.color = '#075985';
    progressDiv.style.display = 'block';
    progressBar.style.width = '20%';

    try {
      addLandingDebugLog('üì° Fetching page HTML...');
      const html = await fetchProductPage(url); // Reuse existing fetch function
      progressBar.style.width = '60%';
      addLandingDebugLog(`‚úÖ Page HTML fetched (${html.length} characters)`);
      
      addLandingDebugLog('üîç Extracting metadata...');
      const metadata = extractLandingPageMetadata(html, url);
      landingPageMetadata = metadata;
      progressBar.style.width = '80%';
      
      addLandingDebugLog(`‚úÖ Title extracted: ${metadata.title || 'Not found'}`);
      addLandingDebugLog(`‚úÖ Description extracted: ${metadata.description ? metadata.description.substring(0, 50) + '...' : 'Not found'}`);
      addLandingDebugLog(`‚úÖ Image extracted: ${metadata.image || 'Not found'}`);

      // Truncate description to 170 chars
      let description = metadata.description || '';
      if (description.length > 170) {
        description = description.substring(0, 170);
        addLandingDebugLog(`‚ö†Ô∏è Description truncated to 170 characters`);
      }

      // Populate form fields
      document.getElementById('landingPageTitle').value = metadata.title || '';
      document.getElementById('landingPageDescription').value = description;
      document.getElementById('landingPageImage').value = metadata.image || '';
      document.getElementById('landingPageUrlFinal').value = url;
      updateLandingDescriptionCounter();

      // Auto-detect schema type
      addLandingDebugLog('üß† Detecting schema type...');
      const detectedType = detectLandingSchemaType(metadata.title, metadata.description, url);
      const schemaTypeSelect = document.getElementById('landingSchemaType');
      if (schemaTypeSelect) {
        schemaTypeSelect.value = 'auto';
        addLandingDebugLog(`‚úÖ Detected schema type: ${detectedType}`);
        // Show detected type in status
        statusDiv.textContent = `‚úÖ Metadata scanned successfully. Detected schema type: ${detectedType}`;
        statusDiv.style.background = '#d4edda';
        statusDiv.style.borderColor = '#c3e6cb';
        statusDiv.style.color = '#155724';
      }

      // Update conditional fields based on detected type
      if (detectedType !== 'auto') {
        schemaTypeSelect.value = detectedType;
        updateLandingSchemaFields();
        addLandingDebugLog(`‚úÖ Schema type set to: ${detectedType}`);
      }
      
      // Scan for existing schema types and show selector panel
      addLandingDebugLog('üîç Scanning for existing schema types...');
      try {
        const existingBlocks = extractJsonLdBlocksFromHtml(html);
        const detectedSchemaTypes = detectSchemaTypesFromBlocks(existingBlocks);
        
        if (detectedSchemaTypes.some(dt => dt.found)) {
          const foundTypes = detectedSchemaTypes.filter(dt => dt.found).map(dt => dt.type);
          addLandingDebugLog(`‚úÖ Found schema types: ${foundTypes.join(', ')}`);
        } else {
          addLandingDebugLog(`‚ÑπÔ∏è No existing schema types detected`);
        }
        
        // Show schema type selector panel
        updateSchemaTypeSelector(detectedSchemaTypes);
        addLandingDebugLog('‚úÖ Schema type selector panel displayed');
        
        // Auto-scan URLs for ItemList if ItemList is detected/selected
        setTimeout(() => {
          const itemListChecked = document.getElementById('schemaType_ItemList')?.checked;
          if (itemListChecked) {
            addLandingDebugLog('üîç ItemList selected - auto-scanning URLs from page...');
            const extractedUrls = extractUrlsFromPage(html, url);
            if (extractedUrls.length > 0) {
              const itemListItemsField = document.getElementById('itemListItems');
              if (itemListItemsField) {
                itemListItemsField.value = extractedUrls.join('\n');
                addLandingDebugLog(`‚úÖ Auto-populated ${extractedUrls.length} URL(s) in ItemList items field`);
                addLandingDebugLog(`   URLs: ${extractedUrls.slice(0, 3).join(', ')}${extractedUrls.length > 3 ? '...' : ''}`);
              }
            } else {
              addLandingDebugLog(`‚ÑπÔ∏è No relevant URLs found on page for ItemList`);
            }
          }
        }, 200);
      } catch (error) {
        addLandingDebugLog(`‚ö†Ô∏è Could not scan schema types: ${error.message}`);
        // Still show panel with empty detection
        const emptyDetection = detectSchemaTypesFromBlocks([]);
        updateSchemaTypeSelector(emptyDetection);
      }
      
      progressBar.style.width = '100%';
      addLandingDebugLog('‚úÖ Metadata scan complete!');
    } catch (error) {
      console.error('Error scanning metadata:', error);
      addLandingDebugLog(`‚ùå Error: ${error.message}`);
      statusDiv.textContent = `‚ùå Error: ${error.message}`;
      statusDiv.style.background = '#f8d7da';
      statusDiv.style.borderColor = '#f5c6cb';
      statusDiv.style.color = '#721c24';
      progressBar.style.width = '0%';
    } finally {
      scanBtn.disabled = false;
      scanBtn.textContent = 'üîç Auto-Scan Metadata';
      setTimeout(() => {
        progressDiv.style.display = 'none';
      }, 1000);
    }
  }

  function extractLandingPageMetadata(html, url) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');

    // Extract title
    let title = '';
    const titleSelectors = [
      'meta[property="og:title"]',
      'meta[name="twitter:title"]',
      'title',
      'h1'
    ];
    for (const selector of titleSelectors) {
      const element = doc.querySelector(selector);
      if (element) {
        title = element.getAttribute('content') || element.textContent.trim();
        if (title) {
          // Clean up title (remove site name suffix if present)
          title = title.replace(/\s*[-|]\s*Alan Ranger Photography.*$/i, '').trim();
          break;
        }
      }
    }

    // Extract description
    let description = '';
    const descSelectors = [
      'meta[name="description"]',
      'meta[property="og:description"]',
      'meta[name="twitter:description"]'
    ];
    for (const selector of descSelectors) {
      const element = doc.querySelector(selector);
      if (element) {
        description = element.getAttribute('content') || '';
        if (description) break;
      }
    }

    // Extract image
    let image = '';
    const imageSelectors = [
      'meta[property="og:image"]',
      'meta[name="twitter:image"]',
      'meta[property="og:image:secure_url"]'
    ];
    for (const selector of imageSelectors) {
      const element = doc.querySelector(selector);
      if (element) {
        image = element.getAttribute('content') || '';
        if (image) {
          // Normalize image URL
          if (image.startsWith('//')) image = 'https:' + image;
          else if (image.startsWith('/')) {
            const urlObj = new URL(url);
            image = urlObj.origin + image;
          }
          if (image.startsWith('http://')) {
            image = image.replace('http://', 'https://');
          }
          break;
        }
      }
    }

    return { title, description, image, url };
  }

  // Extract relevant URLs from page HTML for ItemList
  function extractUrlsFromPage(html, baseUrl) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const baseUrlObj = new URL(baseUrl);
    const baseDomain = baseUrlObj.origin;
    const foundUrls = new Set();
    
    // Find all links on the page
    const links = doc.querySelectorAll('a[href]');
    
    links.forEach(link => {
      let href = link.getAttribute('href');
      if (!href) return;
      
      // Skip anchors, javascript, mailto, tel, etc.
      if (href.startsWith('#') || href.startsWith('javascript:') || 
          href.startsWith('mailto:') || href.startsWith('tel:')) {
        return;
      }
      
      // Normalize URL
      try {
        // Handle relative URLs
        if (href.startsWith('/')) {
          href = baseDomain + href;
        } else if (href.startsWith('./') || !href.startsWith('http')) {
          href = new URL(href, baseUrl).href;
        }
        
        const urlObj = new URL(href);
        
        // Only include URLs from the same domain
        if (urlObj.origin === baseDomain) {
          // Exclude common non-content pages
          const path = urlObj.pathname.toLowerCase();
          const excludePatterns = [
            '/search', '/tag/', '/category/', '/author/', '/feed', 
            '/rss', '/sitemap', '/admin', '/login', '/signup', '/cart',
            '/checkout', '/account', '/settings', '/privacy', '/terms',
            '/contact', '/about', '/home', '/index'
          ];
          
          const shouldExclude = excludePatterns.some(pattern => path.includes(pattern));
          
          // Include if it looks like a content page (has meaningful path segments)
          if (!shouldExclude && path.split('/').filter(p => p && p !== 'index.html').length >= 2) {
            // Remove query params and hash for cleaner URLs
            const cleanUrl = urlObj.origin + urlObj.pathname;
            foundUrls.add(cleanUrl);
          }
        }
      } catch (e) {
        // Skip invalid URLs
      }
    });
    
    // Convert to array, limit to 10 most relevant URLs, and sort
    const urlArray = Array.from(foundUrls)
      .filter(url => url !== baseUrl) // Exclude current page
      .slice(0, 10)
      .sort();
    
    return urlArray;
  }

  function detectLandingSchemaType(title, description, url) {
    const text = ((title || '') + ' ' + (description || '') + ' ' + (url || '')).toLowerCase();
    
    // Service detection keywords (highest priority for service pages)
    // Even if there's a product block, if the page is ABOUT the service, use Service
    const serviceKeywords = ['course', 'tuition', 'workshop', 'training', 'lesson', 'lessons', 'mentoring', 'service', 'private', '1-2-1', 'one-to-one', 'one on one', 'photography lessons', 'photography course'];
    if (serviceKeywords.some(keyword => text.includes(keyword))) {
      return 'Service';
    }

    // WebPage detection keywords (informational content)
    const webpageKeywords = ['guide', 'tips', 'how to', 'tutorial', 'article', 'blog', 'information', 'learn', 'advice'];
    if (webpageKeywords.some(keyword => text.includes(keyword))) {
      return 'WebPage';
    }

    // Product detection keywords (only if page is ABOUT the product, not a service page)
    // Lower priority - don't use Product if service keywords are present
    const productKeywords = ['voucher', 'gift voucher', 'gift card', 'buy now', 'purchase', 'shop', 'store', 'product page'];
    if (productKeywords.some(keyword => text.includes(keyword)) && 
        !serviceKeywords.some(keyword => text.includes(keyword))) {
      return 'Product';
    }

    // ItemList detection (category/gateway pages)
    if (text.includes('category') || text.includes('list') || text.includes('all ') || 
        url.includes('/category/') || url.includes('/all-') || url.includes('/shop') ||
        text.includes('browse') || text.includes('view all')) {
      return 'ItemList';
    }

    // Default to Service for most landing pages (services are more common than products)
    return 'Service';
  }

  // Helper: Detect and normalize schema types from JSON-LD blocks
  function detectSchemaTypesFromBlocks(jsonLdBlocks) {
    const canonicalTypes = ['WebSite', 'Organization', 'LocalBusiness', 'Product', 'Event', 'ItemList', 'Service', 'Person'];
    const detectedTypes = new Set();
    const otherDetectedTypes = new Set(); // For types not in canonical list (like FAQPage)
    
    // Extract all @type values from blocks
    jsonLdBlocks.forEach(block => {
      const extractTypes = (obj) => {
        if (!obj || typeof obj !== 'object') return;
        
        if (obj['@type']) {
          const types = Array.isArray(obj['@type']) ? obj['@type'] : [obj['@type']];
          types.forEach(t => {
            if (canonicalTypes.includes(t)) {
              detectedTypes.add(t);
            } else {
              // Track other types (like FAQPage) but only if they exist
              otherDetectedTypes.add(t);
            }
          });
        }
        
        // Recursively check nested objects
        Object.values(obj).forEach(val => {
          if (Array.isArray(val)) {
            val.forEach(item => extractTypes(item));
          } else if (val && typeof val === 'object') {
            extractTypes(val);
          }
        });
      };
      
      if (block['@graph']) {
        block['@graph'].forEach(item => extractTypes(item));
      } else {
        extractTypes(block);
      }
    });
    
    // Return canonical types (always shown) + other detected types (only if found)
    const result = canonicalTypes.map(type => ({
      type: type,
      found: detectedTypes.has(type)
    }));
    
    // Add other detected types (like FAQPage) - only show if found
    otherDetectedTypes.forEach(type => {
      result.push({
        type: type,
        found: true // Only add if found
      });
    });
    
    return result;
  }

  // Schema type guidance/hints
  const SCHEMA_TYPE_GUIDANCE = {
    WebSite: { hint: 'recommended', icon: '‚úÖ', description: 'Root domain + SearchAction - Always keep' },
    Organization: { hint: 'recommended', icon: '‚úÖ', description: 'Brand and business identity - Always keep' },
    LocalBusiness: { hint: 'recommended', icon: '‚úÖ', description: 'For physical location SEO - Always keep' },
    Product: { hint: 'optional', icon: '‚òê', description: 'For product or gift voucher pages - Only if selling' },
    Event: { hint: 'conditional', icon: '‚ö†', description: 'For individual workshops or classes - May disable on finder pages' },
    ItemList: { hint: 'conditional', icon: '‚úÖ', description: 'For collection/finder pages - Enable on finder pages' },
    Service: { hint: 'recommended', icon: '‚úÖ', description: 'For general offerings (workshops, tuition, mentoring) - Keep' },
    Person: { hint: 'recommended', icon: '‚úÖ', description: 'For author/teacher (Alan Ranger) - Keep' },
    FAQPage: { hint: 'existing only', icon: 'üìã', description: 'Keep existing FAQ schema (cannot add new)' },
    Review: { hint: 'existing only', icon: '‚≠ê', description: 'Keep existing review snippets (nested in Product/Service)' },
    Rating: { hint: 'existing only', icon: '‚≠ê', description: 'Keep existing rating data (nested in Review)' },
    AggregateRating: { hint: 'existing only', icon: '‚≠ê', description: 'Keep existing aggregate rating (nested in Product/Service)' }
  };

  // Update schema type selector UI
  function updateSchemaTypeSelector(detectedTypes) {
    const panel = document.getElementById('schemaTypeSelectorPanel');
    const list = document.getElementById('schemaTypeSelectorList');
    
    if (!panel || !list) return;
    
    // Show panel
    panel.style.display = 'block';
    
    // Clear existing content
    list.innerHTML = '';
    
    // Create checkbox for each schema type
    detectedTypes.forEach(({ type, found }) => {
      // For non-canonical types (like FAQPage), only show if found
      const canonicalTypes = ['WebSite', 'Organization', 'LocalBusiness', 'Product', 'Event', 'ItemList', 'Service', 'Person'];
      if (!canonicalTypes.includes(type) && !found) {
        return; // Skip non-canonical types that weren't found
      }
      
      const guidance = SCHEMA_TYPE_GUIDANCE[type] || { hint: 'optional', icon: '‚òê', description: 'Existing schema type' };
      const checked = found; // Default to checked if found
      
      const item = document.createElement('div');
      item.style.cssText = 'display: flex; align-items: flex-start; gap: 0.75rem; padding: 0.75rem; margin-bottom: 0.5rem; background: white; border-radius: 6px; border: 1px solid #e2e8f0;';
      
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = `schemaType_${type}`;
      checkbox.checked = checked;
      checkbox.style.cssText = 'margin-top: 0.25rem; width: 18px; height: 18px; cursor: pointer;';
      
      const label = document.createElement('label');
      label.htmlFor = `schemaType_${type}`;
      label.style.cssText = 'flex: 1; cursor: pointer; display: flex; align-items: center; gap: 0.5rem;';
      
      const iconSpan = document.createElement('span');
      iconSpan.textContent = guidance.icon;
      iconSpan.style.cssText = 'font-size: 1rem;';
      
      const typeSpan = document.createElement('span');
      typeSpan.textContent = type;
      typeSpan.style.cssText = 'font-weight: 600; color: #1e293b; font-size: 0.95rem;';
      
      const hintSpan = document.createElement('span');
      hintSpan.textContent = `(${guidance.hint})`;
      hintSpan.style.cssText = 'font-size: 0.875rem; color: #64748b; font-style: italic;';
      
      const descDiv = document.createElement('div');
      descDiv.textContent = guidance.description;
      descDiv.style.cssText = 'font-size: 0.8rem; color: #64748b; margin-top: 0.25rem; line-height: 1.4;';
      
      const labelContent = document.createElement('div');
      labelContent.style.cssText = 'display: flex; flex-direction: column; gap: 0.25rem;';
      
      const topRow = document.createElement('div');
      topRow.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';
      topRow.appendChild(iconSpan);
      topRow.appendChild(typeSpan);
      topRow.appendChild(hintSpan);
      
      labelContent.appendChild(topRow);
      labelContent.appendChild(descDiv);
      
      label.appendChild(labelContent);
      
      item.appendChild(checkbox);
      item.appendChild(label);
      
      // Add event listener for ItemList checkbox to show/hide fields
      if (type === 'ItemList') {
        checkbox.addEventListener('change', function() {
          const itemListFields = document.getElementById('landingItemListFields');
          if (itemListFields) {
            itemListFields.style.display = this.checked ? 'block' : 'none';
            addLandingDebugLog(`üìã ItemList checkbox ${this.checked ? 'checked' : 'unchecked'} - fields ${this.checked ? 'shown' : 'hidden'}`);
          }
        });
        // Show fields if checked by default (use setTimeout to ensure DOM is ready)
        if (checked) {
          setTimeout(() => {
            const itemListFields = document.getElementById('landingItemListFields');
            if (itemListFields) {
              itemListFields.style.display = 'block';
              addLandingDebugLog(`üìã ItemList checked by default - showing fields`);
            }
          }, 100);
        }
      }
      
      list.appendChild(item);
    });
  }

  // Get selected schema types from UI
  function getSelectedSchemaTypes() {
    const selected = [];
    
    // Get all checkboxes (including non-canonical types like FAQPage)
    const canonicalTypes = ['WebSite', 'Organization', 'LocalBusiness', 'Product', 'Event', 'ItemList', 'Service', 'Person'];
    const allTypes = [...canonicalTypes];
    
    // Also check for any other types that might be in the UI (like FAQPage)
    const allCheckboxes = document.querySelectorAll('[id^="schemaType_"]');
    allCheckboxes.forEach(checkbox => {
      const type = checkbox.id.replace('schemaType_', '');
      if (!allTypes.includes(type)) {
        allTypes.push(type);
      }
    });
    
    allTypes.forEach(type => {
      const checkbox = document.getElementById(`schemaType_${type}`);
      if (checkbox && checkbox.checked) {
        selected.push(type);
      }
    });
    
    return selected;
  }

  async function generateLandingSchema() {
    landingDebugLog = '';
    addLandingDebugLog('üöÄ Starting enhanced schema generation with analysis...');
    
    const title = document.getElementById('landingPageTitle').value.trim();
    const description = document.getElementById('landingPageDescription').value.trim();
    const image = document.getElementById('landingPageImage').value.trim();
    const url = document.getElementById('landingPageUrlFinal').value.trim();
    const schemaType = document.getElementById('landingSchemaType').value;
    const outputDiv = document.getElementById('landingSchemaOutput');
    const outputText = document.getElementById('landingSchemaOutputText');
    const progressDiv = document.getElementById('landingGenerateProgress');
    const progressBar = document.getElementById('landingGenerateProgressBar');
    const generateBtn = document.getElementById('generateLandingBtn');

    // Validation
    if (!title) {
      alert('Please enter a page title');
      addLandingDebugLog('‚ùå Error: Page title is required');
      return;
    }
    if (!url) {
      alert('Please enter a canonical URL');
      addLandingDebugLog('‚ùå Error: Canonical URL is required');
      return;
    }

    // Validate URL format
    try {
      new URL(url);
      addLandingDebugLog(`‚úÖ URL validated: ${url}`);
    } catch (e) {
      alert('Please enter a valid canonical URL');
      addLandingDebugLog(`‚ùå Error: Invalid URL format - ${e.message}`);
      return;
    }

    generateBtn.disabled = true;
    progressDiv.style.display = 'block';
    progressBar.style.width = '10%';
    addLandingDebugLog(`üìã Inputs: Title="${title}", Description length=${description.length}, Image=${image ? 'Yes' : 'No'}, Schema Type="${schemaType}"`);

    // STEP 1: Fetch and analyze existing schema on page
    let existingSchemas = [];
    let existingSchemaTypes = [];
    let existingAnalysis = null;
    let detectedSchemaTypes = [];
    
    try {
      addLandingDebugLog('');
      addLandingDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      addLandingDebugLog('üìä STEP 1: Analyzing existing schema on page...');
      progressBar.style.width = '20%';
      
      const html = await fetchProductPage(url);
      addLandingDebugLog(`üì° Fetched HTML (${html.length} characters)`);
      addLandingDebugLog(`üîç Searching for JSON-LD blocks...`);
      
      const existingBlocks = extractJsonLdBlocksFromHtml(html);
      
      if (existingBlocks.length > 0) {
        existingSchemas = existingBlocks;
        existingSchemaTypes = extractSchemaTypes(existingBlocks);
        existingAnalysis = analyzeSchemas(existingBlocks, url);
        
        // Detect normalized schema types for selector panel
        detectedSchemaTypes = detectSchemaTypesFromBlocks(existingBlocks);
        
        addLandingDebugLog(`‚úÖ Found ${existingBlocks.length} existing schema block(s)`);
        addLandingDebugLog(`üìã Existing schema types: ${existingSchemaTypes.join(', ') || 'None'}`);
        
        // Log each schema found for debugging
        existingBlocks.forEach((block, idx) => {
          const types = Array.isArray(block['@type']) ? block['@type'].join(', ') : block['@type'];
          const id = block['@id'] || block.url || 'no @id';
          addLandingDebugLog(`   Block ${idx + 1}: ${types} (@id: ${id})`);
        });
        
        if (existingAnalysis.schemas && existingAnalysis.schemas.length > 0) {
          addLandingDebugLog(`üìä Schema analysis:`);
          existingAnalysis.schemas.forEach((s, idx) => {
            const typeStr = Array.isArray(s.type) ? s.type.join(', ') : s.type;
            addLandingDebugLog(`   ${idx + 1}. ${typeStr}: ${s.missingFields?.length || 0} missing fields, ${s.warnings?.length || 0} warnings`);
          });
        }
        
        if (existingAnalysis.missingFields && existingAnalysis.missingFields.length > 0) {
          addLandingDebugLog(`‚ö†Ô∏è Missing fields detected: ${existingAnalysis.missingFields.length}`);
        }
        
        // Note: Schema type selector will be shown by scanLandingPageMetadata() if user scans first
        // If generating without scanning, show selector here
        if (!document.getElementById('schemaTypeSelectorPanel') || 
            document.getElementById('schemaTypeSelectorPanel').style.display === 'none') {
          updateSchemaTypeSelector(detectedSchemaTypes);
        }
      } else {
        addLandingDebugLog(`‚ÑπÔ∏è No existing schema found on page - will generate new schema`);
        addLandingDebugLog(`   (Searched for <script type="application/ld+json"> tags)`);
        // Initialize selector with all unchecked (only if panel not already shown)
        if (!document.getElementById('schemaTypeSelectorPanel') || 
            document.getElementById('schemaTypeSelectorPanel').style.display === 'none') {
          detectedSchemaTypes = detectSchemaTypesFromBlocks([]);
          updateSchemaTypeSelector(detectedSchemaTypes);
        }
      }
    } catch (error) {
      addLandingDebugLog(`‚ö†Ô∏è Could not fetch page for analysis: ${error.message}`);
      addLandingDebugLog(`   Continuing with new schema generation...`);
      // Initialize selector with all unchecked (only if panel not already shown)
      if (!document.getElementById('schemaTypeSelectorPanel') || 
          document.getElementById('schemaTypeSelectorPanel').style.display === 'none') {
        detectedSchemaTypes = detectSchemaTypesFromBlocks([]);
        updateSchemaTypeSelector(detectedSchemaTypes);
      }
    }

    progressBar.style.width = '40%';

    // Truncate description to 170 chars
    let finalDescription = description;
    if (finalDescription.length > 170) {
      finalDescription = finalDescription.substring(0, 170);
      addLandingDebugLog(`‚ö†Ô∏è Description truncated to 170 characters`);
    }

    // STEP 2: Determine actual schema type (auto-detect if needed)
    addLandingDebugLog('');
    addLandingDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    addLandingDebugLog('üß† STEP 2: Determining schema type...');
    
    let actualSchemaType = schemaType;
    if (schemaType === 'auto') {
      actualSchemaType = detectLandingSchemaType(title, description, url);
      addLandingDebugLog(`‚úÖ Auto-detected schema type: ${actualSchemaType}`);
    } else {
      addLandingDebugLog(`‚úÖ Using manual schema type: ${actualSchemaType}`);
    }
    
    // Compare with existing
    if (existingSchemaTypes.length > 0) {
      const existingMatches = existingSchemaTypes.filter(t => 
        t.toLowerCase() === actualSchemaType.toLowerCase() || 
        (actualSchemaType === 'Service' && t.toLowerCase().includes('service'))
      );
      if (existingMatches.length > 0) {
        addLandingDebugLog(`‚úÖ Existing ${existingMatches.join(', ')} schema found - will enhance it`);
      } else {
        addLandingDebugLog(`‚ÑπÔ∏è Existing types (${existingSchemaTypes.join(', ')}) differ from target (${actualSchemaType}) - will add new schema`);
      }
    }

    progressBar.style.width = '60%';

    // STEP 3: Get selected schema types from UI
    const selectedTypes = getSelectedSchemaTypes();
    addLandingDebugLog('');
    addLandingDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    addLandingDebugLog(`üéØ Schema Types Selected: ${selectedTypes.length > 0 ? selectedTypes.join(', ') : 'None (all will be included)'}`);
    addLandingDebugLog(`üîç Debug: selectedTypes array = [${selectedTypes.map(t => `'${t}'`).join(', ')}]`);
    addLandingDebugLog(`üîç Debug: ItemList in selectedTypes? ${selectedTypes.includes('ItemList')}`);
    
    if (selectedTypes.length === 0) {
      addLandingDebugLog(`‚ö†Ô∏è No schema types selected - will include all detected types`);
    }

    // STEP 4: Generate new/enhanced schema
    addLandingDebugLog('');
    addLandingDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    addLandingDebugLog('‚öôÔ∏è STEP 4: Generating enhanced schema...');
    
    let schema;
    let additionalSchemas = []; // For schemas requested via checkbox but not in dropdown
    
    try {
      switch (actualSchemaType) {
        case 'Service':
          schema = generateServiceSchema(title, finalDescription, image, url);
          break;
        case 'ItemList':
          schema = generateItemListSchema(title, finalDescription, image, url);
          break;
        case 'WebPage':
          schema = generateWebPageSchema(title, finalDescription, image, url);
          break;
        case 'Product':
          schema = generateSimplifiedProductSchema(title, finalDescription, image, url);
          break;
        default:
          schema = generateServiceSchema(title, finalDescription, image, url);
          addLandingDebugLog(`‚ö†Ô∏è Unknown schema type, defaulting to Service`);
      }
      addLandingDebugLog(`‚úÖ New schema generated successfully`);
      
      // Check if ItemList is selected in checkbox but not generated as main schema
      addLandingDebugLog(`üîç Checking ItemList: selectedTypes.includes('ItemList')=${selectedTypes.includes('ItemList')}, actualSchemaType='${actualSchemaType}'`);
      if (selectedTypes.includes('ItemList') && actualSchemaType !== 'ItemList') {
        addLandingDebugLog(`üìã ItemList selected in checkbox - checking for items...`);
        const itemListItemsField = document.getElementById('itemListItems');
        const itemListItems = itemListItemsField ? itemListItemsField.value.trim() : '';
        addLandingDebugLog(`   ItemList items field value: "${itemListItems.substring(0, 50)}${itemListItems.length > 50 ? '...' : ''}" (${itemListItems.length} chars)`);
        
        if (itemListItems) {
          addLandingDebugLog(`üìã ItemList selected in checkbox - generating additional ItemList schema`);
          const itemListSchema = generateItemListSchema(title, finalDescription, image, url);
          additionalSchemas.push(itemListSchema);
          addLandingDebugLog(`‚úÖ Additional ItemList schema generated with ${itemListSchema.itemListElement.length} items`);
        } else {
          addLandingDebugLog(`‚ö†Ô∏è ItemList selected but no items provided in ItemList fields`);
          addLandingDebugLog(`   üí° Tip: Check ItemList in selector to show the items field, then enter URLs`);
        }
      }
    } catch (error) {
      addLandingDebugLog(`‚ùå Error generating schema: ${error.message}`);
      alert(`Error generating schema: ${error.message}`);
      progressBar.style.width = '0%';
      generateBtn.disabled = false;
      return;
    }

    progressBar.style.width = '80%';

    // STEP 5: Merge and enhance with existing schemas (filtered by selected types)
    addLandingDebugLog('');
    addLandingDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    addLandingDebugLog('üîß STEP 5: Merging and enhancing schemas...');
    
    let finalSchema;
    let improvements = [];
    
    // Helper function to check if a schema matches selected types
    const matchesSelectedTypes = (block) => {
      if (selectedTypes.length === 0) return true; // Include all if none selected
      
      const blockTypes = Array.isArray(block['@type']) ? block['@type'] : [block['@type']];
      return blockTypes.some(t => selectedTypes.includes(t));
    };
    
    if (existingSchemas.length > 0) {
      // Filter existing schemas by selected types
      const filteredExistingSchemas = existingSchemas.filter(matchesSelectedTypes);
      
      if (filteredExistingSchemas.length < existingSchemas.length) {
        const excluded = existingSchemas.length - filteredExistingSchemas.length;
        addLandingDebugLog(`üîç Filtered out ${excluded} schema(s) based on selected types`);
      }
      
      // Build enhanced schema graph that merges existing + new AND actually enhances
      const allBlocks = [...filteredExistingSchemas];
      
      // Only add new schema if its type is selected
      if (matchesSelectedTypes(schema)) {
        allBlocks.push(schema);
      } else {
        addLandingDebugLog(`üîç Excluding new ${actualSchemaType} schema (not in selected types)`);
      }
      
      // Add any additional schemas (like ItemList when checked but not main schema type)
      additionalSchemas.forEach(additionalSchema => {
        if (matchesSelectedTypes(additionalSchema)) {
          allBlocks.push(additionalSchema);
          const itemCount = additionalSchema.itemListElement ? additionalSchema.itemListElement.length : 0;
          addLandingDebugLog(`‚úÖ Added additional ${additionalSchema['@type']} schema${itemCount > 0 ? ` with ${itemCount} items` : ''}`);
        } else {
          addLandingDebugLog(`üîç Excluding additional ${additionalSchema['@type']} schema (not in selected types)`);
        }
      });
      
      // Enhance schemas before merging - add missing fields, improve data quality
      const enhancedBlocks = allBlocks.map(block => {
        const enhanced = JSON.parse(JSON.stringify(block)); // Deep clone
        
        // Enhance Service schemas
        if (enhanced['@type'] === 'Service' || (Array.isArray(enhanced['@type']) && enhanced['@type'].includes('Service'))) {
          // Add missing recommended fields
          if (!enhanced.provider || !enhanced.provider['@id']) {
            enhanced.provider = {
              '@id': 'https://www.alanranger.com/#org',
              '@type': 'Organization',
              name: 'Alan Ranger Photography',
              url: 'https://www.alanranger.com'
            };
          }
          if (!enhanced.areaServed) {
            enhanced.areaServed = {
              '@type': 'Country',
              name: 'GB'
            };
          }
          // Ensure @id for page-specific Service
          if (!enhanced['@id'] && enhanced.url) {
            enhanced['@id'] = `${enhanced.url}#schema`;
          }
        }
        
        // Enhance Organization/LocalBusiness
        if (enhanced['@id'] === 'https://www.alanranger.com/#org' || 
            (Array.isArray(enhanced['@type']) && enhanced['@type'].includes('Organization'))) {
          if (!enhanced.telephone) {
            enhanced.telephone = '+44 7817 017994';
          }
          if (!enhanced.image) {
            enhanced.image = 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w';
          }
        }
        
        return enhanced;
      });
      
      finalSchema = buildEnhancedSchema(enhancedBlocks, selectedTypes);
      
      // Track improvements
      const newSchemaTypes = extractSchemaTypes([schema]);
      const finalSchemaTypes = extractSchemaTypes(finalSchema['@graph'] || [finalSchema]);
      
      improvements.push(`‚úÖ Merged ${existingSchemas.length} existing schema(s) with new ${actualSchemaType} schema`);
      improvements.push(`üìä Final schema types: ${finalSchemaTypes.join(', ')}`);
      
      // Count deduplications
      const beforeUniqueTypes = new Set(existingSchemaTypes);
      const afterUniqueTypes = new Set(finalSchemaTypes);
      const deduplicated = existingSchemas.length - (finalSchema['@graph'] || [finalSchema]).length;
      if (deduplicated > 0) {
        improvements.push(`‚úÖ Deduplicated ${deduplicated} duplicate schema(s)`);
      }
      
      // Compare field completeness
      if (existingAnalysis && existingAnalysis.missingFields) {
        const beforeMissing = existingAnalysis.missingFields.length;
        const afterAnalysis = analyzeSchemas(finalSchema['@graph'] || [finalSchema], url);
        const afterMissing = afterAnalysis.missingFields?.length || 0;
        
        if (afterMissing < beforeMissing) {
          improvements.push(`‚úÖ Reduced missing fields from ${beforeMissing} to ${afterMissing}`);
        } else if (afterMissing === 0 && beforeMissing > 0) {
          improvements.push(`‚úÖ All missing fields resolved!`);
        }
      }
      
      addLandingDebugLog(`‚úÖ Schema merged and enhanced`);
      improvements.forEach(imp => addLandingDebugLog(`   ${imp}`));
    } else {
      // No existing schema - use new one as-is (if selected)
      const schemaTypes = Array.isArray(schema['@type']) ? schema['@type'] : [schema['@type']];
      const schemaMatches = selectedTypes.length === 0 || schemaTypes.some(t => selectedTypes.includes(t));
      
      if (schemaMatches) {
        // Combine main schema with additional schemas if any
        if (additionalSchemas.length > 0) {
          const allSchemas = [schema, ...additionalSchemas];
          finalSchema = buildEnhancedSchema(allSchemas, selectedTypes);
          addLandingDebugLog(`‚úÖ Using new schema with ${additionalSchemas.length} additional schema(s)`);
        } else {
          finalSchema = schema;
          addLandingDebugLog(`‚úÖ Using new schema (no existing schema to merge)`);
        }
      } else {
        // Check if we have additional schemas even if main schema not selected
        if (additionalSchemas.length > 0) {
          finalSchema = buildEnhancedSchema(additionalSchemas, selectedTypes);
          addLandingDebugLog(`‚úÖ Using ${additionalSchemas.length} additional schema(s) only`);
        } else {
          // Create empty schema structure if new schema type not selected
          finalSchema = { '@context': 'https://schema.org', '@graph': [] };
          addLandingDebugLog(`‚ö†Ô∏è New schema type not selected - creating empty schema structure`);
        }
      }
    }

    // STEP 6: Format and display
    addLandingDebugLog('');
    addLandingDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    addLandingDebugLog('üìÑ STEP 6: Formatting final schema...');
    
    try {
      const schemaJson = JSON.stringify(finalSchema, null, 2);
      
      if (!outputText) {
        addLandingDebugLog(`‚ùå Error: Output text element not found`);
        console.error('Output text element not found!');
        alert('Error: Output element not found');
        return;
      }
      if (!outputDiv) {
        addLandingDebugLog(`‚ùå Error: Output div element not found`);
        console.error('Output div element not found!');
        alert('Error: Output div element not found');
        return;
      }
      
      outputText.textContent = schemaJson;
      outputDiv.style.display = 'block';
      progressBar.style.width = '100%';
      
      // Build and display results table
      const resultsPanel = document.getElementById('landingSchemaResultsPanel');
      const resultsTableBody = document.getElementById('landingSchemaResultsTableBody');
      
      if (resultsPanel && resultsTableBody) {
        resultsTableBody.innerHTML = '';
        
        // Get final schema types
        const finalSchemaTypes = extractSchemaTypes(finalSchema['@graph'] || [finalSchema]);
        const finalTypesSet = new Set(finalSchemaTypes);
        const beforeTypesSet = new Set(existingSchemaTypes);
        
        // Create a map of existing schemas by @id or URL for accurate comparison
        const existingSchemasMap = new Map();
        existingSchemas.forEach(schema => {
          const processSchema = (s) => {
            if (!s || !s['@type']) return;
            const id = s['@id'] || s.url || s.name || JSON.stringify(s);
            const types = Array.isArray(s['@type']) ? s['@type'] : [s['@type']];
            types.forEach(type => {
              if (!existingSchemasMap.has(type)) {
                existingSchemasMap.set(type, []);
              }
              existingSchemasMap.get(type).push({ schema: s, id: id });
            });
            // Check nested objects
            Object.values(s).forEach(val => {
              if (typeof val === 'object' && val !== null && !Array.isArray(val) && val['@type']) {
                processSchema(val);
              } else if (Array.isArray(val)) {
                val.forEach(item => {
                  if (typeof item === 'object' && item !== null && item['@type']) {
                    processSchema(item);
                  }
                });
              }
            });
          };
          processSchema(schema);
        });
        
        // Create a map of final schemas by @id or URL
        const finalSchemasMap = new Map();
        const finalSchemas = finalSchema['@graph'] || [finalSchema];
        finalSchemas.forEach(schema => {
          const processSchema = (s) => {
            if (!s || !s['@type']) return;
            const id = s['@id'] || s.url || s.name || JSON.stringify(s);
            const types = Array.isArray(s['@type']) ? s['@type'] : [s['@type']];
            types.forEach(type => {
              if (!finalSchemasMap.has(type)) {
                finalSchemasMap.set(type, []);
              }
              finalSchemasMap.get(type).push({ schema: s, id: id });
            });
            // Check nested objects
            Object.values(s).forEach(val => {
              if (typeof val === 'object' && val !== null && !Array.isArray(val) && val['@type']) {
                processSchema(val);
              } else if (Array.isArray(val)) {
                val.forEach(item => {
                  if (typeof item === 'object' && item !== null && item['@type']) {
                    processSchema(item);
                  }
                });
              }
            });
          };
          processSchema(schema);
        });
        
        // Combine all types (before + after) for comparison
        const allTypes = [...new Set([...existingSchemaTypes, ...finalSchemaTypes])];
        
        if (allTypes.length > 0) {
          allTypes.forEach(type => {
            const row = document.createElement('tr');
            const beforeSchemas = existingSchemasMap.get(type) || [];
            const afterSchemas = finalSchemasMap.get(type) || [];
            const beforeExists = beforeSchemas.length > 0;
            const afterExists = afterSchemas.length > 0;
            
            let status = '';
            let statusColor = '';
            let enhancementSummary = '';
            
            if (!beforeExists && afterExists) {
              // New schema type added
              status = '‚úÖ Added';
              statusColor = '#10b981';
              const schema = afterSchemas[0].schema;
              const fields = Object.keys(schema).filter(k => !k.startsWith('@'));
              const count = afterSchemas.length > 1 ? ` (${afterSchemas.length} instances)` : '';
              enhancementSummary = `New schema${count} with ${fields.length} fields: ${fields.slice(0, 4).join(', ')}${fields.length > 4 ? '...' : ''}`;
            } else if (beforeExists && afterExists) {
              // Compare schemas to see if they're the same or new instances
              const beforeIds = new Set(beforeSchemas.map(s => s.id));
              const afterIds = new Set(afterSchemas.map(s => s.id));
              
              // Find truly new schemas (not in before)
              const newSchemas = afterSchemas.filter(s => !beforeIds.has(s.id));
              // Find existing schemas that were enhanced
              const enhancedSchemas = afterSchemas.filter(s => beforeIds.has(s.id));
              
              if (newSchemas.length > 0 && enhancedSchemas.length > 0) {
                status = 'üîß Enhanced + Added';
                statusColor = '#3b82f6';
                enhancementSummary = `Enhanced ${enhancedSchemas.length} existing, added ${newSchemas.length} new instance(s)`;
              } else if (newSchemas.length > 0) {
                status = '‚úÖ Added';
                statusColor = '#10b981';
                enhancementSummary = `Added ${newSchemas.length} new instance(s) (${beforeSchemas.length} already existed)`;
              } else if (enhancedSchemas.length > 0) {
                // Compare fields to see what was actually enhanced
                const beforeSchema = beforeSchemas.find(s => beforeIds.has(enhancedSchemas[0].id))?.schema;
                const afterSchema = enhancedSchemas[0].schema;
                
                if (beforeSchema && afterSchema) {
                  const beforeFields = new Set(Object.keys(beforeSchema).filter(k => !k.startsWith('@')));
                  const afterFields = new Set(Object.keys(afterSchema).filter(k => !k.startsWith('@')));
                  
                  const addedFields = [...afterFields].filter(f => !beforeFields.has(f));
                  const improvedFields = [];
                  
                  // Check for field improvements (non-empty values added)
                  beforeFields.forEach(field => {
                    const beforeVal = beforeSchema[field];
                    const afterVal = afterSchema[field];
                    if ((!beforeVal || (typeof beforeVal === 'string' && beforeVal.trim() === '')) && 
                        afterVal && (typeof afterVal !== 'string' || afterVal.trim() !== '')) {
                      improvedFields.push(field);
                    }
                  });
                  
                  const enhancements = [];
                  if (addedFields.length > 0) {
                    enhancements.push(`Added: ${addedFields.slice(0, 3).join(', ')}${addedFields.length > 3 ? '...' : ''}`);
                  }
                  if (improvedFields.length > 0) {
                    enhancements.push(`Improved: ${improvedFields.slice(0, 3).join(', ')}${improvedFields.length > 3 ? '...' : ''}`);
                  }
                  if (addedFields.length === 0 && improvedFields.length === 0) {
                    enhancements.push('Merged/consolidated (no field changes)');
                  }
                  
                  status = 'üîß Enhanced';
                  statusColor = '#3b82f6';
                  enhancementSummary = enhancements.length > 0 ? enhancements.join('; ') : 'Merged and normalized';
                } else {
                  status = 'üîß Enhanced';
                  statusColor = '#3b82f6';
                  enhancementSummary = 'Merged with enhanced schema';
                }
              } else {
                status = 'üîß Merged';
                statusColor = '#3b82f6';
                enhancementSummary = 'Consolidated (no changes detected)';
              }
            } else if (beforeExists && !afterExists) {
              status = '‚ö†Ô∏è Removed';
              statusColor = '#ef4444';
              enhancementSummary = 'Schema type removed during merge';
            } else {
              status = '‚Äî';
              statusColor = '#64748b';
              enhancementSummary = '‚Äî';
            }
            
            row.innerHTML = `
              <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; font-weight: 500; color: #1e293b;">${type}</td>
              <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: center;">
                ${beforeExists ? `<span style="color: #10b981; font-weight: 600;">‚úì</span>${beforeSchemas.length > 1 ? ` <span style="color: #64748b; font-size: 0.75rem;">(${beforeSchemas.length})</span>` : ''}` : '<span style="color: #94a3b8;">‚Äî</span>'}
              </td>
              <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; text-align: center;">
                ${afterExists ? `<span style="color: #10b981; font-weight: 600;">‚úì</span>${afterSchemas.length > 1 ? ` <span style="color: #64748b; font-size: 0.75rem;">(${afterSchemas.length})</span>` : ''}` : '<span style="color: #94a3b8;">‚Äî</span>'}
              </td>
              <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; color: ${statusColor}; font-weight: 500;">${status}</td>
              <td style="padding: 0.75rem; border-bottom: 1px solid #e2e8f0; color: #475569; font-size: 0.8125rem; line-height: 1.4;">${enhancementSummary}</td>
            `;
            resultsTableBody.appendChild(row);
          });
          resultsPanel.style.display = 'block';
        } else {
          // No types found - show message
          const row = document.createElement('tr');
          row.innerHTML = `
            <td colspan="5" style="padding: 0.75rem; text-align: center; color: #64748b; border-bottom: 1px solid #e2e8f0;">
              No schema types to compare
            </td>
          `;
          resultsTableBody.appendChild(row);
          resultsPanel.style.display = 'block';
        }
      }
      
      // Build schema output with suppressor code at the top
      const suppressorCode = '<!-- Squarespace Product Schema Suppressor v1.3 (Code-Block Safe) -->\n\n' +
        '<script>\n' +
        '(function(){\n' +
        '  // Remove Squarespace\'s built-in, short Product JSON-LD\n' +
        '  const removeSquarespaceProduct = () => {\n' +
        '    document.querySelectorAll(\'script[type="application/ld+json"]\').forEach(el => {\n' +
        '      const txt = el.textContent.trim();\n' +
        '      if (txt.includes(\'"@type":"Product"\')) {\n' +
        '        try {\n' +
        '          const j = JSON.parse(txt);\n' +
        '          const looksLikeSquarespace =\n' +
        '            txt.length < 1500 &&\n' +
        '            !j.aggregateRating &&\n' +
        '            !j.review &&\n' +
        '            j.offers &&\n' +
        '            j.name &&\n' +
        '            !txt.includes(\'"hasMerchantReturnPolicy"\');\n' +
        '          if (looksLikeSquarespace) el.remove();\n' +
        '        } catch(e){}\n' +
        '      }\n' +
        '    });\n' +
        '  };\n' +
        '  // Run several times to catch async Squarespace hydration\n' +
        '  removeSquarespaceProduct();\n' +
        '  document.addEventListener(\'DOMContentLoaded\', removeSquarespaceProduct);\n' +
        '  window.addEventListener(\'load\', () => setTimeout(removeSquarespaceProduct, 1000));\n' +
        '  const obs = new MutationObserver(removeSquarespaceProduct);\n' +
        '  obs.observe(document.documentElement, { childList: true, subtree: true });\n' +
        '})();\n' +
        '<' + '/script>\n\n' +
        '<script type="application/ld+json">\n' +
        schemaJson + '\n' +
        '<' + '/script>';
      
      outputText.textContent = suppressorCode;
      
      addLandingDebugLog(`‚úÖ Schema formatted and displayed (${suppressorCode.length} characters)`);
      addLandingDebugLog(`   Includes Schema Suppressor v1.3 to prevent duplicate Squarespace schemas`);
      addLandingDebugLog('');
      addLandingDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      addLandingDebugLog('‚úÖ SCHEMA GENERATION COMPLETE!');
      addLandingDebugLog('');
      addLandingDebugLog('üìä SUMMARY:');
      if (existingSchemas.length > 0) {
        addLandingDebugLog(`   ‚Ä¢ Analyzed ${existingSchemas.length} existing schema block(s)`);
        addLandingDebugLog(`   ‚Ä¢ Found types: ${existingSchemaTypes.join(', ')}`);
        addLandingDebugLog(`   ‚Ä¢ Generated enhanced ${actualSchemaType} schema`);
        addLandingDebugLog(`   ‚Ä¢ Merged existing + new schemas`);
        improvements.forEach(imp => addLandingDebugLog(`   ‚Ä¢ ${imp.replace('‚úÖ ', '').replace('üìä ', '')}`));
      } else {
        addLandingDebugLog(`   ‚Ä¢ No existing schema found`);
        addLandingDebugLog(`   ‚Ä¢ Generated new ${actualSchemaType} schema`);
      }
      
      outputDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    } catch (error) {
      addLandingDebugLog(`‚ùå Error formatting schema: ${error.message}`);
      console.error('Error formatting schema:', error);
      alert(`Error formatting schema: ${error.message}`);
      progressBar.style.width = '0%';
    } finally {
      generateBtn.disabled = false;
      setTimeout(() => {
        progressDiv.style.display = 'none';
      }, 1000);
    }
  }

  function generateServiceSchema(title, description, image, url) {
    addLandingDebugLog('  Building Service schema...');
    const areaServed = document.getElementById('serviceAreaServed').value.trim() || 'GB';
    const servicePrice = parseFloat(document.getElementById('servicePrice').value) || null;

    addLandingDebugLog(`  - Area served: ${areaServed}`);
    if (servicePrice) {
      addLandingDebugLog(`  - Service price: ¬£${servicePrice.toFixed(2)}`);
    }

    const serviceSchema = {
      '@context': 'https://schema.org',
      '@type': 'Service',
      '@id': `${url}#schema`,
      name: title,
      description: description || '',
      url: url,
      provider: {
        '@id': 'https://www.alanranger.com/#org',
        '@type': 'Organization',
        name: 'Alan Ranger Photography',
        url: 'https://www.alanranger.com'
      },
      areaServed: {
        '@type': 'Country',
        name: areaServed
      }
    };

    if (image && image.startsWith('https://')) {
      serviceSchema.image = image;
      addLandingDebugLog('  - Image added');
    }

    if (servicePrice && servicePrice > 0) {
      serviceSchema.offers = {
        '@type': 'Offer',
        price: servicePrice.toFixed(2),
        priceCurrency: 'GBP',
        availability: 'https://schema.org/InStock',
        url: url
      };
      addLandingDebugLog('  - Offers added');
    }

    return serviceSchema;
  }

  function generateItemListSchema(title, description, image, url) {
    const itemsText = document.getElementById('itemListItems')?.value.trim() || '';
    const items = itemsText.split('\n').filter(line => line.trim()).slice(0, 5); // Max 5 items

    // If no items provided, warn but still create ItemList
    if (items.length === 0) {
      addLandingDebugLog(`‚ö†Ô∏è No ItemList items provided - creating empty ItemList`);
    }

    const itemListSchema = {
      '@context': 'https://schema.org',
      '@type': 'ItemList',
      '@id': `${url}#itemlist`,
      name: title || 'Item List',
      description: description || '',
      url: url,
      itemListElement: items.map((itemUrl, index) => {
        const trimmedUrl = itemUrl.trim();
        // Extract name from URL (last segment, formatted)
        const urlParts = trimmedUrl.split('/').filter(p => p);
        const nameFromUrl = urlParts.length > 0 
          ? urlParts[urlParts.length - 1].replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())
          : `Item ${index + 1}`;
        
        return {
          '@type': 'ListItem',
          position: index + 1,
          name: nameFromUrl,
          item: {
            '@type': 'WebPage',
            '@id': trimmedUrl,
            url: trimmedUrl
          }
        };
      })
    };

    if (image && image.startsWith('https://')) {
      itemListSchema.image = image;
    }

    return itemListSchema;
  }

  function generateWebPageSchema(title, description, image, url) {
    const webpageSchema = {
      '@context': 'https://schema.org',
      '@type': 'WebPage',
      '@id': `${url}#schema`,
      headline: title,
      description: description || '',
      url: url,
      mainEntityOfPage: {
        '@type': 'WebPage',
        '@id': url
      },
      publisher: {
        '@id': 'https://www.alanranger.com/#org',
        '@type': 'Organization',
        name: 'Alan Ranger Photography',
        logo: {
          '@type': 'ImageObject',
          url: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w'
        }
      },
      author: {
        '@id': 'https://www.alanranger.com/#org',
        '@type': 'Organization',
        name: 'Alan Ranger Photography'
      }
    };

    if (image && image.startsWith('https://')) {
      webpageSchema.image = image;
      webpageSchema.primaryImageOfPage = {
        '@type': 'ImageObject',
        url: image
      };
    }

    return webpageSchema;
  }

  function generateSimplifiedProductSchema(title, description, image, url) {
    // Simplified Product schema - NO reviews or ratings
    const productSchema = {
      '@context': 'https://schema.org',
      '@type': 'Product',
      '@id': `${url}#schema`,
      name: title,
      description: description || '',
      url: url,
      brand: {
        '@type': 'Brand',
        name: 'Alan Ranger Photography'
      }
    };

    if (image && image.startsWith('https://')) {
      productSchema.image = image;
    }

    // Add basic offers (no price if not provided)
    productSchema.offers = {
      '@type': 'Offer',
      priceCurrency: 'GBP',
      availability: 'https://schema.org/InStock',
      url: url
    };

    return productSchema;
  }

  function copyLandingSchema() {
    const outputText = document.getElementById('landingSchemaOutputText');
    if (!outputText) {
      alert('Schema output not found');
      console.error('landingSchemaOutputText element not found');
      return;
    }
    
    // Get text content from pre element - try multiple methods
    let schemaText = '';
    
    // Method 1: textContent (most reliable for pre elements)
    if (outputText.textContent) {
      schemaText = outputText.textContent.trim();
    }
    // Method 2: innerText (fallback)
    else if (outputText.innerText) {
      schemaText = outputText.innerText.trim();
    }
    // Method 3: value (if it's a textarea)
    else if (outputText.value) {
      schemaText = outputText.value.trim();
    }
    // Method 4: Try to get from parent
    else {
      const parent = outputText.parentElement;
      if (parent && parent.textContent) {
        schemaText = parent.textContent.trim();
      }
    }
    
    if (!schemaText || schemaText.length === 0) {
      alert('No schema to copy. Please generate schema first.');
      console.error('No schema text found. Element:', outputText);
      console.error('textContent:', outputText.textContent);
      console.error('innerText:', outputText.innerText);
      return;
    }
    
    console.log('Copying schema, length:', schemaText.length);
    
    // Try modern clipboard API first
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(schemaText).then(() => {
        alert('Schema copied to clipboard!');
        console.log('Successfully copied to clipboard');
      }).catch(err => {
        console.error('Clipboard API failed:', err);
        // Fallback to execCommand
        fallbackCopySchema(schemaText);
      });
    } else {
      // Fallback for older browsers
      console.log('Clipboard API not available, using fallback');
      fallbackCopySchema(schemaText);
    }
  }
  
  function fallbackCopySchema(text) {
    // Create a temporary textarea
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.left = '-999999px';
    textarea.style.top = '-999999px';
    textarea.style.opacity = '0';
    textarea.style.width = '1px';
    textarea.style.height = '1px';
    document.body.appendChild(textarea);
    
    // Focus and select
    textarea.focus();
    textarea.select();
    
    // For iOS
    textarea.setSelectionRange(0, text.length);
    
    try {
      const successful = document.execCommand('copy');
      document.body.removeChild(textarea);
      if (successful) {
        alert('Schema copied to clipboard!');
        console.log('Successfully copied using execCommand');
      } else {
        console.error('execCommand copy returned false');
        alert('Failed to copy. Please select and copy manually.');
      }
    } catch (err) {
      document.body.removeChild(textarea);
      console.error('Fallback copy failed:', err);
      alert('Failed to copy. Please select and copy manually.');
    }
  }

  function testLandingSchemaOrg() {
    const url = document.getElementById('landingPageUrlFinal').value.trim();
    if (url) {
      window.open(`https://validator.schema.org/#url=${encodeURIComponent(url)}`, '_blank');
    } else {
      alert('Please generate schema first or enter a URL');
    }
  }

  function testLandingGoogleRichResults() {
    const url = document.getElementById('landingPageUrlFinal').value.trim();
    if (url) {
      window.open(`https://search.google.com/test/rich-results?url=${encodeURIComponent(url)}`, '_blank');
    } else {
      alert('Please generate schema first or enter a URL');
    }
  }

  function downloadLandingSchema() {
    const outputText = document.getElementById('landingSchemaOutputText');
    const url = document.getElementById('landingPageUrlFinal').value.trim();
    
    if (!outputText || !outputText.textContent) {
      alert('Please generate schema first');
      return;
    }

    // Get the schema code (which includes suppressor)
    const schemaCode = outputText.textContent;
    const slug = url ? url.split('/').pop().replace(/[^a-z0-9-]/gi, '-').substring(0, 50) : 'landing-page';
    const filename = `${slug}_schema.txt`; // Changed to .txt since it contains HTML/JS
    
    const blob = new Blob([schemaCode], { type: 'text/plain' });
    const downloadUrl = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = downloadUrl;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(downloadUrl);
  }

  function downloadLandingSchemaHtml() {
    const outputText = document.getElementById('landingSchemaOutputText');
    const url = document.getElementById('landingPageUrlFinal').value.trim();
    const title = document.getElementById('landingPageTitle').value.trim() || 'Landing Page';
    
    if (!outputText || !outputText.textContent) {
      alert('Please generate schema first');
      return;
    }

    try {
      // Get the schema code (which already includes suppressor)
      const schemaCode = outputText.textContent;
      const slug = url ? url.split('/').pop().replace(/[^a-z0-9-]/gi, '-').substring(0, 50) : 'landing-page';
      const escapedTitle = title.replace(/"/g, '&quot;').replace(/'/g, '&#39;');
      
      const htmlContent = '<!DOCTYPE html>\n' +
        '<html lang="en">\n' +
        '<head>\n' +
        '  <meta charset="UTF-8">\n' +
        '  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n' +
        '  <title>Schema - ' + escapedTitle + '</title>\n' +
        '</head>\n' +
        '<body>\n' +
        '  <!-- Landing Page Schema -->\n' +
        schemaCode + '\n' +
        '</body>\n' +
        '</html>';
      
      const filename = `${slug}_schema.html`;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const downloadUrl = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = downloadUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(downloadUrl);
    } catch (error) {
      alert(`Error creating HTML file: ${error.message}`);
    }
  }

  function clearLandingForm() {
    document.getElementById('landingPageUrl').value = '';
    document.getElementById('landingPageTitle').value = '';
    document.getElementById('landingPageDescription').value = '';
    document.getElementById('landingPageImage').value = '';
    document.getElementById('landingPageUrlFinal').value = '';
    document.getElementById('landingSchemaType').value = 'auto';
    document.getElementById('serviceAreaServed').value = '';
    document.getElementById('servicePrice').value = '';
    document.getElementById('itemListItems').value = '';
    document.getElementById('landingSchemaOutput').style.display = 'none';
    document.getElementById('landingSchemaResultsPanel').style.display = 'none';
    document.getElementById('landingScanStatus').style.display = 'none';
    document.getElementById('landingDebugLogContainer').style.display = 'none';
    document.getElementById('landingScanProgress').style.display = 'none';
    document.getElementById('landingGenerateProgress').style.display = 'none';
    // Hide schema type selector panel
    const schemaTypePanel = document.getElementById('schemaTypeSelectorPanel');
    if (schemaTypePanel) {
      schemaTypePanel.style.display = 'none';
    }
    updateLandingSchemaFields();
    updateLandingDescriptionCounter();
    landingPageMetadata = null;
    landingDebugLog = '';
  }

  // Product Schema Generation
  async function generateProductSchema() {
    // Check server status first (skip alert in Electron mode or web deployment)
    const isRunning = await ensureLocalExecutorRunning();
    if (!isRunning && !isElectronMode) {
      const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                              window.location.hostname.includes('localhost') === false;
      
      if (isWebDeployment) {
        const output = document.getElementById('productOutput');
        if (output) {
          output.value = '‚ÑπÔ∏è Local server features require Electron app or local development.\n';
          output.value += '   Download the Electron app for full automation.\n';
          output.value += '   Or run locally: npm run start-local\n';
        }
        return;
      }
      
      alert('Local server is not running. Please run "npm run start-local" in your terminal first.');
      return;
    }
    
    const fileInput = document.getElementById('productCsvFile');
    const step3Input = document.getElementById('file-step3');
    const output = document.getElementById('productOutput');
    const successMsg = document.getElementById('productSchemaSuccess');

    // In Electron mode with auto-chaining, skip file upload check - the Python script will find the file automatically
    // The merge script creates: 03 ‚Äì combined_product_reviews.csv
    // The schema script looks for: 03*.xlsx or products_with_review_data_final*.xlsx
    // If no file uploaded but we're in Electron mode, proceed anyway - script will handle it
    const fileToProcess = (step3Input && step3Input.files.length > 0) ? step3Input.files[0] : 
                          (fileInput && fileInput.files.length > 0) ? fileInput.files[0] : null;

    if (!fileToProcess && !isElectronMode) {
      // Only require file upload in browser mode
      alert("Please upload a product Excel file (from Step 3) first.");
      return;
    }

    // In Electron mode, the file was already created by Step 3b automatically
    // The Python script will automatically find and use: 03 ‚Äì combined_product_reviews.csv
    if (isElectronMode && !fileToProcess) {
      console.log("‚ÑπÔ∏è Electron mode: Using automatically created file from Step 3b");
      console.log("   Expected file: inputs-files/workflow/03 ‚Äì combined_product_reviews.csv");
    } else if (fileToProcess) {
      const fileName = fileToProcess.name;
      // Check if file needs to be saved to workflow directory first (browser mode only)
      if (!fileName.includes('products_with_review_data_final') && !fileName.includes('03')) {
        const proceed = confirm(
          "The uploaded file doesn't match the expected name (03 ‚Äì products_with_review_data_final.xlsx).\n\n" +
          "Please ensure the file from Step 3 is saved in /inputs-files/workflow/ as:\n" +
          "03 ‚Äì products_with_review_data_final.xlsx\n\n" +
          "Click OK to continue with preview, or Cancel to upload the correct file."
        );
        if (!proceed) return;
      }
    }

    // Use local task runner for schema generation
    await runLocalTask('schema', 4, '‚öôÔ∏è Generating Product Schema...', () => {
      output.value = "Schema generation complete. Check your project folder:\n- /outputs/ folder for individual JSON/HTML files\n- /inputs-files/workflow/ folder for combined CSV\n\n(All files remain in your Dropbox project folder)";
      if (successMsg) {
        successMsg.style.display = 'block';
        successMsg.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      
      // Optionally stop the server after completion (commented out by default)
      // fetch("http://localhost:8000/exit").then(() => console.log("üßπ Local executor stopped."));
    });
  }

  // File upload handler for validator tab
  function onFileUpload() {
    const fileInput = document.getElementById('validatorCsvFile');
    if (fileInput.files.length > 0) {
      const fileName = fileInput.files[0].name;
      console.log('CSV file selected:', fileName);
      // File is ready for validation
    }
  }

  // Download template CSV file
  function downloadTemplateCSV() {
    const csvContent = 'URL,Page Name,Category\nhttps://www.example.com/product-1,Product One,Products\nhttps://www.example.com/product-2,Product Two,Products\nhttps://www.example.com/event-1,Event One,Events\nhttps://www.example.com/event-2,Event Two,Events';
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'validator-urls-template.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // ---- NEW: Central cache the scanner already fills ------------
  const ResultCache = new Map(); // key: url, value: { blocks, issues, warnings, info, rawHtml? }
  
  // Call this right after you complete analysis for a URL
  function cacheResult(url, payload) {
    ResultCache.set(url, payload);
  }

  // Schema Validator Tab Logic
  const SCHEMA_REQUIREMENTS = {
    WebSite: {
      required: ['name', 'url'],
      recommended: ['description', 'image', 'publisher']
    },
    Product: {
      required: ['name', 'url'],
      recommended: ['description', 'image', 'brand', 'offers', 'aggregateRating', 'review']
    },
    Event: {
      required: ['name', 'startDate'],
      recommended: ['endDate', 'location', 'organizer', 'offers', 'image', 'description', 'performer']
    },
    Organization: {
      required: ['name'],
      recommended: ['url', 'logo', 'address', 'contactPoint', 'telephone', 'description', 'image']
    },
    BreadcrumbList: {
      required: ['itemListElement'],
      recommended: []
    },
    ItemList: {
      required: ['itemListElement'],
      recommended: ['name']
    },
    LocalBusiness: {
      required: ['name'],
      recommended: ['address', 'telephone', 'url', 'openingHours', 'description', 'image']
    }
  };

  const DEFAULT_VALUES = {
    Product: {
      brand: { '@type': 'Brand', name: '[REPLACE WITH BRAND NAME]' },
      offers: {
        '@type': 'Offer',
        price: '[REPLACE WITH PRICE]',
        priceCurrency: 'GBP',
        availability: 'https://schema.org/InStock',
        url: '[AUTO-INFERRED FROM PAGE URL]'
      },
      description: '[REPLACE WITH PRODUCT DESCRIPTION]',
      image: '[REPLACE WITH PRODUCT IMAGE URL]'
    },
    Event: {
      organizer: {
        '@type': 'Organization',
        name: 'Alan Ranger Photography',
        logo: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w',
        url: 'https://www.alanranger.com'
      },
      performer: {
        '@type': 'Person',
        name: 'Alan Ranger'
      },
      location: {
        '@type': 'Place',
        name: '[REPLACE WITH VENUE NAME]',
        address: {
          '@type': 'PostalAddress',
          addressCountry: 'GB'
        }
      },
      offers: {
        '@type': 'Offer',
        price: '0.00',
        priceCurrency: 'GBP',
        availability: 'https://schema.org/InStock',
        validFrom: '[AUTO-INFERRED FROM START DATE]'
      },
      description: '[REPLACE WITH EVENT DESCRIPTION]',
      image: '[REPLACE WITH EVENT IMAGE URL]'
    }
  };

  let validationResults = [];

  // Parse CSV and extract URLs
  function parseCSVForValidation(csvFile) {
    return new Promise((resolve, reject) => {
      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        complete: function(results) {
          const urls = [];
          const headers = results.meta.fields || [];
          
          const urlColumn = headers.find(h => 
            h.toLowerCase() === 'url' || h.toLowerCase() === 'link' || h.toLowerCase() === 'website'
          );
          
          if (!urlColumn) {
            reject(new Error('No URL column found. Expected column name: URL, Link, or Website'));
            return;
          }
          
          results.data.forEach((row, index) => {
            const url = row[urlColumn];
            if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
              const trimmedUrl = url.trim();
              // Deduplicate URLs - only add if not already in array
              if (!urls.find(u => u.url === trimmedUrl)) {
                urls.push({
                  url: trimmedUrl,
                  row: urls.length, // Use current array index, not CSV row number
                  allFields: row
                });
              }
            }
          });
          
          resolve(urls);
        },
        error: function(error) {
          reject(error);
        }
      });
    });
  }

  // Server fallback: Fetch JSON-LD via server when client-side fails
  async function fetchPageSchemaServer(url) {
    try {
      // Determine API base URL (use deployed API when running locally)
      const apiBaseUrl = getApiBaseUrl();
      
      const apiUrl = `${apiBaseUrl}/api/fetch-jsonld?url=${encodeURIComponent(url)}`;
      debugLog(`Calling server fallback API: ${apiUrl}`, 'info');
      
      const response = await fetch(apiUrl);
      if (!response.ok) {
        throw new Error(`Server API returned ${response.status}`);
      }
      
      const data = await response.json();
      
      if (!data.ok) {
        throw new Error(data.error || 'Server API error');
      }
      
      debugLog(`Server fallback: found ${data.count} JSON-LD blocks`, data.count > 0 ? 'success' : 'warn');
      
      // Process scripts to extract types and detect duplicates
      const allNodes = [];
      const typeMap = new Map(); // type -> @id -> count
      
      data.scripts.forEach(block => {
        try {
          const nodes = flattenJsonLd(block, []);
          nodes.forEach(node => {
            allNodes.push(node);
            const types = asArray(node['@type']);
            types.forEach(type => {
              const idKey = node['@id'] || 'NO_ID';
              const mapKey = `${type}|${idKey}`;
              typeMap.set(mapKey, (typeMap.get(mapKey) || 0) + 1);
            });
          });
        } catch (e) {
          debugLog(`Error processing server block: ${e.message}`, 'warn');
        }
      });
      
      // Extract unique types
      const uniqueTypes = new Set();
      allNodes.forEach(node => {
        const types = asArray(node['@type']);
        types.forEach(t => uniqueTypes.add(t));
      });
      
      // Detect duplicates (excluding global injections)
      const globalPatterns = ['website', 'org', 'local', 'breadcrumbs'];
      const duplicateWarnings = [];
      
      typeMap.forEach((count, mapKey) => {
        if (count > 1) {
          const [type, idKey] = mapKey.split('|');
          const isGlobal = idKey !== 'NO_ID' && globalPatterns.some(p => idKey.includes(p));
          if (!isGlobal) {
            const idLabel = idKey === 'NO_ID' ? 'NO_ID' : `#${idKey.split('#')[1]}`;
            duplicateWarnings.push(`‚ö†Ô∏è DUPLICATE: ${type} (${idLabel}) √ó ${count}`);
          }
        }
      });
      
      return {
        url,
        jsonLd: data.scripts,
        schemaFound: data.count > 0,
        schemaType: Array.from(uniqueTypes).join(', '),
        serverFallback: true,
        duplicateWarnings: duplicateWarnings,
        blockCount: data.count
      };
      
    } catch (error) {
      debugLog(`Server fallback failed: ${error.message}`, 'error');
      throw error;
    }
  }

  // Helper: Detect Google Merchant Listing pattern in Product schema
  function detectMerchantListing(json) {
    // Check if this is a Product schema
    const isProduct = json['@type'] === 'Product' || 
                     (Array.isArray(json['@type']) && json['@type'].includes('Product'));
    
    if (!isProduct) {
      return false;
    }
    
    // Check for required Merchant Center fields
    // offers can be an object or array
    const offers = json.offers;
    if (!offers) {
      debugLog(`[MerchantListing] Product schema missing 'offers' field`, 'info');
      return false;
    }
    
    // Handle offers as object or array
    const offer = Array.isArray(offers) ? offers[0] : offers;
    
    // Check for price: can be direct price OR AggregateOffer with lowPrice/highPrice
    const hasPrice = offer && (
      offer.price || 
      (offer.lowPrice && offer.highPrice) || // AggregateOffer pattern
      (offer.lowPrice && offer.lowPrice === offer.highPrice) // Single price in AggregateOffer
    );
    
    const hasPriceCurrency = offer && offer.priceCurrency;
    const hasAvailability = offer && offer.availability;
    
    // Check for hasMerchantReturnPolicy at Product level OR inside offers object
    const hasReturnPolicy = json.hasMerchantReturnPolicy || (offer && offer.hasMerchantReturnPolicy);
    
    const hasMerchantListingFields = 
      hasPrice &&
      hasPriceCurrency &&
      hasAvailability &&
      hasReturnPolicy;
    
    if (!hasMerchantListingFields) {
      const missingFields = [];
      if (!hasPrice) missingFields.push('price (or lowPrice/highPrice for AggregateOffer)');
      if (!hasPriceCurrency) missingFields.push('priceCurrency');
      if (!hasAvailability) missingFields.push('availability');
      if (!hasReturnPolicy) missingFields.push('hasMerchantReturnPolicy (at Product or Offer level)');
      debugLog(`[MerchantListing] Product schema missing Merchant Center fields: ${missingFields.join(', ')}`, 'info');
    } else {
      debugLog(`[MerchantListing] ‚úÖ Product schema has all Merchant Center fields!`, 'success');
    }
    
    return hasMerchantListingFields;
  }

  // Helper: Extract types from JSON-LD block
  function extractTypesFromBlock(json, blockInfo, scriptIndex) {
    const blockTypes = [];
    
    if (json['@type']) {
      const types = Array.isArray(json['@type']) ? json['@type'] : [json['@type']];
      blockTypes.push(...types);
    }
    
    if (json['@graph']) {
      for (const item of json['@graph']) {
        if (item['@type']) {
          const types = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
          blockTypes.push(...types);
        }
      }
    }
    
    if (blockTypes.length > 0) {
      blockInfo.push({
        index: scriptIndex,
        types: blockTypes,
        hasId: !!json['@id'] || !!(json['@graph'] && json['@graph'].some(n => n['@id'])),
        isGraph: !!json['@graph']
      });
    }
    
    return blockTypes;
  }

  // Helper: Parse JSON-LD blocks from scripts
  // Helper: Decode HTML entities to normal JSON (Squarespace-compatible)
  function decodeHTML(str) {
    if (!str) return str;
    return str
      .replace(/&quot;/g, '"')
      .replace(/&apos;/g, "'")
      .replace(/&amp;/g, '&')
      .replace(/&#x2F;/g, '/')
      .replace(/&#x2f;/g, '/')
      .replace(/\\\//g, '/') // Also handle escaped forward slashes
      .trim();
  }

  // Helper: Find all JSON-LD script tags (including Squarespace patterns)
  function findAllJsonLdScripts(doc) {
    const scripts = [];
    
    // Standard pattern: script[type="application/ld+json"]
    const standardScripts = doc.querySelectorAll('script[type="application/ld+json"]');
    scripts.push(...Array.from(standardScripts));
    
    // Squarespace pattern: script[data-type="application/ld+json"]
    const squarespaceScripts = doc.querySelectorAll('script[data-type="application/ld+json"]');
    scripts.push(...Array.from(squarespaceScripts));
    
    // Also check noscript tags for JSON-LD content
    const noscriptTags = doc.querySelectorAll('noscript');
    for (const noscript of noscriptTags) {
      const noscriptStandard = noscript.querySelectorAll('script[type="application/ld+json"]');
      const noscriptSquarespace = noscript.querySelectorAll('script[data-type="application/ld+json"]');
      scripts.push(...Array.from(noscriptStandard));
      scripts.push(...Array.from(noscriptSquarespace));
    }
    
    // Deduplicate scripts (in case a script appears in multiple queries)
    const uniqueScripts = [];
    const seenScripts = new Set();
    for (const script of scripts) {
      if (!seenScripts.has(script)) {
        seenScripts.add(script);
        uniqueScripts.push(script);
      }
    }
    
    return uniqueScripts;
  }

  // Helper: Parse JSON-LD blocks with improved detection
  function parseJsonLdBlocks(scripts, schemaTypeCell) {
    const jsonLdBlocks = [];
    let detectedTypes = [];
    const blockInfo = [];
    const productCount = { total: 0, blocks: [] };
    
    for (let scriptIndex = 0; scriptIndex < scripts.length; scriptIndex++) {
      const script = scripts[scriptIndex];
      try {
        // Decode escaped content before parsing
        const decodedText = decodeHTML(script.textContent);
        const json = JSON.parse(decodedText);
        
        jsonLdBlocks.push(json);
        const blockTypes = extractTypesFromBlock(json, blockInfo, scriptIndex);
        detectedTypes.push(...blockTypes);
        
        // Track Product schemas specifically
        const hasProduct = blockTypes.includes('Product');
        if (hasProduct) {
          productCount.total++;
          productCount.blocks.push(scriptIndex);
        }
      } catch (e) {
        // Try parsing after decoding if initial parse failed
        try {
          const decodedText = decodeHTML(script.textContent);
          const json = JSON.parse(decodedText);
          jsonLdBlocks.push(json);
          const blockTypes = extractTypesFromBlock(json, blockInfo, scriptIndex);
          detectedTypes.push(...blockTypes);
          
          const hasProduct = blockTypes.includes('Product');
          if (hasProduct) {
            productCount.total++;
            productCount.blocks.push(scriptIndex);
          }
        } catch (e2) {
          console.warn('Failed to parse JSON-LD:', e);
          debugLog(`Failed to parse JSON-LD block ${scriptIndex}: ${e.message}`, 'error');
        }
      }
    }
    
    // Log duplicate Product detection
    if (productCount.total > 1) {
      debugLog(`Duplicate Product schemas detected (${productCount.total} found) ‚Äî first retained, subsequent skipped.`, 'warn');
      debugLog(`Product schemas found in blocks: ${productCount.blocks.join(', ')}`, 'info');
    }
    
    return { jsonLdBlocks, detectedTypes, blockInfo };
  }

  // Helper: Detect and log duplicate types
  function detectDuplicateTypes(detectedTypes, blockInfo) {
    const typeCounts = {};
    for (const t of detectedTypes) {
      typeCounts[t] = (typeCounts[t] || 0) + 1;
    }
    
    const duplicates = Object.keys(typeCounts).filter(t => typeCounts[t] > 1);
    
    if (duplicates.length > 0) {
      // Log duplicate detection as info (expected for multi-instance schemas like Event, Product)
      debugLog(`Duplicate schema types detected: ${duplicates.map(t => `${t} (${typeCounts[t]}x)`).join(', ')}`, 'info');
      debugLog(`Block details: ${blockInfo.map(b => `Block ${b.index}: ${b.types.join(',')}${b.hasId ? ' (has @id)' : ''}${b.isGraph ? ' (@graph)' : ''}`).join('; ')}`, 'info');
    }
    
    return { duplicates, typeCounts };
  }

  // Helper: Extract types from JSON-LD data
  function extractTypesFromJsonLd(data, detectedTypes) {
    if (data['@type']) {
      if (Array.isArray(data['@type'])) {
        detectedTypes.push(...data['@type']);
      } else {
        detectedTypes.push(data['@type']);
      }
    }
    if (data['@graph']) {
      for (const item of data['@graph']) {
        if (item['@type']) {
          if (Array.isArray(item['@type'])) {
            detectedTypes.push(...item['@type']);
          } else {
            detectedTypes.push(item['@type']);
          }
        }
      }
    }
  }

  // Helper: Parse JSON-LD blocks from scripts (with Squarespace pattern support)
  function parseJsonLdBlocksFromScripts(scripts) {
    const jsonLdBlocks = [];
    for (const script of scripts) {
      try {
        // Decode HTML entities before parsing
        const decodedText = decodeHTML(script.textContent);
        const json = JSON.parse(decodedText);
        jsonLdBlocks.push(json);
      } catch (e) {
        console.warn('Failed to parse JSON-LD:', e);
      }
    }
    return jsonLdBlocks;
  }

  // Helper: Extract detected types from scripts (with Squarespace pattern support)
  function extractDetectedTypes(scripts) {
    const detectedTypes = [];
    for (const s of scripts) {
      try {
        // Decode HTML entities before parsing
        const decodedText = decodeHTML(s.textContent.trim());
        const data = JSON.parse(decodedText);
        extractTypesFromJsonLd(data, detectedTypes);
      } catch (err) {
        console.warn('Invalid JSON-LD block', err);
      }
    }
    return detectedTypes;
  }

  // Helper: Handle direct fetch fallback
  async function handleDirectFetchFallback(url, schemaTypeCell) {
    if (schemaTypeCell) setProgress(schemaTypeCell, 15, 'Fetching');
    const response = await fetch(url, { mode: 'cors' });
    const htmlText = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlText, 'text/html');
    
    if (schemaTypeCell) setProgress(schemaTypeCell, 40, 'Fetched');
    
    // Find all JSON-LD script tags (including Squarespace patterns)
    const scripts = findAllJsonLdScripts(doc);
    const detectedTypes = extractDetectedTypes(scripts);
    
    if (schemaTypeCell) {
      const uniqueTypes = [...new Set(detectedTypes)];
      const schemaType = uniqueTypes.length ? uniqueTypes.join(', ') : 'None';
      setProgress(schemaTypeCell, uniqueTypes.length ? 85 : 70, uniqueTypes.length ? 'Detected' : 'Scanning');
    }
    
    const uniqueTypes = [...new Set(detectedTypes)];
    const schemaType = uniqueTypes.length ? uniqueTypes.join(', ') : 'None';
    const jsonLdBlocks = parseJsonLdBlocksFromScripts(scripts);
    
    return {
      url,
      jsonLd: jsonLdBlocks,
      schemaFound: jsonLdBlocks.length > 0,
      schemaType: schemaType
    };
  }

  // Helper: Handle server fallback
  async function handleServerFallback(url, schemaTypeCell) {
    debugLog(`Local parse failed for ${url}, trying server fallback...`, 'info');
    if (schemaTypeCell) {
      setProgress(schemaTypeCell, 10, 'Server fallback...');
    }
    
    try {
      const serverData = await fetchPageSchemaServer(url);
      
      if (schemaTypeCell) {
        setProgress(schemaTypeCell, 100, 'Done');
        setTimeout(() => {
          const schemaTypeText = serverData.schemaType || '‚Äî';
          schemaTypeCell.textContent = serverData.schemaFound ? `${schemaTypeText} (server)` : '‚Äî';
        }, 500);
      }
      
      serverData.parsePath = 'server';
      serverData.localParseFailed = true;
      
      return serverData;
    } catch (serverError) {
      if (schemaTypeCell) {
        markProgressError(schemaTypeCell);
        setProgress(schemaTypeCell, 100, 'Error');
      }
      throw serverError;
    }
  }

  // Helper: Process fetched HTML and extract schema (also check noscript tags and Squarespace patterns)
  function processFetchedHtml(html, schemaTypeCell, url) {
    if (schemaTypeCell) setProgress(schemaTypeCell, 40, 'Fetched');
    
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Find all JSON-LD script tags (including Squarespace patterns)
    const scripts = findAllJsonLdScripts(doc);
    
    if (schemaTypeCell) setProgress(schemaTypeCell, 60, 'Parsed DOM');
    
    const { jsonLdBlocks, detectedTypes, blockInfo } = parseJsonLdBlocks(scripts, schemaTypeCell);
    detectDuplicateTypes(detectedTypes, blockInfo);
    
    // Diagnostic log for detected blocks
    console.info(`Detected ${jsonLdBlocks.length} JSON-LD blocks (including Squarespace code blocks)`);
    debugLog(`Found ${scripts.length} JSON-LD script blocks, detected types: ${detectedTypes.length > 0 ? [...new Set(detectedTypes)].join(', ') : 'None'} (${detectedTypes.length} total, ${[...new Set(detectedTypes)].length} unique)`, detectedTypes.length > 0 ? 'success' : 'warn');
    
    if (schemaTypeCell) {
      const uniqueTypes = [...new Set(detectedTypes)];
      const schemaType = uniqueTypes.length ? uniqueTypes.join(', ') : 'None';
      setProgress(schemaTypeCell, uniqueTypes.length ? 85 : 70, uniqueTypes.length ? 'Detected' : 'Scanning');
    }
    
    return {
      url,
      jsonLd: jsonLdBlocks,
      schemaFound: jsonLdBlocks.length > 0,
      schemaType: detectedTypes.length ? [...new Set(detectedTypes)].join(', ') : 'None'
    };
  }

  // Helper: Handle fetch errors with fallbacks
  async function handleFetchErrors(error, url, schemaTypeCell) {
    try {
      return await handleDirectFetchFallback(url, schemaTypeCell);
    } catch (err) {
      if (schemaTypeCell) {
        markProgressError(schemaTypeCell);
        setProgress(schemaTypeCell, 100, 'Error');
      }
      return await handleServerFallback(url, schemaTypeCell);
    }
  }

  // Fetch page and extract JSON-LD
  async function fetchPageSchema(url, progressIndex) {
    const schemaTypeCell = progressIndex !== undefined ? document.getElementById(`schemaTypeCell_${progressIndex}`) : null;
    
    try {
      const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
      
      if (schemaTypeCell) setProgress(schemaTypeCell, 15, 'Fetching');
      const response = await fetch(proxyUrl);
      const data = await response.json();
      const html = data.contents;
      
      return processFetchedHtml(html, schemaTypeCell, url);
    } catch (error) {
      return await handleFetchErrors(error, url, schemaTypeCell);
    }
  }

  // Extract schema types
  function extractSchemaTypes(jsonLdBlocks) {
    const types = new Set();
    
