<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unified Schema Generator v4.2 - Smart Enriched Schema Generator (EventSeries Optimization)</title>
  <!--
    CHANGELOG v4.2 Smart Enriched Schema Generator (EventSeries Optimization)
    =========================================================================
    
    Changes from v4.1:
    - Added detectEventSeries() for repeat workshop patterns
    - Groups multi-instance Bluebell & Batsford workshops into EventSeries
    - Adds eventSchedule + subjectOf ItemList linkage
    - Includes grouping summary in console + UI
    
    Changes from v4:
    - Added intelligent region + geo inference for workshops/lessons
    - Added full PostalAddress reconstruction with region map matching
    - Added availabilityStarts and itemCondition for Merchant Center
    - Added performer.sameAs LinkedIn/YouTube links
    - Added courseMode hybrid logic (InPerson/Online detection)
    - Added location verification summary with coverage stats
    - Added UI toggles for enrichment options (location enrichment, availabilityStarts)
    - Enhanced eventType and material fields for SEO context
    
    Changes from v3.5:
    - Enhanced address parsing with full PostalAddress structure (streetAddress, addressLocality, addressRegion, postalCode, addressCountry)
    - Added toggle options: Include Reviews, Include Performer, Group Repeating Events, Include Merchant Center Fields
    - localStorage persistence for toggle states
    - Enhanced organizer/provider blocks with full address and sameAs (Instagram, Facebook, LinkedIn)
    - Enhanced performer block with sameAs link
    - Enhanced offers with hasMerchantReturnPolicy (when merchant fields enabled)
    - Review injection: top 5 reviews trimmed to 300 chars (toggleable)
    - Event schedule grouping: detects repeating weekly events and creates EventSeries with eventSchedule
    - SEO metadata enhancers: potentialAction, isFamilyFriendly, learningResourceType, typicalAgeRange, courseMode, subjectOf
    - Enhanced keywords: combines tags + category + location + topic words
    - "about" field: auto-generated topic summary
    - identifier field: slug from URL
    - sameAs array: event URL + product URL
    - CSV type detection: auto-detects Lessons vs Workshops
    - Enhanced validation summary with statistics (events with reviews, performer, offers)
    - Merchant Center feed export (Phase 6): JSON feed download when toggle enabled
    - Timezone: scheduleTimezone set to "Europe/London" for eventSchedule
    - EventSeries type for superEvent (not Event)
    
    Technical improvements:
    - All processing remains client-side (no server/API calls)
    - Schema Suppressor v1.3 only in Product Schema tab (removed from Event Schema)
    - Empty/invalid fields are omitted (not emitted as empty strings)
    - Past events automatically skipped
    - Offers only included when price > 0
  -->
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      margin: 0;
    }
    .container {
      max-width: 95vw;
      width: 100%;
      margin: 0 auto;
      background: white;
      padding: 2.5rem;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.15);
      position: relative;
    }
    .version-badge {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      z-index: 10;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .version-badge .version {
      display: block;
      font-size: 1rem;
    }
    .version-badge .date {
      display: block;
      font-size: 0.75rem;
      opacity: 0.9;
      margin-top: 0.25rem;
    }
    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      color: #2d3748;
      padding-right: 150px;
      font-weight: 700;
    }
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      border-bottom: 2px solid #e2e8f0;
    }
    .tab {
      padding: 0.875rem 1.75rem;
      background: #f7fafc;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      border-radius: 8px 8px 0 0;
      transition: all 0.3s ease;
      color: #4a5568;
      border-bottom: 3px solid transparent;
    }
    .tab:hover {
      background: #edf2f7;
      color: #2d3748;
    }
    .tab.active {
      background: white;
      color: #667eea;
      border-bottom-color: #667eea;
      font-weight: 600;
    }
    .tab-content {
      display: none !important;
      padding: 20px;
      border-top: none;
    }
    .tab-content.active {
      display: block !important;
    }
    .tab-content h2 {
      color: #2d3748;
      font-size: 1.75rem;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }
    .tab-content h3 {
      color: #4a5568;
      font-size: 1.25rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    .tab-content p {
      color: #4a5568;
      line-height: 1.7;
      margin-bottom: 1rem;
    }
    .tab-content ul {
      color: #4a5568;
      line-height: 1.8;
      margin-bottom: 1.5rem;
      padding-left: 1.5rem;
    }
    .tab-content li {
      margin-bottom: 0.5rem;
    }
    .tab-content code {
      background: #f7fafc;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #667eea;
    }
    .instructions {
      background: linear-gradient(135deg, #f6f8fb 0%, #edeff2 100%);
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 1.5rem;
      line-height: 1.7;
      border-left: 4px solid #667eea;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      color: #4a5568;
    }
    .instructions h2 {
      color: #2d3748;
      font-size: 1.75rem;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }
    .instructions h3 {
      color: #4a5568;
      font-size: 1.25rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    .instructions p {
      color: #4a5568;
      margin-bottom: 1rem;
    }
    .instructions ul {
      color: #4a5568;
      margin-bottom: 1.5rem;
      padding-left: 1.5rem;
    }
    .instructions li {
      margin-bottom: 0.5rem;
    }
    .instructions strong {
      display: block;
      margin-bottom: 0.75rem;
      color: #2d3748;
      font-size: 1.1rem;
    }
    /* Ensure Tab Guide is hidden by default and only shows when active */
    #guideTab.tab-content {
      display: none !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
    }
    #guideTab.tab-content.active {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
    }
    #guideTab .instructions {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    .instructions pre {
      background: #ffffff;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.9rem;
      border: 1px solid #e2e8f0;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }
    input[type="file"], select {
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      width: 100%;
      max-width: 400px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      transition: all 0.2s;
      background: white;
    }
    input[type="file"]:hover, select:hover {
      border-color: #667eea;
    }
    input[type="file"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    button {
      margin-top: 1rem;
      padding: 0.875rem 1.75rem;
      font-size: 1rem;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
    }
    button:active {
      transform: translateY(0);
    }
    button.secondary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      box-shadow: 0 4px 12px rgba(245, 87, 108, 0.3);
      margin-left: 0.5rem;
    }
    button.secondary:hover {
      box-shadow: 0 6px 16px rgba(245, 87, 108, 0.4);
    }
    textarea {
      width: 100%;
      height: 400px;
      margin-top: 1rem;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      padding: 1.25rem;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      transition: all 0.2s;
      background: #fafbfc;
      line-height: 1.6;
    }
    textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      background: white;
    }
    pre {
      background: #fafbfc;
      padding: 1.25rem;
      overflow-x: auto;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.6;
    }
    #categoryFilterContainer {
      margin-top: 1rem;
    }
    .test-url-section {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 2px solid #e2e8f0;
    }
    .test-url-section input {
      width: 100%;
      max-width: 600px;
      padding: 0.75rem 1rem;
      margin-right: 0.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s;
    }
    .test-url-section input:hover {
      border-color: #667eea;
    }
    .test-url-section input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    .test-url-section .button-group {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .warning {
      color: #e53e3e;
      font-weight: 600;
    }
    label {
      display: block;
      margin-top: 1.5rem;
      font-weight: 600;
      color: #2d3748;
      font-size: 0.95rem;
    }
    h3 {
      color: #2d3748;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 0.5rem;
    }
    h4 {
      color: #4a5568;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1.5rem;
      background: white;
      border-radius: 8px;
      overflow: visible;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      table-layout: auto;
    }
    .results-table th {
      background: #f7fafc;
      padding: 1rem;
      text-align: left;
      font-weight: 600;
      color: #2d3748;
      border-bottom: 2px solid #e2e8f0;
      white-space: normal;
      line-height: 1.4;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .results-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #fff;
    }
    .filter-row th {
      background: #f9fafb;
      padding: 0.5rem;
    }
    .filter-input {
      width: 100%;
      padding: 0.375rem 0.5rem;
      font-size: 0.875rem;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      background: #fff;
    }
    .filter-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .sortable-header {
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    .sortable-header:hover {
      color: #667eea;
    }
    .sort-indicator {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-left: 0.25rem;
    }
    .sort-indicator.sorted-asc::after {
      content: ' ‚Üë';
      color: #667eea;
    }
    .sort-indicator.sorted-desc::after {
      content: ' ‚Üì';
      color: #667eea;
    }
    .scrollable-container {
      max-height: calc(100vh - 400px);
      min-height: 600px;
      overflow-y: auto;
    }
    .results-table th:nth-child(1) { min-width: 250px; } /* Page URL */
    .results-table th:nth-child(2) { min-width: 200px; } /* Schema Type */
    .results-table th:nth-child(3) { min-width: 80px; max-width: 100px; width: 100px; } /* Status - narrower */
    .results-table th:nth-child(4) { min-width: 220px; } /* Missing Fields - wider */
    .results-table th:nth-child(5) { min-width: 220px; } /* Warnings - wider */
    .results-table th:nth-child(6) { min-width: 220px; } /* Info - wider */
    .results-table th:nth-child(7) { min-width: 140px; max-width: 160px; } /* Rich Results Status (external) */
    .results-table th:nth-child(8) { min-width: 140px; max-width: 160px; } /* Schema.org Status (external) */
    .results-table th:nth-child(9) { min-width: 200px; } /* Notes */
    .results-table th:nth-child(10) { min-width: 280px; } /* Actions */
    
    th:nth-child(4), td:nth-child(4) { background: #fff8f8; }    /* Missing */
    th:nth-child(5), td:nth-child(5) { background: #fffaf2; }    /* Warnings */
    th:nth-child(6), td:nth-child(6) { background: #f4fff7; }    /* Info */
    
    .missing-entry { color: #c00; font-weight: 500; margin: 0.25rem 0; }
    .warning-entry { 
      color: #b47f00; 
      font-weight: 500; 
      margin: 0.125rem 0; 
      font-size: 0.75rem;
      line-height: 1.3;
      max-height: 3rem;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .warning-entry:hover {
      max-height: none;
      overflow: visible;
      -webkit-line-clamp: unset;
    }
    .info-entry { color: #006b3b; font-weight: 500; margin: 0.25rem 0; }
    .status-badge.no-schema {
      background: #e2e8f0;
      color: #4a5568;
    }
    .status-select {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      background: white;
      min-width: 120px;
    }
    .status-select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .notes-textarea {
      width: 100%;
      min-width: 180px;
      max-width: 220px;
      height: 3rem;
      min-height: 2.5rem;
      max-height: 4rem;
      padding: 0.375rem 0.5rem;
      font-size: 0.75rem;
      line-height: 1.3;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-family: inherit;
      resize: vertical;
      overflow-y: auto;
    }
    .notes-textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .save-btn {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      margin: 0.25rem 0;
      background: #48bb78;
      color: white;
    }
    .save-btn:hover {
      background: #38a169;
    }
    .save-btn:disabled {
      background: #a0aec0;
      cursor: not-allowed;
    }
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 1rem 1.5rem;
      background: #48bb78;
      color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10000;
      animation: slideIn 0.3s ease;
    }
    .toast.error {
      background: #e53e3e;
    }
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    .results-table td {
      padding: 0.75rem 1rem;
      vertical-align: top;
    }
    .results-table td:nth-child(1) { 
      white-space: normal; 
      word-break: break-all;
      min-width: 250px;
      max-width: 350px;
    } /* Page URL */
    .results-table td:nth-child(2) { 
      white-space: normal; 
      min-width: 200px;
      max-width: 300px;
    } /* Schema Type */
    .results-table td:nth-child(3) { 
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 80px;
      max-width: 100px;
      width: 100px;
    } /* Status */
    .results-table td:nth-child(3) .status-explanation {
      display: none; /* Hide explanation text to prevent column expansion */
    }
    .results-table td:nth-child(4) { 
      white-space: normal; 
      min-width: 180px;
      max-width: 250px;
    } /* Missing Fields */
    .results-table td:nth-child(5) { 
      white-space: normal; 
      min-width: 150px;
      max-width: 200px;
      font-size: 0.875rem;
      padding: 0.5rem 0.75rem;
      vertical-align: top;
    } /* Warnings */
    .results-table td:nth-child(6) { 
      white-space: normal; 
      min-width: 180px;
      max-width: 250px;
    } /* Info */
    .results-table td.missing-fields {
      white-space: normal;
      min-width: 180px;
      max-width: 250px;
    }
    .results-table td:last-child {
      white-space: normal;
      min-width: 280px;
      width: auto;
    }
    .results-table td:last-child .enhance-btn,
    .results-table td:last-child .save-btn {
      display: inline-block;
      white-space: nowrap;
      margin: 0.25rem 0;
    }
    .results-table tr:hover {
      background: #f9fafb;
    }
    .status-valid {
      color: #38a169;
      font-weight: 600;
    }
    .status-invalid {
      color: #e53e3e;
      font-weight: 600;
    }
    .status-processing {
      color: #667eea;
      font-weight: 600;
    }
    .enhance-btn {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      margin: 0.25rem 0;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 1rem;
    }
    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
    }
    .missing-fields {
      font-size: 0.875rem;
      color: #e53e3e;
    }
    .scrollable-container {
      max-height: calc(100vh - 400px);
      min-height: 600px;
      overflow-y: auto;
      margin-top: 1rem;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      background: #fafbfc;
    }
    .url-link {
      color: #667eea;
      text-decoration: none;
      word-break: break-all;
    }
    .url-link:hover {
      text-decoration: underline;
    }
    .status-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.875rem;
      font-weight: 600;
    }
    .status-badge.valid {
      background: #c6f6d5;
      color: #22543d;
    }
    .status-badge.issues {
      background: #feebc8;
      color: #744210;
    }
    .status-badge.error {
      background: #fed7d7;
      color: #742a2a;
    }
    .status-badge.no-schema {
      background: #e2e8f0;
      color: #4a5568;
    }
    .single-url-section {
      background: #f7fafc;
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 2rem;
      border: 2px solid #e2e8f0;
    }
    .single-url-section label {
      margin-top: 0;
      font-weight: 600;
      color: #2d3748;
    }
    .single-url-section input {
      width: 100%;
      max-width: 600px;
      padding: 0.75rem 1rem;
      margin-top: 0.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
    }
    .help-block {
      background: #f0f7ff;
      border-left: 4px solid #667eea;
      padding: 1rem 1.5rem;
      margin-top: 1.5rem;
      border-radius: 6px;
      cursor: pointer;
    }
    .help-block-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.5rem;
    }
    .help-block-content {
      display: none;
      margin-top: 1rem;
      color: #4a5568;
      line-height: 1.7;
    }
    .help-block-content.active {
      display: block;
    }
    .help-block-icon {
      transition: transform 0.3s ease;
    }
    .help-block.expanded .help-block-icon {
      transform: rotate(180deg);
    }
    .batch-section {
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 2px solid #e2e8f0;
    }
    .progress-wrap {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .progress {
      width: 160px;
      height: 8px;
      background: #eee;
      border-radius: 999px;
      overflow: hidden;
    }
    .progress > span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #7c4dff, #4fc3f7);
      transition: width 0.25s ease;
    }
    .progress-label {
      font-size: 0.85rem;
      color: #555;
      min-width: 72px;
    }
    
    /* --- Row Progress Bars --- */
    .progress {
      position: relative;
      width: 100%;
      height: 6px;
      background: #f0f0f0;
      border-radius: 3px;
      overflow: hidden;
      margin-top: 4px;
      display: block;
    }
    
    .progress-inner {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00b67a, #e57200);
      border-radius: 3px;
      transition: width 0.3s ease;
      max-height: 6px;
    }
    
    /* === Status Badge Styling === */
    .chip-queued {
      background: linear-gradient(90deg, #cfd9df 0%, #e2ebf0 100%);
      color: #555;
      border-radius: 8px;
      padding: 4px 10px;
      font-size: 13px;
      font-weight: 600;
      display: inline-block;
    }
    
    .chip-fetching {
      background: linear-gradient(90deg, #ffe259 0%, #ffa751 100%);
      color: #333;
      border-radius: 8px;
      padding: 4px 10px;
      font-size: 13px;
      font-weight: 600;
      display: inline-block;
    }
    
    .chip-valid {
      background: #27AE60;
      color: white;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    .chip-valid:hover {
      background: #229954;
    }
    
    .chip-critical {
      background: #E74C3C;
      color: white;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    .chip-critical:hover {
      background: #C0392B;
    }
    
    .status-badge.no-schema {
      background: linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%);
      color: #333;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    
    /* Issues Modal */
    .issues-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(20, 20, 33, 0.45);
      align-items: center;
      justify-content: center;
      z-index: 9999;
      border: none;
      padding: 0;
    }
    .issues-backdrop::backdrop {
      background: rgba(20, 20, 33, 0.45);
    }
    .issues-modal {
      width: min(760px, 94vw);
      max-height: 80vh;
      overflow: auto;
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
      padding: 1.25rem 1.5rem;
    }
    .issues-modal h3 {
      margin: 0.2rem 0 0.8rem 0;
      font-size: 1.15rem;
    }
    .issues-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: #1a202c;
      margin: -1.25rem -1.5rem 1rem -1.5rem;
      border-radius: 14px 14px 0 0;
    }
    .issues-modal-header h3 {
      color: #fff;
      margin: 0;
    }
    .issues-close-x {
      background: #fff;
      border: 2px solid #fff;
      font-size: 1.5rem;
      color: #1a202c;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      border-radius: 6px;
      transition: all 0.2s;
      font-weight: bold;
    }
    .issues-close-x:hover {
      background-color: #ef4444;
      color: #fff;
      border-color: #ef4444;
    }
    .issues-close-x:active {
      background-color: #dc2626;
    }
    .issues-meta {
      font-size: 0.9rem;
      color: #555;
      margin: 0.5rem 0 1rem;
    }
    .issues-list {
      margin: 0.25rem 0 0.75rem 1rem;
    }
    .issues-list li {
      margin: 0.2rem 0;
    }
    .issues-json {
      background: #000000 !important;
      color: #ffffff !important;
      border-radius: 10px;
      padding: 0.75rem;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.82rem;
    }
    .gen-enhanced-modal {
      background: #1e293b;
      color: #e2e8f0;
    }
    .gen-enhanced-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: #0f172a;
      margin: -1.25rem -1.5rem 1rem -1.5rem;
      border-radius: 14px 14px 0 0;
      border-bottom: 2px solid #334155;
    }
    .gen-enhanced-header h3 {
      color: #fff;
      margin: 0;
      font-size: 1.15rem;
      font-weight: 600;
    }
    .gen-enhanced-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #334155;
    }
    .gen-copy-btn {
      background: #3b82f6;
      color: #fff;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gen-copy-btn:hover {
      background: #2563eb;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
    .gen-close-btn {
      background: #64748b;
      color: #fff;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gen-close-btn:hover {
      background: #475569;
      box-shadow: 0 4px 12px rgba(100, 116, 139, 0.4);
    }
    .gen-enhanced-modal .issues-meta {
      color: #94a3b8;
    }
    .severity-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      color: white;
    }
    .severity-badge.passed {
      background-color: #10b981;
    }
    .severity-badge.warning {
      background-color: #f59e0b;
    }
    .severity-badge.critical {
      background-color: #ef4444;
    }
    .summary-card {
      padding: 1rem;
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .summary-card pre {
      white-space: pre-wrap;
      font-size: 0.875rem;
      color: #374151;
      margin: 0;
      font-family: inherit;
    }
    .recommended-fix-card {
      padding: 1rem;
      background: #fffbeb;
      border: 1px solid #fbbf24;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .recommended-fix-card h4 {
      font-size: 1rem;
      font-weight: 600;
      color: #92400e;
      margin: 0 0 0.5rem 0;
    }
    .recommended-fix-card p {
      font-size: 0.875rem;
      color: #374151;
      margin: 0 0 0.75rem 0;
    }
    .recommended-fix-textarea {
      width: 100% !important;
      height: 18rem !important;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
      font-size: 0.75rem !important;
      background: #000000 !important;
      color: #ffffff !important;
      padding: 0.75rem !important;
      border-radius: 6px !important;
      border: 1px solid #333 !important;
      resize: vertical;
      overflow: auto;
    }
    .copy-schema-btn {
      margin-top: 0.75rem;
      background: #d97706;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .copy-schema-btn:hover {
      background: #b45309;
    }
    .system-node {
      opacity: 0.5;
      filter: grayscale(0.6);
    }
    .system-node td:first-child::after {
      content: " (Squarespace auto-schema)";
      font-style: italic;
      color: #888;
      margin-left: 0.5rem;
    }
    .help-link {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.75rem;
    }
    .help-link a {
      color: #2563eb;
      text-decoration: underline;
    }
    .help-link a:hover {
      color: #1d4ed8;
    }
    .chip-issues {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #F5B041;
      color: black;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      border: 1px solid #E67E22;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-issues:hover {
      background: #E67E22;
    }
    .chip-issues::after {
      content: " (non-critical)";
      font-size: 0.8em;
      opacity: 0.7;
    }
    .duplicate-warning {
      color: #b47f00;
      font-weight: 500;
    }
    .chip-critical {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #E74C3C;
      color: white;
      border: 1px solid #C0392B;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-critical:hover {
      background: #C0392B;
    }
    .chip-passed {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-passed:hover {
      background: #229954;
    }
    .status-explanation {
      display: inline-block;
      margin-left: 0.75rem;
      font-size: 0.875rem;
      color: #6b7280;
      font-style: italic;
      vertical-align: middle;
    }
    #statusCell_0, #statusCell_1, #statusCell_2, [id^="statusCell_"] {
      white-space: normal;
      line-height: 1.5;
    }
    .status-legend {
      display: flex;
      gap: 1rem;
      margin-bottom: 0.75rem;
      padding: 0.75rem;
      background: #2d3748;
      border-radius: 8px;
      font-size: 0.875rem;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .status-legend-item {
      color: #fff;
    }
    .status-legend-item span:not(.chip-sample):not(.info-entry) {
      color: #e2e8f0;
    }
    .status-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .status-legend-item .chip-sample {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    .chip-sample.passed {
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
    }
    .chip-sample.issues {
      background: #F5B041;
      color: black;
      border: 1px solid #E67E22;
    }
    .chip-sample.critical {
      background: #E74C3C;
      color: white;
      border: 1px solid #C0392B;
    }
    .chip-sample.info {
      background: #5DADE2;
      color: white;
      border: 1px solid #3498DB;
    }
    .chip-info {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #5DADE2;
      color: white;
      border: 1px solid #3498DB;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-info:hover {
      background: #3498DB;
    }
    .chip-ok {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-ok:hover {
      background: #229954;
    }
    .badge {
      display: inline-block;
      padding: 0.15rem 0.4rem;
      border-radius: 0.5rem;
      background: #fff3cd;
      color: #7a5b00;
      border: 1px solid #ffe08a;
      margin: 0.1rem 0.15rem;
      font-size: 0.8rem;
    }
    /* Debug Console Styles */
    .debug-console {
      margin-top: 1.5rem;
      border: 1px solid #cbd5e0;
      border-radius: 8px;
      background: #f7fafc;
      max-height: 400px;
      overflow-y: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
    }
    .debug-console-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #edf2f7;
      border-bottom: 1px solid #cbd5e0;
      border-radius: 8px 8px 0 0;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .debug-console-actions {
      display: flex;
      gap: 0.5rem;
    }
    .debug-console-content {
      padding: 1rem;
      line-height: 1.6;
      color: #2d3748;
    }
    .debug-log-entry {
      margin: 0.25rem 0;
      padding: 0.25rem 0.5rem;
      border-left: 3px solid #4299e1;
      background: #fff;
    }
    .debug-log-entry.error {
      border-left-color: #f56565;
      background: #fed7d7;
    }
    .debug-log-entry.warn {
      border-left-color: #ed8936;
      background: #feebc8;
    }
    .debug-log-entry.success {
      border-left-color: #48bb78;
      background: #c6f6d5;
    }
    .debug-log-time {
      color: #718096;
      font-size: 0.75rem;
      margin-right: 0.5rem;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Modal styling */
    #detail-modal { position: fixed; inset: 0; z-index: 9999; }
    #detail-modal .modal-backdrop { position:absolute; inset:0; background:rgba(0,0,0,.45); }
    #detail-modal .modal { position: absolute; top: 8%; left: 50%; transform: translateX(-50%); width: min(1100px, 92vw); background:#fff; border-radius:12px; box-shadow: 0 10px 40px rgba(0,0,0,.2); }
    #detail-modal .modal-head { display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid #eee; }
    #detail-modal .modal-body { padding:18px; max-height:70vh; overflow:auto; }
    #detail-modal #modal-close { background:none; border:none; font-size:1.5rem; cursor:pointer; padding:0; width:30px; height:30px; display:flex; align-items:center; justify-content:center; }
    #detail-modal #modal-close:hover { color:#f00; }
    .code-card { border:1px solid #eee; border-radius:10px; margin-bottom:12px; }
    .code-card-head { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; background:#fafafa; border-bottom:1px solid #eee; }
    .code-card pre { margin:0; padding:12px; overflow:auto; background:#000; color:#fff; }
    .code-card pre code { color:#fff; }
    .code-card .copy-btn { background:#2563eb; color:#fff; border:none; padding:0.375rem 0.75rem; border-radius:4px; cursor:pointer; font-size:0.875rem; }
    .code-card .copy-btn:hover { background:#1d4ed8; }
    .grid.grid-two { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 768px) {
      .grid.grid-two { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="version-badge">
    <span class="version">v4.2</span>
    <span class="date">Smart Enriched Schema Generator ‚Äî EventSeries Optimization</span>
  </div>
  <h1>Unified Schema Generator - Events & Products</h1>

  <div class="tabs">
    <button class="tab active" onclick="switchTab('event')">Event Schema</button>
    <button class="tab" onclick="switchTab('product')">Product Schema</button>
    <button class="tab" onclick="switchTab('validator')">Schema Validator</button>
    <button class="tab" onclick="switchTab('guide')">üß† Tab Guide</button>
  </div>

  <!-- Event Tab Content -->
  <div id="eventTab" class="tab-content active">
    <div class="instructions">
      <strong>üìÖ Event Schema Generator v4 - Smart Enriched Schema Generator</strong><br>
      1. Upload your event CSV file (exported from Squarespace Events).<br>
      2. Ensure it includes these fields: <code>Event_Title</code>, <code>Start_Date</code>, <code>Start_Time</code>, <code>End_Date</code>, <code>End_Time</code>, <code>Event_URL</code>, <code>Event_Image</code>, <code>Location_Business_Name</code>, <code>Location_Address</code>, <code>Location_City_State_ZIP</code>, <code>Excerpt</code>, <code>Category</code>, <code>Workflow_State</code>, <code>Tags</code>, <code>Price</code>, <code>Published_Date</code>.<br>
      3. Configure enrichment options below.<br>
      4. Select a category filter (or "All Categories") to generate schema for specific event types.<br>
      5. Click <b>Generate Event Schema</b> to create valid JSON-LD blocks.<br><br>
      
      ‚úÖ This tool works entirely offline in your browser.<br>
      ‚úÖ Only includes structured data compliant with Google Rich Results.<br>
      ‚úÖ Only published events with future start dates are included automatically.<br>
      ‚úÖ <strong>v4 Features:</strong> Enhanced address parsing, full organizer/provider blocks, SEO metadata, event scheduling, review enrichment, breadcrumbs, and comprehensive validation.<br>
      ‚úÖ Schema includes organizer, performer, location with parsed address, duration, aggregateRating, offers, and SEO enhancers.<br><br>

      <strong>üìÑ Data Workflow Summary:</strong><br>
      <pre>
Step 1: Export events from Squarespace ‚Üí events_export.csv
     ‚Üì
Step 2: Verify CSV contains all required fields
     ‚Üì
Step 3: Upload CSV and select category filter
     ‚Üì
Step 4: Generate JSON-LD schema blocks
     ‚Üì
Step 5: Paste schema into Squarespace event page (see instructions below)
      </pre>

      <strong>üìå Squarespace Instructions:</strong><br>
      ‚Ä¢ Open your event page in Squarespace.<br>
      ‚Ä¢ Navigate to <b>Page Settings ‚Üí Advanced ‚Üí Header Code Injection</b><br>
      ‚Ä¢ OR insert a <b>Code Block</b> onto the event page.<br>
      ‚Ä¢ <b>Paste the entire generated schema block</b> (includes both ItemList and Event schemas).<br>
      ‚Ä¢ The schema will include all events matching your selected category filter.<br>
      ‚Ä¢ <span class="warning">‚ö†Ô∏è Best Practice:</span> Paste the schema on a main events listing page (e.g., "All Workshops" or category archive page) rather than individual event pages.<br>
      ‚Ä¢ For individual event pages, you can generate schema for a single category containing just that event.<br>
      ‚Ä¢ Always validate your schema after deployment using the test URL tools below.
    </div>

    <label for="eventCsvFile">Upload Event CSV File:</label>
    <input type="file" id="eventCsvFile" accept=".csv" aria-label="Event CSV file upload">
    
    <div style="margin-top: 1rem; padding: 1rem; background: #fff3cd; border-radius: 8px; border: 1px solid #ffc107;">
      <h4 style="margin-top: 0; color: #856404;">üìé Optional Enrichment Files:</h4>
      <label for="reviewsCsvFile" style="display: block; margin-bottom: 0.5rem;">
        Reviews CSV (03 ‚Äì combined_product_reviews.csv):
        <input type="file" id="reviewsCsvFile" accept=".csv" style="margin-left: 0.5rem;">
      </label>
      <label for="mappingsCsvFile" style="display: block;">
        Event-Product Mappings CSV (event-product-mappings-*.csv):
        <input type="file" id="mappingsCsvFile" accept=".csv" style="margin-left: 0.5rem;">
      </label>
      <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; color: #856404;">
        ‚ÑπÔ∏è These files are required for review enrichment and product mapping. Upload them to enable reviews and offers.
      </p>
    </div>
    
    <div id="eventOptionsContainer" style="display:none; margin-top: 1rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
      <h4 style="margin-top: 0;">‚öôÔ∏è Enrichment Options:</h4>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="includeReviews" checked style="margin-right: 0.5rem;">
        <span>Include Reviews (from product mappings)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="includePerformer" checked style="margin-right: 0.5rem;">
        <span>Include Performer (Alan Ranger)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="groupRepeatingEvents" style="margin-right: 0.5rem;">
        <span>Group Repeating Events (EventSchedule)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="includeMerchantFields" style="margin-right: 0.5rem;">
        <span>Include Merchant Center Fields (Phase 6)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="toggleLocationEnrichment" checked style="margin-right: 0.5rem;">
        <span>Auto-Enrich Locations (Geo + Region Fallbacks)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="toggleAvailabilityStarts" style="margin-right: 0.5rem;">
        <span>Include AvailabilityStarts (Merchant+)</span>
      </label>
    </div>
    
    <div id="eventCategoryFilterContainer" style="display:none; margin-top: 1rem;">
      <p>Select category to generate schema for:</p>
      <select id="eventCategoryFilter" aria-label="Event category filter"></select>
      <button onclick="generateEventSchema()">Generate Event Schema</button>
    </div>

    <h3>Generated JSON-LD Schema:</h3>
    <div id="eventOutputContainer" style="position: relative; z-index: 1; margin-bottom: 1rem;">
      <button id="copySchemaButtonTop" onclick="copyToClipboard('eventOutput')" style="margin-bottom: 0.75rem; background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; position: relative; z-index: 10; display: inline-block; visibility: visible; opacity: 1;">üìã Copy Schema to Clipboard</button>
      <pre id="eventOutput" style="position: relative; z-index: 1; max-height: 600px; overflow-y: auto; margin-bottom: 0.75rem;"></pre>
      <button id="copySchemaButton" onclick="copyToClipboard('eventOutput')" style="margin-top: 0; background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; position: relative; z-index: 10; display: inline-block; visibility: visible; opacity: 1;">üìã Copy Schema to Clipboard</button>
    </div>
    
    <div id="debugLogContainer" style="display:none; margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6; max-height: 400px; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
        <h4 style="margin: 0;">üîç Debug Log:</h4>
        <button onclick="copyDebugLog(this)" style="padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
          üìã Copy Debug Log
        </button>
      </div>
      <pre id="debugLog" style="margin: 0; font-size: 0.875rem; white-space: pre-wrap; word-wrap: break-word;"></pre>
    </div>
    
    <div id="summaryPanel" style="display:none; margin-top: 1rem; padding: 1rem; background: #e8f4f8; border-radius: 8px; border: 1px solid #3182ce;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
        <h4 style="margin: 0; color: #2c5282;">üìä Schema Generation Summary</h4>
        <button onclick="showFieldVerificationModal()" style="padding: 0.5rem 1rem; background: #48bb78; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
          üîç View Field Verification
        </button>
      </div>
      <div id="summaryContent" style="font-size: 0.875rem; line-height: 1.6;"></div>
    </div>
    
    <div id="merchantFeedContainer" style="display:none; margin-top: 1rem;">
      <button id="exportMerchantFeedBtn" onclick="exportMerchantFeed()" style="padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">
        üì• Export Merchant Center Feed (.json)
      </button>
    </div>

    <div class="test-url-section">
      <h4>Test Generated Schema:</h4>
      <p>Paste a URL containing your schema to validate it:</p>
      <label for="eventTestUrl">Test URL:</label>
      <input type="text" id="eventTestUrl" placeholder="https://example.com/page-with-schema" aria-label="Event test URL">
      <div class="button-group">
        <button onclick="testSchemaOrg('eventTestUrl')">Test on Schema.org Validator</button>
        <button onclick="testGoogleRichResults('eventTestUrl')" class="secondary">Test on Google Rich Results</button>
      </div>
    </div>
  </div>

  <!-- Field Verification Modal -->
  <div id="fieldVerificationModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); overflow-y: auto;" onclick="if(event.target.id === 'fieldVerificationModal') closeFieldVerificationModal();">
    <div style="background-color: white; margin: 2% auto; padding: 2rem; border-radius: 12px; width: 90%; max-width: 900px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative;" onclick="event.stopPropagation();">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 2px solid #e2e8f0; padding-bottom: 1rem;">
        <h2 style="margin: 0; color: #2d3748;">üîç Field Verification Summary</h2>
        <button onclick="closeFieldVerificationModal()" style="background: #f56565; color: white; border: none; border-radius: 6px; padding: 0.5rem 1rem; cursor: pointer; font-size: 1rem;">‚úï Close</button>
      </div>
      <div id="fieldVerificationModalContent"></div>
    </div>
  </div>

  <!-- Product Tab Content -->
  <div id="productTab" class="tab-content">
    <div class="instructions">
      <strong>üõ† Product Schema Generator</strong><br><br>
      
      ‚úÖ This tool works entirely offline in your browser.<br>
      ‚úÖ Only includes structured data compliant with Google Rich Results and Merchant Center policies.<br>
      ‚úÖ Automatically includes Schema Suppressor v1.3 to prevent duplicate Squarespace Product schemas.<br><br>

      <!-- Desktop App Launch Button (Web Mode Only) -->
      <div id="desktop-launch" style="display:none; margin-bottom:1rem; padding:1.5rem; border:2px dashed #ccc; border-radius:12px; background:#fffbe6;">
        <h3 style="margin-bottom:0.5rem; color:#2d3748; text-align:center;">üíª Want Automated Steps?</h3>
        <p style="margin-bottom:1rem; color:#4a5568; text-align:center;">This web version runs in read-only mode. The desktop app can automatically chain steps 2‚Üí3a‚Üí3b‚Üí4 after you upload a file.</p>
        
        <div style="background:#f7fafc; padding:1rem; border-radius:8px; margin-bottom:1rem; border:1px solid #e2e8f0;">
          <p style="margin:0 0 0.75rem 0; font-weight:600; color:#2d3748;">üìã How to use the desktop app:</p>
          <ol style="margin:0; padding-left:1.5rem; color:#4a5568; line-height:1.8;">
            <li>Open your project folder in a terminal</li>
            <li>Run: <code style="background:#edf2f7; padding:2px 6px; border-radius:4px; font-family:monospace;">npm run build:desktop</code></li>
            <li>Navigate to: <code style="background:#edf2f7; padding:2px 6px; border-radius:4px; font-family:monospace;" id="exePathDisplay">%LOCALAPPDATA%\SchemaTools\SchemaTools-win32-x64\SchemaTools.exe</code></li>
            <li>Double-click <strong>SchemaTools.exe</strong> to launch</li>
          </ol>
          <p style="margin:0.75rem 0 0 0; padding:0.75rem; background:#e8f4f8; border-radius:6px; font-size:0.875rem; color:#2c5282; border-left:3px solid #3182ce;">
            <strong>‚ÑπÔ∏è Note:</strong> The built app (.exe) is saved to <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">%LOCALAPPDATA%</code> to avoid Dropbox file locks. 
            <strong>All input/output files remain in your Dropbox project folder</strong> (<code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">inputs-files/</code> and <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">outputs/</code>).
          </p>
        </div>
        
        <div style="text-align:center;">
          <button id="copyPathBtn" style="padding:0.75rem 1.5rem; font-size:1rem; border:none; border-radius:8px; background:#0078D4; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-right:0.5rem; margin-bottom:0.5rem;" onmouseover="this.style.background='#005a9e'" onmouseout="this.style.background='#0078D4'">
            üìã Copy Build Command
          </button>
          <button id="openFolderBtn" style="padding:0.75rem 1.5rem; font-size:1rem; border:none; border-radius:8px; background:#27AE60; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-right:0.5rem; margin-bottom:0.5rem;" onmouseover="this.style.background='#229954'" onmouseout="this.style.background='#27AE60'">
            üìÅ Open PowerShell Here
          </button>
          <button id="showInstructionsBtn" style="padding:0.75rem 1.5rem; font-size:1rem; border:1px solid #0078D4; border-radius:8px; background:white; color:#0078D4; cursor:pointer; font-weight:600; transition:background 0.2s; margin-right:0.5rem; margin-bottom:0.5rem;" onmouseover="this.style.background='#f0f7ff'" onmouseout="this.style.background='white'">
            ‚ÑπÔ∏è Show Full Path
          </button>
          <button id="openExeBtnWeb" style="padding:0.75rem 1.5rem; font-size:1rem; border:none; border-radius:8px; background:#9b59b6; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-bottom:0.5rem;" onmouseover="this.style.background='#8e44ad'" onmouseout="this.style.background='#9b59b6'">
            ‚ñ∂Ô∏è Open Electron App (if built)
          </button>
        </div>
      </div>

      <!-- Build Desktop App Section (Electron Mode Only) -->
      <div id="build-desktop-section" style="display:none; margin-bottom:1rem; padding:1.5rem; border:2px solid #27AE60; border-radius:12px; background:#f0fdf4;">
        <h3 style="margin-bottom:0.5rem; color:#2d3748; text-align:center;">üî® Build Desktop App</h3>
        <p style="margin-bottom:1rem; color:#4a5568; text-align:center;">Build the Windows .exe file directly from this app.</p>
        
        <div style="text-align:center; margin-bottom:1rem;">
          <button id="buildDesktopBtn" style="padding:1rem 2rem; font-size:1.2rem; border:none; border-radius:8px; background:#27AE60; color:white; cursor:pointer; font-weight:600; transition:background 0.2s;" onmouseover="this.style.background='#229954'" onmouseout="this.style.background='#27AE60'">
            üî® Build Desktop App (npm run build:desktop)
          </button>
          <button id="openExeBtn" style="display:none; padding:1rem 2rem; font-size:1.2rem; border:none; border-radius:8px; background:#0078D4; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-left:0.5rem;" onmouseover="this.style.background='#005a9e'" onmouseout="this.style.background='#0078D4'">
            ‚ñ∂Ô∏è Open Built App (SchemaTools.exe)
          </button>
        </div>
        
        <div id="buildOutput" style="display:none; margin-top:1rem; padding:1rem; background:#1e1e1e; color:#d4d4d4; border-radius:8px; font-family:'Courier New', monospace; font-size:0.75rem; max-height:300px; overflow-y:auto; white-space:pre-wrap;"></div>
      </div>

      <!-- ===================== COMBINED DEBUG LOG ===================== -->
      <div id="combined-debug-log-section" style="margin-top: 2rem; margin-bottom: 1.5rem; padding: 1.5rem; background: #1e1e1e; border: 2px solid #4a5568; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h3 style="color: #d4d4d4; margin: 0; font-size: 1.25rem; font-weight: 600;">üìã Combined Debug Log (All Steps)</h3>
          <div>
            <button id="clearCombinedLogBtn" onclick="clearCombinedLog()" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #4a5568; border-radius: 6px; background: #2d3748; color: #d4d4d4; cursor: pointer; margin-right: 0.5rem; transition: background 0.2s;" onmouseover="this.style.background='#4a5568'" onmouseout="this.style.background='#2d3748'">
              üóëÔ∏è Clear Log
            </button>
            <button id="copyCombinedLogBtn" onclick="copyCombinedLog()" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: none; border-radius: 6px; background: #667eea; color: white; cursor: pointer; font-weight: 600; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
              üìã Copy All Logs
            </button>
          </div>
        </div>
        <div id="combinedDebugLog" style="padding: 1rem; background: #0d1117; color: #d4d4d4; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 500px; overflow-y: auto; white-space: pre-wrap; border: 1px solid #30363d;">No logs yet. Step outputs will appear here as they run...</div>
      </div>

      <!-- ===================== STATUS DASHBOARD ===================== -->
      <div id="workflow-status-dashboard" style="margin-top: 1rem; margin-bottom: 1.5rem; padding: 1.5rem; background: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
        <h3 style="color: #2d3748; margin: 0 0 1rem 0; font-size: 1.25rem; font-weight: 600;">üìä Workflow Status Dashboard</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem;">
          <div id="step-status-0" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.05); border-radius: 8px; text-align: center; color: #2d3748;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è≥</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 0</div>
            <div id="step-status-text-0" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Initializing</div>
          </div>
          <div id="step-status-1" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 1</div>
            <div id="step-status-text-1" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-2" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 2</div>
            <div id="step-status-text-2" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-3a" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 3a</div>
            <div id="step-status-text-3a" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-3b" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 3b</div>
            <div id="step-status-text-3b" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-4" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 4</div>
            <div id="step-status-text-4" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
        </div>
      </div>

      <!-- ===================== PRODUCT SCHEMA WORKFLOW ===================== -->
      <section id="product-schema-workflow" style="display: flex; flex-direction: column; gap: 1.5rem; margin-top: 1.5rem;">

        <!-- STEP 0: Initialize Local Executor -->
        <div id="step0-init" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step0-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è≥</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">‚öôÔ∏è Step 0 ‚Äì Setup Check</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Checking your setup and unlocking the workflow. This happens automatically.
          </p>
          <div id="executorStatus" style="margin-top: 0.75rem; padding: 0.75rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; color: #856404; font-size: 0.875rem; font-weight: 500;">
            üîç Checking your setup...
          </div>
          <div id="executorActions" style="margin-top: 0.75rem; display: flex; gap: 0.75rem; flex-wrap: wrap;">
            <button id="startLocalBtn" style="display: none; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
              ‚ö° Start Local Server
            </button>
            <button id="copyCommandBtn" style="display: none; background: #718096; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#4a5568'" onmouseout="this.style.background='#718096'">
              üìã Copy CLI Command
            </button>
          </div>
          <pre id="executorConsole" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 150px; overflow-y: auto; white-space: pre-wrap;"></pre>
        </div>

        <!-- STEP 1 -->
        <div id="step1-container" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step1-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è∏Ô∏è</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">üßæ Step 1 ‚Äì Squarespace Product Export Setup</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What to do:</strong> Export your products from Squarespace ‚Üí <strong>Commerce ‚Üí Products ‚Üí Export CSV</strong>.<br>
            Then upload the CSV file below. <strong>After upload, Step 2 will start automatically.</strong>
          </p>
          <input type="file" id="file-step1" accept=".csv" style="margin-top: 0.75rem; display: block; font-size: 0.875rem; opacity: 0.5; cursor: not-allowed;" disabled />
          <p id="step1LockMessage" style="font-size: 0.75rem; color: #718096; margin-top: 0.5rem; font-style: italic;">
            ‚è≥ Step 0 is checking your setup... this will unlock automatically.
          </p>
          <div id="progress-step1" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step1" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
        </div>

        <!-- STEP 2 -->
        <div id="step2-container" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step2-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è∏Ô∏è</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">üßπ Step 2 ‚Äì Clean and Normalize CSV</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> This step formats your Squarespace export for schema generation.<br>
            <strong>When:</strong> Runs automatically after Step 1 upload completes.<br>
            <strong>You don't need to do anything</strong> - just wait for it to finish. Step 3a will start automatically next.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Triggered automatically after Step 1 upload</li>
            <li>Normalizes column names and trims invalid rows</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">02 ‚Äì products_cleaned.xlsx</code></li>
          </ul>
          <div id="step2WebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Web Mode:</strong> Steps 2-4 require Electron app or local execution.<br>
            <small>Download Electron desktop app for full automation.</small>
          </div>
          <div id="progress-step2" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step2" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="cleanConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3a: Fetch Google Reviews -->
        <div id="step3a-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì• Step 3a ‚Äì Fetch Google Reviews</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> Connects to your Google My Business account and retrieves all customer reviews.<br>
            <strong>When:</strong> Runs automatically after Step 2 completes.<br>
            <strong>First time:</strong> A browser window will open for OAuth authorization - just approve it.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires valid OAuth JSON in <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">/inputs-files/workflow/credentials/</code></li>
            <li>First time: Browser will open for OAuth authorization</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03b ‚Äì google_reviews.csv</code></li>
          </ul>
          <div id="step3aWebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="fetchGoogleReviews" onclick="runGoogleReviewsFetcher()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            üì• Fetch Google Reviews (Local)
          </button>
          <div id="progress-step3a" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3a" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="googleConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3b: Merge Reviews -->
        <div id="step3b-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üîó Step 3b ‚Äì Merge Trustpilot and Google Reviews</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> Combines both review sources into one clean dataset ready for schema generation.<br>
            <strong>When:</strong> Runs automatically after Step 3a completes.<br>
            <strong>You don't need to do anything</strong> - just wait for it to finish. Step 4 will start automatically next.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03a ‚Äì trustpilot_historical_reviews.csv</code> and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03b ‚Äì google_reviews.csv</code></li>
            <li>Filters out reviews below 4‚òÖ</li>
            <li>Automatically maps reviews to product names</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì combined_product_reviews.csv</code></li>
          </ul>
          <div id="step3bWebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="mergeReviewsBtn" onclick="runMergeReviews()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            üîó Merge Reviews
          </button>
          <div id="progress-step3b" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3b" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="mergeConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3c: Upload Merged Dataset (for Step 4) -->
        <div style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì§ Step 3c ‚Äì Upload Merged Dataset</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            After merging reviews, upload the final merged file for schema generation.<br>
            File: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì products_with_review_data_final.xlsx</code>
          </p>
          <input type="file" id="file-step3" accept=".xlsx" style="margin-top: 0.75rem; display: block; font-size: 0.875rem;" />
          <div id="progress-step3" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
        </div>

        <!-- STEP 4 -->
        <div id="step4-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">‚öôÔ∏è Step 4 ‚Äì Generate Product Schema</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> Generates JSON-LD schema files from your merged review data.<br>
            <strong>When:</strong> Runs automatically after Step 3b completes.<br>
            <strong>What you need to do:</strong> Nothing - just wait for it to finish. Your schema files will be ready!
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">02 ‚Äì products_cleaned.xlsx</code> and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì combined_product_reviews.csv</code></li>
            <li>Generates one HTML file per product with embedded reviews</li>
            <li>Includes aggregate ratings and individual review data</li>
            <li>‚úÖ <strong>Automatically includes Schema Suppressor v1.3</strong> - removes duplicate Squarespace Product schemas</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">/outputs/</code> folder (HTML files) and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">04 ‚Äì alanranger_product_schema_FINAL_WITH_REVIEW_RATINGS.csv</code></li>
          </ul>
          <div id="step4WebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="run-step4" onclick="generateProductSchema()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            Generate Schema (Step 4)
          </button>
          <div id="progress-step4" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step4" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="step4MatchStatus" style="display:none; margin-top: 0.75rem; padding: 0.75rem; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px; font-size: 0.875rem; color: #0c4a6e;">
            <strong>üìä Products Matched:</strong> <span id="step4MatchCount">0</span> products have reviews embedded in their schema
          </div>
          <div id="productSchemaSuccess" style="display:none; margin-top: 1rem; padding: 1rem; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; color: #155724;">
            ‚úÖ Schema generation complete.<br>
            Files saved in your project folder: <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">/outputs/</code> (individual JSON/HTML files) and <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">/inputs-files/workflow/</code> (combined CSV).
          </div>
        </div>

        <!-- STEP 5 -->
        <div style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì• Step 5 ‚Äì Insert Schema into Squarespace</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Open your product page ‚Üí <strong>Code Block</strong> ‚Üí paste generated schema.<br>
            Validate using <a href="https://search.google.com/test/rich-results" target="_blank" style="color: #667eea; text-decoration: underline;">Rich Results Test</a>.
          </p>
        </div>

      </section>

    </div>

    <h3 style="margin-top: 2rem;">Generated JSON-LD Schema:</h3>
    <p style="color: #4a5568; font-size: 0.9rem; margin-bottom: 0.5rem;">Preview of JSON-LD schema blocks for each product:</p>
    <textarea id="productOutput" readonly style="min-height: 400px; font-family: 'Courier New', monospace; font-size: 0.85rem; width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px;"></textarea>
    <button onclick="copyToClipboard('productOutput')" style="margin-top: 0.75rem; background: #667eea; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer;">Copy to Clipboard</button>
    
    <!-- Hidden file input for Step 4 (backward compatibility) -->
    <input type="file" id="productCsvFile" accept=".csv,.xlsx" style="display: none;" aria-label="Product CSV/XLSX file upload">

    <div class="test-url-section">
      <h4>Test Generated Schema:</h4>
      <p>Paste a URL containing your schema to validate it:</p>
      <label for="productTestUrl">Test URL:</label>
      <input type="text" id="productTestUrl" placeholder="https://example.com/page-with-schema" aria-label="Product test URL">
      <div class="button-group">
        <button onclick="testSchemaOrg('productTestUrl')">Test on Schema.org Validator</button>
        <button onclick="testGoogleRichResults('productTestUrl')" class="secondary">Test on Google Rich Results</button>
      </div>
    </div>
  </div>

  <!-- Schema Validator Tab Content -->
  <div id="validatorTab" class="tab-content">
    <div class="instructions">
      <strong>üîç Schema Validator</strong><br><button class='secondary' style='float:right;margin-top:-0.25rem' onclick='switchTab("guide")'>Open Tab Guide ‚Üí</button>
      Validate schema markup on your pages using industry-standard validators. Choose single URL validation or batch processing from CSV.<br><br>
      
      ‚úÖ Works entirely in your browser (no server required).<br>
      ‚úÖ Validates Product, Event, Organization, and other schema types.<br>
      ‚úÖ Identifies missing fields and provides enhancement suggestions.<br><br>
      
      <strong>‚ö†Ô∏è Note:</strong> Cross-origin restrictions may prevent fetching some URLs. Use URLs from the same domain or enable CORS if testing locally.
    </div>

    <!-- Single URL Validator Section -->
    <div class="single-url-section">
      <label for="singleUrlInput">Validate a Single URL:</label>
      <input type="text" id="singleUrlInput" placeholder="https://www.example.com/page-with-schema" aria-label="Single URL to validate">
      <button onclick="runSingleUrlValidation()" style="margin-top: 0.75rem;">Run Validation</button>
      <p style="margin-top: 0.75rem; color: #4a5568; font-size: 0.9rem;">This will process the URL and display validation results in the table below. Use the validator buttons in the table to open external validators.</p>
      <label style="margin-top: 0.75rem; display: flex; align-items: center; gap: 0.5rem; font-weight: normal;">
        <input type="checkbox" id="autoSaveToSupabase" style="width: auto; margin: 0;" onchange="saveAutoSavePreference()">
        <span>Auto-save to Supabase</span>
      </label>
    </div>

    <!-- Batch CSV Validator Section -->
    <div class="batch-section">
      <label for="validatorCsvFile" style="margin-top: 0;">Upload CSV File with URLs:</label>
      <p style="margin-top: 0.5rem; margin-bottom: 1rem; color: #4a5568; font-size: 0.95rem; font-style: italic;">
        Use this to batch validate multiple URLs from your site for schema health.
      </p>
      <input type="file" id="validatorCsvFile" accept=".csv" aria-label="Validator CSV file upload" onchange="onFileUpload()">
      <button onclick="startValidation()">Validate URLs</button>
      <button onclick="downloadTemplateCSV()" class="secondary" style="margin-left: 0.5rem;">Download Template CSV</button>
      <button id="exportAllBtn" onclick="exportAllEnhanced()" class="secondary" style="margin-left: 0.5rem;" disabled>Export All Enhanced</button>
      <button id="saveAllBtn" onclick="saveAllToSupabase()" class="secondary" style="margin-left: 0.5rem;" disabled>Save All to Supabase</button>

    <div id="validatorProgress" style="display:none; margin-top: 1.5rem;">
      <div class="progress-bar">
        <div id="progressBarFill" class="progress-bar-fill" style="width: 0%;"></div>
      </div>
      <p id="progressText" style="margin-top: 0.75rem; color: #4a5568; font-size: 0.95rem;">Processing...</p>
    </div>

    <div id="validatorResults" style="display:none; margin-top: 2rem;">
      <h3>Validation Results</h3>
      <p style="margin-top: 0.5rem; margin-bottom: 1rem; color: #4a5568; font-size: 0.9rem; font-style: italic;">
        External validators open in a new tab. Due to cross-origin limits, results can't be read automatically ‚Äî set the status after reviewing.
      </p>
      <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
        <button onclick="setAllExternalStatusTo('Passed')" class="secondary" style="font-size: 0.875rem; padding: 0.5rem 1rem;">Set all Not run ‚Üí Passed</button>
        <button onclick="resetAllExternalStatus()" class="secondary" style="font-size: 0.875rem; padding: 0.5rem 1rem;">Reset all to Not run</button>
      </div>
      
      <!-- Status Legend -->
      <div class="status-legend">
        <div class="status-legend-item">
          <span class="chip-sample passed">‚úÖ Passed</span>
          <span>All valid; no missing fields</span>
        </div>
        <div class="status-legend-item">
          <span class="chip-sample issues">‚ö†Ô∏è Warning</span>
          <span>Duplicate or redundant schema nodes (non-critical)</span>
        </div>
        <div class="status-legend-item">
          <span class="info-entry">‚ÑπÔ∏è Info</span>
          <span>Legitimate multi-instance schemas (normal for Events, Products, FAQs)</span>
        </div>
        <div class="status-legend-item">
          <span class="chip-sample critical">‚ùå Critical</span>
          <span>Structural or required field errors</span>
        </div>
        <div class="status-legend-item" style="margin-left: auto;">
          <span style="color: #6b7280;">üí° Click any badge or "View Details" to see full analysis</span>
        </div>
      </div>
      
      <div class="scrollable-container">
        <table class="results-table">
          <thead>
            <tr>
              <th><span class="sortable-header" data-column="0">Page URL</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="1">Schema Type</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="2">Status</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="3">Missing Fields</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="4">Warnings</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="5">Info</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="6">Rich Results<br>Status (external)</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="7">Schema.org<br>Status (external)</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="8">Notes</span><span class="sort-indicator"> ‚Üï</span></th>
              <th>Actions</th>
            </tr>
            <tr class="filter-row">
              <th><input type="text" class="filter-input" data-column="0" placeholder="Filter URL..."></th>
              <th><input type="text" class="filter-input" data-column="1" placeholder="Filter Type..."></th>
              <th><input type="text" class="filter-input" data-column="2" placeholder="Filter Status..."></th>
              <th><input type="text" class="filter-input" data-column="3" placeholder="Filter Missing..."></th>
              <th><input type="text" class="filter-input" data-column="4" placeholder="Filter Warnings..."></th>
              <th><input type="text" class="filter-input" data-column="5" placeholder="Filter Info..."></th>
              <th><input type="text" class="filter-input" data-column="6" placeholder="Filter Rich Results..."></th>
              <th><input type="text" class="filter-input" data-column="7" placeholder="Filter Schema.org..."></th>
              <th><input type="text" class="filter-input" data-column="8" placeholder="Filter Notes..."></th>
              <th></th>
            </tr>
          </thead>
          <tbody id="resultsTableBody">
          </tbody>
        </table>
      </div>
    </div>

    </div>

    <!-- Help Block -->
    <div class="help-section" style="margin-top:1rem;padding:1rem;background:#f9f9f9;border-radius:8px;">
      <strong>‚ÑπÔ∏è How to Read Results:</strong>
      <ul style="margin-top:0.5rem;">
        <li><b>Schema Type</b>: Type(s) detected from JSON-LD (<code>@type</code> values).</li>
        <li><b>Status</b>: "Error" means fetch failed; "OK" means schema was found.</li>
        <li><b>Skipped</b>: Offline mode‚Äîexternal validators not queried.</li>
        <li><b>Schema.org / Google Buttons</b>: Open page in respective validators for manual checks.</li>
        <li><b>Save to Supabase</b>: (Optional) Stores results if DB logging is enabled.</li>
      </ul>
    </div>

    <div class="help-block" onclick="toggleHelpBlock()" onkeydown="if(event.key==='Enter'||event.key===' ')toggleHelpBlock()" role="button" tabindex="0" aria-expanded="false" id="helpBlock">
      <div class="help-block-header">
        <span>‚ÑπÔ∏è About Schema Validators</span>
        <span class="help-block-icon">‚ñº</span>
      </div>
      <div class="help-block-content" id="helpBlockContent">
        <strong>Schema.org Validator:</strong><br>
        Validates that your schema markup follows the Schema.org vocabulary specifications. Checks for correct syntax, required fields, and proper structure. Essential for ensuring your schema is semantically correct.<br><br>
        
        <strong>Google Rich Results Test:</strong><br>
        Tests whether your schema qualifies for Google's rich results (enhanced search listings). Shows which rich result types are detected and any issues that might prevent them from appearing in search results.<br><br>
        
        <strong>Results:</strong><br>
        Validation results are displayed in the table above. For detailed analysis, you'll need to manually review the validator pages opened in new tabs. When Supabase integration is connected, results can be automatically captured and stored for analysis.<br><br>
        
        <strong>Note:</strong> Both validators open in new browser tabs so you can review the detailed results while keeping this tool open.
      </div>
    </div>

    <!-- Debug Console -->
    <div class="debug-console">
      <div class="debug-console-header">
        <span>üîç Debug Console</span>
        <div class="debug-console-actions">
          <button onclick="clearDebugConsole()" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Clear</button>
          <button onclick="copyDebugConsole()" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Copy Logs</button>
        </div>
      </div>
      <div class="debug-console-content" id="debugConsoleContent">
        <div class="debug-log-entry success">
          <span class="debug-log-time"></span>Debug console ready. Logs will appear here when validation runs.
        </div>
      </div>
    </div>
  </div>

  <!-- Tab Guide Tab Content -->
  <div id="guideTab" class="tab-content">
    <div class="instructions" style="max-width: 100%;">
      <h2>üß† Tool Guide: What Each Tab Does</h2>

      <p>This tool contains several tabs, each with a specific use:</p>

      <h3>üü¢ Event Schema</h3>
      <ul>
        <li>Use this tab to generate JSON-LD Event schema from a CSV of your photography workshops.</li>
        <li>Supports <code>location</code>, <code>performer</code>, <code>offers</code>, and <code>organizer</code> fields.</li>
        <li>Paste the resulting schema into a code block on your Squarespace event page.</li>
      </ul>

      <h3>üîµ Product Schema</h3>
      <ul>
        <li>Generates <code>Product</code> schema from a CSV of lessons, vouchers, or services.</li>
        <li>Automatically filters out products with weak or missing reviews.</li>
        <li>‚úÖ <strong>Includes Schema Suppressor v1.3</strong> - automatically removes duplicate Squarespace Product schemas to prevent conflicts.</li>
        <li>Paste the JSON-LD into product pages on Squarespace.</li>
      </ul>

      <h3>üü° Schema Validator</h3>
      <ul>
        <li>Enter one or more live URLs (CSV or single entry support coming).</li>
        <li>Fetches the page content and validates all structured data inside it.</li>
        <li>Flags missing or invalid fields and optionally builds an enhanced schema block you can download.</li>
        <li>Use this to <strong>audit</strong>, <strong>debug</strong>, or <strong>improve</strong> existing Squarespace pages.</li>
      </ul>

      <h3>üìå Best Practices</h3>
      <ul>
        <li>Only insert schema relevant to the page (don't paste every product on every product page).</li>
        <li>Always validate using the <strong>Schema Validator</strong> before and after injecting schema.</li>
        <li>Use <code>&lt;script type="application/ld+json"&gt;</code> inside a code block on Squarespace pages.</li>
      </ul>

      <h3>üîß Upcoming Features</h3>
      <ul>
        <li>Support for validating a single URL directly (no CSV needed).</li>
        <li>Supabase integration to track schema versions and history.</li>
        <li>AI suggestions for schema fixes.</li>
      </ul>
    </div>
  </div>

</div>

<script>
  // Tab switching - MUST be absolutely first, before any other code
  function switchTab(mode) {
    // Clear cache and storage when switching tabs
    try {
      // Clear ResultCache if it exists
      if (typeof ResultCache !== 'undefined') {
        if (ResultCache instanceof Map) {
          ResultCache.clear();
        } else if (ResultCache.clear && typeof ResultCache.clear === 'function') {
          ResultCache.clear();
        }
      }
      // Clear validationResults if it exists
      if (typeof validationResults !== 'undefined' && Array.isArray(validationResults)) {
        validationResults.length = 0;
      }
      // Clear localStorage and sessionStorage
      localStorage.removeItem('schemaValidatorResults');
      localStorage.removeItem('schemaValidatorCache');
      sessionStorage.removeItem('schemaValidatorResults');
      sessionStorage.removeItem('schemaValidatorCache');
    } catch (e) {
      console.warn('Failed to clear storage:', e);
    }
    
    // Clear the results table
    const tableBody = document.getElementById('resultsTableBody');
    if (tableBody) {
      tableBody.innerHTML = '';
    }
    
    // Reset all active tabs and contents
    const tabs = document.querySelectorAll('.tab');
    const contents = document.querySelectorAll('.tab-content');
    
    for (const tab of tabs) {
      tab.classList.remove('active');
    }
    for (const content of contents) {
      content.classList.remove('active');
    }
    
    // Activate correct tab based on mode
    const tabMap = {
      'event': { tabIndex: 0, contentId: 'eventTab' },
      'product': { tabIndex: 1, contentId: 'productTab' },
      'validator': { tabIndex: 2, contentId: 'validatorTab' },
      'guide': { tabIndex: 3, contentId: 'guideTab' }
    };
    
    const config = tabMap[mode];
    if (config && tabs[config.tabIndex] && tabs[config.tabIndex] !== null) {
      tabs[config.tabIndex].classList.add('active');
      const content = document.getElementById(config.contentId);
      if (content) {
        content.classList.add('active');
      }
    }
  }
  
  // Make it globally available
  window.switchTab = switchTab;
</script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
  // Override console methods to also log to debug console (MUST be before debugLog)
  const originalConsoleLog = console.log.bind(console);
  const originalConsoleError = console.error.bind(console);
  const originalConsoleWarn = console.warn.bind(console);
  
  // Schema Validator Suppression Configuration
  const SUPPRESSION_CONFIG = {
    suppressions: {
      global: {
        ignoreSchemaTypes: [
          "BreadcrumbList",
          "SearchAction",
          "Person",
          "Event",
          "ItemList",
          "Article",
          "Product"
        ],
        ignoreRecommendedFields: [
          "publisher",
          "telephone",
          "url",
          "description",
          "image",
          "logo",
          "contactPoint"
        ],
        ignoreWarningsContaining: [
          "Duplicate Event",
          "Duplicate BreadcrumbList",
          "Recommended field",
          "Unknown schema type",
          "Missing recommended",
          "normal navigation schema",
          "acceptable for combined schema types"
        ],
        ignoreInfoContaining: [
          "BreadcrumbList detected",
          "Recommended field",
          "Legitimate multi-instance schemas",
          "cached or blocked"
        ],
        ignoreUrlsMatching: [
          "/photographic-workshops-near-me",
          "/photography-classes",
          "/photography-services",
          "/photography-workshops",
          "/shop"
        ],
        downgradeDuplicates: true,
        collapseMultiInstanceEvents: true,
        hideSquarespaceInjectedBlocks: true,
        treatWarningsAsPass: true
      },
      rules: {
        Organization: {
          suppressMissingRecommended: true,
          ignoreExtraNodes: true
        },
        LocalBusiness: {
          suppressMissingRecommended: true,
          ignoreExtraNodes: true
        },
        WebSite: {
          suppressMissingRecommended: true,
          requireOnly: ["url", "name"]
        },
        Person: {
          ignoreUnknownType: true
        },
        BreadcrumbList: {
          collapseDuplicates: true
        },
        Event: {
          allowMultiple: true,
          collapseDuplicates: true
        },
        Product: {
          allowMultiple: true,
          ignoreNoReview: true
        }
      }
    }
  };

  // Multi-instance allowed schema types (expected to appear multiple times on a page)
  const MULTI_INSTANCE_ALLOWED_TYPES = ['Event', 'Product', 'Course', 'Article', 'Review', 'FAQPage', 'ListItem', 'Offer'];

  // Helper: Detect inferred schema types based on patterns in JSON-LD
  function detectInferredTypes(allNodes) {
    const inferredTypes = [];
    const typeCounts = {};
    
    // Count occurrences of each type
    allNodes.forEach(node => {
      const types = asArray(node['@type']);
      types.forEach(type => {
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });
    });
    
    // Rule 1: Carousel inference
    // If ‚â•3 Event items exist ‚Üí infer Carousel
    const eventCount = typeCounts['Event'] || 0;
    if (eventCount >= 3) {
      inferredTypes.push({ type: 'Carousel', reason: `from ${eventCount} Event schemas` });
    }
    
    // Rule 2: Carousel inference from Product/Course
    // If multiple Product or Course schemas exist ‚Üí also infer Carousel
    const productCount = typeCounts['Product'] || 0;
    const courseCount = typeCounts['Course'] || 0;
    if ((productCount + courseCount) >= 3) {
      inferredTypes.push({ type: 'Carousel', reason: `from ${productCount + courseCount} Product/Course schemas` });
    }
    
    // Rule 3: ReviewSnippet inference
    // If any item contains aggregateRating or review ‚Üí infer ReviewSnippet
    const hasReviews = allNodes.some(node => {
      return node.aggregateRating || 
             (node.review && Array.isArray(node.review) && node.review.length > 0) ||
             node.reviews;
    });
    
    if (hasReviews) {
      const reviewCount = allNodes.filter(node => {
        return node.aggregateRating || 
               (node.review && Array.isArray(node.review) && node.review.length > 0) ||
               node.reviews;
      }).length;
      inferredTypes.push({ type: 'ReviewSnippet', reason: `from ${reviewCount} item${reviewCount !== 1 ? 's' : ''} with reviews` });
    }
    
    // Rule 4: MerchantListing (Google) inference
    // If any Product schema contains all Merchant Center fields ‚Üí infer MerchantListing (Google)
    const productNodes = allNodes.filter(node => {
      const types = asArray(node['@type']);
      return types.includes('Product');
    });
    
    console.log(`[MerchantListing] Checking ${productNodes.length} Product node(s) for Merchant Center fields`);
    debugLog(`[MerchantListing] Checking ${productNodes.length} Product node(s) for Merchant Center fields`, 'info');
    
    // Debug: Log Product node details
    productNodes.forEach((node, idx) => {
      console.log(`[MerchantListing] Product node ${idx + 1}:`, {
        '@type': node['@type'],
        hasOffers: !!node.offers,
        offersType: node.offers ? (Array.isArray(node.offers) ? 'array' : 'object') : 'none',
        hasPriceCurrency: !!node.offers?.priceCurrency || !!node.offers?.[0]?.priceCurrency,
        hasPrice: !!node.offers?.price || !!node.offers?.[0]?.price,
        hasAvailability: !!node.offers?.availability || !!node.offers?.[0]?.availability,
        hasMerchantReturnPolicy: !!node.hasMerchantReturnPolicy
      });
    });
    
    const hasMerchantListing = productNodes.some(node => {
      const detected = detectMerchantListing(node);
      if (detected) {
        console.log(`[MerchantListing] ‚úÖ Detected MerchantListing in Product node:`, node);
        debugLog(`[MerchantListing] ‚úÖ Detected MerchantListing in Product node: ${JSON.stringify({ '@type': node['@type'], hasOffers: !!node.offers, hasReturnPolicy: !!node.hasMerchantReturnPolicy })}`, 'success');
      }
      return detected;
    });
    
    if (hasMerchantListing) {
      inferredTypes.push({ type: 'MerchantListing (Google)', reason: 'Product schema contains all Merchant Center fields (offers, price, priceCurrency, availability, hasMerchantReturnPolicy)' });
      console.log(`[MerchantListing] ‚úÖ Added MerchantListing (Google) to inferred types. Total inferred types:`, inferredTypes);
      debugLog(`[MerchantListing] ‚úÖ Added MerchantListing (Google) to inferred types`, 'success');
    } else {
      console.log(`[MerchantListing] ‚ùå No Product schemas found with all Merchant Center fields`);
      debugLog(`[MerchantListing] ‚ùå No Product schemas found with all Merchant Center fields`, 'info');
    }
    
    // Deduplicate inferred types (e.g., if Carousel appears twice)
    const uniqueInferred = [];
    const seenTypes = new Set();
    inferredTypes.forEach(item => {
      if (!seenTypes.has(item.type)) {
        seenTypes.add(item.type);
        uniqueInferred.push(item);
      }
    });
    
    return uniqueInferred;
  }

  // Suppression Filtering Functions
  function shouldSuppressWarning(message, url = '') {
    if (!message) return false;
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing warning by URL pattern: ${message}`, 'info');
      return true;
    }
    
    // Check message content
    if (sup.ignoreWarningsContaining.some(pattern => message.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing warning by pattern: ${message}`, 'info');
      return true;
    }
    
    return false;
  }

  function shouldSuppressInfo(message, url = '') {
    if (!message) return false;
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing info by URL pattern: ${message}`, 'info');
      return true;
    }
    
    // Check message content
    if (sup.ignoreInfoContaining.some(pattern => message.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing info by pattern: ${message}`, 'info');
      return true;
    }
    
    return false;
  }

  function shouldSuppressMissingField(field, schemaType, url = '') {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    const rule = SUPPRESSION_CONFIG.suppressions.rules[schemaType];
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing missing field by URL pattern: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check if schema type should be ignored
    if (sup.ignoreSchemaTypes.includes(schemaType)) {
      debugLog(`[SUPPRESSION] Suppressing missing field by schema type: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check if field is in ignoreRecommendedFields
    if (sup.ignoreRecommendedFields.includes(field)) {
      debugLog(`[SUPPRESSION] Suppressing missing field by recommended field list: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check type-specific rules
    if (rule) {
      if (rule.suppressMissingRecommended && field.toLowerCase().includes('recommended')) {
        debugLog(`[SUPPRESSION] Suppressing missing field by type rule (suppressMissingRecommended): ${schemaType}.${field}`, 'info');
        return true;
      }
      if (rule.requireOnly && !rule.requireOnly.includes(field)) {
        debugLog(`[SUPPRESSION] Suppressing missing field by type rule (requireOnly): ${schemaType}.${field}`, 'info');
        return true;
      }
    }
    
    return false;
  }

  function shouldSuppressSchemaType(schemaType) {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    return sup.ignoreSchemaTypes.includes(schemaType);
  }

  function shouldDowngradeDuplicate(schemaType) {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    const rule = SUPPRESSION_CONFIG.suppressions.rules[schemaType];
    
    if (sup.downgradeDuplicates) {
      return true;
    }
    
    if (rule && rule.collapseDuplicates) {
      return true;
    }
    
    return false;
  }

  function filterSuppressedWarnings(warnings, url = '') {
    if (!warnings || !Array.isArray(warnings)) return [];
    return warnings.filter(w => !shouldSuppressWarning(w, url));
  }

  function filterSuppressedInfo(info, url = '') {
    if (!info || !Array.isArray(info)) return [];
    return info.filter(i => !shouldSuppressInfo(i, url));
  }

  function filterSuppressedMissingFields(missingFields, schemaType, url = '') {
    if (!missingFields || !Array.isArray(missingFields)) return [];
    
    return missingFields.filter(field => {
      // Extract field name from different formats
      const fieldName = typeof field === 'string' 
        ? field.split(':')[1]?.trim().replace(/["\s]/g, '') || field.split('.')[1] || field
        : field.field || field;
      
      return !shouldSuppressMissingField(fieldName, schemaType, url);
    });
  }

  // Debug Console Logging Functions - MUST be first
  function debugLog(message, level = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const prefix = `[${timestamp}]`;
    
    // Console logging - use original methods to avoid recursion
    if (level === 'error') {
      originalConsoleError(`${prefix} ‚ùå ${message}`);
    } else if (level === 'warn') {
      originalConsoleWarn(`${prefix} ‚ö†Ô∏è ${message}`);
    } else if (level === 'success') {
      originalConsoleLog(`${prefix} ‚úÖ ${message}`);
    } else {
      originalConsoleLog(`${prefix} ${message}`);
    }
    
    // Also write to visible debug panel (statusDebugPanel) - REMOVED, using bottom debug console only
    // Remove this section - debug panel above table has been removed
    
    // Also write to existing debug console (debugConsoleContent)
    const consoleContent = document.getElementById('debugConsoleContent');
    if (consoleContent) {
      const entry = document.createElement('div');
      entry.className = `debug-log-entry ${level}`;
      
      const timeSpan = document.createElement('span');
      timeSpan.className = 'debug-log-time';
      timeSpan.textContent = prefix;
      
      const messageSpan = document.createElement('span');
      messageSpan.textContent = typeof message === 'object' ? JSON.stringify(message, null, 2) : message;
      
      entry.appendChild(timeSpan);
      entry.appendChild(messageSpan);
      consoleContent.appendChild(entry);
      
      // Auto-scroll to bottom
      consoleContent.scrollTop = consoleContent.scrollHeight;
      
      // Keep max 100 entries to prevent memory issues
      const entries = consoleContent.querySelectorAll('.debug-log-entry');
      if (entries.length > 100) {
        entries[0].remove();
      }
    }
  }
  
  function clearDebugConsole() {
    const consoleContent = document.getElementById('debugConsoleContent');
    if (consoleContent) {
      consoleContent.innerHTML = '<div class="debug-log-entry success"><span class="debug-log-time"></span>Debug console cleared.</div>';
    }
  }
  
  function copyDebugConsole() {
    const consoleContent = document.getElementById('debugConsoleContent');
    if (!consoleContent) return;
    
    const entries = consoleContent.querySelectorAll('.debug-log-entry');
    const logs = Array.from(entries).map(entry => {
      const time = entry.querySelector('.debug-log-time')?.textContent || '';
      const message = entry.textContent.replace(time, '').trim();
      return `${time} ${message}`;
    }).join('\n');
    
    navigator.clipboard.writeText(logs).then(() => {
      debugLog('‚úÖ Logs copied to clipboard!', 'success');
      setTimeout(() => {
        const lastEntry = consoleContent.querySelector('.debug-log-entry:last-child');
        if (lastEntry && lastEntry.textContent.includes('copied to clipboard')) {
          lastEntry.remove();
        }
      }, 2000);
    }).catch(err => {
      debugLog('‚ùå Failed to copy logs: ' + err.message, 'error');
    });
  }
  
  // Override console methods to also log to debug console (after debugLog is defined)
  // Ensure originalConsole methods are available (they're defined earlier in this script block)
  if (typeof originalConsoleLog !== 'undefined') {
    console.log = function(...args) {
      try {
        originalConsoleLog.apply(console, args);
        const message = args.map(a => {
          if (typeof a === 'object') {
            try {
              return JSON.stringify(a, null, 2);
            } catch (e) {
              return String(a);
            }
          }
          return String(a);
        }).join(' ');
        // Use originalConsoleLog to avoid recursion
        if (message && typeof debugLog === 'function') {
          debugLog(message, 'info');
        }
      } catch (e) {
        // Fallback to native console if override fails
        console.log.apply(console, args);
      }
    };
  }
  
  if (typeof originalConsoleError !== 'undefined') {
    console.error = function(...args) {
      try {
        originalConsoleError.apply(console, args);
        const message = args.map(a => {
          if (typeof a === 'object') {
            try {
              return JSON.stringify(a, null, 2);
            } catch (e) {
              return String(a);
            }
          }
          return String(a);
        }).join(' ');
        // Use originalConsoleError to avoid recursion
        if (message && typeof debugLog === 'function') {
          debugLog(message, 'error');
        }
      } catch (e) {
        // Fallback to native console if override fails
        console.error.apply(console, args);
      }
    };
  }
  
  if (typeof originalConsoleWarn !== 'undefined') {
    console.warn = function(...args) {
      try {
        originalConsoleWarn.apply(console, args);
        const message = args.map(a => {
          if (typeof a === 'object') {
            try {
              return JSON.stringify(a, null, 2);
            } catch (e) {
              return String(a);
            }
          }
          return String(a);
        }).join(' ');
        // Use originalConsoleWarn to avoid recursion
        if (message && typeof debugLog === 'function') {
          debugLog(message, 'warn');
        }
      } catch (e) {
        // Fallback to native console if override fails
        console.warn.apply(console, args);
      }
    };
  }

  // Supabase Configuration
  const SUPABASE_URL = 'https://igzvwbvgvmzvvzoclufx.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnenZ3YnZndm16dnZ6b2NsdWZ4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2Nzc5MjgsImV4cCI6MjA3MzI1MzkyOH0.A9TCmnXKJhDRYBkrO0mAMPiUQeV9enweeyRWKWQ1SZY';
  
  // Initialize Supabase client (wait for library to load)
  let supabase = null;
  let supabaseAvailable = false;
  
  // Wait for Supabase library to load
  function initSupabase() {
    // Check for Supabase library loaded via CDN (UMD build)
    if (typeof window.supabase !== 'undefined' && typeof window.supabase.createClient === 'function') {
      try {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        supabaseAvailable = true;
        console.log('‚úÖ Supabase client initialized successfully');
        
        // Update bulk buttons state when Supabase is available
        updateBulkButtons();
        
        return true;
      } catch (error) {
        console.error('Failed to initialize Supabase client:', error);
      }
    }
    return false;
  }
  
  // Try to initialize when script loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      if (!initSupabase()) {
        // Retry after delays
        setTimeout(initSupabase, 500);
        setTimeout(initSupabase, 1500);
      }
    });
  } else {
    if (!initSupabase()) {
      // Retry after delays
      setTimeout(initSupabase, 500);
      setTimeout(initSupabase, 1500);
    }
  }
  
  // Final retry after all scripts load
  window.addEventListener('load', function() {
    if (!supabaseAvailable) {
      initSupabase();
    }
    // Load auto-run preference
    loadAutoRunPreference();
    // Load auto-save preference
    loadAutoSavePreference();
  });
  
  
  // Progress bar helpers
  function renderProgress(cell) {
    cell.innerHTML = `
      <div class="progress-wrap">
        <div class="progress"><span style="width:0%"></span></div>
        <div class="progress-label">0%</div>
      </div>`;
  }
  
  function setProgress(cell, pct, text) {
    const bar = cell.querySelector('.progress > span');
    const lbl = cell.querySelector('.progress-label');
    if (bar) { bar.style.width = Math.max(0, Math.min(100, pct)) + '%'; }
    if (lbl) { lbl.textContent = (text ? text + ' ¬∑ ' : '') + Math.round(pct) + '%'; }
  }
  
  function markProgressError(cell) {
    const bar = cell.querySelector('.progress > span');
    if (bar) { bar.style.background = 'linear-gradient(90deg,#ff5252,#ff8a80)'; }
  }
  
  // ---- NEW: Modal helpers --------------------------------------
  function openModal(title, html) {
    let modal = document.querySelector('#detail-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'detail-modal';
      modal.innerHTML = `
        <div class="modal-backdrop"></div>
        <div class="modal">
          <div class="modal-head">
            <h3 id="modal-title"></h3>
            <button id="modal-close" aria-label="Close">‚úñ</button>
          </div>
          <div class="modal-body"></div>
        </div>`;
      document.body.appendChild(modal);
      modal.querySelector('#modal-close').onclick = () => modal.remove();
      modal.querySelector('.modal-backdrop').onclick = () => modal.remove();
    }
    modal.querySelector('#modal-title').textContent = title;
    modal.querySelector('.modal-body').innerHTML = html;
  }

  // Step completion modals
  function showStepSuccessModal(stepNumber, stepName, message, nextStepInstructions, fileLocation) {
    const html = `
      <div style="padding: 1.5rem;">
        <div style="text-align: center; margin-bottom: 1.5rem;">
          <div style="font-size: 4rem; margin-bottom: 1rem;">‚úÖ</div>
          <h2 style="color: #27AE60; margin: 0 0 0.5rem 0;">Step ${stepNumber} Complete!</h2>
          <p style="color: #4a5568; font-size: 1.1rem; margin: 0;">${stepName}</p>
        </div>
        
        <div style="background: #f7fafc; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #2d3748;">What happened:</p>
          <p style="margin: 0; color: #4a5568; line-height: 1.6;">${message}</p>
          ${fileLocation ? `<p style="margin: 1rem 0 0 0; color: #2d3748;"><strong>üìÅ File saved:</strong> <code style="background: #e2e8f0; padding: 2px 6px; border-radius: 4px;">${fileLocation}</code></p>` : ''}
        </div>
        
        ${nextStepInstructions ? `
        <div style="background: #e6f3ff; padding: 1rem; border-left: 4px solid #007bff; border-radius: 4px; margin-bottom: 1rem;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #004085;">üí° What's Next:</p>
          <p style="margin: 0; color: #004085; line-height: 1.6;">${nextStepInstructions}</p>
        </div>
        ` : ''}
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="document.querySelector('#detail-modal').remove()" style="padding: 0.75rem 2rem; background: #667eea; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer;">
            Got it!
          </button>
        </div>
      </div>
    `;
    openModal(`‚úÖ Step ${stepNumber} Complete`, html);
  }

  function showStepErrorModal(stepNumber, stepName, errorMessage, troubleshootingSteps) {
    const html = `
      <div style="padding: 1.5rem;">
        <div style="text-align: center; margin-bottom: 1.5rem;">
          <div style="font-size: 4rem; margin-bottom: 1rem;">‚ùå</div>
          <h2 style="color: #E74C3C; margin: 0 0 0.5rem 0;">Step ${stepNumber} Failed</h2>
          <p style="color: #4a5568; font-size: 1.1rem; margin: 0;">${stepName}</p>
        </div>
        
        <div style="background: #fff5f5; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 4px solid #E74C3C;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #c53030;">Error:</p>
          <p style="margin: 0; color: #742a2a; line-height: 1.6; font-family: monospace; background: #fff; padding: 0.5rem; border-radius: 4px;">${escapeHtml(errorMessage)}</p>
        </div>
        
        ${troubleshootingSteps ? `
        <div style="background: #fffbf0; padding: 1rem; border-radius: 8px; border-left: 4px solid #f59e0b;">
          <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: #92400e;">üîß Troubleshooting:</p>
          <ul style="margin: 0; padding-left: 1.5rem; color: #78350f; line-height: 1.8;">
            ${troubleshootingSteps.map(step => `<li>${step}</li>`).join('')}
          </ul>
        </div>
        ` : ''}
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="document.querySelector('#detail-modal').remove()" style="padding: 0.75rem 2rem; background: #E74C3C; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer;">
            Close
          </button>
        </div>
      </div>
    `;
    openModal(`‚ùå Step ${stepNumber} Failed`, html);
  }

  function showFinalCompletionModal() {
    if (!window.completedSteps) {
      return;
    }
    
    const steps = window.completedSteps;
    const stepNames = {
      2: 'Step 2 - Clean and Normalize CSV',
      '3a': 'Step 3a - Fetch Google Reviews',
      '3b': 'Step 3b - Merge Reviews',
      4: 'Step 4 - Generate Product Schema'
    };
    
    let summaryHtml = '<div style="padding: 1.5rem;">';
    summaryHtml += '<div style="text-align: center; margin-bottom: 1.5rem;">';
    summaryHtml += '<div style="font-size: 4rem; margin-bottom: 1rem;">üéâ</div>';
    summaryHtml += '<h2 style="color: #27AE60; margin: 0 0 0.5rem 0;">All Steps Complete!</h2>';
    summaryHtml += '<p style="color: #4a5568; font-size: 1.1rem; margin: 0;">Your product schemas are ready</p>';
    summaryHtml += '</div>';
    
    summaryHtml += '<div style="background: #f7fafc; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">';
    summaryHtml += '<p style="margin: 0 0 1rem 0; font-weight: 600; color: #2d3748;">üìä Step Summary:</p>';
    
    const stepOrder = [2, '3a', '3b', 4];
    let allSuccess = true;
    
    for (const stepId of stepOrder) {
      const step = steps[stepId];
      const stepName = stepNames[stepId] || `Step ${stepId}`;
      
      if (step) {
        summaryHtml += `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: #d4edda; border-left: 4px solid #27AE60; border-radius: 4px;">`;
        summaryHtml += `<p style="margin: 0; font-weight: 600; color: #155724;">‚úÖ ${stepName}</p>`;
        summaryHtml += `<p style="margin: 0.25rem 0 0 0; color: #155724; font-size: 0.9rem;">${step.message}</p>`;
        if (step.file) {
          summaryHtml += `<p style="margin: 0.25rem 0 0 0; color: #155724; font-size: 0.85rem;"><code style="background: #c3e6cb; padding: 2px 6px; border-radius: 3px;">${step.file}</code></p>`;
        }
        summaryHtml += `</div>`;
      } else {
        allSuccess = false;
        summaryHtml += `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">`;
        summaryHtml += `<p style="margin: 0; font-weight: 600; color: #856404;">‚ö†Ô∏è ${stepName}</p>`;
        summaryHtml += `<p style="margin: 0.25rem 0 0 0; color: #856404; font-size: 0.9rem;">Status unknown</p>`;
        summaryHtml += `</div>`;
      }
    }
    
    summaryHtml += '</div>';
    
    // Add Schema Generation Summary if Step 4 data is available
    const step4 = steps[4];
    if (step4 && (step4.totalProducts !== null || step4.matchCount !== null || step4.mappedGoogleCount !== null)) {
      summaryHtml += '<div style="background: #fff9e6; padding: 1rem; border-left: 4px solid #ff9800; border-radius: 4px; margin-bottom: 1rem;">';
      summaryHtml += '<p style="margin: 0 0 0.75rem 0; font-weight: 600; color: #e65100; font-size: 1rem;">üìä Schema Generation Summary:</p>';
      summaryHtml += '<div style="font-size: 0.9rem; color: #5d4037;">';
      
      // Product counts
      summaryHtml += '<div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #ffe0b2;">';
      if (step4.totalProducts !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Total products:</strong> ${step4.totalProducts}</div>`;
      }
      if (step4.matchCount !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Products with reviews:</strong> <span style="color: #27AE60; font-weight: 600;">${step4.matchCount}</span></div>`;
      }
      if (step4.productsWithoutReviews !== null) {
        summaryHtml += `<div><strong>Products without reviews:</strong> ${step4.productsWithoutReviews}</div>`;
      }
      summaryHtml += '</div>';
      
      // Mapped reviews section
      summaryHtml += '<div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #ffe0b2;">';
      summaryHtml += '<div style="font-weight: 600; margin-bottom: 0.5rem; color: #e65100;">üìä Mapped Reviews:</div>';
      
      // Google reviews
      if (step4.mappedGoogleCount !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;">`;
        summaryHtml += `<strong>Google reviews mapped:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.mappedGoogleCount}</span>`;
        if (step4.googleReviewsCount !== null && step4.googleReviewsCount !== step4.mappedGoogleCount) {
          summaryHtml += ` <span style="color: #757575; font-size: 0.85em;">(of ${step4.googleReviewsCount} total)</span>`;
        }
        summaryHtml += `</div>`;
        if (step4.latestGoogleDate) {
          summaryHtml += `<div style="margin-left: 1.5rem; margin-bottom: 0.25rem; color: #757575; font-size: 0.85em;">Latest: ${step4.latestGoogleDate}</div>`;
        }
      } else if (step4.googleReviewsCount !== null) {
        // Fallback to old format
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Google reviews:</strong> ${step4.googleReviewsCount}</div>`;
      }
      
      // Trustpilot reviews
      if (step4.mappedTrustpilotCount !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;">`;
        summaryHtml += `<strong>Trustpilot reviews mapped:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.mappedTrustpilotCount}</span>`;
        if (step4.trustpilotReviewsCount !== null && step4.trustpilotReviewsCount !== step4.mappedTrustpilotCount) {
          summaryHtml += ` <span style="color: #757575; font-size: 0.85em;">(of ${step4.trustpilotReviewsCount} total)</span>`;
        }
        summaryHtml += `</div>`;
        if (step4.latestTrustpilotDate) {
          summaryHtml += `<div style="margin-left: 1.5rem; margin-bottom: 0.25rem; color: #757575; font-size: 0.85em;">Latest: ${step4.latestTrustpilotDate}</div>`;
        }
      } else if (step4.trustpilotReviewsCount !== null) {
        // Fallback to old format
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Trustpilot reviews:</strong> ${step4.trustpilotReviewsCount}</div>`;
      }
      
      // Total mapped reviews
      if (step4.totalMappedReviews !== null) {
        summaryHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ffe0b2;"><strong>Total mapped reviews:</strong> <span style="color: #27AE60; font-weight: 600;">${step4.totalMappedReviews}</span></div>`;
      }
      
      // Overall latest review date (if available and different from individual dates)
      if (step4.latestReviewDate && (!step4.latestGoogleDate || !step4.latestTrustpilotDate || step4.latestReviewDate !== step4.latestGoogleDate || step4.latestReviewDate !== step4.latestTrustpilotDate)) {
        summaryHtml += `<div style="margin-top: 0.25rem; color: #757575; font-size: 0.85em;">Overall latest review: ${step4.latestReviewDate}</div>`;
      }
      
      summaryHtml += '</div>';
      summaryHtml += '</div>';
      summaryHtml += '</div>';
    }
    
    summaryHtml += '<div style="background: #e6f3ff; padding: 1rem; border-left: 4px solid #007bff; border-radius: 4px; margin-bottom: 1rem;">';
    summaryHtml += '<p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #004085;">üí° Next Steps:</p>';
    summaryHtml += '<ul style="margin: 0; padding-left: 1.5rem; color: #004085; line-height: 1.8;">';
    summaryHtml += '<li>Find your schema files in the <code style="background: #cbd5e0; padding: 2px 4px; border-radius: 3px;">outputs/</code> folder</li>';
    summaryHtml += '<li>Each product has a Squarespace-ready HTML file</li>';
    summaryHtml += '<li>Copy-paste the HTML into Squarespace Code Blocks</li>';
    summaryHtml += '<li>Validate with <a href="https://search.google.com/test/rich-results" target="_blank" style="color: #007bff; text-decoration: underline;">Google Rich Results Test</a></li>';
    summaryHtml += '</ul>';
    summaryHtml += '</div>';
    
    summaryHtml += '<div style="text-align: center; margin-top: 1.5rem;">';
    summaryHtml += '<button onclick="document.querySelector(\'#detail-modal\').remove()" style="padding: 0.75rem 2rem; background: #27AE60; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer;">';
    summaryHtml += 'Got it!';
    summaryHtml += '</button>';
    summaryHtml += '</div>';
    summaryHtml += '</div>';
    
    openModal('üéâ Workflow Complete!', summaryHtml);
  }

  function codeBlock(label, code) {
    return `
      <div class="code-card">
        <div class="code-card-head">
          <strong>${label}</strong>
          <button class="copy-btn" data-code="${encodeURIComponent(code)}">Copy</button>
        </div>
        <pre><code>${escapeHtml(code)}</code></pre>
      </div>`;
  }

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }

  // Copy button handler
  document.addEventListener('click', (e) => {
    const copy = e.target.closest('.copy-btn');
    if (!copy) return;
    const code = decodeURIComponent(copy.dataset.code || '');
    navigator.clipboard.writeText(code).then(() => { 
      copy.textContent = 'Copied'; 
      setTimeout(() => copy.textContent = 'Copy', 1200); 
    });
  });

  // Minimal extractor: same logic you use in the scanner, but HTML-in
  function extractJsonLdBlocksFromHtml(html) {
    const blocks = [];
    const re = /<script[^>]+type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi;
    let m;
    while ((m = re.exec(html))) {
      try {
        const json = JSON.parse(m[1].trim());
        if (Array.isArray(json)) json.forEach(j => blocks.push(j));
        else if (json['@graph']) json['@graph'].forEach(j => blocks.push(j));
        else blocks.push(json);
      } catch {}
    }
    return blocks;
  }

  // Build a single, cleaned-up, recommended schema graph
  function buildEnhancedSchema(blocks) {
    const graph = [];
    const types = t => Array.isArray(t) ? t : [t].filter(Boolean);
    const seen = new Set();
    const add = (node) => {
      const key = JSON.stringify([types(node['@type']).sort(), node['@id'] || node.url || node.name]);
      if (seen.has(key)) return;
      seen.add(key);
      graph.push(node);
    };

    // Merge Organization/LocalBusiness
    const org = {
      '@type': ['Organization','LocalBusiness'],
      '@id': 'https://www.alanranger.com/#org',
      name: 'Alan Ranger Photography',
      url: 'https://www.alanranger.com/',
      telephone: '+44 7817 017994',
      image: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w'
    };

    // Keep existing ItemList/Event/etc., but ensure @id where missing
    blocks.forEach(b => {
      const ts = types(b['@type']);
      if (ts.includes('Organization') || ts.includes('LocalBusiness')) {
        // prefer our canonical org baseline merged
        return;
      }
      if (!b['@id'] && (b.url || b.name)) b['@id'] = (b.url || `#${(b.name||'node').toLowerCase().replace(/\s+/g,'-')}`);
      add(b);
    });

    add(org);

    return { '@context': 'https://schema.org', '@graph': graph };
  }

  // Event delegation for View Details and Generate Enhanced buttons
  document.addEventListener('click', async (e) => {
      // View Details - use new improved modal
      const view = e.target.closest('.btn-view-details, [data-action="view-details"], .view-details-btn');
      if (view) {
        const row = view.closest('tr');
        if (!row) return;
        const rowData = getRowDataFromTr(row);
        openIssuesModal(rowData);
        return;
      }

    // Generate Enhanced
    const gen = e.target.closest('.btn-generate-enhanced, [data-action="generate-enhanced"], .enhance-btn');
    if (gen && (gen.textContent.includes('Generate Enhanced') || gen.id?.includes('genBtn'))) {
      const row = gen.closest('tr');
      const url = row?.dataset?.url || row?.querySelector('a.url-link')?.href;
      if (!url) {
        alert('Could not determine URL for this row.');
        return;
      }
      
      try {
        // Update button state
        const originalText = gen.textContent;
        gen.disabled = true;
        gen.textContent = 'Fetching...';
        
        // Server-side fetch (avoids CORS)
        const res = await fetch(`/api/fetch-html?url=${encodeURIComponent(url)}`, { method: 'GET' });
        if (!res.ok) throw new Error(`Server fetch failed: ${res.status}`);
        const html = await res.text();

        // Extract JSON-LD blocks from HTML
        const blocks = extractJsonLdBlocksFromHtml(html);
        // Build an enhanced consolidated schema suggestion
        const enhanced = buildEnhancedSchema(blocks);

        gen.textContent = originalText;
        gen.disabled = false;
        
        // Use the proper Enhanced Schema modal instead of openModal
        const backdrop = document.getElementById('genBackdrop');
        const metaEl = document.getElementById('genMeta');
        const jsonEl = document.getElementById('genJson');
        const titleEl = document.getElementById('genTitle');
        if (backdrop && metaEl && jsonEl && titleEl) {
          titleEl.textContent = 'Enhanced Schema (suggestion)';
          metaEl.textContent = url;
          jsonEl.textContent = JSON.stringify(enhanced, null, 2);
          // Store URL and JSON for save function
          backdrop.dataset.url = url;
          backdrop.dataset.json = JSON.stringify(enhanced, null, 2);
          backdrop.style.display = 'flex';
          setupCopyButton();
          setupSaveButton();
        } else {
          openModal('Enhanced Schema (suggestion)', codeBlock('Paste this in a single <script type="application/ld+json">', JSON.stringify(enhanced, null, 2)));
        }
      } catch (err) {
        gen.textContent = originalText;
        gen.disabled = false;
        alert(`Enhanced Schema Error: ${escapeHtml(err.message)}\n\nTip: server route must exist at /api/fetch-html.`);
      }
    }
  });
  
  // Helper: Collect existing schema types from the page
  function collectExistingSchemaTypes(jsonLdBlocks) {
    const types = new Set();
    
    if (!jsonLdBlocks || !Array.isArray(jsonLdBlocks)) {
      return [];
    }
    
    jsonLdBlocks.forEach(block => {
      try {
        // Handle @graph structure
        if (block['@graph'] && Array.isArray(block['@graph'])) {
          block['@graph'].forEach(item => {
            if (item['@type']) {
              const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
              itemTypes.forEach(t => types.add(t));
            }
          });
        }
        // Handle array of schemas
        else if (Array.isArray(block)) {
          block.forEach(item => {
            if (item['@type']) {
              const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
              itemTypes.forEach(t => types.add(t));
            }
          });
        }
        // Handle single schema object
        else if (block['@type']) {
          const blockTypes = Array.isArray(block['@type']) ? block['@type'] : [block['@type']];
          blockTypes.forEach(t => types.add(t));
        }
      } catch (e) {
        console.warn('Invalid JSON-LD block ignored:', e);
      }
    });
    
    return Array.from(types);
  }

  // Helper: Determine required schema types based on missing fields
  function determineRequiredSchemaTypes(missingFields, missingRecommended, existingTypes = []) {
    const globalTypes = ['Organization', 'LocalBusiness', 'Person', 'Service', 'WebSite', 'BreadcrumbList'];
    
    // Check which global types already exist
    const existingGlobalTypes = existingTypes.filter(t => globalTypes.includes(t));
    
    const needsOrg = missingFields.some(f => f.includes('Organization')) || 
                    missingRecommended.some(f => f.includes('Organization') || f.includes('url') || f.includes('logo'));
    const needsLocal = missingFields.some(f => f.includes('LocalBusiness')) || 
                       missingRecommended.some(f => f.includes('LocalBusiness') || f.includes('address') || f.includes('telephone'));
    const needsWebSite = missingFields.some(f => f.includes('WebSite')) || 
                         missingRecommended.some(f => f.includes('WebSite'));
    
    const types = [];
    
    // Only add Organization if it doesn't already exist
    if ((needsOrg || needsLocal) && !existingGlobalTypes.includes('Organization')) {
      types.push('Organization');
    }
    
    // Only add LocalBusiness if it doesn't already exist
    if (needsLocal && !existingGlobalTypes.includes('LocalBusiness')) {
      types.push('LocalBusiness');
    }
    
    // Only add WebSite if it doesn't already exist
    if (needsWebSite && !existingGlobalTypes.includes('WebSite')) {
      types.push('WebSite');
    }
    
    // Don't add default types if global schemas already exist
    if (types.length === 0 && existingGlobalTypes.length === 0) {
      types.push('Organization', 'LocalBusiness');
    }
    
    return types;
  }

  // Helper: Add recommended fields to fix object
  function addRecommendedFieldsToFix(fix, missingRecommended, baseUrl) {
    if (missingRecommended.includes('url')) {
      fix["url"] = baseUrl;
    }
    if (missingRecommended.includes('logo')) {
      fix["logo"] = "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w";
    }
    if (missingRecommended.includes('image')) {
      fix["image"] = fix["logo"] || "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w";
    }
    if (missingRecommended.includes('description')) {
      fix["description"] = "UK Landscape Photography Workshops, Private Tuition, and Online Classes by Alan Ranger, Qualified Tutor and Professional Photographer.";
    }
    if (missingRecommended.includes('address')) {
      fix["address"] = {
        "@type": "PostalAddress",
        "streetAddress": "45 Hathaway Road, Tile Hill Village",
        "addressLocality": "Coventry",
        "addressRegion": "West Midlands",
        "postalCode": "CV4 9HW",
        "addressCountry": "GB"
      };
    }
    if (missingRecommended.includes('telephone')) {
      fix["telephone"] = "+44 7817 017994";
    }
    if (missingRecommended.includes('sameAs')) {
      fix["sameAs"] = [
        "https://www.facebook.com/alanrangerphotography",
        "https://www.instagram.com/alanrangerphoto",
        "https://www.youtube.com/@alanrangerphotography"
      ];
    }
  }

  // Helper: Build recommended fix based on missing fields
  function buildRecommendedFix(url, missingFields = [], missingRecommended = [], existingTypes = []) {
    const baseUrl = url.split('#')[0];
    
    const types = determineRequiredSchemaTypes(missingFields, missingRecommended, existingTypes);
    
    // If no types to add (all global types already exist), return null
    if (types.length === 0) {
      return null;
    }
    
    const fix = {
      "@context": "https://schema.org"
    };
    
    fix["@type"] = types.length === 1 ? types[0] : types;
    fix["@id"] = `${baseUrl}#org`;
    fix["name"] = "Alan Ranger Photography";
    
    // Add url if missing
    if (missingRecommended.includes('url') || missingFields.some(f => f.includes('url'))) {
      fix["url"] = baseUrl;
    }
    
    // Add recommended fields
    addRecommendedFieldsToFix(fix, missingRecommended, baseUrl);
    
    // Add address if missing (for LocalBusiness)
    const needsLocal = types.includes('LocalBusiness');
    if (needsLocal && (missingRecommended.includes('address') || missingFields.some(f => f.includes('address')))) {
      if (!fix["address"]) {
        fix["address"] = {
          "@type": "PostalAddress",
          "streetAddress": "45 Hathaway Road, Tile Hill Village",
          "addressLocality": "Coventry",
          "addressRegion": "West Midlands",
          "postalCode": "CV4 9HW",
          "addressCountry": "GB"
        };
      }
    }
    
    return JSON.stringify(fix, null, 2);
  }

  function getRecommendedSchema(url, existingTypes = []) {
    // Use the new buildRecommendedFix function for consistency
    return buildRecommendedFix(url, [], [], existingTypes);
  }

  // Helper: Parse issues list from rowData
  function parseIssuesList(rowData) {
    let issuesList = [];
    try {
      if (rowData.tr && rowData.tr.dataset.issuesList) {
        issuesList = JSON.parse(rowData.tr.dataset.issuesList);
      } else if (rowData.issuesList) {
        issuesList = rowData.issuesList;
      } else if (rowData.tr && rowData.tr.dataset.missingDetail) {
        const missing = JSON.parse(rowData.tr.dataset.missingDetail);
        issuesList = missing.map(m => ({ message: m, type: 'Unknown' }));
      } else if (rowData.missingFields) {
        const missing = Array.isArray(rowData.missingFields) ? rowData.missingFields : String(rowData.missingFields).split(',').map(s => s.trim()).filter(Boolean);
        issuesList = missing.map(m => ({ message: m, type: 'Unknown' }));
      }
    } catch (err) {
      console.warn('Failed to parse issues data:', err);
    }
    return issuesList;
  }

  // Helper: Determine severity badge from issues
  function determineSeverityBadge(issueCount, duplicates) {
    if (duplicates.length > 2 || issueCount > 3) {
      return { severity: 'critical', badgeColor: 'severity-badge critical', badgeLabel: '‚ùå Critical' };
    }
    if (issueCount > 0 || duplicates.length > 0) {
      return { severity: 'warning', badgeColor: 'severity-badge warning', badgeLabel: '‚ö†Ô∏è Issues' };
    }
    return { severity: 'passed', badgeColor: 'severity-badge passed', badgeLabel: '‚úÖ Passed' };
  }

  // Helper: Build human-readable summary for modal
  function buildHumanReadableSummary(blockCount, schemaTypes, duplicates, missingFieldsBadges) {
    const parts = [];
    
    if (blockCount > 0) {
      parts.push(`Found ${blockCount} JSON-LD block${blockCount !== 1 ? 's' : ''}`);
    }
    
    if (schemaTypes && schemaTypes.length > 0) {
      const typesList = Array.isArray(schemaTypes) ? schemaTypes.join(', ') : schemaTypes;
      const uniqueTypesCount = Array.isArray(schemaTypes) ? schemaTypes.length : (schemaTypes.split(',').map(t => t.trim()).filter(Boolean).length);
      parts.push(`${uniqueTypesCount} unique schema type${uniqueTypesCount !== 1 ? 's' : ''}: ${typesList}`);
    }
    
    // Only show duplicate count for non-multi-instance types
    if (duplicates && duplicates.length > 0) {
      const nonMultiInstanceDuplicates = duplicates.filter(d => !MULTI_INSTANCE_ALLOWED_TYPES.includes(d));
      if (nonMultiInstanceDuplicates.length > 0) {
        parts.push(`${nonMultiInstanceDuplicates.length} duplicate${nonMultiInstanceDuplicates.length !== 1 ? 's' : ''} detected`);
      }
    }
    
    if (missingFieldsBadges && missingFieldsBadges.length > 0) {
      parts.push(`${missingFieldsBadges.length} missing field${missingFieldsBadges.length !== 1 ? 's' : ''}`);
    }
    
    return parts.length > 0 ? parts.join('. ') : 'No schema data available.';
  }

  // Helper: Build schema table HTML for modal
  function buildSchemaTableHtml(result) {
    if (!result || !result.schemas || result.schemas.length === 0) {
      return '';
    }
    
    let tableHtml = `
      <div style="margin-top: 1.5rem;">
        <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 600;">Detected Schema Nodes</h4>
        <table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
          <thead>
            <tr style="background: #f3f4f6; border-bottom: 2px solid #d1d5db;">
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Type</th>
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">@id</th>
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Name</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    for (const s of result.schemas) {
      const schema = s.schema || {};
      const isSystem = s.systemInjected ? 'system-node' : '';
      const typeDisplay = Array.isArray(s.type) ? s.type.join(', ') : s.type;
      const idDisplay = schema['@id'] || '‚Äî';
      const nameDisplay = schema.name || '‚Äî';
      
      tableHtml += `
        <tr class="${isSystem}" style="border-bottom: 1px solid #e5e7eb;">
          <td style="padding: 0.5rem;">${typeDisplay}</td>
          <td style="padding: 0.5rem;">${idDisplay}</td>
          <td style="padding: 0.5rem;">${nameDisplay}</td>
        </tr>
      `;
    }
    
    tableHtml += `
          </tbody>
        </table>
      </div>
    `;
    
    return tableHtml;
  }

  // Helper: Check if Organization nodes need recommended fix
  function checkOrganizationNodesForFix(result, missingFieldsBadges, existingTypes = []) {
    const globalTypes = ['Organization', 'LocalBusiness', 'Person', 'Service', 'WebSite', 'BreadcrumbList'];
    const existingGlobalTypes = existingTypes.filter(t => globalTypes.includes(t));
    
    // If global types already exist, don't show recommended fix
    if (existingGlobalTypes.length > 0) {
      return { shouldShowRecommendedFix: false, hasValidOrgNode: true, existingGlobalTypes };
    }
    
    let shouldShowRecommendedFix = false;
    let hasValidOrgNode = false;
    
    if (result && result.schemas) {
      const orgSchemas = result.schemas.filter(s => s.type === 'Organization' || (Array.isArray(s.type) && s.type.includes('Organization')));
      if (orgSchemas.length > 0) {
        const allMissingRequired = orgSchemas.every(s => {
          const schema = s.schema || {};
          const hasName = schema.name && schema.name.trim();
          const hasUrl = schema.url && schema.url.trim();
          const hasId = schema['@id'] && schema['@id'].trim();
          return !hasName && !hasUrl && !hasId;
        });
        hasValidOrgNode = orgSchemas.some(s => {
          const schema = s.schema || {};
          return schema.name && schema.name.trim();
        });
        shouldShowRecommendedFix = allMissingRequired && !hasValidOrgNode;
      } else {
        shouldShowRecommendedFix = true;
      }
    } else {
      const orgMissingFields = missingFieldsBadges.filter(m => m.type === 'Organization');
      const orgMissingRequired = orgMissingFields.some(m => ['name', 'url'].includes(m.field));
      shouldShowRecommendedFix = orgMissingRequired && orgMissingFields.length > 0;
    }
    
    return { shouldShowRecommendedFix, hasValidOrgNode, existingGlobalTypes: [] };
  }

  // Helper: Build recommended fix HTML
  function buildRecommendedFixHtml(shouldShowRecommendedFix, hasValidOrgNode, recommendedFix, existingGlobalTypes = []) {
    if (shouldShowRecommendedFix && recommendedFix) {
      return `
        <div class="recommended-fix-card">
          <h4>Recommended Fix (for Squarespace footer injection)</h4>
          <p>Copy and paste the following schema block into your Squarespace <strong>Settings ‚Üí Advanced ‚Üí Code Injection ‚Üí Footer</strong> section.</p>
          <textarea class="recommended-fix-textarea" readonly id="recommendedSchemaText">${recommendedFix}</textarea>
          <button class="copy-schema-btn" id="copySchemaBtn">üìã Copy Recommended Schema</button>
        </div>
      `;
    }
    if (hasValidOrgNode || existingGlobalTypes.length > 0) {
      const globalTypesList = existingGlobalTypes.length > 0 
        ? existingGlobalTypes.join(', ')
        : 'Organization';
      return `
        <div class="recommended-fix-card" style="background: #f0fdf4; border-color: #10b981;">
          <h4 style="color: #065f46;">‚úÖ Detected global schema types ‚Äî no extra injection required</h4>
          <p style="color: #047857;">Found existing ${globalTypesList} schema${existingGlobalTypes.length > 1 ? 's' : ''} on this page. Your global schema structure is correct. Recommendations will only appear for missing page-specific types (Product, Event, Article, Course, etc.).</p>
        </div>
      `;
    }
    return '';
  }

  // Helper: Setup modal button handlers
  function setupModalButtonHandlers(recommendedFix, json, jsonDetails, rowData) {
    const copyBtn = document.getElementById('copySchemaBtn');
    if (copyBtn) {
      copyBtn.onclick = () => {
        const textarea = document.getElementById('recommendedSchemaText');
        textarea.select();
        navigator.clipboard.writeText(recommendedFix).then(() => {
          copyBtn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            copyBtn.textContent = 'üìã Copy Recommended Schema';
          }, 2000);
        }).catch(err => {
          console.error('Failed to copy:', err);
          copyBtn.textContent = '‚ùå Copy Failed';
          setTimeout(() => {
            copyBtn.textContent = 'üìã Copy Recommended Schema';
          }, 2000);
        });
      };
    }
    
    json.textContent = (rowData.firstJsonLd || '').trim();
    jsonDetails.style.display = rowData.firstJsonLd ? 'block' : 'none';
    
    const copyJsonBtn = document.getElementById('issuesCopyJsonBtn');
    if (copyJsonBtn) {
      copyJsonBtn.onclick = async () => {
        const jsonText = json.textContent.trim();
        if (!jsonText) {
          alert('No JSON-LD content to copy');
          return;
        }
        try {
          await navigator.clipboard.writeText(jsonText);
          copyJsonBtn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            copyJsonBtn.textContent = 'Copy JSON-LD';
          }, 2000);
        } catch (err) {
          const textarea = document.createElement('textarea');
          textarea.value = jsonText;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
            copyJsonBtn.textContent = '‚úÖ Copied!';
            setTimeout(() => {
              copyJsonBtn.textContent = 'Copy JSON-LD';
            }, 2000);
          } catch (e) {
            alert('Failed to copy. Please select and copy manually.');
          }
          textarea.remove();
        }
      };
    }
  }

  // ---- Issues modal helpers ----
  function openIssuesModal(rowData) {
    const backdrop = document.getElementById('issuesBackdrop');
    const meta = document.getElementById('issuesMeta');
    const content = document.getElementById('issuesContent');
    const list = document.getElementById('issuesList');
    const json = document.getElementById('issuesJson');
    const jsonDetails = document.getElementById('issuesJsonDetails');
    const btnSchema = document.getElementById('issuesSchemaOrgBtn');
    const btnGoogle = document.getElementById('issuesGoogleBtn');
    const closeBtn = document.getElementById('issuesCloseBtn');
    const closeXBtn = document.getElementById('issuesCloseXBtn');
    
    // Get cached result data
    const cachedData = ResultCache.get(rowData.url) || {};
    const rowIndex = rowData.tr ? Array.from(rowData.tr.parentNode.children).indexOf(rowData.tr) : -1;
    const result = rowIndex >= 0 ? validationResults[rowIndex] : null;
    
    // Merge cached data with validation result
    const blocks = cachedData.blocks || result?.schemas?.map(s => s.schema).filter(Boolean) || [];
    const issuesList = parseIssuesList(rowData);
    const missingFields = result?.missingFields || cachedData.warnings?.filter(w => w.includes('missing')) || [];
    const warnings = result?.warnings || cachedData.warnings || [];
    const info = result?.info || cachedData.info || [];
    
    meta.textContent = `${rowData.url} ¬∑ Types: ${rowData.schemaType || 'None'}`;
    content.innerHTML = '';
    list.innerHTML = '';
    
    const missingFieldsBadges = result?.missingFieldsBadges || [];
    // Filter duplicates to exclude multi-instance allowed types
    const duplicates = issuesList
      .filter(i => i.message && i.message.includes('DUPLICATE'))
      .map(i => i.type)
      .filter(type => !MULTI_INSTANCE_ALLOWED_TYPES.includes(type));
    const schemaTypes = rowData.schemaType ? rowData.schemaType.split(', ') : (cachedData.schemaTypes || []);
    const issueCount = issuesList.filter(i => i.message && i.message.includes('missing')).length;
    // Use actual block count from result or cached data
    const blockCount = result?.blockCount || blocks.length || result?.schemas?.length || 0;
    
    // Get inferred types from result
    const inferredTypes = result?.inferredTypes || [];
    
    // Collect existing schema types from blocks
    const existingTypes = collectExistingSchemaTypes(blocks);
    
    const severityBadge = determineSeverityBadge(issueCount, duplicates);
    const humanReadableSummary = buildHumanReadableSummary(blockCount, schemaTypes, duplicates, missingFieldsBadges);
    const orgFixCheck = checkOrganizationNodesForFix(result, missingFieldsBadges, existingTypes);
    
    // Build inferred types HTML section
    let inferredTypesHtml = '';
    if (inferredTypes.length > 0) {
      inferredTypesHtml = `
        <div style="margin-top: 1.5rem; padding: 1rem; background: #f9fafb; border-radius: 8px; border-left: 4px solid #6b7280;">
          <h4 style="margin: 0 0 0.75rem 0; font-size: 1rem; font-weight: 600; color: #374151;">Inferred Structured Data Types</h4>
          <p style="margin: 0 0 0.75rem 0; font-size: 0.875rem; color: #6b7280;">Based on schema relationships and patterns:</p>
          <ul style="margin: 0; padding-left: 1.5rem; list-style: disc;">
            ${inferredTypes.map(item => `<li style="margin-bottom: 0.5rem;"><strong>${item.type}</strong> (${item.reason})</li>`).join('')}
          </ul>
        </div>
      `;
    }
    
    // Extract missing recommended fields from warnings
    const missingRecommended = warnings.filter(w => w.includes('Missing recommended:')).map(w => {
      const match = w.match(/Missing recommended: (\w+)/);
      return match ? match[1] : null;
    }).filter(Boolean);
    
    // Extract missing required fields
    const missingRequiredFields = missingFields.filter(f => typeof f === 'string' && f.includes('missing')).map(f => {
      const match = f.match(/(\w+):\s*"(\w+)"\s*missing/);
      return match ? `${match[1]}.${match[2]}` : null;
    }).filter(Boolean);
    
    // Build recommended fix using the new function with existing types
    const recommendedFix = buildRecommendedFix(rowData.url, missingRequiredFields, missingRecommended, existingTypes);
    const recommendedFixHtml = buildRecommendedFixHtml(
      orgFixCheck.shouldShowRecommendedFix || (missingRecommended.length > 0 && recommendedFix !== null), 
      orgFixCheck.hasValidOrgNode, 
      recommendedFix,
      orgFixCheck.existingGlobalTypes || []
    );
    const schemaTableHtml = buildSchemaTableHtml(result);
    
    // Build issues list HTML
    let issuesHtml = '';
    if (issuesList.length === 0 && missingFields.length === 0 && warnings.length === 0) {
      issuesHtml = '<li>None</li>';
    } else {
      if (missingFields.length > 0) {
        issuesHtml += missingFields.map(f => `<li class="missing-entry">‚ùå ${f}</li>`).join('');
      }
      if (warnings.length > 0) {
        issuesHtml += warnings.map(w => `<li class="warning-entry">‚ö†Ô∏è ${w}</li>`).join('');
      }
      if (info.length > 0) {
        issuesHtml += info.map(i => `<li class="info-entry">${i}</li>`).join('');
      }
    }
    
    // Show JSON-LD blocks if available
    let jsonLdHtml = '';
    if (blocks.length > 0) {
      jsonDetails.style.display = 'none'; // Hide the old single block display
      const blocksHtml = blocks.map((block, idx) => {
        const blockJson = JSON.stringify(block, null, 2);
        return `
          <div class="json-block-card" style="margin-bottom: 1rem; border: 1px solid #e2e8f0; border-radius: 8px; overflow: hidden;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem; background: #f7fafc; border-bottom: 1px solid #e2e8f0;">
              <h5 style="margin: 0; font-size: 0.9rem; font-weight: 600;">JSON-LD Block #${idx + 1}</h5>
              <button class="copy-block-btn secondary" data-block-index="${idx}" style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: #2563eb; color: white; border-color: #2563eb; cursor: pointer; border-radius: 4px;">üìã Copy Block ${idx + 1}</button>
            </div>
            <pre style="margin: 0; padding: 1rem; background: #000; color: #fff; overflow-x: auto; font-size: 0.85rem; max-height: 400px; overflow-y: auto;">${escapeHtml(blockJson)}</pre>
          </div>
        `;
      }).join('');
      
      jsonLdHtml = `
        <div style="margin-top: 1.5rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <h4 style="margin: 0; font-size: 1rem; font-weight: 600;">JSON-LD Blocks (${blocks.length})</h4>
            <button class="copy-all-blocks-btn secondary" style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: #2563eb; color: white; border-color: #2563eb; cursor: pointer;">üìã Copy All Blocks</button>
          </div>
          ${blocksHtml}
        </div>
      `;
      
      // Store blocks data for copy functionality
      backdrop.dataset.blocksJson = JSON.stringify(blocks);
    } else {
      jsonDetails.style.display = 'none';
      jsonLdHtml = '<p style="color: #6b7280; font-style: italic; margin-top: 1.5rem;">No JSON-LD blocks captured.</p>';
    }
    
    content.innerHTML = `
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem;">
        <h3 style="margin: 0; font-size: 1.25rem; font-weight: 600;">Schema Analysis Summary</h3>
        <span class="${severityBadge.badgeColor}">${severityBadge.badgeLabel}</span>
      </div>
      
      <div class="summary-card">
        <pre>${humanReadableSummary.trim()}</pre>
      </div>
      
      <div style="margin-top: 1.5rem;">
        <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 600;">Issues</h4>
        <ul class="issues-list" style="list-style: none; padding: 0; margin: 0;">
          ${issuesHtml || '<li>None</li>'}
        </ul>
      </div>
      
      ${recommendedFixHtml}
      
      ${inferredTypesHtml}
      
      ${schemaTableHtml}
      
      ${jsonLdHtml}
      
      <div class="help-link">
        ${orgFixCheck.shouldShowRecommendedFix ? '<p>Need help implementing this? ' : ''}
        ${orgFixCheck.shouldShowRecommendedFix ? '<a href="https://support.squarespace.com/hc/en-us/articles/206543167" target="_blank">View Squarespace injection guide</a></p>' : ''}
        <p style="margin-top: 0.5rem; font-style: italic; color: #6b7280;">
          Diagnostic: ${issueCount} missing field${issueCount !== 1 ? 's' : ''}${duplicates.length > 0 ? `, ${duplicates.length} duplicate type${duplicates.length !== 1 ? 's' : ''} detected` : ''}${result?.multiInstanceCounts && Object.keys(result.multiInstanceCounts).length > 0 ? `. ${Object.entries(result.multiInstanceCounts).map(([type, count]) => `${count} ${type}${count !== 1 ? 's' : ''}`).join(', ')} detected (expected)` : ''}.
        </p>
      </div>
    `;
    
    setupModalButtonHandlers(recommendedFix, json, jsonDetails, rowData);
    
    btnSchema.onclick = () => globalThis.open('https://validator.schema.org/?url=' + encodeURIComponent(rowData.url), '_blank');
    btnGoogle.onclick = () => globalThis.open('https://search.google.com/test/rich-results?url=' + encodeURIComponent(rowData.url), '_blank');
    
    function close() {
      backdrop.close();
      document.removeEventListener('keydown', esc);
    }
    function esc(e) {
      if (e.key === 'Escape') close();
    }
    closeBtn.onclick = close;
    if (closeXBtn) {
      closeXBtn.onclick = close;
    }
    backdrop.onclick = (e) => {
      if (e.target === backdrop) close();
    };
    backdrop.showModal();
    
    // Setup copy button handlers after modal is opened and content is rendered
    setTimeout(() => {
      // Copy individual block buttons
      const copyBlockBtns = backdrop.querySelectorAll('.copy-block-btn');
      console.log(`Found ${copyBlockBtns.length} copy block buttons`);
      copyBlockBtns.forEach(btn => {
        btn.onclick = () => {
          const blockIndex = parseInt(btn.dataset.blockIndex);
          const blocksData = JSON.parse(backdrop.dataset.blocksJson || '[]');
          if (blocksData[blockIndex]) {
            const blockJson = JSON.stringify(blocksData[blockIndex], null, 2);
            navigator.clipboard.writeText(blockJson).then(() => {
              btn.textContent = '‚úÖ Copied!';
              setTimeout(() => {
                btn.textContent = `üìã Copy Block ${blockIndex + 1}`;
              }, 2000);
            }).catch(() => {
              alert('Failed to copy. Please select and copy manually.');
            });
          }
        };
      });
      
      // Copy all blocks button
      const copyAllBtn = backdrop.querySelector('.copy-all-blocks-btn');
      console.log(`Copy all blocks button found: ${!!copyAllBtn}`);
      if (copyAllBtn) {
        copyAllBtn.onclick = () => {
          const blocksData = JSON.parse(backdrop.dataset.blocksJson || '[]');
          const allBlocksJson = JSON.stringify(blocksData, null, 2);
          navigator.clipboard.writeText(allBlocksJson).then(() => {
            copyAllBtn.textContent = '‚úÖ All Copied!';
            setTimeout(() => {
              copyAllBtn.textContent = 'üìã Copy All Blocks';
            }, 2000);
          }).catch(() => {
            alert('Failed to copy. Please select and copy manually.');
          });
        };
      } else {
        console.warn('Copy all blocks button not found in modal');
      }
    }, 300);
  }
  
  // Build a minimal rowData snapshot from a <tr>
  function getRowDataFromTr(tr) {
    const tds = tr.querySelectorAll('td');
    const url = tds[0]?.querySelector('a')?.href || tds[0]?.textContent?.trim() || '';
    // keep a handle to <tr> so we can read dataset fields
    const trRef = tr;
    const schemaType = tds[1]?.textContent?.trim() || '';
    const missing = tds[3]?.textContent?.trim() || '';
    // store first JSON-LD snippet in a dataset if available when row was computed
    const firstJson = tr.dataset.firstJsonld || '';
    // Get index from row to find validation result
    const rowIndex = Array.from(tr.parentNode.children).indexOf(tr);
    const result = validationResults[rowIndex];
    
    let issuesList = [];
    if (result && result.issuesList) {
      issuesList = result.issuesList;
    } else if (tr.dataset.issuesList) {
      try {
        issuesList = JSON.parse(tr.dataset.issuesList);
      } catch (e) {
        console.warn('Failed to parse issuesList:', e);
      }
    }
    
    let missingFields;
    if (result && result.missingFields) {
      missingFields = result.missingFields;
    } else if (missing) {
      missingFields = missing.split(',').map(s => s.trim()).filter(Boolean);
    } else {
      missingFields = [];
    }
    
    return { 
      url, 
      schemaType, 
      missingFields: missingFields, 
      firstJsonLd: firstJson, 
      tr: trRef, 
      issuesList,
      schemaSummary: result && result.schemaSummary ? result.schemaSummary : null
    };
  }
  
  // ---- Schema core fields (minimal, safe set) ----
  const CORE_REQUIRED = {
    WebSite:      ["name", "url"],
    Organization: ["name"],
    LocalBusiness:["name"]   // keep minimal; address/telephone vary a lot
  };
  
  // Flatten any JSON-LD object/array/@graph into a list of typed nodes
  function flattenJsonLd(node, out = []) {
    if (!node) return out;
    if (Array.isArray(node)) { node.forEach(n=>flattenJsonLd(n, out)); return out; }
    if (node['@graph']) { flattenJsonLd(node['@graph'], out); }
    if (node['@type']) out.push(node);
    return out;
  }
  
  // Build a map: type -> array of nodes for that type
  function indexByType(nodes) {
    const idx = {};
    nodes.forEach(n => {
      const types = Array.isArray(n['@type']) ? n['@type'] : [n['@type']];
      types.forEach(t => {
        (idx[t] ||= []).push(n);
      });
    });
    return idx;
  }
  
  // Helper: Check if field is missing for a node
  function isFieldMissing(node, field) {
    return !node.hasOwnProperty(field) || !node[field];
  }

  // Helper: Check if message already exists for this type+field+key combination
  function isAlreadyFlagged(messages, type, field, key) {
    return messages.some(m => m.type === type && m.field === field && m.key === key);
  }

  // Helper: Check if node is system-injected (Squarespace auto-generated)
  function isSystemInjectedNode(type, node) {
    return type === 'Organization' && 
      !node['@id'] && 
      (!node.name || !node.name.trim()) && 
      (!node.url || !node.url.trim());
  }

  // Helper: Process required fields for a node group
  function processRequiredFieldsForNode(messages, type, field, key, firstNode, instances) {
    if (isFieldMissing(firstNode, field) && !isAlreadyFlagged(messages, type, field, key)) {
      messages.push({ 
        type: type, 
        field: field, 
        nodeIndex: instances[0].index,
        key: key,
        instances: instances.length,
        hasId: !!firstNode['@id'],
        systemInjected: isSystemInjectedNode(type, firstNode)
      });
    }
  }

  // Inspect which types are present and which required fields are missing per type
  function computeMissingFields(allNodes) {
    const idx = indexByType(allNodes);
    const messages = [];
    
    Object.keys(idx).forEach(t => {
      if (!CORE_REQUIRED[t]) return;
      
      const required = CORE_REQUIRED[t];
      const nodesByKey = {};
      
      idx[t].forEach((n, nodeIndex) => {
        const key = n['@id'] || JSON.stringify([n['@type'], n.url, n.name]).slice(0, 100);
        if (!nodesByKey[key]) nodesByKey[key] = [];
        nodesByKey[key].push({ node: n, index: nodeIndex });
      });
      
      Object.keys(nodesByKey).forEach(key => {
        const instances = nodesByKey[key];
        const firstNode = instances[0].node;
        
        if (isSystemInjectedNode(t, firstNode)) {
          return;
        }
        
        required.forEach(req => {
          processRequiredFieldsForNode(messages, t, req, key, firstNode, instances);
        });
      });
    });
    
    return messages;
  }
  
  // Try to find a candidate value for a field in OTHER types (so we can suggest)
  function findFieldElsewhere(allNodes, field, exceptType) {
    for (const n of allNodes) {
      const types = Array.isArray(n['@type']) ? n['@type'] : [n['@type']];
      if (types.includes(exceptType)) continue;
      if (n[field]) return { fromType: types.join(','), value: (''+n[field]).slice(0,120) };
    }
    return null;
  }
  
  // ---------- Enhanced Schema Builder ----------
  const asArray = v => Array.isArray(v) ? v : (v ? [v] : []);
  const uniq = arr => [...new Set(arr)];
  function firstNonEmpty(...vals){ for(const v of vals){ if(typeof v==='string' && v.trim()) return v.trim(); } return ''; }
  
  function pageMeta(doc, url){
    const get = s => doc.querySelector(s)?.getAttribute('content') || '';
    return {
      url,
      title: doc.querySelector('h1')?.textContent?.trim() || doc.title || '',
      ogTitle: get('meta[property="og:title"]'),
      ogDesc: get('meta[property="og:description"]'),
      ogImage: get('meta[property="og:image"]'),
      logo: get('meta[itemprop="logo"]') || get('meta[property="og:logo"]') || '',
      siteName: get('meta[property="og:site_name"]')
    };
  }
  
  function ensureId(node, baseUrl, suffix){
    if (!node['@id']) node['@id'] = baseUrl.replace(/#.*$/,'') + '#' + suffix;
    return node;
  }
  
  function dedupeById(nodes){
    const map = new Map();
    nodes.forEach(n=>{
      const key = n['@id'] || JSON.stringify([n['@type'], n.name, n.url]);
      if (!map.has(key)) map.set(key, n);
    });
    return [...map.values()];
  }
  
  function prettyScript(json){
    return `<script type="application/ld+json">\n${JSON.stringify(json, null, 2)}\n<\/script>`;
  }
  
  function buildBreadcrumbs(doc, url){
    // 1) Try semantic breadcrumbs in DOM
    let items = [];
    const nav = doc.querySelector('nav[aria-label="breadcrumb"], .breadcrumbs, ol.breadcrumb, ul.breadcrumb');
    if (nav){
      const links = nav.querySelectorAll('a, [itemprop="item"]');
      let pos=1;
      links.forEach(a=>{
        const href = a.getAttribute('href') || a.getAttribute('content') || '';
        const name = a.textContent?.trim() || a.getAttribute('title') || '';
        if (name) items.push({ "@type":"ListItem", position: pos++, name, item: href.startsWith('http') ? href : new URL(href, url).href });
      });
    }
    // 2) Fallback to URL path
    if (!items.length){
      const u = new URL(url);
      const segs = u.pathname.split('/').filter(Boolean);
      let path=u.origin, pos=1;
      items.push({ "@type":"ListItem", position: pos++, name: "Home", item: u.origin });
      for(const s of segs){
        path += '/' + s;
        items.push({ "@type":"ListItem", position: pos++, name: decodeURIComponent(s.replace(/-/g,' ')).replace(/\b\w/g,m=>m.toUpperCase()), item: path });
      }
    }
    return {
      "@type":"BreadcrumbList",
      "@id": url.replace(/#.*$/,'') + "#breadcrumbs",
      "itemListElement": items
    };
  }
  
  // Helper: Detect global schema patterns
  function detectGlobalPatterns(nodes, baseUrl) {
    const existingIds = new Set();
    for (const n of nodes) {
      if (n['@id']) existingIds.add(n['@id']);
    }
    
    const hasGlobalWebsite = existingIds.has(baseUrl + '#website') || 
                             nodes.some(n => n['@type'] === 'WebSite' && n['@id'] && n['@id'].includes('#website'));
    const hasGlobalOrg = existingIds.has(baseUrl + '#org') ||
                        nodes.some(n => {
                          const types = asArray(n['@type']);
                          return (types.includes('Organization') || types.includes('LocalBusiness')) && 
                                 n['@id'] && n['@id'].includes('#org');
                        });
    const hasGlobalLocal = existingIds.has(baseUrl + '#local') ||
                          nodes.some(n => n['@type'] === 'LocalBusiness' && n['@id'] && n['@id'].includes('#local'));
    
    return { hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal };
  }

  // Helper: Build website node
  function buildWebsiteNode(idx, siteName, meta) {
    const website = (idx.WebSite && idx.WebSite[0]) ? structuredClone(idx.WebSite[0]) : {"@type":"WebSite"};
    website.name = website.name || siteName || "Alan Ranger Photography";
    website.url = website.url || meta.url;
    return website;
  }

  // Helper: Build organization node
  function buildOrgNode(idx, siteName, meta) {
    const org = (idx.Organization && idx.Organization[0]) ? structuredClone(idx.Organization[0]) : {"@type":"Organization"};
    org.name = org.name || siteName || "Alan Ranger Photography";
    org.url = org.url || meta.url;
    if (!org.logo && meta.logo) org.logo = meta.logo;
    if (!org.image && meta.ogImage) org.image = meta.ogImage;
    return org;
  }

  // Helper: Build local business node
  function buildLocalNode(idx, org, siteName, meta) {
    let local = (idx.LocalBusiness && idx.LocalBusiness[0]) ? structuredClone(idx.LocalBusiness[0]) : 
                (idx.Organization && idx.Organization[0] ? structuredClone(idx.Organization[0]) : null);
    
    if (local) {
      local.name = local.name || org.name || siteName;
      local.url = local.url || meta.url;
      if (!local.image && meta.ogImage) local.image = meta.ogImage;
      if (!local['@type']) local['@type'] = 'LocalBusiness';
    }
    
    return local;
  }

  // Helper: Build core schema nodes
  function buildCoreSchemaNodes(idx, meta, url) {
    const siteName = firstNonEmpty(null, meta.siteName, meta.title, "Alan Ranger Photography");
    const website = buildWebsiteNode(idx, siteName, meta);
    const org = buildOrgNode(idx, siteName, meta);
    const local = buildLocalNode(idx, org, siteName, meta);
    return { website, org, local };
  }

  // Helper: Build final schema graph
  function buildSchemaGraph(hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal, website, org, local, breadcrumbs, extras) {
    const graph = [];
    
    if (!hasGlobalWebsite) {
      graph.push(website);
    }
    
    if (!hasGlobalOrg) {
      graph.push(org);
    }
    
    if (local && !hasGlobalLocal) {
      graph.push(local);
    }
    
    if (breadcrumbs.itemListElement && breadcrumbs.itemListElement.length > 0) {
      graph.push(breadcrumbs);
    }
    
    graph.push(...extras);
    
    return dedupeById(graph);
  }

  // Helper: Process schema with fallback (check for existing Product before generating)
  async function processSchemaWithFallback(url, doc, nodes) {
    const meta = pageMeta(doc, url);
    const idx = indexByType(nodes);
    
    // Check for existing Product schema
    const hasExistingProduct = nodes.some(n => {
      const types = asArray(n['@type']);
      return types.includes('Product') || types.includes('Course');
    });
    
    if (hasExistingProduct) {
      debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî skipping Product generation to prevent duplicates`, 'info');
    }
    
    let { website, org, local } = buildCoreSchemaNodes(idx, meta, url);
    
    const baseUrl = url.replace(/#.*$/,'');
    const { hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal } = detectGlobalPatterns(nodes, baseUrl);
    
    if (!hasGlobalWebsite) website = ensureId(website, url, 'website');
    if (!hasGlobalOrg) org = ensureId(org, url, 'org');
    if (local && !hasGlobalLocal) local = ensureId(local, url, 'local');
    
    const breadcrumbs = buildBreadcrumbs(doc, url);
    const keepTypes = ['Product','Event','ItemList','FAQPage','Article','BlogPosting','Course'];
    
    // Only include Product/Course if they don't already exist
    const extras = nodes.filter(n => {
      const types = asArray(n['@type']);
      const hasKeepType = types.some(t => keepTypes.includes(t));
      
      // Skip Product/Course if already exists to prevent duplicates
      if ((types.includes('Product') || types.includes('Course')) && hasExistingProduct) {
        return false; // Don't include Product/Course nodes if we detected existing ones
      }
      
      return hasKeepType;
    });
    
    const finalGraph = buildSchemaGraph(hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal, website, org, local, breadcrumbs, extras);
    
    return { "@context":"https://schema.org", "@graph": finalGraph };
  }

  async function generateEnhancedFor(url){
    const apiBaseUrl = getApiBaseUrl();
    const apiUrl = `${apiBaseUrl}/api/fetch?url=${encodeURIComponent(url)}`;
    
    debugLog(`[Generate Enhanced] Fetching via API: ${apiUrl}`, 'info');
    
    try {
      // Use API proxy for Squarespace pages
      const res = await fetch(apiUrl);
      
      if (!res.ok) {
        const errorText = await res.text().catch(() => 'Unknown error');
        throw new Error(`API returned ${res.status}: ${errorText.substring(0, 100)}`);
      }
      
      const html = await res.text();
      
      if (!html || html.length === 0) {
        throw new Error('API returned empty response');
      }
      
      debugLog(`[Generate Enhanced] Received ${html.length} bytes of HTML`, 'success');
      
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      
      // Find all script tags with JSON-LD (including Squarespace patterns)
      const scripts = findAllJsonLdScripts(doc);
      
      let nodes = [];
      for (const s of scripts) {
        try {
          // Decode HTML entities before parsing
          const decodedText = decodeHTML(s.textContent);
          nodes = flattenJsonLd(JSON.parse(decodedText.trim()), nodes);
        } catch(e) {
          debugLog(`[Generate Enhanced] Failed to parse JSON-LD block: ${e.message}`, 'warning');
        }
      }
      
      // Check for existing Product schema before generating
      const hasExistingProduct = nodes.some(n => {
        const types = asArray(n['@type']);
        return types.includes('Product') || types.includes('Course');
      });
      
      if (hasExistingProduct) {
        debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî will not generate duplicate`, 'info');
      }
      
      debugLog(`[Generate Enhanced] Found ${nodes.length} schema nodes`, 'info');
      
      return await processSchemaWithFallback(url, doc, nodes);
    } catch (error) {
      debugLog(`[Generate Enhanced] API fetch failed: ${error.message}`, 'error');
      
      // Fallback to direct fetch if API fails (will likely fail due to CORS)
      debugLog(`[Generate Enhanced] Attempting direct fetch fallback...`, 'warning');
      
      try {
        const res = await fetch(url, {mode:'cors'});
        if (!res.ok) {
          throw new Error(`Direct fetch returned ${res.status}`);
        }
        const html = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Find all script tags with JSON-LD (including Squarespace patterns)
        const scripts = findAllJsonLdScripts(doc);
        
        let nodes = [];
        for (const s of scripts) {
          try {
            // Decode HTML entities before parsing
            const decodedText = decodeHTML(s.textContent);
            nodes = flattenJsonLd(JSON.parse(decodedText.trim()), nodes);
          } catch(_) {}
        }
        
        // Check for existing Product schema
        const hasExistingProduct = nodes.some(n => {
          const types = asArray(n['@type']);
          return types.includes('Product') || types.includes('Course');
        });
        
        if (hasExistingProduct) {
          debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî will not generate duplicate`, 'info');
        }
        
        return await processSchemaWithFallback(url, doc, nodes);
      } catch (err) {
        const errorMsg = err.message || 'Unknown error';
        debugLog(`[Generate Enhanced] Direct fetch also failed: ${errorMsg}`, 'error');
        throw new Error(`Failed to fetch page: ${errorMsg}. API endpoint: ${apiUrl}`);
      }
    }
  }
  
  // Modal plumbing
  (function initGenModal(){
    // Function to setup save button handler
    function setupSaveButton() {
      const saveBtn = document.getElementById('genSaveBtn');
      const backdrop = document.getElementById('genBackdrop');
      if (saveBtn && backdrop) {
        saveBtn.onclick = async () => {
          try {
            const url = backdrop.dataset.url || '';
            const json = backdrop.dataset.json || document.getElementById('genJson')?.textContent || '';
            
            if (!json || json.trim().length === 0) {
              alert('No content to save');
              return;
            }
            
            // Generate filename from URL
            let filename = 'schema';
            if (url) {
              try {
                const urlObj = new URL(url);
                // Extract pathname and convert to filename-safe string
                const pathParts = urlObj.pathname.split('/').filter(p => p);
                if (pathParts.length > 0) {
                  filename = pathParts[pathParts.length - 1].replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                  // Limit filename length
                  if (filename.length > 50) {
                    filename = filename.substring(0, 50);
                  }
                } else {
                  filename = urlObj.hostname.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                }
              } catch (e) {
                console.warn('Failed to parse URL for filename:', e);
              }
            }
            
            // Add timestamp to ensure uniqueness
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
            const fullFilename = `${filename}-${timestamp}.json`;
            
            // Create blob and download
            const blob = new Blob([json], { type: 'application/json' });
            const blobUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = fullFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(blobUrl);
            
            // Update button feedback
            const originalText = saveBtn.textContent;
            saveBtn.textContent = '‚úÖ Saved!';
            saveBtn.style.background = '#10b981';
            setTimeout(() => {
              saveBtn.textContent = originalText;
              saveBtn.style.background = '#10b981';
            }, 2000);
            
            console.log(`Saved schema to: ${fullFilename}`);
          } catch (err) {
            console.error('Failed to save file:', err);
            alert('Failed to save file: ' + err.message);
          }
        };
      }
    }
    
    // Function to setup copy button handler
    function setupCopyButton() {
      const copyBtn = document.getElementById('genCopyBtn');
      const jsonEl = document.getElementById('genJson');
      if (copyBtn && jsonEl) {
        copyBtn.onclick = async () => {
          try {
            const text = jsonEl.textContent || jsonEl.innerText;
            if (!text || text.trim().length === 0) {
              alert('No content to copy');
              return;
            }
            
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
              copyBtn.textContent = '‚úÖ Copied!';
              setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
            } else {
              // Fallback: use textarea method for older browsers
              const textarea = document.createElement('textarea');
              textarea.value = text;
              textarea.style.position = 'fixed';
              textarea.style.left = '-999999px';
              document.body.appendChild(textarea);
              textarea.select();
              textarea.setSelectionRange(0, 99999); // For mobile devices
              
              try {
                document.execCommand('copy');
                copyBtn.textContent = '‚úÖ Copied!';
                setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
              } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
                debugLog('Copy failed: ' + err.message, 'error');
              } finally {
                document.body.removeChild(textarea);
              }
            }
          } catch (err) {
            alert('Failed to copy to clipboard: ' + err.message);
            debugLog('Copy error: ' + err.message, 'error');
          }
        };
      }
    }
    
    // Setup close button and backdrop
    function setupCloseButton() {
      const backdrop = document.getElementById('genBackdrop');
      const closeBtn = document.getElementById('genCloseBtn');
      if (backdrop && closeBtn) {
        closeBtn.onclick = () => {
          if (backdrop.close) {
            backdrop.close();
          } else {
            backdrop.style.display = 'none';
          }
        };
        backdrop.onclick = (e) => {
          if (e.target === backdrop) {
            if (backdrop.close) {
              backdrop.close();
            } else {
              backdrop.style.display = 'none';
            }
          }
        };
      }
    }
    
    // Try to setup immediately if DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setupCopyButton();
        setupSaveButton();
        setupCloseButton();
      });
    } else {
      setupCopyButton();
      setupSaveButton();
      setupCloseButton();
    }
    
    // Also setup when modal is opened (in case elements weren't ready earlier)
    window.__openGenModal = (url, json)=>{
      const backdropEl = document.getElementById('genBackdrop');
      const metaEl = document.getElementById('genMeta');
      const jsonEl = document.getElementById('genJson');
      if (!backdropEl) {
        alert('Error: Modal element not found. Please refresh the page.');
        return;
      }
      if (metaEl) metaEl.textContent = url;
      if (jsonEl) jsonEl.textContent = prettyScript(json);
      
      // Store URL and JSON for save function
      backdropEl.dataset.url = url;
      backdropEl.dataset.json = json;
      
      // Re-attach copy and save button handlers in case they weren't set up earlier
      setupCopyButton();
      setupSaveButton();
      
      // Use dialog API if available
      if (backdropEl.showModal) {
        backdropEl.showModal();
      } else {
        backdropEl.style.display='flex';
      }
    };
  })();
  
  // Copy to clipboard
  // Combined Debug Log Functions
  function addToCombinedLog(msg, stepId, task) {
    const combinedLog = document.getElementById('combinedDebugLog');
    if (!combinedLog) return;
    
    // Get step name
    const stepNames = {
      '0': 'Step 0 - Setup Check',
      2: 'Step 2 - Clean',
      '3a': 'Step 3a - Fetch Google Reviews',
      '3b': 'Step 3b - Merge Reviews',
      4: 'Step 4 - Generate Schema'
    };
    const stepName = stepNames[stepId] || `Step ${stepId}`;
    
    // Add timestamp and step header if this is a new step
    const currentText = combinedLog.textContent;
    const stepHeader = `\n${'='.repeat(60)}\n${stepName} (${task})\n${'='.repeat(60)}\n`;
    
    // Check if we need to add step header
    if (currentText === 'No logs yet. Step outputs will appear here as they run...') {
      combinedLog.textContent = stepHeader;
    } else if (msg.includes('üöÄ Starting') && !currentText.includes(`${stepName} (${task})`)) {
      combinedLog.textContent += stepHeader;
    } else if (stepId === '0' && (msg.includes('Running in Electron') || msg.includes('[Server]')) && !currentText.includes('Step 0')) {
      // Add Step 0 header on first message
      combinedLog.textContent = stepHeader;
    }
    
    // Add the message with timestamp for important events
    if (msg.includes('üöÄ Starting') || msg.includes('‚ùå') || msg.includes('‚úÖ Task') || msg.includes('Error:') || msg.includes('[Server]')) {
      const now = new Date();
      const timestamp = `[${now.toTimeString().substring(0, 8)}]`;
      combinedLog.textContent += `${timestamp} ${msg}`;
    } else {
      combinedLog.textContent += msg;
    }
    combinedLog.scrollTop = combinedLog.scrollHeight;
  }
  
  function copyCombinedLog() {
    const combinedLog = document.getElementById('combinedDebugLog');
    if (!combinedLog) return;
    
    const text = combinedLog.textContent || 'No logs available';
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(() => {
        const btn = document.getElementById('copyCombinedLogBtn');
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '‚úÖ Copied!';
          btn.style.background = '#27AE60';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '#667eea';
          }, 2000);
        }
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy to clipboard. Please select and copy manually.');
      });
    } else {
      // Fallback for older browsers
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand('copy');
        const btn = document.getElementById('copyCombinedLogBtn');
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '‚úÖ Copied!';
          btn.style.background = '#27AE60';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '#667eea';
          }, 2000);
        }
      } catch (err) {
        alert('Failed to copy. Please select and copy manually.');
      }
      document.body.removeChild(textarea);
    }
  }
  
  function clearCombinedLog() {
    const combinedLog = document.getElementById('combinedDebugLog');
    if (combinedLog) {
      combinedLog.textContent = 'No logs yet. Step outputs will appear here as they run...';
    }
  }

  function copyToClipboard(outputId) {
    const element = document.getElementById(outputId);
    if (!element) {
      console.error(`Element with id "${outputId}" not found`);
      showToast('‚ùå Error: Output element not found', 'error');
      return;
    }
    
    const text = element.tagName === 'TEXTAREA' ? element.value : element.textContent;
    
    if (!text || text.trim() === '') {
      showToast('‚ö†Ô∏è Nothing to copy. Please generate schema first.', 'warning');
      return;
    }
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(function() {
        showToast('‚úÖ Schema copied to clipboard!', 'success');
      }, function(err) {
        console.error('Clipboard write failed:', err);
        showToast('‚ùå Failed to copy. Please try selecting and copying manually.', 'error');
      });
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      try {
        document.execCommand('copy');
        showToast('‚úÖ Schema copied to clipboard!', 'success');
      } catch (err) {
        console.error('Fallback copy failed:', err);
        showToast('‚ùå Failed to copy. Please try selecting and copying manually.', 'error');
      }
      document.body.removeChild(textArea);
    }
  }
  
  function showToast(message, type = 'success') {
    const toast = document.createElement('div');
    toast.textContent = message;
    const bgColor = type === 'success' ? '#27AE60' : type === 'error' ? '#E74C3C' : '#E57200';
    toast.style.cssText = `position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white; padding: 14px 24px; border-radius: 8px; z-index: 10000; font-size: 0.875rem; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: slideIn 0.3s ease-out;`;
    document.body.appendChild(toast);
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }

  // Test URL functions
  function testSchemaOrg(inputId) {
    const url = document.getElementById(inputId).value;
    if (!url) {
      alert('Please enter a URL to test');
      return;
    }
    window.open('https://validator.schema.org/#url=' + encodeURIComponent(url), '_blank');
  }

  function testGoogleRichResults(inputId) {
    const url = document.getElementById(inputId).value;
    if (!url) {
      alert('Please enter a URL to test');
      return;
    }
    window.open('https://search.google.com/test/rich-results?url=' + encodeURIComponent(url), '_blank');
  }

  // Helper: Validate URL input
  function validateUrlInput() {
    const urlInput = document.getElementById('singleUrlInput');
    if (!urlInput) {
      console.error('singleUrlInput element not found');
      alert('Error: Input field not found. Please refresh the page.');
      return null;
    }
    
    const url = urlInput.value.trim();
    console.log('URL input:', url);
    
    if (!url) {
      alert('Please enter a URL to validate');
      return null;
    }
    
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      alert('Please enter a valid URL starting with http:// or https://');
      return null;
    }
    
    return { urlInput, url };
  }

  // Helper: Show results table
  function showResultsTable() {
    const resultsDiv = document.getElementById('validatorResults');
    if (resultsDiv) {
      resultsDiv.style.display = 'block';
      return resultsDiv;
    }
    console.error('validatorResults element not found');
    alert('Error: Results table not found. Please refresh the page.');
    return null;
  }

  // Helper: Find or create result index
  function findOrCreateResultIndex(url) {
    if (typeof validationResults === 'undefined') {
      console.error('validationResults array not defined');
      alert('Error: Validation system not initialized. Please refresh the page.');
      return null;
    }
    
    const existingIndex = validationResults.findIndex(r => r.url === url);
    if (existingIndex >= 0) {
      console.log('Updating existing row at index:', existingIndex);
      return existingIndex;
    }
    
    console.log('Creating new row, current length:', validationResults.length);
    const index = validationResults.length;
    
    const placeholderResult = {
      url: url,
      row: index,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null,
      validatorGoogleStatus: 'Not run',
      validatorSchemaOrgStatus: 'Not run',
      notes: '',
      issuesList: []
    };
    
    validationResults.push(placeholderResult);
    console.log('Added placeholder result, new length:', validationResults.length);
    return index;
  }

  // Helper: Initialize validation row UI
  function initializeValidationRow(index, url) {
    if (typeof updateTableRow === 'undefined') {
      console.error('updateTableRow function not defined');
      alert('Error: updateTableRow function not found. Please refresh the page.');
      return false;
    }
    
    updateTableRow(index, {
      url: url,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null,
      validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
      validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
      notes: validationResults[index]?.notes || '',
      issuesList: []
    });
    
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    if (schemaTypeCell) {
      if (typeof renderProgress === 'undefined' || typeof setProgress === 'undefined') {
        console.error('renderProgress or setProgress not defined');
      } else {
        renderProgress(schemaTypeCell);
        setProgress(schemaTypeCell, 5, 'Queued');
      }
    }
    
    return true;
  }

  // Helper: Run external validators if enabled
  async function runExternalValidatorsIfEnabled(index, url) {
    const autoRunCheckbox = document.getElementById('autoRunExternalChecks');
    const shouldAutoRun = autoRunCheckbox ? autoRunCheckbox.checked : true;
    
    if (!shouldAutoRun) {
      return;
    }
    
    // Wait longer for DOM to be fully updated and select elements to be created
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Retry logic - try multiple times if elements aren't found
    let retries = 3;
    let schemaOrgRan = false;
    let richResultsRan = false;
    
    while (retries > 0 && (!schemaOrgRan || !richResultsRan)) {
      try {
        const schemaOrgStatusSelect = document.getElementById(`schemaOrgStatus_${index}`);
        if (schemaOrgStatusSelect && schemaOrgStatusSelect.value === 'Not run' && !schemaOrgRan) {
          if (typeof runSchemaOrgValidator === 'function') {
            try {
              await runSchemaOrgValidator(index, url);
              schemaOrgRan = true;
            } catch (err) {
              console.error(`Schema.org validation failed for ${url}:`, err);
              debugLog(`Schema.org validation failed for ${url}: ${err.message}`, 'error');
              schemaOrgRan = true; // Mark as attempted to prevent retry loop
            }
          } else {
            console.warn(`runSchemaOrgValidator function not found for index ${index}`);
            schemaOrgRan = true;
          }
        } else if (schemaOrgStatusSelect && schemaOrgStatusSelect.value !== 'Not run') {
          schemaOrgRan = true; // Already run
        }
        
        const googleStatusSelect = document.getElementById(`googleStatus_${index}`);
        if (googleStatusSelect && googleStatusSelect.value === 'Not run' && !richResultsRan) {
          if (typeof runRichResultsValidator === 'function') {
            try {
              await runRichResultsValidator(index, url);
              richResultsRan = true;
            } catch (err) {
              console.error(`Rich Results validation failed for ${url}:`, err);
              debugLog(`Rich Results validation failed for ${url}: ${err.message}`, 'error');
              richResultsRan = true; // Mark as attempted to prevent retry loop
            }
          } else {
            console.warn(`runRichResultsValidator function not found for index ${index}`);
            richResultsRan = true;
          }
        } else if (googleStatusSelect && googleStatusSelect.value !== 'Not run') {
          richResultsRan = true; // Already run
        }
        
        // If both ran or both select elements don't exist, break
        if (schemaOrgRan && richResultsRan) {
          break;
        }
        
        // If elements still don't exist after waiting, wait a bit more
        if (retries > 1 && (!schemaOrgStatusSelect || !googleStatusSelect)) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
        
      } catch (error) {
        console.error(`External validation error for ${url}:`, error);
        debugLog(`External validation error for ${url}: ${error.message}`, 'error');
      }
      
      retries--;
      if (retries > 0 && (!schemaOrgRan || !richResultsRan)) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
    
    if (!schemaOrgRan || !richResultsRan) {
      console.warn(`External validations may not have completed for index ${index}, URL: ${url}`);
      debugLog(`External validations may not have completed for index ${index}, URL: ${url}`, 'warning');
    }
  }

  // Helper: Auto-save to Supabase if enabled
  function autoSaveToSupabaseIfEnabled(index, url) {
    const autoSaveCheckbox = document.getElementById('autoSaveToSupabase');
    const shouldAutoSave = autoSaveCheckbox ? autoSaveCheckbox.checked : false;
    
    if (shouldAutoSave && supabaseAvailable && supabase && typeof saveToSupabase === 'function') {
      setTimeout(async () => {
        try {
          await saveToSupabase(index, true);
          debugLog(`Auto-saved to Supabase: ${url}`, 'success');
        } catch (error) {
          debugLog(`Auto-save failed for ${url}: ${error.message}`, 'error');
        }
      }, 2000);
    }
  }

  // Helper: Handle validation error
  function handleValidationError(error, index, url) {
    console.error('Error validating URL:', error);
    console.error('Error stack:', error.stack);
    alert('Error validating URL: ' + error.message + '\n\nCheck console for details.');
    
    if (typeof index !== 'undefined' && validationResults && validationResults[index]) {
      validationResults[index] = {
        url: url || 'Unknown',
        row: index || 0,
        schemaType: null,
        valid: false,
        schemaFound: false,
        missingFields: [],
        warnings: [],
        schemas: [],
        error: error.message,
        validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
        validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
        notes: validationResults[index]?.notes || '',
        issuesList: []
      };
      
      if (typeof updateTableRow === 'function') {
        updateTableRow(index, validationResults[index]);
      }
    }
    
    if (typeof updateBulkButtons === 'function') {
      updateBulkButtons();
    }
  }

  // Single URL validation
  async function runSingleUrlValidation() {
    console.log('runSingleUrlValidation called');
    
    try {
      const urlInputData = validateUrlInput();
      if (!urlInputData) return;
      
      const resultsDiv = showResultsTable();
      if (!resultsDiv) return;
      
      const index = findOrCreateResultIndex(urlInputData.url);
      if (index === null) return;
      
      if (!initializeValidationRow(index, urlInputData.url)) return;
      
      console.log('Starting processUrl...');
      if (typeof processUrl === 'undefined') {
        console.error('processUrl function not defined');
        alert('Error: processUrl function not found. Please refresh the page.');
        return;
      }
      
      const urlData = { url: urlInputData.url, row: index };
      const result = await processUrl(urlData);
      console.log('processUrl completed:', result);
      
      validationResults[index] = {
        ...result,
        validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
        validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
        notes: validationResults[index]?.notes || ''
      };
      
      console.log('Updating table row with results...');
      updateTableRow(index, validationResults[index]);
      
      if (typeof updateBulkButtons === 'function') {
        updateBulkButtons();
      }
      
      await runExternalValidatorsIfEnabled(index, urlInputData.url);
      autoSaveToSupabaseIfEnabled(index, urlInputData.url);
      
      urlInputData.urlInput.value = '';
      
      if (resultsDiv) {
        resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      
    } catch (error) {
      let errorUrl = '';
      try {
        const urlInputData = validateUrlInput();
        errorUrl = urlInputData?.url || '';
      } catch {
        errorUrl = '';
      }
      handleValidationError(error, typeof index !== 'undefined' ? index : undefined, errorUrl);
    }
  }
  
  // Make it globally accessible
  window.runSingleUrlValidation = runSingleUrlValidation;

  // Toggle help block
  function toggleHelpBlock() {
    const helpBlock = document.getElementById('helpBlock');
    const content = document.getElementById('helpBlockContent');
    
    helpBlock.classList.toggle('expanded');
    content.classList.toggle('active');
    helpBlock.setAttribute('aria-expanded', helpBlock.classList.contains('expanded'));
  }

  // Event Schema Generation v4 - Smart Enriched Schema Generator
  let events = [];
  let reviewsData = null;
  let mappingsData = null;

  // Schema Suppressor v1.3 block (Code-Block Safe)
  const SCHEMA_SUPPRESSOR_BLOCK = `<!-- Squarespace Product Schema Suppressor v1.3 (Code-Block Safe) -->

<script>
(function(){
  const removeSquarespaceProduct = () => {
    document.querySelectorAll('script[type="application/ld+json"]').forEach(el => {
      const txt = el.textContent.trim();
      if (txt.includes('"@type":"Product"')) {
        try {
          const j = JSON.parse(txt);
          const looksLikeSquarespace =
            txt.length < 1500 &&
            !j.aggregateRating &&
            !j.review &&
            j.offers &&
            j.name &&
            !txt.includes('"hasMerchantReturnPolicy"');
          if (looksLikeSquarespace) el.remove();
        } catch(e){}
      }
    });
  };
  removeSquarespaceProduct();
  document.addEventListener('DOMContentLoaded', removeSquarespaceProduct);
  window.addEventListener('load', () => setTimeout(removeSquarespaceProduct, 1000));
  const obs = new MutationObserver(removeSquarespaceProduct);
  obs.observe(document.documentElement, { childList: true, subtree: true });
})();
<` + `/script>

`;

  // Detect EventSeries groups for recurring workshops (v4.2)
  function detectEventSeries(events) {
    const grouped = {};
    
    const keywords = [
      "Bluebell Photography Workshop",
      "Batsford Arboretum Autumn Photography Workshop"
    ];
    
    for (const e of events) {
      const title = e.name || e.Event_Title || "";
      const keyMatch = keywords.find(k => title.includes(k));
      if (keyMatch) {
        const key = keyMatch.trim().toLowerCase();
        if (!grouped[key]) grouped[key] = [];
        grouped[key].push(e);
      }
    }
    
    // Filter out groups with fewer than 2 events
    Object.keys(grouped).forEach(k => {
      if (grouped[k].length < 2) delete grouped[k];
    });
    
    return grouped;
  }

  // Detect CSV type (Lessons vs Workshops) - v4
  function detectCsvType(fileName, headers) {
    const fileNameLower = (fileName || '').toLowerCase();
    const headersStr = (headers || []).join(' ').toLowerCase();
    
    if (fileNameLower.includes('beginners-photography-lessons') || 
        fileNameLower.includes('lesson') ||
        headersStr.includes('beginners-photography-lessons')) {
      return 'lessons';
    } else if (fileNameLower.includes('photographic-workshops') ||
               fileNameLower.includes('workshop') ||
               headersStr.includes('photographic-workshops')) {
      return 'workshops';
    }
    return 'unknown';
  }

  document.getElementById('eventCsvFile').addEventListener('change', function(e) {
    if (!e.target.files || !e.target.files[0]) {
      console.error('No file selected');
      return;
    }
    
    Papa.parse(e.target.files[0], {
      header: true,
      skipEmptyLines: true,
      complete: function(results) {
        if (!results.data || results.data.length === 0) {
          alert('CSV file is empty or could not be parsed. Please check the file format.');
          return;
        }
        
        events = results.data;
        console.log('‚úÖ Loaded', events.length, 'events from CSV');
        
        // Detect CSV type
        const csvType = detectCsvType(e.target.files[0].name, results.meta.fields || []);
        console.log('üìã CSV Type detected:', csvType);
        
        const categories = [...new Set(
          events.map(e => {
            const cat = e['Category'] || e['category'] || e['CATEGORY'] || '';
            return cat.split(',')[0].trim();
          }).filter(Boolean)
        )];
        
        const filterSelect = document.getElementById('eventCategoryFilter');
        filterSelect.innerHTML = '<option value="__ALL__">All Categories</option>';
        categories.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          filterSelect.appendChild(opt);
        });
        
        // Always show the container and button, even if no categories found
        document.getElementById('eventCategoryFilterContainer').style.display = 'block';
        document.getElementById('eventOptionsContainer').style.display = 'block';
        
        // Load toggle states from localStorage
        const includeReviews = localStorage.getItem('eventSchema.includeReviews');
        const includePerformer = localStorage.getItem('eventSchema.includePerformer');
        const groupRepeatingEvents = localStorage.getItem('eventSchema.groupRepeatingEvents');
        const includeMerchantFields = localStorage.getItem('eventSchema.includeMerchantFields');
        const enrichLocations = localStorage.getItem('eventSchema.enrichLocations');
        const includeAvailabilityStarts = localStorage.getItem('eventSchema.includeAvailabilityStarts');
        
        if (includeReviews !== null) document.getElementById('includeReviews').checked = includeReviews === 'true';
        if (includePerformer !== null) document.getElementById('includePerformer').checked = includePerformer === 'true';
        if (groupRepeatingEvents !== null) document.getElementById('groupRepeatingEvents').checked = groupRepeatingEvents === 'true';
        if (includeMerchantFields !== null) {
          document.getElementById('includeMerchantFields').checked = includeMerchantFields === 'true';
          document.getElementById('merchantFeedContainer').style.display = includeMerchantFields === 'true' ? 'block' : 'none';
        }
        if (enrichLocations !== null) document.getElementById('toggleLocationEnrichment').checked = enrichLocations === 'true';
        if (includeAvailabilityStarts !== null) document.getElementById('toggleAvailabilityStarts').checked = includeAvailabilityStarts === 'true';
        
        // Save toggle states on change
        document.getElementById('includeReviews').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includeReviews', this.checked);
        });
        document.getElementById('includePerformer').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includePerformer', this.checked);
        });
        document.getElementById('groupRepeatingEvents').addEventListener('change', function() {
          localStorage.setItem('eventSchema.groupRepeatingEvents', this.checked);
        });
        document.getElementById('includeMerchantFields').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includeMerchantFields', this.checked);
          document.getElementById('merchantFeedContainer').style.display = this.checked ? 'block' : 'none';
        });
        document.getElementById('toggleLocationEnrichment').addEventListener('change', function() {
          localStorage.setItem('eventSchema.enrichLocations', this.checked);
        });
        document.getElementById('toggleAvailabilityStarts').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includeAvailabilityStarts', this.checked);
        });
        
        console.log('‚úÖ Category filter and Generate button displayed');
      },
      error: function(error) {
        console.error('Error parsing CSV:', error);
        alert('Error parsing CSV file: ' + (error.message || 'Unknown error') + '\n\nPlease check that the file is a valid CSV.');
      }
    });
  });

  // Load reviews and mappings CSVs from file inputs (optional, for review enrichment)
  async function loadReviewData() {
    const debugLog = [];
    
    // Load reviews CSV from file input
    const reviewsFileInput = document.getElementById('reviewsCsvFile');
    if (reviewsFileInput && reviewsFileInput.files && reviewsFileInput.files[0]) {
      debugLog.push(`üìÑ Loading reviews CSV: ${reviewsFileInput.files[0].name}`);
      try {
        const file = reviewsFileInput.files[0];
        const text = await file.text();
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            reviewsData = results.data;
            debugLog.push(`‚úÖ Loaded ${reviewsData.length} reviews from CSV`);
            debugLog.push(`   Columns found: ${results.meta.fields ? results.meta.fields.join(', ') : 'unknown'}`);
            if (reviewsData.length > 0) {
              debugLog.push(`   Sample review keys: ${Object.keys(reviewsData[0]).join(', ')}`);
            }
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          },
          error: function(error) {
            debugLog.push(`‚ùå Error parsing reviews CSV: ${error.message}`);
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          }
        });
      } catch (e) {
        debugLog.push(`‚ùå Error reading reviews file: ${e.message}`);
        window.debugLog = window.debugLog || [];
        window.debugLog.push(...debugLog);
        updateDebugLog();
      }
    } else {
      debugLog.push('‚ö†Ô∏è No reviews CSV file uploaded (optional)');
      window.debugLog = window.debugLog || [];
      window.debugLog.push(...debugLog);
      updateDebugLog();
    }

    // Load mappings CSV from file input
    const mappingsFileInput = document.getElementById('mappingsCsvFile');
    if (mappingsFileInput && mappingsFileInput.files && mappingsFileInput.files[0]) {
      debugLog.push(`üìÑ Loading mappings CSV: ${mappingsFileInput.files[0].name}`);
      try {
        const file = mappingsFileInput.files[0];
        const text = await file.text();
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            mappingsData = results.data;
            debugLog.push(`‚úÖ Loaded ${mappingsData.length} mappings from CSV`);
            debugLog.push(`   Columns found: ${results.meta.fields ? results.meta.fields.join(', ') : 'unknown'}`);
            if (mappingsData.length > 0) {
              debugLog.push(`   Sample mapping keys: ${Object.keys(mappingsData[0]).join(', ')}`);
            }
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          },
          error: function(error) {
            debugLog.push(`‚ùå Error parsing mappings CSV: ${error.message}`);
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          }
        });
      } catch (e) {
        debugLog.push(`‚ùå Error reading mappings file: ${e.message}`);
        window.debugLog = window.debugLog || [];
        window.debugLog.push(...debugLog);
        updateDebugLog();
      }
    } else {
      debugLog.push('‚ö†Ô∏è No mappings CSV file uploaded (optional)');
      window.debugLog = window.debugLog || [];
      window.debugLog.push(...debugLog);
      updateDebugLog();
    }
  }
  
  // Add debug log entry
  function addDebugLog(message) {
    window.debugLog = window.debugLog || [];
    window.debugLog.push(message);
    updateDebugLog();
  }
  
  // Copy debug log to clipboard
  function copyDebugLog(btnElement) {
    const debugLogElement = document.getElementById('debugLog');
    if (!debugLogElement || !window.debugLog || window.debugLog.length === 0) {
      alert('No debug log available to copy.');
      return;
    }
    
    const logText = window.debugLog.join('\n');
    
    // Try modern clipboard API first
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(logText).then(() => {
        if (btnElement) {
          const originalText = btnElement.textContent;
          btnElement.textContent = '‚úÖ Copied!';
          btnElement.style.background = '#48bb78';
          setTimeout(() => {
            btnElement.textContent = originalText;
            btnElement.style.background = '#667eea';
          }, 2000);
        }
      }).catch(err => {
        console.error('Failed to copy debug log:', err);
        // Fallback to textarea method
        fallbackCopyToClipboard(logText, btnElement);
      });
    } else {
      // Fallback for browsers without clipboard API
      fallbackCopyToClipboard(logText, btnElement);
    }
  }
  
  // Fallback copy method using textarea
  function fallbackCopyToClipboard(text, btnElement) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      const successful = document.execCommand('copy');
      if (successful) {
        if (btnElement) {
          const originalText = btnElement.textContent;
          btnElement.textContent = '‚úÖ Copied!';
          btnElement.style.background = '#48bb78';
          setTimeout(() => {
            btnElement.textContent = originalText;
            btnElement.style.background = '#667eea';
          }, 2000);
        }
      } else {
        throw new Error('execCommand failed');
      }
    } catch (err) {
      console.error('Fallback copy failed:', err);
      alert('Failed to copy debug log. Please select the debug log text and copy manually (Ctrl+C).');
    } finally {
      document.body.removeChild(textArea);
    }
  }
  
  // Show field verification modal
  function showFieldVerificationModal() {
    if (!window.fieldVerificationStats) {
      alert('Field verification data not available. Please generate schema first.');
      return;
    }
    
    const modal = document.getElementById('fieldVerificationModal');
    if (modal) {
      modal.style.display = 'block';
      updateFieldVerificationModal();
    }
  }
  
  // Close field verification modal
  function closeFieldVerificationModal() {
    const modal = document.getElementById('fieldVerificationModal');
    if (modal) {
      modal.style.display = 'none';
      // Ensure copy buttons are visible after modal closes
      const copyButton = document.getElementById('copySchemaButton');
      const copyButtonTop = document.getElementById('copySchemaButtonTop');
      if (copyButton) {
        copyButton.style.display = 'inline-block';
        copyButton.style.visibility = 'visible';
        copyButton.style.opacity = '1';
      }
      if (copyButtonTop) {
        copyButtonTop.style.display = 'inline-block';
        copyButtonTop.style.visibility = 'visible';
        copyButtonTop.style.opacity = '1';
      }
    }
  }
  
  // Update field verification modal content
  function updateFieldVerificationModal() {
    const content = document.getElementById('fieldVerificationModalContent');
    if (!content || !window.fieldVerificationStats) return;
    
    const stats = window.fieldVerificationStats;
    let html = '<div style="max-height: 70vh; overflow-y: auto;">';
    
    // Event Core Fields
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #667eea;">';
    html += '<h3 style="margin-top: 0; color: #667eea;">üß© Event Core Fields</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>@context</td><td style="text-align: center;">${stats.coreFields?.context || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>@type</td><td style="text-align: center;">${stats.coreFields?.type || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>name</td><td style="text-align: center;">${stats.coreFields?.name || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>startDate</td><td style="text-align: center;">${stats.coreFields?.startDate || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>endDate</td><td style="text-align: center;">${stats.coreFields?.endDate || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>duration</td><td style="text-align: center;">${stats.coreFields?.duration || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>identifier</td><td style="text-align: center;">${stats.coreFields?.identifier || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += '</table></div>';
    
    // Location/Address Fields
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #38b2ac;">';
    html += '<h3 style="margin-top: 0; color: #38b2ac;">üèõ Location / Address Fields</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>location.@type</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>location.name</td><td style="text-align: center;">${stats.locationFields?.name || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.streetAddress</td><td style="text-align: center;">${stats.locationFields?.streetAddress || '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.locationFields?.streetAddressCount || 0} / ${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.addressLocality</td><td style="text-align: center;">${stats.locationFields?.locality || '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.locationFields?.localityCount || 0} / ${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.addressRegion</td><td style="text-align: center;">${stats.locationFields?.region || '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.locationFields?.regionCount || 0} / ${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.postalCode</td><td style="text-align: center;">${stats.locationFields?.postalCode || '‚úÖ'}</td><td style="text-align: right;">${stats.locationFields?.postalCodeCount || stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.addressCountry</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += '</table></div>';
    
    // Offers & Merchant Fields
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #ed8936;">';
    html += '<h3 style="margin-top: 0; color: #ed8936;">üí∞ Offers & Merchant Fields</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>offers.@type</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.price</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.priceCurrency</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.seller.name</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.hasMerchantReturnPolicy</td><td style="text-align: center;">${stats.merchantFields ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.merchantFields ? stats.offersBlocks : 0}</td></tr>`;
    html += `<tr><td>sku</td><td style="text-align: center;">${stats.merchantFields ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.merchantFields ? stats.eventsWithMappings : 0}</td></tr>`;
    html += `<tr><td>brand</td><td style="text-align: center;">${stats.merchantFields ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.merchantFields ? stats.eventsWithMappings : 0}</td></tr>`;
    html += '</table></div>';
    
    // Reviews & Ratings
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #48bb78;">';
    html += '<h3 style="margin-top: 0; color: #48bb78;">‚≠ê Reviews & Ratings</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>aggregateRating.@type</td><td style="text-align: center;">${stats.aggregateRatingsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.aggregateRatingsAdded || 0}</td></tr>`;
    html += `<tr><td>aggregateRating.ratingValue</td><td style="text-align: center;">${stats.aggregateRatingsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.aggregateRatingsAdded || 0}</td></tr>`;
    html += `<tr><td>aggregateRating.reviewCount</td><td style="text-align: center;">${stats.aggregateRatingsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.aggregateRatingsAdded || 0}</td></tr>`;
    html += `<tr><td>review array</td><td style="text-align: center;">${stats.reviewSnippetsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.reviewSnippetsAdded || 0}</td></tr>`;
    html += '</table></div>';
    
    // Organizer/Provider/Performer
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #9f7aea;">';
    html += '<h3 style="margin-top: 0; color: #9f7aea;">üë• Organizer / Provider / Performer</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>organizer.@type</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>organizer.name</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>organizer.logo</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>organizer.sameAs</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>performer</td><td style="text-align: center;">${stats.performerToggled ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.performerToggled ? stats.eventsGenerated : 0}</td></tr>`;
    html += `<tr><td>provider</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += '</table></div>';
    
    html += '</div>';
    content.innerHTML = html;
  }
  
  // Update debug log display
  function updateDebugLog() {
    const debugLogElement = document.getElementById('debugLog');
    const debugLogContainer = document.getElementById('debugLogContainer');
    if (debugLogElement && window.debugLog) {
      debugLogElement.textContent = window.debugLog.join('\n');
      if (debugLogContainer) {
        debugLogContainer.style.display = 'block';
      }
    }
  }
  
  // Update summary panel
  function updateSummaryPanel(summary) {
    const summaryPanel = document.getElementById('summaryPanel');
    const summaryContent = document.getElementById('summaryContent');
    if (summaryPanel && summaryContent) {
      summaryPanel.style.display = 'block';
      summaryContent.innerHTML = summary;
    }
  }
  
  // Build summary HTML
  function buildSummaryHTML(stats) {
    let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">';
    
    // CSV & Events Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #667eea;">';
    html += '<strong style="color: #667eea;">üìã CSV & Events</strong><br>';
    html += `CSV Type: ${stats.csvType || 'Unknown'}<br>`;
    html += `Total rows parsed: ${stats.totalRows || 0}<br>`;
    html += `Future events included: ${stats.futureEvents || 0}<br>`;
    html += `Events generated: ${stats.eventsGenerated || 0}<br>`;
    html += `Repeating groups: ${stats.repeatingGroups || 0}`;
    html += '</div>';
    
    // Reviews & Ratings Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #48bb78;">';
    html += '<strong style="color: #48bb78;">‚≠ê Reviews & Ratings</strong><br>';
    html += `Reviews loaded: ${stats.reviewsLoaded || 0}<br>`;
    html += `Products with reviews: ${stats.productsWithReviews || 0}<br>`;
    html += `Aggregate ratings added: ${stats.aggregateRatingsAdded || 0}<br>`;
    html += `Review snippets added: ${stats.reviewSnippetsAdded || 0}`;
    html += '</div>';
    
    // Offers & Merchant Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #ed8936;">';
    html += '<strong style="color: #ed8936;">üí∞ Offers & Merchant</strong><br>';
    html += `Offers blocks: ${stats.offersBlocks || 0}<br>`;
    html += `Performer toggled: ${stats.performerToggled ? 'ON' : 'OFF'}<br>`;
    html += `Merchant fields: ${stats.merchantFields ? 'ON' : 'OFF'}<br>`;
    html += `Merchant feed items: ${stats.merchantFeedItems || 0}`;
    html += '</div>';
    
    // Mappings Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #9f7aea;">';
    html += '<strong style="color: #9f7aea;">üîó Mappings</strong><br>';
    html += `Event mappings loaded: ${stats.mappingsLoaded || 0}<br>`;
    html += `Events with mappings: ${stats.eventsWithMappings || 0}<br>`;
    html += `Events with product URLs: ${stats.eventsWithProductUrls || 0}`;
    html += '</div>';
    
    // Structure Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #38b2ac;">';
    html += '<strong style="color: #38b2ac;">üß≠ Structure</strong><br>';
    html += `Breadcrumb chains: ${stats.breadcrumbChains || 0}<br>`;
    html += `ItemList items: ${stats.itemListItems || 0}<br>`;
    html += `EventSeries groups: ${stats.eventSeriesGroups || 0}`;
    if (stats.eventSeriesCreated && stats.eventSeriesCreated > 0) {
      html += `<br>üîÅ EventSeries Created: ${stats.eventSeriesCreated}`;
    }
    html += '</div>';
    
    // Validation Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid ' + (stats.validationStatus === 'Valid' ? '#48bb78' : stats.validationStatus === 'Warnings' ? '#ed8936' : '#f56565') + ';">';
    html += '<strong style="color: ' + (stats.validationStatus === 'Valid' ? '#48bb78' : stats.validationStatus === 'Warnings' ? '#ed8936' : '#f56565') + ';">‚úÖ Validation</strong><br>';
    html += `Status: ${stats.validationStatus || 'Unknown'}<br>`;
    html += `Errors: ${stats.validationErrors || 0}<br>`;
    html += `Warnings: ${stats.validationWarnings || 0}`;
    html += '</div>';
    
    html += '</div>';
    return html;
  }

  // Normalize URL for matching (lowercase, strip trailing /)
  function normalizeUrl(url) {
    if (!url) return '';
    return url.toLowerCase().replace(/\/$/, '');
  }
  
  // Match product URLs even when one has path prefix (e.g., /photography-services-near-me/)
  function matchProductUrl(mappingUrl, reviewUrl) {
    if (!mappingUrl || !reviewUrl) return false;
    
    const normMapping = normalizeUrl(mappingUrl);
    const normReview = normalizeUrl(reviewUrl);
    
    // Exact match
    if (normMapping === normReview) return true;
    
    // Extract final slug from both URLs
    const mappingSlug = normMapping.split('/').pop() || '';
    const reviewSlug = normReview.split('/').pop() || '';
    
    // Match if final slugs are the same
    if (mappingSlug && reviewSlug && mappingSlug === reviewSlug) return true;
    
    // Also check if one URL contains the other's slug
    if (mappingSlug && normReview.includes(mappingSlug)) return true;
    if (reviewSlug && normMapping.includes(reviewSlug)) return true;
    
    return false;
  }
  
  // Find review data for a product URL (handles path prefix differences)
  function findReviewData(productUrl, reviewsDict) {
    if (!productUrl || !reviewsDict) return null;
    
    const normProductUrl = normalizeUrl(productUrl);
    
    // Try exact match first
    if (reviewsDict[normProductUrl]) {
      return reviewsDict[normProductUrl];
    }
    
    // Try matching by slug (handles /photography-services-near-me/ prefix differences)
    const productSlug = normProductUrl.split('/').pop() || '';
    if (productSlug) {
      for (const reviewUrl in reviewsDict) {
        if (matchProductUrl(productUrl, reviewUrl)) {
          return reviewsDict[reviewUrl];
        }
      }
    }
    
    return null;
  }

  // Build reviews dictionary: { product_url: { ratingValue, reviewCount } }
  function buildReviewsDict() {
    addDebugLog('üîç Building reviews dictionary...');
    if (!reviewsData) {
      addDebugLog('‚ö†Ô∏è No reviews data available');
      return {};
    }
    addDebugLog(`üìä Processing ${reviewsData.length} reviews...`);
    
    const dict = {};
    const productReviews = {};
    
    reviewsData.forEach((review, idx) => {
      // Try multiple ways to get product URL
      let productUrl = normalizeUrl(review.product_url || review.url || '');
      
      // If no product_url, try to construct from product_slug + domain_url
      if (!productUrl && review.product_slug) {
        const domain = review.domain_url || 'https://www.alanranger.com';
        // Remove trailing slash from domain and leading slash from slug
        const cleanDomain = domain.replace(/\/$/, '');
        const cleanSlug = review.product_slug.replace(/^\//, '');
        productUrl = normalizeUrl(`${cleanDomain}/${cleanSlug}`);
        
        if (idx < 3) {
          addDebugLog(`   Review ${idx + 1}: Constructed URL from slug: ${productUrl}`);
        }
      }
      
      if (!productUrl) {
        if (idx < 3) {
          addDebugLog(`   Review ${idx + 1}: No product_url or product_slug found (keys: ${Object.keys(review).join(', ')})`);
        }
        return;
      }
      
      if (!productReviews[productUrl]) {
        productReviews[productUrl] = [];
      }
      productReviews[productUrl].push(review);
    });
    
    addDebugLog(`üì¶ Found ${Object.keys(productReviews).length} unique product URLs`);
    
    // Aggregate reviews per product
    Object.keys(productReviews).forEach((productUrl, idx) => {
      const reviews = productReviews[productUrl];
      const validReviews = reviews.filter(r => {
        // Try multiple rating fields (note: CSV has ratingValue with capital V)
        const rating = parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 0);
        return rating >= 4 && rating <= 5;
      });
      
      if (idx < 3) {
        addDebugLog(`   Product ${idx + 1}: ${productUrl} - ${reviews.length} total reviews, ${validReviews.length} valid (‚â•4‚òÖ)`);
      }
      
      if (validReviews.length >= 3) {
        const totalRating = validReviews.reduce((sum, r) => {
          return sum + parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 0);
        }, 0);
        const avgRating = totalRating / validReviews.length;
        const reviewCount = Math.min(validReviews.length, 999);
        
        dict[productUrl] = {
          ratingValue: Math.round(avgRating * 10) / 10,
          reviewCount: reviewCount
        };
      }
    });
    
    addDebugLog(`‚úÖ Reviews dictionary built: ${Object.keys(dict).length} products with valid reviews`);
    
    // Show sample product URLs that have reviews
    const sampleProducts = Object.keys(dict).slice(0, 3);
    if (sampleProducts.length > 0) {
      addDebugLog(`   Sample products with reviews:`);
      sampleProducts.forEach(url => {
        const data = dict[url];
        addDebugLog(`     ${url} ‚Üí Rating: ${data.ratingValue}, Count: ${data.reviewCount}`);
      });
    }
    
    return dict;
  }

  // Build mappings dictionary: { event_url: { product_url, sku, brand, price, availability } }
  function buildMappingsDict() {
    addDebugLog('üîç Building mappings dictionary...');
    if (!mappingsData) {
      addDebugLog('‚ö†Ô∏è No mappings data available');
      return {};
    }
    addDebugLog(`üìä Processing ${mappingsData.length} mappings...`);
    
    const dict = {};
    let successCount = 0;
    let failCount = 0;
    
    mappingsData.forEach((mapping, idx) => {
      const eventUrl = normalizeUrl(mapping.event_url || '');
      const productUrl = normalizeUrl(mapping.product_url || '');
      
      if (idx < 3) {
        addDebugLog(`   Mapping ${idx + 1}: event_url="${eventUrl}", product_url="${productUrl}"`);
      }
      
      if (eventUrl && productUrl) {
        // Extract SKU from product URL slug
        const urlParts = productUrl.split('/');
        const productSlug = urlParts[urlParts.length - 1] || '';
        const sku = productSlug.toUpperCase().replace(/-/g, '-').replace(/[^A-Z0-9-]/g, '');
        
        dict[eventUrl] = {
          product_url: productUrl,
          sku: sku || null,
          brand: {
            "@type": "Brand",
            "name": "Alan Ranger Photography"
          },
          price: mapping.price_gbp || mapping.json_price || null,
          availability: mapping.availability || mapping.json_availability || "https://schema.org/InStock",
          product_title: mapping.product_title || null
        };
        successCount++;
      } else {
        failCount++;
        if (idx < 3) {
          addDebugLog(`   ‚ö†Ô∏è Mapping ${idx + 1} skipped: missing event_url or product_url`);
        }
      }
    });
    
    addDebugLog(`‚úÖ Mappings dictionary built: ${successCount} successful, ${failCount} skipped`);
    return dict;
  }

  // Parse location with intelligent region inference and geo coordinates (v4.1)
  function parseLocation(locationAddress = '', locationName = '', eventTitle = '') {
    const result = {
      streetAddress: '',
      addressLocality: '',
      addressRegion: '',
      postalCode: '',
      addressCountry: 'GB',
      geo: null,
      regionMatched: false
    };

    const regionMap = {
      "Wales": { region: "Wales", lat: 52.1307, lon: -3.7837 },
      "Scotland": { region: "Scotland", lat: 56.4907, lon: -4.2026 },
      "Cumbria": { region: "North West England", lat: 54.5772, lon: -2.7975 },
      "Yorkshire": { region: "Yorkshire and the Humber", lat: 53.9586, lon: -1.0803 },
      "Norfolk": { region: "East of England", lat: 52.6309, lon: 1.2974 },
      "Devon": { region: "South West England", lat: 50.7156, lon: -3.5309 },
      "Dorset": { region: "South West England", lat: 50.7090, lon: -2.0846 },
      "Warwickshire": { region: "West Midlands", lat: 52.2819, lon: -1.5845 },
      "Coventry": { region: "West Midlands", lat: 52.4068, lon: -1.5197 },
      "Peak District": { region: "East Midlands", lat: 53.3430, lon: -1.7770 },
      "Anglesey": { region: "Wales", lat: 53.2559, lon: -4.3424 },
      "Lake District": { region: "North West England", lat: 54.4609, lon: -3.0886 },
      "Gloucestershire": { region: "South West England", lat: 51.8642, lon: -2.2382 },
      "Northumberland": { region: "North East England", lat: 55.2088, lon: -2.0783 },
      "Somerset": { region: "South West England", lat: 51.1051, lon: -2.9262 },
      "Exmoor": { region: "South West England", lat: 51.1314, lon: -3.6897 },
      "Suffolk": { region: "East of England", lat: 52.1872, lon: 0.9708 },
      "Dartmoor": { region: "South West England", lat: 50.5610, lon: -3.9336 },
      "Snowdonia": { region: "Wales", lat: 52.8311, lon: -4.0840 },
      "Gower": { region: "Wales", lat: 51.5694, lon: -4.1289 },
      "Kerry": { region: "Ireland", lat: 52.1609, lon: -9.5250 },
      "Shropshire": { region: "West Midlands", lat: 52.7073, lon: -2.7553 },
      "Worcestershire": { region: "West Midlands", lat: 52.1920, lon: -2.2237 }
    };

    // Parse address parts
    const parts = locationAddress.split(',').map(p => p.trim()).filter(Boolean);
    for (const p of parts) {
      // Match UK postcode pattern
      if (/\b[A-Z]{1,2}\d{1,2}\s?\d[A-Z]{2}\b/i.test(p)) {
        result.postalCode = p.toUpperCase().replace(/\s+/g, ' ');
      } else if (!result.streetAddress && p) {
        result.streetAddress = p;
      } else if (!result.addressLocality && p && p !== result.streetAddress) {
        result.addressLocality = p;
      }
    }

    // Try to infer region and geo from keywords
    for (const [key, val] of Object.entries(regionMap)) {
      const searchText = `${locationAddress} ${locationName} ${eventTitle}`.toLowerCase();
      if (searchText.includes(key.toLowerCase())) {
        result.addressRegion = val.region;
        result.geo = {
          "@type": "GeoCoordinates",
          "latitude": val.lat,
          "longitude": val.lon
        };
        result.regionMatched = true;
        break;
      }
    }

    // Fallback: use location name or default
    if (!result.addressLocality && locationName) {
      result.addressLocality = locationName.split(' ')[0];
    }
    if (!result.addressRegion) {
      result.addressRegion = "West Midlands"; // Default fallback
    }

    return result;
  }

  // Enhanced address parsing - v4 Smart Enriched
  function parseAddress(locationAddressRaw, locationCityStateZip) {
    const address = { "@type": "PostalAddress" };
    
    if (!locationAddressRaw && !locationCityStateZip) {
      address.addressCountry = "GB";
      return address;
    }

    // Don't combine fields - Location_Address already has everything, Location_City_State_ZIP is just postcode
    let fullAddress = locationAddressRaw || '';
    
    // If Location_City_State_ZIP exists and doesn't duplicate postcode, append it
    if (locationCityStateZip && !fullAddress.includes(locationCityStateZip)) {
      fullAddress = fullAddress ? `${fullAddress}, ${locationCityStateZip}` : locationCityStateZip;
    }
    
    // Clean up the address string
    fullAddress = fullAddress.replace(/\s+/g, ' ').trim();
    
    // Split by comma and process
    const parts = fullAddress.split(",").map(p => p.trim()).filter(Boolean);
    
    // UK postcode pattern
    const ukPostcodePattern = /^[A-Z]{1,2}\d[A-Z\d]?\s*\d[A-Z]{2}$/i;
    
    // UK county/region patterns
    const ukRegions = ['West Midlands', 'Warwickshire', 'Worcestershire', 'Gloucestershire', 'Herefordshire', 'Shropshire', 'Staffordshire', 'Derbyshire', 'Nottinghamshire', 'Leicestershire', 'Northamptonshire', 'Oxfordshire', 'Buckinghamshire', 'Berkshire', 'Hampshire', 'Surrey', 'Kent', 'Essex', 'Suffolk', 'Norfolk', 'Cambridgeshire', 'Lincolnshire', 'Yorkshire', 'Lancashire', 'Cheshire', 'Cumbria', 'Northumberland', 'Durham', 'North Yorkshire', 'South Yorkshire', 'West Yorkshire', 'East Yorkshire'];
    
    // Process parts from end to beginning (postcode, region, city, street)
    for (let i = parts.length - 1; i >= 0; i--) {
      const part = parts[i];
      const partUpper = part.toUpperCase();

      // Country (skip "England" - it's not a region)
      if (!address.addressCountry && /^(United Kingdom|UK|Scotland|Wales|Northern Ireland)$/i.test(part)) {
        address.addressCountry = "GB";
      }
      // Postal code
      else if (!address.postalCode && ukPostcodePattern.test(part)) {
        address.postalCode = part.toUpperCase().replace(/\s+/g, ' ');
      }
      // Region/County (check against known UK regions, skip "England")
      else if (!address.addressRegion && !/^(United Kingdom|UK|England)$/i.test(part)) {
        const matchedRegion = ukRegions.find(r => partUpper.includes(r.toUpperCase()) || partUpper === r.toUpperCase());
        if (matchedRegion) {
          address.addressRegion = matchedRegion;
        }
      }
    }
    
    // Now process from beginning to end for street and locality
    // UK addresses typically: street, city, county/region, postcode, country
    const streetParts = [];
    let localityFound = false;
    
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const partUpper = part.toUpperCase();
      
      // Skip if already processed (postcode, country, region)
      if (ukPostcodePattern.test(part)) continue;
      if (/^(United Kingdom|UK|England|Scotland|Wales|Northern Ireland)$/i.test(part)) continue;
      if (address.addressRegion && (partUpper.includes(address.addressRegion.toUpperCase()) || partUpper === address.addressRegion.toUpperCase())) continue;
      
      // Check if it's a known UK region (should have been caught in first loop, but double-check)
      const isRegion = ukRegions.some(r => partUpper.includes(r.toUpperCase()));
      if (isRegion) continue;
      
      // First part(s) are street address, then comes locality (city)
      if (!localityFound && part.length > 2) {
        // If we already have street parts, this is likely the locality
        if (streetParts.length > 0) {
          address.addressLocality = part;
          localityFound = true;
        } else {
          // First part is street address
          streetParts.push(part);
        }
      } else if (!localityFound) {
        // Still collecting street address parts
        streetParts.push(part);
      }
    }
    
    // Assign street address (combine all street parts)
    if (streetParts.length > 0) {
      address.streetAddress = streetParts.join(', ');
    }
    
    // Default country if not found
    if (!address.addressCountry) {
      address.addressCountry = "GB";
    }
    
    // Only return fields that have values (omit empty fields)
    const cleanAddress = {};
    if (address["@type"]) cleanAddress["@type"] = address["@type"];
    if (address.streetAddress) cleanAddress.streetAddress = address.streetAddress;
    if (address.addressLocality) cleanAddress.addressLocality = address.addressLocality;
    if (address.addressRegion) cleanAddress.addressRegion = address.addressRegion;
    if (address.postalCode) cleanAddress.postalCode = address.postalCode;
    if (address.addressCountry) cleanAddress.addressCountry = address.addressCountry;
    
    return cleanAddress;
  }

  // Combine date and time into ISO 8601 format
  function combineDateTime(dateStr, timeStr) {
    if (!dateStr) return null;
    if (!timeStr) return dateStr; // Return date only if no time
    
    // Normalize time format (handle HH:MM:SS or HH:MM)
    const timeMatch = timeStr.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?/);
    if (!timeMatch) return dateStr;
    
    const hours = timeMatch[1].padStart(2, '0');
    const minutes = timeMatch[2].padStart(2, '0');
    const seconds = timeMatch[3] ? timeMatch[3].padStart(2, '0') : '00';
    
    return `${dateStr}T${hours}:${minutes}:${seconds}`;
  }

  // Compute duration in ISO 8601 format (PT120M default)
  function computeDuration(startDate, endDate, startTime, endTime) {
    if (!startDate || !endDate) return "PT120M";
    
    try {
      const start = combineDateTime(startDate, startTime);
      const end = combineDateTime(endDate, endTime);
      
      if (!start || !end) return "PT120M";
      
      const startDateObj = new Date(start);
      const endDateObj = new Date(end);
      const diffMs = endDateObj - startDateObj;
      
      if (diffMs <= 0) return "PT120M";
      
      const diffMins = Math.round(diffMs / (1000 * 60));
      return `PT${diffMins}M`;
    } catch (e) {
      return "PT120M";
    }
  }

  // Detect if location is virtual (Zoom/Online)
  function isVirtualLocation(locationName, locationAddress) {
    const virtualKeywords = ['zoom', 'online', 'virtual', 'webinar'];
    const locationStr = (locationName || '').toLowerCase() + ' ' + (locationAddress || '').toLowerCase();
    return virtualKeywords.some(keyword => locationStr.includes(keyword));
  }

  // Detect audience type from keywords
  function detectAudience(eventTitle, description, tags) {
    const text = ((eventTitle || '') + ' ' + (description || '') + ' ' + (tags || '')).toLowerCase();
    
    if (text.includes('beginner') || text.includes('beginners')) {
      return {
        "@type": "EducationalAudience",
        "educationalRole": "student",
        "audienceType": "Beginner"
      };
    }
    if (text.includes('advanced') || text.includes('professional')) {
      return {
        "@type": "EducationalAudience",
        "educationalRole": "student",
        "audienceType": "Advanced"
      };
    }
    if (text.includes('intermediate')) {
      return {
        "@type": "EducationalAudience",
        "educationalRole": "student",
        "audienceType": "Intermediate"
      };
    }
    return null;
  }

  // Extract keywords from Tags
  function extractKeywords(tags) {
    if (!tags) return [];
    return tags.split(/[,;|]/).map(t => t.trim()).filter(Boolean);
  }

  // Trim description if too long
  function trimDescription(description, maxLength = 5000) {
    if (!description) return '';
    if (description.length <= maxLength) return description;
    return description.substring(0, maxLength - 3) + '...';
  }

  // Validate Event schema structure
  function validateEventSchema(schema) {
    const errors = [];
    const warnings = [];
    
    if (!schema || !schema['@graph']) {
      return { isValid: false, message: 'Invalid schema structure: missing @graph', errors: ['Missing @graph'] };
    }
    
    const graph = schema['@graph'] || [];
    const events = graph.filter(item => item['@type'] === 'Event');
    
    if (events.length === 0) {
      return { isValid: false, message: 'No Event schemas found', errors: ['No events in @graph'] };
    }
    
    events.forEach((event, idx) => {
      // Required fields for Event schema
      const required = ['name', 'startDate', 'eventStatus', 'eventAttendanceMode'];
      required.forEach(field => {
        if (!event[field]) {
          errors.push(`Event ${idx + 1}: Missing required field "${field}"`);
        }
      });
      
      // Validate dates
      if (event.startDate && !/^\d{4}-\d{2}-\d{2}/.test(event.startDate)) {
        warnings.push(`Event ${idx + 1}: startDate format may be invalid`);
      }
      
      // Validate offers
      if (event.offers) {
        if (!event.offers.price || !event.offers.priceCurrency) {
          warnings.push(`Event ${idx + 1}: Offers missing price or priceCurrency`);
        }
      }
      
      // Validate location
      if (!event.location) {
        warnings.push(`Event ${idx + 1}: Missing location`);
      }
    });
    
    const isValid = errors.length === 0;
    const message = isValid 
      ? `Schema.org compliant (${events.length} event${events.length !== 1 ? 's' : ''})`
      : `${errors.length} error${errors.length !== 1 ? 's' : ''} found`;
    
    return { isValid, message, errors, warnings };
  }

  async function generateEventSchema() {
    try {
      // Initialize debug log and statistics
      window.debugLog = [];
      const stats = {
        csvType: 'Unknown',
        totalRows: 0,
        futureEvents: 0,
        eventsGenerated: 0,
        repeatingGroups: 0,
        reviewsLoaded: 0,
        productsWithReviews: 0,
        aggregateRatingsAdded: 0,
        reviewSnippetsAdded: 0,
        offersBlocks: 0,
        performerToggled: false,
        merchantFields: false,
        merchantFeedItems: 0,
        mappingsLoaded: 0,
        eventsWithMappings: 0,
        eventsWithProductUrls: 0,
        breadcrumbChains: 0,
        itemListItems: 0,
        eventSeriesGroups: 0,
        validationStatus: 'Unknown',
        validationErrors: 0,
        validationWarnings: 0
      };
      
      addDebugLog('üöÄ Starting event schema generation...');
      addDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      
      // Check if events are loaded
      if (!events || events.length === 0) {
        addDebugLog('‚ùå No events loaded');
        alert('Please upload a CSV file first.');
        return;
      }
      
      stats.totalRows = events.length;
      addDebugLog(`üìã CSV & Events Section:`);
      addDebugLog(`   ‚úÖ Total rows parsed: ${stats.totalRows}`);
      
      // Detect CSV type
      const eventFileInput = document.getElementById('eventCsvFile');
      if (eventFileInput && eventFileInput.files && eventFileInput.files[0]) {
        const csvType = detectCsvType(eventFileInput.files[0].name, []);
        stats.csvType = csvType;
        addDebugLog(`   ‚úÖ CSV Type detected: ${csvType}`);
      }
      
      // Load review data if available
      await loadReviewData();
      
      // Get toggle options
      const includeReviews = document.getElementById('includeReviews')?.checked !== false;
      const includePerformer = document.getElementById('includePerformer')?.checked !== false;
      const groupRepeatingEvents = document.getElementById('groupRepeatingEvents')?.checked === true;
      const includeMerchantFields = document.getElementById('includeMerchantFields')?.checked === true;
      const enrichLocations = document.getElementById('toggleLocationEnrichment')?.checked !== false;
      const includeAvailabilityStarts = document.getElementById('toggleAvailabilityStarts')?.checked === true;
      
      stats.performerToggled = includePerformer;
      stats.merchantFields = includeMerchantFields;
      stats.enrichLocations = enrichLocations;
      
      addDebugLog(`‚öôÔ∏è Toggle states: Reviews=${includeReviews}, Performer=${includePerformer}, GroupRepeating=${groupRepeatingEvents}, MerchantFields=${includeMerchantFields}, EnrichLocations=${enrichLocations}, AvailabilityStarts=${includeAvailabilityStarts}`);
      
      const selectedCategory = document.getElementById('eventCategoryFilter').value;
      const today = new Date().toISOString().split('T')[0];
      const filtered = events.filter(e =>
        (selectedCategory === "__ALL__" || (e['Category'] || e['category'] || e['CATEGORY'] || '').split(',')[0].trim() === selectedCategory) &&
        e['Start_Date'] >= today &&
        e['Workflow_State'] === 'Published'
      );
      
      stats.futureEvents = filtered.length;
      addDebugLog(`   ‚úÖ Future events included: ${stats.futureEvents} (filtered from ${stats.totalRows} total)`);
      
      if (filtered.length === 0) {
        addDebugLog('‚ùå No events match criteria');
        alert('No events found matching the selected category and date criteria.');
        return;
      }

    // Build dictionaries for review enrichment
    addDebugLog('\n‚≠ê Reviews & Ratings Section:');
    const reviewsDict = buildReviewsDict();
    const mappingsDict = buildMappingsDict();
    
    stats.reviewsLoaded = reviewsData ? reviewsData.length : 0;
    stats.productsWithReviews = Object.keys(reviewsDict).length;
    stats.mappingsLoaded = mappingsData ? mappingsData.length : 0;
    
    addDebugLog(`   ‚úÖ Reviews loaded: ${stats.reviewsLoaded}`);
    addDebugLog(`   ‚úÖ Products with reviews: ${stats.productsWithReviews}`);
    addDebugLog(`   ‚úÖ Event mappings loaded: ${stats.mappingsLoaded}`);
    
    // Show sample mappings
    const sampleMappings = Object.keys(mappingsDict).slice(0, 3);
    if (sampleMappings.length > 0) {
      addDebugLog(`   Sample mappings:`);
      sampleMappings.forEach(eventUrl => {
        const mapping = mappingsDict[eventUrl];
        addDebugLog(`     ${eventUrl} ‚Üí ${mapping.product_url}`);
      });
    }

    const itemList = {
      "@type": "ItemList",
      "name": selectedCategory === "__ALL__" ? "Events" : selectedCategory + " Events",
      "itemListElement": filtered.map((event, i) => ({
        "@type": "ListItem",
        "position": i + 1,
        "url": event['Event_URL']
      }))
    };

    // Enhanced organizer block with full address and sameAs
    const organizerAddress = parseAddress("45 Hathaway Road", "Coventry, West Midlands, CV4 9HW");
    const organizerBlock = {
      "@type": "Organization",
      "name": "Alan Ranger Photography",
      "url": "https://www.alanranger.com",
      "logo": "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w",
      "address": organizerAddress,
      "sameAs": [
        "https://www.instagram.com/alanrangerphoto",
        "https://www.facebook.com/alanrangerphotography",
        "https://www.linkedin.com/in/alanranger"
      ]
    };

    const eventSchemas = filtered.map((event, index) => {
      const eventUrl = normalizeUrl(event['Event_URL'] || '');
      const mappingData = mappingsDict[eventUrl];
      const productUrl = mappingData ? mappingData.product_url : null;
      const reviewData = productUrl ? findReviewData(productUrl, reviewsDict) : null;
      
      // Track statistics
      if (mappingData) stats.eventsWithMappings++;
      if (productUrl) stats.eventsWithProductUrls++;
      
      // Debug logging for first 3 events
      if (index < 3) {
        addDebugLog(`\nüìÖ Event ${index + 1}: ${event['Event_Title']}`);
        addDebugLog(`   Event URL: ${eventUrl}`);
        addDebugLog(`   Mapping found: ${mappingData ? 'YES' : 'NO'}`);
        if (mappingData) {
          addDebugLog(`   Product URL: ${productUrl}`);
          addDebugLog(`   Mapping Price: ${mappingData.price || 'none'}`);
          addDebugLog(`   CSV Price: ${event['Price'] || 'none'}`);
          addDebugLog(`   Mapping Availability: ${mappingData.availability || 'none'}`);
        }
        addDebugLog(`   Review data found: ${reviewData ? 'YES' : 'NO'}`);
        if (reviewData) {
          addDebugLog(`   Rating: ${reviewData.ratingValue}, Count: ${reviewData.reviewCount}`);
        } else if (productUrl) {
          addDebugLog(`   ‚ö†Ô∏è Product URL exists but no reviews found in reviews dict`);
          // Try to find matching review URL
          const productSlug = normalizeUrl(productUrl).split('/').pop();
          const matchingReviewUrls = Object.keys(reviewsDict).filter(url => {
            const reviewSlug = normalizeUrl(url).split('/').pop();
            return reviewSlug === productSlug;
          });
          if (matchingReviewUrls.length > 0) {
            addDebugLog(`   üí° Found ${matchingReviewUrls.length} review URL(s) with matching slug: ${matchingReviewUrls[0]}`);
          }
        } else {
          addDebugLog(`   ‚ö†Ô∏è No product URL (no mapping found)`);
        }
      }
      
      // üß© Event Core Fields Verification
      const startDate = combineDateTime(event['Start_Date'], event['Start_Time']);
      const endDate = combineDateTime(event['End_Date'], event['End_Time']);
      const duration = computeDuration(event['Start_Date'], event['End_Date'], event['Start_Time'], event['End_Time']);
      
      if (index < 3) {
        addDebugLog(`\n   üß© Event Core Fields:`);
        addDebugLog(`      ‚úÖ @context: https://schema.org`);
        addDebugLog(`      ‚úÖ @type: Event`);
        addDebugLog(`      ‚úÖ name: ${event['Event_Title'] ? 'Present' : 'MISSING'}`);
        addDebugLog(`      ‚úÖ startDate: ${startDate ? startDate.substring(0, 16) : 'MISSING'}`);
        addDebugLog(`      ‚úÖ endDate: ${endDate ? endDate.substring(0, 16) : 'MISSING'}`);
        addDebugLog(`      ‚úÖ duration: ${duration || 'MISSING'}`);
        addDebugLog(`      ‚úÖ eventStatus: EventScheduled`);
        addDebugLog(`      ‚úÖ identifier: ${eventUrl.split('/').pop() || 'MISSING'}`);
      }
      
      const address = enrichLocations 
        ? parseLocation(event['Location_Address'], event['Location_Business_Name'], event['Event_Title'])
        : parseAddress(event['Location_Address'], event['Location_City_State_ZIP']);
      const isVirtual = isVirtualLocation(event['Location_Business_Name'], event['Location_Address']);
      
      // Track address field statistics
      if (!isVirtual && address) {
        if (!stats.locationStats) {
          stats.locationStats = {
            streetAddress: { valid: 0, total: 0 },
            addressLocality: { valid: 0, total: 0 },
            addressRegion: { valid: 0, total: 0 },
            postalCode: { valid: 0, total: 0 },
            geoCoordinates: { valid: 0, total: 0 },
            fallbackApplied: 0,
            regionMapMatches: 0
          };
        }
        stats.locationStats.total++;
        if (address.streetAddress) {
          stats.locationStats.streetAddress.valid++;
          stats.addressFieldsWithStreetAddress = (stats.addressFieldsWithStreetAddress || 0) + 1;
        }
        if (address.addressLocality) {
          stats.locationStats.addressLocality.valid++;
          stats.addressFieldsWithLocality = (stats.addressFieldsWithLocality || 0) + 1;
        }
        if (address.addressRegion) {
          stats.locationStats.addressRegion.valid++;
          stats.addressFieldsWithRegion = (stats.addressFieldsWithRegion || 0) + 1;
          if (enrichLocations && address.regionMatched) {
            stats.locationStats.regionMapMatches++;
          }
        }
        if (address.postalCode) {
          stats.locationStats.postalCode.valid++;
          stats.addressFieldsWithPostalCode = (stats.addressFieldsWithPostalCode || 0) + 1;
        }
        if (enrichLocations && address.geo) {
          stats.locationStats.geoCoordinates.valid++;
        }
        if (!address.addressRegion || !address.addressLocality) {
          stats.locationStats.fallbackApplied++;
        }
      }
      
      // üèõ Location / Address Fields Verification
      if (index < 3) {
        addDebugLog(`\n   üèõ Location / Address Fields:`);
        addDebugLog(`      ‚úÖ location.@type: ${isVirtual ? 'VirtualLocation' : 'Place'}`);
        addDebugLog(`      ‚úÖ location.name: ${event['Location_Business_Name'] || 'MISSING'}`);
        if (!isVirtual && address) {
          addDebugLog(`      ‚úÖ address.streetAddress: ${address.streetAddress || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.addressLocality: ${address.addressLocality || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.addressRegion: ${address.addressRegion || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.postalCode: ${address.postalCode || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.addressCountry: ${address.addressCountry || 'MISSING'}`);
          // Debug: show what CSV fields contain (only for first 3 events)
          addDebugLog(`      üìã CSV Location_Address: "${event['Location_Address'] || 'empty'}"`);
          addDebugLog(`      üìã CSV Location_City_State_ZIP: "${event['Location_City_State_ZIP'] || 'empty'}"`);
        } else if (isVirtual) {
          addDebugLog(`      ‚úÖ OnlineEventAttendanceMode override applied`);
        }
      }
      
      // üë• Organizer / Provider / Performer Verification
      if (index < 3) {
        addDebugLog(`\n   üë• Organizer / Provider / Performer:`);
        addDebugLog(`      ‚úÖ organizer.@type: Organization`);
        addDebugLog(`      ‚úÖ organizer.name: Alan Ranger Photography`);
        addDebugLog(`      ‚úÖ organizer.logo: ${organizerBlock.logo ? 'Present' : 'MISSING'}`);
        addDebugLog(`      ‚úÖ organizer.sameAs: ${organizerBlock.sameAs ? organizerBlock.sameAs.length + ' links' : 'MISSING'}`);
        addDebugLog(`      ‚úÖ performer: ${includePerformer ? 'ON (will be added)' : 'OFF'}`);
        const category = (event['Category'] || event['category'] || '').split(',')[0].trim();
        const titleLower = (event['Event_Title'] || '').toLowerCase();
        if (category.toLowerCase().includes('course') || category.toLowerCase().includes('lesson') || titleLower.includes('course')) {
          addDebugLog(`      ‚úÖ provider: Present (same as organizer)`);
        }
      }
      
      const audience = detectAudience(event['Event_Title'], event['Excerpt'], event['Tags']);
      const keywords = extractKeywords(event['Tags']);
      const description = trimDescription(event['Excerpt'] || event['Description'], 5000);
      const validFrom = event['Published_Date'] || event['Start_Date'];
      
      // Extract identifier (slug from URL)
      const urlParts = eventUrl.split('/');
      const identifier = urlParts[urlParts.length - 1] || '';
      
      // Build enhanced keywords array (combine tags, category, location, and topic words)
      const category = (event['Category'] || event['category'] || '').split(',')[0].trim();
      const locationName = event['Location_Business_Name'] || '';
      const titleLower = (event['Event_Title'] || '').toLowerCase();
      const topicKeywords = [];
      if (titleLower.includes('photography')) topicKeywords.push('photography course', 'photography workshop');
      if (titleLower.includes('lightroom')) topicKeywords.push('Lightroom', 'photo editing');
      if (titleLower.includes('beginner')) topicKeywords.push('beginner photography', 'photography for beginners');
      if (titleLower.includes('landscape')) topicKeywords.push('landscape photography');
      if (titleLower.includes('portrait')) topicKeywords.push('portrait photography');
      if (titleLower.includes('macro')) topicKeywords.push('macro photography');
      const allKeywords = [...keywords, ...topicKeywords, category, locationName].filter(Boolean);
      
      // Generate "about" field (short phrase summarizing topic)
      let about = '';
      if (titleLower.includes('beginner')) about = 'Photography fundamentals and camera basics';
      else if (titleLower.includes('lightroom')) about = 'Photo editing and post-processing';
      else if (titleLower.includes('landscape')) about = 'Landscape photography techniques';
      else if (titleLower.includes('portrait')) about = 'Portrait photography skills';
      else if (titleLower.includes('macro')) about = 'Macro and close-up photography';
      else about = 'Photography education and training';
      
      // Build location (virtual or physical)
      let location;
      if (isVirtual) {
        location = {
          "@type": "VirtualLocation",
          "url": event['Event_URL'] || "https://www.alanranger.com"
        };
      } else {
        // Build PostalAddress object
        const postalAddress = {
          "@type": "PostalAddress",
          "streetAddress": address.streetAddress || undefined,
          "addressLocality": address.addressLocality || undefined,
          "addressRegion": address.addressRegion || undefined,
          "postalCode": address.postalCode || undefined,
          "addressCountry": address.addressCountry || "GB"
        };
        // Remove undefined fields
        Object.keys(postalAddress).forEach(key => {
          if (postalAddress[key] === undefined) delete postalAddress[key];
        });
        
        location = {
          "@type": "Place",
          "name": event['Location_Business_Name'] || "Alan Ranger Photography",
          "address": postalAddress
        };
        
        // Add geo coordinates if available (v4.1)
        if (enrichLocations && address.geo) {
          location.geo = address.geo;
        }
      }

      // Phase 3: Extract product data from mappings
      const useMappingPrice = mappingData && mappingData.price;
      const useMappingAvailability = mappingData && mappingData.availability;
      const eventPrice = useMappingPrice ? parseFloat(mappingData.price) : parseFloat(event['Price'] || 0);
      
      // Normalize availability to Schema.org URL format
      let normalizedAvailability = "https://schema.org/InStock"; // Default
      if (useMappingAvailability && mappingData.availability) {
        const avail = String(mappingData.availability).trim();
        if (avail === 'https://schema.org/InStock' || avail === 'InStock' || avail.toLowerCase() === 'in stock') {
          normalizedAvailability = "https://schema.org/InStock";
        } else if (avail === 'https://schema.org/OutOfStock' || avail === 'OutOfStock' || avail.toLowerCase() === 'out of stock') {
          normalizedAvailability = "https://schema.org/OutOfStock";
        } else if (avail === 'https://schema.org/PreOrder' || avail === 'PreOrder' || avail.toLowerCase() === 'preorder') {
          normalizedAvailability = "https://schema.org/PreOrder";
        } else {
          // Default to InStock if unrecognized format
          normalizedAvailability = "https://schema.org/InStock";
          console.warn(`‚ö†Ô∏è Unrecognized availability format "${avail}" for ${event['Event_Title']}, defaulting to InStock`);
        }
      }
