<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unified Schema Generator - Events & Products</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      margin: 0;
    }
    .container {
      max-width: 95vw;
      width: 100%;
      margin: 0 auto;
      background: white;
      padding: 2.5rem;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.15);
      position: relative;
    }
    .version-badge {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      z-index: 10;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .version-badge .version {
      display: block;
      font-size: 1rem;
    }
    .version-badge .date {
      display: block;
      font-size: 0.75rem;
      opacity: 0.9;
      margin-top: 0.25rem;
    }
    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      color: #2d3748;
      padding-right: 150px;
      font-weight: 700;
    }
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      border-bottom: 2px solid #e2e8f0;
    }
    .tab {
      padding: 0.875rem 1.75rem;
      background: #f7fafc;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      border-radius: 8px 8px 0 0;
      transition: all 0.3s ease;
      color: #4a5568;
      border-bottom: 3px solid transparent;
    }
    .tab:hover {
      background: #edf2f7;
      color: #2d3748;
    }
    .tab.active {
      background: white;
      color: #667eea;
      border-bottom-color: #667eea;
      font-weight: 600;
    }
    .tab-content {
      display: none !important;
      padding: 20px;
      border-top: none;
    }
    .tab-content.active {
      display: block !important;
    }
    .tab-content h2 {
      color: #2d3748;
      font-size: 1.75rem;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }
    .tab-content h3 {
      color: #4a5568;
      font-size: 1.25rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    .tab-content p {
      color: #4a5568;
      line-height: 1.7;
      margin-bottom: 1rem;
    }
    .tab-content ul {
      color: #4a5568;
      line-height: 1.8;
      margin-bottom: 1.5rem;
      padding-left: 1.5rem;
    }
    .tab-content li {
      margin-bottom: 0.5rem;
    }
    .tab-content code {
      background: #f7fafc;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #667eea;
    }
    .instructions {
      background: linear-gradient(135deg, #f6f8fb 0%, #edeff2 100%);
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 1.5rem;
      line-height: 1.7;
      border-left: 4px solid #667eea;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      color: #4a5568;
    }
    .instructions h2 {
      color: #2d3748;
      font-size: 1.75rem;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }
    .instructions h3 {
      color: #4a5568;
      font-size: 1.25rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    .instructions p {
      color: #4a5568;
      margin-bottom: 1rem;
    }
    .instructions ul {
      color: #4a5568;
      margin-bottom: 1.5rem;
      padding-left: 1.5rem;
    }
    .instructions li {
      margin-bottom: 0.5rem;
    }
    .instructions strong {
      display: block;
      margin-bottom: 0.75rem;
      color: #2d3748;
      font-size: 1.1rem;
    }
    /* Ensure Tab Guide is hidden by default and only shows when active */
    #guideTab.tab-content {
      display: none !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
    }
    #guideTab.tab-content.active {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
    }
    #guideTab .instructions {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    .instructions pre {
      background: #ffffff;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.9rem;
      border: 1px solid #e2e8f0;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }
    input[type="file"], select {
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      width: 100%;
      max-width: 400px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      transition: all 0.2s;
      background: white;
    }
    input[type="file"]:hover, select:hover {
      border-color: #667eea;
    }
    input[type="file"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    button {
      margin-top: 1rem;
      padding: 0.875rem 1.75rem;
      font-size: 1rem;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
    }
    button:active {
      transform: translateY(0);
    }
    button.secondary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      box-shadow: 0 4px 12px rgba(245, 87, 108, 0.3);
      margin-left: 0.5rem;
    }
    button.secondary:hover {
      box-shadow: 0 6px 16px rgba(245, 87, 108, 0.4);
    }
    textarea {
      width: 100%;
      height: 400px;
      margin-top: 1rem;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      padding: 1.25rem;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      transition: all 0.2s;
      background: #fafbfc;
      line-height: 1.6;
    }
    textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      background: white;
    }
    pre {
      background: #fafbfc;
      padding: 1.25rem;
      overflow-x: auto;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.6;
    }
    #categoryFilterContainer {
      margin-top: 1rem;
    }
    .test-url-section {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 2px solid #e2e8f0;
    }
    .test-url-section input {
      width: 100%;
      max-width: 600px;
      padding: 0.75rem 1rem;
      margin-right: 0.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s;
    }
    .test-url-section input:hover {
      border-color: #667eea;
    }
    .test-url-section input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    .test-url-section .button-group {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .warning {
      color: #e53e3e;
      font-weight: 600;
    }
    label {
      display: block;
      margin-top: 1.5rem;
      font-weight: 600;
      color: #2d3748;
      font-size: 0.95rem;
    }
    h3 {
      color: #2d3748;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 0.5rem;
    }
    h4 {
      color: #4a5568;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1.5rem;
      background: white;
      border-radius: 8px;
      overflow: visible;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      table-layout: auto;
    }
    .results-table th {
      background: #f7fafc;
      padding: 1rem;
      text-align: left;
      font-weight: 600;
      color: #2d3748;
      border-bottom: 2px solid #e2e8f0;
      white-space: normal;
      line-height: 1.4;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .results-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #fff;
    }
    .filter-row th {
      background: #f9fafb;
      padding: 0.5rem;
    }
    .filter-input {
      width: 100%;
      padding: 0.375rem 0.5rem;
      font-size: 0.875rem;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      background: #fff;
    }
    .filter-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .sortable-header {
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    .sortable-header:hover {
      color: #667eea;
    }
    .sort-indicator {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-left: 0.25rem;
    }
    .sort-indicator.sorted-asc::after {
      content: ' ‚Üë';
      color: #667eea;
    }
    .sort-indicator.sorted-desc::after {
      content: ' ‚Üì';
      color: #667eea;
    }
    .scrollable-container {
      max-height: calc(100vh - 400px);
      min-height: 600px;
      overflow-y: auto;
    }
    .results-table th:nth-child(1) { min-width: 250px; } /* Page URL */
    .results-table th:nth-child(2) { min-width: 200px; } /* Schema Type */
    .results-table th:nth-child(3) { min-width: 80px; max-width: 100px; width: 100px; } /* Status - narrower */
    .results-table th:nth-child(4) { min-width: 220px; } /* Missing Fields - wider */
    .results-table th:nth-child(5) { min-width: 220px; } /* Warnings - wider */
    .results-table th:nth-child(6) { min-width: 220px; } /* Info - wider */
    .results-table th:nth-child(7) { min-width: 140px; max-width: 160px; } /* Rich Results Status (external) */
    .results-table th:nth-child(8) { min-width: 140px; max-width: 160px; } /* Schema.org Status (external) */
    .results-table th:nth-child(9) { min-width: 200px; } /* Notes */
    .results-table th:nth-child(10) { min-width: 280px; } /* Actions */
    
    th:nth-child(4), td:nth-child(4) { background: #fff8f8; }    /* Missing */
    th:nth-child(5), td:nth-child(5) { background: #fffaf2; }    /* Warnings */
    th:nth-child(6), td:nth-child(6) { background: #f4fff7; }    /* Info */
    
    .missing-entry { color: #c00; font-weight: 500; margin: 0.25rem 0; }
    .warning-entry { 
      color: #b47f00; 
      font-weight: 500; 
      margin: 0.125rem 0; 
      font-size: 0.75rem;
      line-height: 1.3;
      max-height: 3rem;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .warning-entry:hover {
      max-height: none;
      overflow: visible;
      -webkit-line-clamp: unset;
    }
    .info-entry { color: #006b3b; font-weight: 500; margin: 0.25rem 0; }
    .status-badge.no-schema {
      background: #e2e8f0;
      color: #4a5568;
    }
    .status-select {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      background: white;
      min-width: 120px;
    }
    .status-select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .notes-textarea {
      width: 100%;
      min-width: 180px;
      max-width: 220px;
      height: 3rem;
      min-height: 2.5rem;
      max-height: 4rem;
      padding: 0.375rem 0.5rem;
      font-size: 0.75rem;
      line-height: 1.3;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-family: inherit;
      resize: vertical;
      overflow-y: auto;
    }
    .notes-textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .save-btn {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      margin: 0.25rem 0;
      background: #48bb78;
      color: white;
    }
    .save-btn:hover {
      background: #38a169;
    }
    .save-btn:disabled {
      background: #a0aec0;
      cursor: not-allowed;
    }
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 1rem 1.5rem;
      background: #48bb78;
      color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10000;
      animation: slideIn 0.3s ease;
    }
    .toast.error {
      background: #e53e3e;
    }
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    .results-table td {
      padding: 0.75rem 1rem;
      vertical-align: top;
    }
    .results-table td:nth-child(1) { 
      white-space: normal; 
      word-break: break-all;
      min-width: 250px;
      max-width: 350px;
    } /* Page URL */
    .results-table td:nth-child(2) { 
      white-space: normal; 
      min-width: 200px;
      max-width: 300px;
    } /* Schema Type */
    .results-table td:nth-child(3) { 
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 80px;
      max-width: 100px;
      width: 100px;
    } /* Status */
    .results-table td:nth-child(3) .status-explanation {
      display: none; /* Hide explanation text to prevent column expansion */
    }
    .results-table td:nth-child(4) { 
      white-space: normal; 
      min-width: 180px;
      max-width: 250px;
    } /* Missing Fields */
    .results-table td:nth-child(5) { 
      white-space: normal; 
      min-width: 150px;
      max-width: 200px;
      font-size: 0.875rem;
      padding: 0.5rem 0.75rem;
      vertical-align: top;
    } /* Warnings */
    .results-table td:nth-child(6) { 
      white-space: normal; 
      min-width: 180px;
      max-width: 250px;
    } /* Info */
    .results-table td.missing-fields {
      white-space: normal;
      min-width: 180px;
      max-width: 250px;
    }
    .results-table td:last-child {
      white-space: normal;
      min-width: 280px;
      width: auto;
    }
    .results-table td:last-child .enhance-btn,
    .results-table td:last-child .save-btn {
      display: inline-block;
      white-space: nowrap;
      margin: 0.25rem 0;
    }
    .results-table tr:hover {
      background: #f9fafb;
    }
    .status-valid {
      color: #38a169;
      font-weight: 600;
    }
    .status-invalid {
      color: #e53e3e;
      font-weight: 600;
    }
    .status-processing {
      color: #667eea;
      font-weight: 600;
    }
    .enhance-btn {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      margin: 0.25rem 0;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 1rem;
    }
    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
    }
    .missing-fields {
      font-size: 0.875rem;
      color: #e53e3e;
    }
    .scrollable-container {
      max-height: calc(100vh - 400px);
      min-height: 600px;
      overflow-y: auto;
      margin-top: 1rem;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      background: #fafbfc;
    }
    .url-link {
      color: #667eea;
      text-decoration: none;
      word-break: break-all;
    }
    .url-link:hover {
      text-decoration: underline;
    }
    .status-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.875rem;
      font-weight: 600;
    }
    .status-badge.valid {
      background: #c6f6d5;
      color: #22543d;
    }
    .status-badge.issues {
      background: #feebc8;
      color: #744210;
    }
    .status-badge.error {
      background: #fed7d7;
      color: #742a2a;
    }
    .status-badge.no-schema {
      background: #e2e8f0;
      color: #4a5568;
    }
    .single-url-section {
      background: #f7fafc;
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 2rem;
      border: 2px solid #e2e8f0;
    }
    .single-url-section label {
      margin-top: 0;
      font-weight: 600;
      color: #2d3748;
    }
    .single-url-section input {
      width: 100%;
      max-width: 600px;
      padding: 0.75rem 1rem;
      margin-top: 0.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
    }
    .help-block {
      background: #f0f7ff;
      border-left: 4px solid #667eea;
      padding: 1rem 1.5rem;
      margin-top: 1.5rem;
      border-radius: 6px;
      cursor: pointer;
    }
    .help-block-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.5rem;
    }
    .help-block-content {
      display: none;
      margin-top: 1rem;
      color: #4a5568;
      line-height: 1.7;
    }
    .help-block-content.active {
      display: block;
    }
    .help-block-icon {
      transition: transform 0.3s ease;
    }
    .help-block.expanded .help-block-icon {
      transform: rotate(180deg);
    }
    .batch-section {
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 2px solid #e2e8f0;
    }
    .progress-wrap {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .progress {
      width: 160px;
      height: 8px;
      background: #eee;
      border-radius: 999px;
      overflow: hidden;
    }
    .progress > span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #7c4dff, #4fc3f7);
      transition: width 0.25s ease;
    }
    .progress-label {
      font-size: 0.85rem;
      color: #555;
      min-width: 72px;
    }
    
    /* --- Row Progress Bars --- */
    .progress {
      position: relative;
      width: 100%;
      height: 6px;
      background: #f0f0f0;
      border-radius: 3px;
      overflow: hidden;
      margin-top: 4px;
      display: block;
    }
    
    .progress-inner {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00b67a, #e57200);
      border-radius: 3px;
      transition: width 0.3s ease;
      max-height: 6px;
    }
    
    /* === Status Badge Styling === */
    .chip-queued {
      background: linear-gradient(90deg, #cfd9df 0%, #e2ebf0 100%);
      color: #555;
      border-radius: 8px;
      padding: 4px 10px;
      font-size: 13px;
      font-weight: 600;
      display: inline-block;
    }
    
    .chip-fetching {
      background: linear-gradient(90deg, #ffe259 0%, #ffa751 100%);
      color: #333;
      border-radius: 8px;
      padding: 4px 10px;
      font-size: 13px;
      font-weight: 600;
      display: inline-block;
    }
    
    .chip-valid {
      background: #27AE60;
      color: white;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    .chip-valid:hover {
      background: #229954;
    }
    
    .chip-critical {
      background: #E74C3C;
      color: white;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    .chip-critical:hover {
      background: #C0392B;
    }
    
    .status-badge.no-schema {
      background: linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%);
      color: #333;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    
    /* Issues Modal */
    .issues-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(20, 20, 33, 0.45);
      align-items: center;
      justify-content: center;
      z-index: 9999;
      border: none;
      padding: 0;
    }
    .issues-backdrop::backdrop {
      background: rgba(20, 20, 33, 0.45);
    }
    .issues-modal {
      width: min(760px, 94vw);
      max-height: 80vh;
      overflow: auto;
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
      padding: 1.25rem 1.5rem;
    }
    .issues-modal h3 {
      margin: 0.2rem 0 0.8rem 0;
      font-size: 1.15rem;
    }
    .issues-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: #1a202c;
      margin: -1.25rem -1.5rem 1rem -1.5rem;
      border-radius: 14px 14px 0 0;
    }
    .issues-modal-header h3 {
      color: #fff;
      margin: 0;
    }
    .issues-close-x {
      background: #fff;
      border: 2px solid #fff;
      font-size: 1.5rem;
      color: #1a202c;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      border-radius: 6px;
      transition: all 0.2s;
      font-weight: bold;
    }
    .issues-close-x:hover {
      background-color: #ef4444;
      color: #fff;
      border-color: #ef4444;
    }
    .issues-close-x:active {
      background-color: #dc2626;
    }
    .issues-meta {
      font-size: 0.9rem;
      color: #555;
      margin: 0.5rem 0 1rem;
    }
    .issues-list {
      margin: 0.25rem 0 0.75rem 1rem;
    }
    .issues-list li {
      margin: 0.2rem 0;
    }
    .issues-json {
      background: #000000 !important;
      color: #ffffff !important;
      border-radius: 10px;
      padding: 0.75rem;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.82rem;
    }
    .gen-enhanced-modal {
      background: #1e293b;
      color: #e2e8f0;
    }
    .gen-enhanced-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: #0f172a;
      margin: -1.25rem -1.5rem 1rem -1.5rem;
      border-radius: 14px 14px 0 0;
      border-bottom: 2px solid #334155;
    }
    .gen-enhanced-header h3 {
      color: #fff;
      margin: 0;
      font-size: 1.15rem;
      font-weight: 600;
    }
    .gen-enhanced-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #334155;
    }
    .gen-copy-btn {
      background: #3b82f6;
      color: #fff;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gen-copy-btn:hover {
      background: #2563eb;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
    .gen-close-btn {
      background: #64748b;
      color: #fff;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gen-close-btn:hover {
      background: #475569;
      box-shadow: 0 4px 12px rgba(100, 116, 139, 0.4);
    }
    .gen-enhanced-modal .issues-meta {
      color: #94a3b8;
    }
    .severity-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      color: white;
    }
    .severity-badge.passed {
      background-color: #10b981;
    }
    .severity-badge.warning {
      background-color: #f59e0b;
    }
    .severity-badge.critical {
      background-color: #ef4444;
    }
    .summary-card {
      padding: 1rem;
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .summary-card pre {
      white-space: pre-wrap;
      font-size: 0.875rem;
      color: #374151;
      margin: 0;
      font-family: inherit;
    }
    .recommended-fix-card {
      padding: 1rem;
      background: #fffbeb;
      border: 1px solid #fbbf24;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .recommended-fix-card h4 {
      font-size: 1rem;
      font-weight: 600;
      color: #92400e;
      margin: 0 0 0.5rem 0;
    }
    .recommended-fix-card p {
      font-size: 0.875rem;
      color: #374151;
      margin: 0 0 0.75rem 0;
    }
    .recommended-fix-textarea {
      width: 100% !important;
      height: 18rem !important;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
      font-size: 0.75rem !important;
      background: #000000 !important;
      color: #ffffff !important;
      padding: 0.75rem !important;
      border-radius: 6px !important;
      border: 1px solid #333 !important;
      resize: vertical;
      overflow: auto;
    }
    .copy-schema-btn {
      margin-top: 0.75rem;
      background: #d97706;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .copy-schema-btn:hover {
      background: #b45309;
    }
    .system-node {
      opacity: 0.5;
      filter: grayscale(0.6);
    }
    .system-node td:first-child::after {
      content: " (Squarespace auto-schema)";
      font-style: italic;
      color: #888;
      margin-left: 0.5rem;
    }
    .help-link {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.75rem;
    }
    .help-link a {
      color: #2563eb;
      text-decoration: underline;
    }
    .help-link a:hover {
      color: #1d4ed8;
    }
    .chip-issues {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #F5B041;
      color: black;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      border: 1px solid #E67E22;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-issues:hover {
      background: #E67E22;
    }
    .chip-issues::after {
      content: " (non-critical)";
      font-size: 0.8em;
      opacity: 0.7;
    }
    .duplicate-warning {
      color: #b47f00;
      font-weight: 500;
    }
    .chip-critical {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #E74C3C;
      color: white;
      border: 1px solid #C0392B;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-critical:hover {
      background: #C0392B;
    }
    .chip-passed {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-passed:hover {
      background: #229954;
    }
    .status-explanation {
      display: inline-block;
      margin-left: 0.75rem;
      font-size: 0.875rem;
      color: #6b7280;
      font-style: italic;
      vertical-align: middle;
    }
    #statusCell_0, #statusCell_1, #statusCell_2, [id^="statusCell_"] {
      white-space: normal;
      line-height: 1.5;
    }
    .status-legend {
      display: flex;
      gap: 1rem;
      margin-bottom: 0.75rem;
      padding: 0.75rem;
      background: #2d3748;
      border-radius: 8px;
      font-size: 0.875rem;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .status-legend-item {
      color: #fff;
    }
    .status-legend-item span:not(.chip-sample):not(.info-entry) {
      color: #e2e8f0;
    }
    .status-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .status-legend-item .chip-sample {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    .chip-sample.passed {
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
    }
    .chip-sample.issues {
      background: #F5B041;
      color: black;
      border: 1px solid #E67E22;
    }
    .chip-sample.critical {
      background: #E74C3C;
      color: white;
      border: 1px solid #C0392B;
    }
    .chip-sample.info {
      background: #5DADE2;
      color: white;
      border: 1px solid #3498DB;
    }
    .chip-info {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #5DADE2;
      color: white;
      border: 1px solid #3498DB;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-info:hover {
      background: #3498DB;
    }
    .chip-ok {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-ok:hover {
      background: #229954;
    }
    .badge {
      display: inline-block;
      padding: 0.15rem 0.4rem;
      border-radius: 0.5rem;
      background: #fff3cd;
      color: #7a5b00;
      border: 1px solid #ffe08a;
      margin: 0.1rem 0.15rem;
      font-size: 0.8rem;
    }
    /* Debug Console Styles */
    .debug-console {
      margin-top: 1.5rem;
      border: 1px solid #cbd5e0;
      border-radius: 8px;
      background: #f7fafc;
      max-height: 400px;
      overflow-y: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
    }
    .debug-console-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #edf2f7;
      border-bottom: 1px solid #cbd5e0;
      border-radius: 8px 8px 0 0;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .debug-console-actions {
      display: flex;
      gap: 0.5rem;
    }
    .debug-console-content {
      padding: 1rem;
      line-height: 1.6;
      color: #2d3748;
    }
    .debug-log-entry {
      margin: 0.25rem 0;
      padding: 0.25rem 0.5rem;
      border-left: 3px solid #4299e1;
      background: #fff;
    }
    .debug-log-entry.error {
      border-left-color: #f56565;
      background: #fed7d7;
    }
    .debug-log-entry.warn {
      border-left-color: #ed8936;
      background: #feebc8;
    }
    .debug-log-entry.success {
      border-left-color: #48bb78;
      background: #c6f6d5;
    }
    .debug-log-time {
      color: #718096;
      font-size: 0.75rem;
      margin-right: 0.5rem;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Modal styling */
    #detail-modal { position: fixed; inset: 0; z-index: 9999; }
    #detail-modal .modal-backdrop { position:absolute; inset:0; background:rgba(0,0,0,.45); }
    #detail-modal .modal { position: absolute; top: 8%; left: 50%; transform: translateX(-50%); width: min(1100px, 92vw); background:#fff; border-radius:12px; box-shadow: 0 10px 40px rgba(0,0,0,.2); }
    #detail-modal .modal-head { display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid #eee; }
    #detail-modal .modal-body { padding:18px; max-height:70vh; overflow:auto; }
    #detail-modal #modal-close { background:none; border:none; font-size:1.5rem; cursor:pointer; padding:0; width:30px; height:30px; display:flex; align-items:center; justify-content:center; }
    #detail-modal #modal-close:hover { color:#f00; }
    .code-card { border:1px solid #eee; border-radius:10px; margin-bottom:12px; }
    .code-card-head { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; background:#fafafa; border-bottom:1px solid #eee; }
    .code-card pre { margin:0; padding:12px; overflow:auto; background:#000; color:#fff; }
    .code-card pre code { color:#fff; }
    .code-card .copy-btn { background:#2563eb; color:#fff; border:none; padding:0.375rem 0.75rem; border-radius:4px; cursor:pointer; font-size:0.875rem; }
    .code-card .copy-btn:hover { background:#1d4ed8; }
    .grid.grid-two { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 768px) {
      .grid.grid-two { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="version-badge">
    <span class="version">v1.12.0</span>
    <span class="date">2025-11-04</span>
  </div>
  <h1>Unified Schema Generator - Events & Products</h1>

  <div class="tabs">
    <button class="tab active" onclick="switchTab('event')">Event Schema</button>
    <button class="tab" onclick="switchTab('product')">Product Schema</button>
    <button class="tab" onclick="switchTab('validator')">Schema Validator</button>
    <button class="tab" onclick="switchTab('guide')">üß† Tab Guide</button>
  </div>

  <!-- Event Tab Content -->
  <div id="eventTab" class="tab-content active">
    <div class="instructions">
      <strong>üìÖ Event Schema Generator</strong><br>
      1. Upload your event CSV file (exported from Squarespace Events).<br>
      2. Ensure it includes these fields: <code>Event_Title</code>, <code>Start_Date</code>, <code>End_Date</code>, <code>Event_URL</code>, <code>Event_Image</code>, <code>Location_Business_Name</code>, <code>Location_Address</code>, <code>Excerpt</code>, <code>Category</code>, <code>Workflow_State</code>.<br>
      3. Select a category filter (or "All Categories") to generate schema for specific event types.<br>
      4. Click <b>Generate Event Schema</b> to create valid JSON-LD blocks.<br><br>
      
      ‚úÖ This tool works entirely offline in your browser.<br>
      ‚úÖ Only includes structured data compliant with Google Rich Results.<br>
      ‚úÖ Only published events with future start dates are included automatically.<br>
      ‚úÖ Schema includes organizer, performer, location with parsed address.<br><br>

      <strong>üìÑ Data Workflow Summary:</strong><br>
      <pre>
Step 1: Export events from Squarespace ‚Üí events_export.csv
     ‚Üì
Step 2: Verify CSV contains all required fields
     ‚Üì
Step 3: Upload CSV and select category filter
     ‚Üì
Step 4: Generate JSON-LD schema blocks
     ‚Üì
Step 5: Paste schema into Squarespace event page (see instructions below)
      </pre>

      <strong>üìå Squarespace Instructions:</strong><br>
      ‚Ä¢ Open your event page in Squarespace.<br>
      ‚Ä¢ Navigate to <b>Page Settings ‚Üí Advanced ‚Üí Header Code Injection</b><br>
      ‚Ä¢ OR insert a <b>Code Block</b> onto the event page.<br>
      ‚Ä¢ <b>Paste the entire generated schema block</b> (includes both ItemList and Event schemas).<br>
      ‚Ä¢ The schema will include all events matching your selected category filter.<br>
      ‚Ä¢ <span class="warning">‚ö†Ô∏è Best Practice:</span> Paste the schema on a main events listing page (e.g., "All Workshops" or category archive page) rather than individual event pages.<br>
      ‚Ä¢ For individual event pages, you can generate schema for a single category containing just that event.<br>
      ‚Ä¢ Always validate your schema after deployment using the test URL tools below.
    </div>

    <label for="eventCsvFile">Upload Event CSV File:</label>
    <input type="file" id="eventCsvFile" accept=".csv" aria-label="Event CSV file upload">
    
    <div id="eventCategoryFilterContainer" style="display:none;">
      <p>Select category to generate schema for:</p>
      <select id="eventCategoryFilter" aria-label="Event category filter"></select>
      <button onclick="generateEventSchema()">Generate Event Schema</button>
    </div>

    <h3>Generated JSON-LD Schema:</h3>
    <pre id="eventOutput"></pre>
    <button onclick="copyToClipboard('eventOutput')">Copy to Clipboard</button>

    <div class="test-url-section">
      <h4>Test Generated Schema:</h4>
      <p>Paste a URL containing your schema to validate it:</p>
      <label for="eventTestUrl">Test URL:</label>
      <input type="text" id="eventTestUrl" placeholder="https://example.com/page-with-schema" aria-label="Event test URL">
      <div class="button-group">
        <button onclick="testSchemaOrg('eventTestUrl')">Test on Schema.org Validator</button>
        <button onclick="testGoogleRichResults('eventTestUrl')" class="secondary">Test on Google Rich Results</button>
      </div>
    </div>
  </div>

  <!-- Product Tab Content -->
  <div id="productTab" class="tab-content">
    <div class="instructions">
      <strong>üõ† Product Schema Generator</strong><br><br>
      
      ‚úÖ This tool works entirely offline in your browser.<br>
      ‚úÖ Only includes structured data compliant with Google Rich Results and Merchant Center policies.<br><br>

      <!-- ===================== STATUS DASHBOARD ===================== -->
      <div id="workflow-status-dashboard" style="margin-top: 1rem; margin-bottom: 1.5rem; padding: 1.5rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
        <h3 style="color: white; margin: 0 0 1rem 0; font-size: 1.25rem; font-weight: 600;">üìä Workflow Status Dashboard</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem;">
          <div id="step-status-0" class="step-status-card" style="padding: 0.75rem; background: rgba(255,255,255,0.15); border-radius: 8px; text-align: center; color: white;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è≥</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 0</div>
            <div id="step-status-text-0" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Initializing</div>
          </div>
          <div id="step-status-1" class="step-status-card" style="padding: 0.75rem; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center; color: white; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 1</div>
            <div id="step-status-text-1" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-2" class="step-status-card" style="padding: 0.75rem; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center; color: white; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 2</div>
            <div id="step-status-text-2" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-3a" class="step-status-card" style="padding: 0.75rem; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center; color: white; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 3a</div>
            <div id="step-status-text-3a" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-3b" class="step-status-card" style="padding: 0.75rem; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center; color: white; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 3b</div>
            <div id="step-status-text-3b" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-4" class="step-status-card" style="padding: 0.75rem; background: rgba(255,255,255,0.1); border-radius: 8px; text-align: center; color: white; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 4</div>
            <div id="step-status-text-4" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
        </div>
      </div>

      <!-- ===================== PRODUCT SCHEMA WORKFLOW ===================== -->
      <section id="product-schema-workflow" style="display: flex; flex-direction: column; gap: 1.5rem; margin-top: 1.5rem;">

        <!-- STEP 0: Initialize Local Executor -->
        <div id="step0-init" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step0-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è≥</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">‚öôÔ∏è Step 0 ‚Äì Electron Desktop App</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            This step ensures the Electron desktop app is running with the local automation bridge active.
          </p>
          <div id="executorStatus" style="margin-top: 0.75rem; padding: 0.75rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; color: #856404; font-size: 0.875rem; font-weight: 500;">
            üîç Checking status‚Ä¶
          </div>
          <div id="executorActions" style="margin-top: 0.75rem; display: flex; gap: 0.75rem; flex-wrap: wrap;">
            <button id="startLocalBtn" style="display: none; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
              ‚ö° Start Local Server
            </button>
            <button id="copyCommandBtn" style="display: none; background: #718096; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#4a5568'" onmouseout="this.style.background='#718096'">
              üìã Copy CLI Command
            </button>
          </div>
          <pre id="executorConsole" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></pre>
        </div>

        <!-- STEP 1 -->
        <div id="step1-container" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step1-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è∏Ô∏è</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">üßæ Step 1 ‚Äì Squarespace Product Export Setup</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Export your latest products from Squarespace ‚Üí <strong>Commerce ‚Üí Products ‚Üí Export CSV</strong>.<br>
            Save in <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">/inputs-files/workflow/</code> as <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">01 ‚Äì products_YYYY-MM-DD.csv</code>.
          </p>
          <input type="file" id="file-step1" accept=".csv" style="margin-top: 0.75rem; display: block; font-size: 0.875rem; opacity: 0.5; cursor: not-allowed;" disabled />
          <p id="step1LockMessage" style="font-size: 0.75rem; color: #718096; margin-top: 0.5rem; font-style: italic;">
            ‚è≥ Complete Step 0 first to unlock this step.
          </p>
          <div id="progress-step1" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step1" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
        </div>

        <!-- STEP 2 -->
        <div id="step2-container" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step2-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è∏Ô∏è</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">üßπ Step 2 ‚Äì Clean and Normalize CSV</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            This step automatically formats your latest Squarespace export for schema generation.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Triggered automatically after Step 1 upload</li>
            <li>Normalizes column names and trims invalid rows</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">02 ‚Äì products_cleaned.xlsx</code></li>
          </ul>
          <div id="step2WebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Web Mode:</strong> Steps 2-4 require Electron app or local execution.<br>
            <small>Download Electron desktop app for full automation.</small>
          </div>
          <div id="progress-step2" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step2" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="cleanConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3a: Fetch Google Reviews -->
        <div id="step3a-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì• Step 3a ‚Äì Fetch Google Reviews Automatically</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            This step connects to your Google My Business account and retrieves all customer reviews.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires valid OAuth JSON in <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">/inputs-files/workflow/credentials/</code></li>
            <li>First time: Browser will open for OAuth authorization</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03b ‚Äì google_reviews.csv</code></li>
          </ul>
          <div id="step3aWebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="fetchGoogleReviews" onclick="runGoogleReviewsFetcher()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            üì• Fetch Google Reviews (Local)
          </button>
          <div id="progress-step3a" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3a" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="googleConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3b: Merge Reviews -->
        <div id="step3b-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üîó Step 3b ‚Äì Merge Trustpilot and Google Reviews</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Combine both review sources into one clean dataset ready for schema generation.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03a ‚Äì trustpilot_historical_reviews.csv</code> and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03b ‚Äì google_reviews.csv</code></li>
            <li>Filters out reviews below 4‚òÖ</li>
            <li>Automatically maps reviews to product names</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì combined_product_reviews.csv</code></li>
          </ul>
          <div id="step3bWebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="mergeReviewsBtn" onclick="runMergeReviews()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            üîó Merge Reviews
          </button>
          <div id="progress-step3b" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3b" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="mergeConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3c: Upload Merged Dataset (for Step 4) -->
        <div style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì§ Step 3c ‚Äì Upload Merged Dataset</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            After merging reviews, upload the final merged file for schema generation.<br>
            File: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì products_with_review_data_final.xlsx</code>
          </p>
          <input type="file" id="file-step3" accept=".xlsx" style="margin-top: 0.75rem; display: block; font-size: 0.875rem;" />
          <div id="progress-step3" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
        </div>

        <!-- STEP 4 -->
        <div id="step4-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">‚öôÔ∏è Step 4 ‚Äì Generate Product Schema</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Click below to generate JSON-LD schema from your Step 3 Excel file.
          </p>
          <div id="step4WebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="run-step4" onclick="generateProductSchema()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            Generate Schema (Step 4)
          </button>
          <div id="progress-step4" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step4" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="productSchemaSuccess" style="display:none; margin-top: 1rem; padding: 1rem; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; color: #155724;">
            ‚úÖ Schema generation complete.<br>
            Files saved in /outputs and /workflow.
          </div>
        </div>

        <!-- STEP 5 -->
        <div style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì• Step 5 ‚Äì Insert Schema into Squarespace</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Open your product page ‚Üí <strong>Code Block</strong> ‚Üí paste generated schema.<br>
            Validate using <a href="https://search.google.com/test/rich-results" target="_blank" style="color: #667eea; text-decoration: underline;">Rich Results Test</a>.
          </p>
        </div>

      </section>

    </div>

    <h3 style="margin-top: 2rem;">Generated JSON-LD Schema:</h3>
    <p style="color: #4a5568; font-size: 0.9rem; margin-bottom: 0.5rem;">Preview of JSON-LD schema blocks for each product:</p>
    <textarea id="productOutput" readonly style="min-height: 400px; font-family: 'Courier New', monospace; font-size: 0.85rem; width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px;"></textarea>
    <button onclick="copyToClipboard('productOutput')" style="margin-top: 0.75rem; background: #667eea; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer;">Copy to Clipboard</button>
    
    <!-- Hidden file input for Step 4 (backward compatibility) -->
    <input type="file" id="productCsvFile" accept=".csv,.xlsx" style="display: none;" aria-label="Product CSV/XLSX file upload">

    <div class="test-url-section">
      <h4>Test Generated Schema:</h4>
      <p>Paste a URL containing your schema to validate it:</p>
      <label for="productTestUrl">Test URL:</label>
      <input type="text" id="productTestUrl" placeholder="https://example.com/page-with-schema" aria-label="Product test URL">
      <div class="button-group">
        <button onclick="testSchemaOrg('productTestUrl')">Test on Schema.org Validator</button>
        <button onclick="testGoogleRichResults('productTestUrl')" class="secondary">Test on Google Rich Results</button>
      </div>
    </div>
  </div>

  <!-- Schema Validator Tab Content -->
  <div id="validatorTab" class="tab-content">
    <div class="instructions">
      <strong>üîç Schema Validator</strong><br><button class='secondary' style='float:right;margin-top:-0.25rem' onclick='switchTab("guide")'>Open Tab Guide ‚Üí</button>
      Validate schema markup on your pages using industry-standard validators. Choose single URL validation or batch processing from CSV.<br><br>
      
      ‚úÖ Works entirely in your browser (no server required).<br>
      ‚úÖ Validates Product, Event, Organization, and other schema types.<br>
      ‚úÖ Identifies missing fields and provides enhancement suggestions.<br><br>
      
      <strong>‚ö†Ô∏è Note:</strong> Cross-origin restrictions may prevent fetching some URLs. Use URLs from the same domain or enable CORS if testing locally.
    </div>

    <!-- Single URL Validator Section -->
    <div class="single-url-section">
      <label for="singleUrlInput">Validate a Single URL:</label>
      <input type="text" id="singleUrlInput" placeholder="https://www.example.com/page-with-schema" aria-label="Single URL to validate">
      <button onclick="runSingleUrlValidation()" style="margin-top: 0.75rem;">Run Validation</button>
      <p style="margin-top: 0.75rem; color: #4a5568; font-size: 0.9rem;">This will process the URL and display validation results in the table below. Use the validator buttons in the table to open external validators.</p>
      <label style="margin-top: 0.75rem; display: flex; align-items: center; gap: 0.5rem; font-weight: normal;">
        <input type="checkbox" id="autoSaveToSupabase" style="width: auto; margin: 0;" onchange="saveAutoSavePreference()">
        <span>Auto-save to Supabase</span>
      </label>
    </div>

    <!-- Batch CSV Validator Section -->
    <div class="batch-section">
      <label for="validatorCsvFile" style="margin-top: 0;">Upload CSV File with URLs:</label>
      <p style="margin-top: 0.5rem; margin-bottom: 1rem; color: #4a5568; font-size: 0.95rem; font-style: italic;">
        Use this to batch validate multiple URLs from your site for schema health.
      </p>
      <input type="file" id="validatorCsvFile" accept=".csv" aria-label="Validator CSV file upload" onchange="onFileUpload()">
      <button onclick="startValidation()">Validate URLs</button>
      <button onclick="downloadTemplateCSV()" class="secondary" style="margin-left: 0.5rem;">Download Template CSV</button>
      <button id="exportAllBtn" onclick="exportAllEnhanced()" class="secondary" style="margin-left: 0.5rem;" disabled>Export All Enhanced</button>
      <button id="saveAllBtn" onclick="saveAllToSupabase()" class="secondary" style="margin-left: 0.5rem;" disabled>Save All to Supabase</button>

    <div id="validatorProgress" style="display:none; margin-top: 1.5rem;">
      <div class="progress-bar">
        <div id="progressBarFill" class="progress-bar-fill" style="width: 0%;"></div>
      </div>
      <p id="progressText" style="margin-top: 0.75rem; color: #4a5568; font-size: 0.95rem;">Processing...</p>
    </div>

    <div id="validatorResults" style="display:none; margin-top: 2rem;">
      <h3>Validation Results</h3>
      <p style="margin-top: 0.5rem; margin-bottom: 1rem; color: #4a5568; font-size: 0.9rem; font-style: italic;">
        External validators open in a new tab. Due to cross-origin limits, results can't be read automatically ‚Äî set the status after reviewing.
      </p>
      <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
        <button onclick="setAllExternalStatusTo('Passed')" class="secondary" style="font-size: 0.875rem; padding: 0.5rem 1rem;">Set all Not run ‚Üí Passed</button>
        <button onclick="resetAllExternalStatus()" class="secondary" style="font-size: 0.875rem; padding: 0.5rem 1rem;">Reset all to Not run</button>
      </div>
      
      <!-- Status Legend -->
      <div class="status-legend">
        <div class="status-legend-item">
          <span class="chip-sample passed">‚úÖ Passed</span>
          <span>All valid; no missing fields</span>
        </div>
        <div class="status-legend-item">
          <span class="chip-sample issues">‚ö†Ô∏è Warning</span>
          <span>Duplicate or redundant schema nodes (non-critical)</span>
        </div>
        <div class="status-legend-item">
          <span class="info-entry">‚ÑπÔ∏è Info</span>
          <span>Legitimate multi-instance schemas (normal for Events, Products, FAQs)</span>
        </div>
        <div class="status-legend-item">
          <span class="chip-sample critical">‚ùå Critical</span>
          <span>Structural or required field errors</span>
        </div>
        <div class="status-legend-item" style="margin-left: auto;">
          <span style="color: #6b7280;">üí° Click any badge or "View Details" to see full analysis</span>
        </div>
      </div>
      
      <div class="scrollable-container">
        <table class="results-table">
          <thead>
            <tr>
              <th><span class="sortable-header" data-column="0">Page URL</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="1">Schema Type</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="2">Status</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="3">Missing Fields</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="4">Warnings</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="5">Info</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="6">Rich Results<br>Status (external)</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="7">Schema.org<br>Status (external)</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="8">Notes</span><span class="sort-indicator"> ‚Üï</span></th>
              <th>Actions</th>
            </tr>
            <tr class="filter-row">
              <th><input type="text" class="filter-input" data-column="0" placeholder="Filter URL..."></th>
              <th><input type="text" class="filter-input" data-column="1" placeholder="Filter Type..."></th>
              <th><input type="text" class="filter-input" data-column="2" placeholder="Filter Status..."></th>
              <th><input type="text" class="filter-input" data-column="3" placeholder="Filter Missing..."></th>
              <th><input type="text" class="filter-input" data-column="4" placeholder="Filter Warnings..."></th>
              <th><input type="text" class="filter-input" data-column="5" placeholder="Filter Info..."></th>
              <th><input type="text" class="filter-input" data-column="6" placeholder="Filter Rich Results..."></th>
              <th><input type="text" class="filter-input" data-column="7" placeholder="Filter Schema.org..."></th>
              <th><input type="text" class="filter-input" data-column="8" placeholder="Filter Notes..."></th>
              <th></th>
            </tr>
          </thead>
          <tbody id="resultsTableBody">
          </tbody>
        </table>
      </div>
    </div>

    </div>

    <!-- Help Block -->
    <div class="help-section" style="margin-top:1rem;padding:1rem;background:#f9f9f9;border-radius:8px;">
      <strong>‚ÑπÔ∏è How to Read Results:</strong>
      <ul style="margin-top:0.5rem;">
        <li><b>Schema Type</b>: Type(s) detected from JSON-LD (<code>@type</code> values).</li>
        <li><b>Status</b>: "Error" means fetch failed; "OK" means schema was found.</li>
        <li><b>Skipped</b>: Offline mode‚Äîexternal validators not queried.</li>
        <li><b>Schema.org / Google Buttons</b>: Open page in respective validators for manual checks.</li>
        <li><b>Save to Supabase</b>: (Optional) Stores results if DB logging is enabled.</li>
      </ul>
    </div>

    <div class="help-block" onclick="toggleHelpBlock()" onkeydown="if(event.key==='Enter'||event.key===' ')toggleHelpBlock()" role="button" tabindex="0" aria-expanded="false" id="helpBlock">
      <div class="help-block-header">
        <span>‚ÑπÔ∏è About Schema Validators</span>
        <span class="help-block-icon">‚ñº</span>
      </div>
      <div class="help-block-content" id="helpBlockContent">
        <strong>Schema.org Validator:</strong><br>
        Validates that your schema markup follows the Schema.org vocabulary specifications. Checks for correct syntax, required fields, and proper structure. Essential for ensuring your schema is semantically correct.<br><br>
        
        <strong>Google Rich Results Test:</strong><br>
        Tests whether your schema qualifies for Google's rich results (enhanced search listings). Shows which rich result types are detected and any issues that might prevent them from appearing in search results.<br><br>
        
        <strong>Results:</strong><br>
        Validation results are displayed in the table above. For detailed analysis, you'll need to manually review the validator pages opened in new tabs. When Supabase integration is connected, results can be automatically captured and stored for analysis.<br><br>
        
        <strong>Note:</strong> Both validators open in new browser tabs so you can review the detailed results while keeping this tool open.
      </div>
    </div>

    <!-- Debug Console -->
    <div class="debug-console">
      <div class="debug-console-header">
        <span>üîç Debug Console</span>
        <div class="debug-console-actions">
          <button onclick="clearDebugConsole()" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Clear</button>
          <button onclick="copyDebugConsole()" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Copy Logs</button>
        </div>
      </div>
      <div class="debug-console-content" id="debugConsoleContent">
        <div class="debug-log-entry success">
          <span class="debug-log-time"></span>Debug console ready. Logs will appear here when validation runs.
        </div>
      </div>
    </div>
  </div>

  <!-- Tab Guide Tab Content -->
  <div id="guideTab" class="tab-content">
    <div class="instructions" style="max-width: 100%;">
      <h2>üß† Tool Guide: What Each Tab Does</h2>

      <p>This tool contains several tabs, each with a specific use:</p>

      <h3>üü¢ Event Schema</h3>
      <ul>
        <li>Use this tab to generate JSON-LD Event schema from a CSV of your photography workshops.</li>
        <li>Supports <code>location</code>, <code>performer</code>, <code>offers</code>, and <code>organizer</code> fields.</li>
        <li>Paste the resulting schema into a code block on your Squarespace event page.</li>
      </ul>

      <h3>üîµ Product Schema</h3>
      <ul>
        <li>Generates <code>Product</code> schema from a CSV of lessons, vouchers, or services.</li>
        <li>Automatically filters out products with weak or missing reviews.</li>
        <li>Paste the JSON-LD into product pages on Squarespace.</li>
      </ul>

      <h3>üü° Schema Validator</h3>
      <ul>
        <li>Enter one or more live URLs (CSV or single entry support coming).</li>
        <li>Fetches the page content and validates all structured data inside it.</li>
        <li>Flags missing or invalid fields and optionally builds an enhanced schema block you can download.</li>
        <li>Use this to <strong>audit</strong>, <strong>debug</strong>, or <strong>improve</strong> existing Squarespace pages.</li>
      </ul>

      <h3>üìå Best Practices</h3>
      <ul>
        <li>Only insert schema relevant to the page (don't paste every product on every product page).</li>
        <li>Always validate using the <strong>Schema Validator</strong> before and after injecting schema.</li>
        <li>Use <code>&lt;script type="application/ld+json"&gt;</code> inside a code block on Squarespace pages.</li>
      </ul>

      <h3>üîß Upcoming Features</h3>
      <ul>
        <li>Support for validating a single URL directly (no CSV needed).</li>
        <li>Supabase integration to track schema versions and history.</li>
        <li>AI suggestions for schema fixes.</li>
      </ul>
    </div>
  </div>

</div>

<script>
  // Tab switching - MUST be absolutely first, before any other code
  function switchTab(mode) {
    // Clear cache and storage when switching tabs
    try {
      // Clear ResultCache if it exists
      if (typeof ResultCache !== 'undefined') {
        if (ResultCache instanceof Map) {
          ResultCache.clear();
        } else if (ResultCache.clear && typeof ResultCache.clear === 'function') {
          ResultCache.clear();
        }
      }
      // Clear validationResults if it exists
      if (typeof validationResults !== 'undefined' && Array.isArray(validationResults)) {
        validationResults.length = 0;
      }
      // Clear localStorage and sessionStorage
      localStorage.removeItem('schemaValidatorResults');
      localStorage.removeItem('schemaValidatorCache');
      sessionStorage.removeItem('schemaValidatorResults');
      sessionStorage.removeItem('schemaValidatorCache');
    } catch (e) {
      console.warn('Failed to clear storage:', e);
    }
    
    // Clear the results table
    const tableBody = document.getElementById('resultsTableBody');
    if (tableBody) {
      tableBody.innerHTML = '';
    }
    
    // Reset all active tabs and contents
    const tabs = document.querySelectorAll('.tab');
    const contents = document.querySelectorAll('.tab-content');
    
    for (const tab of tabs) {
      tab.classList.remove('active');
    }
    for (const content of contents) {
      content.classList.remove('active');
    }
    
    // Activate correct tab based on mode
    const tabMap = {
      'event': { tabIndex: 0, contentId: 'eventTab' },
      'product': { tabIndex: 1, contentId: 'productTab' },
      'validator': { tabIndex: 2, contentId: 'validatorTab' },
      'guide': { tabIndex: 3, contentId: 'guideTab' }
    };
    
    const config = tabMap[mode];
    if (config && tabs[config.tabIndex] && tabs[config.tabIndex] !== null) {
      tabs[config.tabIndex].classList.add('active');
      const content = document.getElementById(config.contentId);
      if (content) {
        content.classList.add('active');
      }
    }
  }
  
  // Make it globally available
  window.switchTab = switchTab;
</script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
  // Override console methods to also log to debug console (MUST be before debugLog)
  const originalConsoleLog = console.log.bind(console);
  const originalConsoleError = console.error.bind(console);
  const originalConsoleWarn = console.warn.bind(console);
  
  // Schema Validator Suppression Configuration
  const SUPPRESSION_CONFIG = {
    suppressions: {
      global: {
        ignoreSchemaTypes: [
          "BreadcrumbList",
          "SearchAction",
          "Person",
          "Event",
          "ItemList",
          "Article",
          "Product"
        ],
        ignoreRecommendedFields: [
          "publisher",
          "telephone",
          "url",
          "description",
          "image",
          "logo",
          "contactPoint"
        ],
        ignoreWarningsContaining: [
          "Duplicate Event",
          "Duplicate BreadcrumbList",
          "Recommended field",
          "Unknown schema type",
          "Missing recommended",
          "normal navigation schema",
          "acceptable for combined schema types"
        ],
        ignoreInfoContaining: [
          "BreadcrumbList detected",
          "Recommended field",
          "Legitimate multi-instance schemas",
          "cached or blocked"
        ],
        ignoreUrlsMatching: [
          "/photographic-workshops-near-me",
          "/photography-classes",
          "/photography-services",
          "/photography-workshops",
          "/shop"
        ],
        downgradeDuplicates: true,
        collapseMultiInstanceEvents: true,
        hideSquarespaceInjectedBlocks: true,
        treatWarningsAsPass: true
      },
      rules: {
        Organization: {
          suppressMissingRecommended: true,
          ignoreExtraNodes: true
        },
        LocalBusiness: {
          suppressMissingRecommended: true,
          ignoreExtraNodes: true
        },
        WebSite: {
          suppressMissingRecommended: true,
          requireOnly: ["url", "name"]
        },
        Person: {
          ignoreUnknownType: true
        },
        BreadcrumbList: {
          collapseDuplicates: true
        },
        Event: {
          allowMultiple: true,
          collapseDuplicates: true
        },
        Product: {
          allowMultiple: true,
          ignoreNoReview: true
        }
      }
    }
  };

  // Multi-instance allowed schema types (expected to appear multiple times on a page)
  const MULTI_INSTANCE_ALLOWED_TYPES = ['Event', 'Product', 'Course', 'Article', 'Review', 'FAQPage', 'ListItem', 'Offer'];

  // Helper: Detect inferred schema types based on patterns in JSON-LD
  function detectInferredTypes(allNodes) {
    const inferredTypes = [];
    const typeCounts = {};
    
    // Count occurrences of each type
    allNodes.forEach(node => {
      const types = asArray(node['@type']);
      types.forEach(type => {
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });
    });
    
    // Rule 1: Carousel inference
    // If ‚â•3 Event items exist ‚Üí infer Carousel
    const eventCount = typeCounts['Event'] || 0;
    if (eventCount >= 3) {
      inferredTypes.push({ type: 'Carousel', reason: `from ${eventCount} Event schemas` });
    }
    
    // Rule 2: Carousel inference from Product/Course
    // If multiple Product or Course schemas exist ‚Üí also infer Carousel
    const productCount = typeCounts['Product'] || 0;
    const courseCount = typeCounts['Course'] || 0;
    if ((productCount + courseCount) >= 3) {
      inferredTypes.push({ type: 'Carousel', reason: `from ${productCount + courseCount} Product/Course schemas` });
    }
    
    // Rule 3: ReviewSnippet inference
    // If any item contains aggregateRating or review ‚Üí infer ReviewSnippet
    const hasReviews = allNodes.some(node => {
      return node.aggregateRating || 
             (node.review && Array.isArray(node.review) && node.review.length > 0) ||
             node.reviews;
    });
    
    if (hasReviews) {
      const reviewCount = allNodes.filter(node => {
        return node.aggregateRating || 
               (node.review && Array.isArray(node.review) && node.review.length > 0) ||
               node.reviews;
      }).length;
      inferredTypes.push({ type: 'ReviewSnippet', reason: `from ${reviewCount} item${reviewCount !== 1 ? 's' : ''} with reviews` });
    }
    
    // Rule 4: MerchantListing (Google) inference
    // If any Product schema contains all Merchant Center fields ‚Üí infer MerchantListing (Google)
    const productNodes = allNodes.filter(node => {
      const types = asArray(node['@type']);
      return types.includes('Product');
    });
    
    console.log(`[MerchantListing] Checking ${productNodes.length} Product node(s) for Merchant Center fields`);
    debugLog(`[MerchantListing] Checking ${productNodes.length} Product node(s) for Merchant Center fields`, 'info');
    
    // Debug: Log Product node details
    productNodes.forEach((node, idx) => {
      console.log(`[MerchantListing] Product node ${idx + 1}:`, {
        '@type': node['@type'],
        hasOffers: !!node.offers,
        offersType: node.offers ? (Array.isArray(node.offers) ? 'array' : 'object') : 'none',
        hasPriceCurrency: !!node.offers?.priceCurrency || !!node.offers?.[0]?.priceCurrency,
        hasPrice: !!node.offers?.price || !!node.offers?.[0]?.price,
        hasAvailability: !!node.offers?.availability || !!node.offers?.[0]?.availability,
        hasMerchantReturnPolicy: !!node.hasMerchantReturnPolicy
      });
    });
    
    const hasMerchantListing = productNodes.some(node => {
      const detected = detectMerchantListing(node);
      if (detected) {
        console.log(`[MerchantListing] ‚úÖ Detected MerchantListing in Product node:`, node);
        debugLog(`[MerchantListing] ‚úÖ Detected MerchantListing in Product node: ${JSON.stringify({ '@type': node['@type'], hasOffers: !!node.offers, hasReturnPolicy: !!node.hasMerchantReturnPolicy })}`, 'success');
      }
      return detected;
    });
    
    if (hasMerchantListing) {
      inferredTypes.push({ type: 'MerchantListing (Google)', reason: 'Product schema contains all Merchant Center fields (offers, price, priceCurrency, availability, hasMerchantReturnPolicy)' });
      console.log(`[MerchantListing] ‚úÖ Added MerchantListing (Google) to inferred types. Total inferred types:`, inferredTypes);
      debugLog(`[MerchantListing] ‚úÖ Added MerchantListing (Google) to inferred types`, 'success');
    } else {
      console.log(`[MerchantListing] ‚ùå No Product schemas found with all Merchant Center fields`);
      debugLog(`[MerchantListing] ‚ùå No Product schemas found with all Merchant Center fields`, 'info');
    }
    
    // Deduplicate inferred types (e.g., if Carousel appears twice)
    const uniqueInferred = [];
    const seenTypes = new Set();
    inferredTypes.forEach(item => {
      if (!seenTypes.has(item.type)) {
        seenTypes.add(item.type);
        uniqueInferred.push(item);
      }
    });
    
    return uniqueInferred;
  }

  // Suppression Filtering Functions
  function shouldSuppressWarning(message, url = '') {
    if (!message) return false;
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing warning by URL pattern: ${message}`, 'info');
      return true;
    }
    
    // Check message content
    if (sup.ignoreWarningsContaining.some(pattern => message.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing warning by pattern: ${message}`, 'info');
      return true;
    }
    
    return false;
  }

  function shouldSuppressInfo(message, url = '') {
    if (!message) return false;
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing info by URL pattern: ${message}`, 'info');
      return true;
    }
    
    // Check message content
    if (sup.ignoreInfoContaining.some(pattern => message.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing info by pattern: ${message}`, 'info');
      return true;
    }
    
    return false;
  }

  function shouldSuppressMissingField(field, schemaType, url = '') {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    const rule = SUPPRESSION_CONFIG.suppressions.rules[schemaType];
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing missing field by URL pattern: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check if schema type should be ignored
    if (sup.ignoreSchemaTypes.includes(schemaType)) {
      debugLog(`[SUPPRESSION] Suppressing missing field by schema type: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check if field is in ignoreRecommendedFields
    if (sup.ignoreRecommendedFields.includes(field)) {
      debugLog(`[SUPPRESSION] Suppressing missing field by recommended field list: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check type-specific rules
    if (rule) {
      if (rule.suppressMissingRecommended && field.toLowerCase().includes('recommended')) {
        debugLog(`[SUPPRESSION] Suppressing missing field by type rule (suppressMissingRecommended): ${schemaType}.${field}`, 'info');
        return true;
      }
      if (rule.requireOnly && !rule.requireOnly.includes(field)) {
        debugLog(`[SUPPRESSION] Suppressing missing field by type rule (requireOnly): ${schemaType}.${field}`, 'info');
        return true;
      }
    }
    
    return false;
  }

  function shouldSuppressSchemaType(schemaType) {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    return sup.ignoreSchemaTypes.includes(schemaType);
  }

  function shouldDowngradeDuplicate(schemaType) {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    const rule = SUPPRESSION_CONFIG.suppressions.rules[schemaType];
    
    if (sup.downgradeDuplicates) {
      return true;
    }
    
    if (rule && rule.collapseDuplicates) {
      return true;
    }
    
    return false;
  }

  function filterSuppressedWarnings(warnings, url = '') {
    if (!warnings || !Array.isArray(warnings)) return [];
    return warnings.filter(w => !shouldSuppressWarning(w, url));
  }

  function filterSuppressedInfo(info, url = '') {
    if (!info || !Array.isArray(info)) return [];
    return info.filter(i => !shouldSuppressInfo(i, url));
  }

  function filterSuppressedMissingFields(missingFields, schemaType, url = '') {
    if (!missingFields || !Array.isArray(missingFields)) return [];
    
    return missingFields.filter(field => {
      // Extract field name from different formats
      const fieldName = typeof field === 'string' 
        ? field.split(':')[1]?.trim().replace(/["\s]/g, '') || field.split('.')[1] || field
        : field.field || field;
      
      return !shouldSuppressMissingField(fieldName, schemaType, url);
    });
  }

  // Debug Console Logging Functions - MUST be first
  function debugLog(message, level = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const prefix = `[${timestamp}]`;
    
    // Console logging - use original methods to avoid recursion
    if (level === 'error') {
      originalConsoleError(`${prefix} ‚ùå ${message}`);
    } else if (level === 'warn') {
      originalConsoleWarn(`${prefix} ‚ö†Ô∏è ${message}`);
    } else if (level === 'success') {
      originalConsoleLog(`${prefix} ‚úÖ ${message}`);
    } else {
      originalConsoleLog(`${prefix} ${message}`);
    }
    
    // Also write to visible debug panel (statusDebugPanel) - REMOVED, using bottom debug console only
    // Remove this section - debug panel above table has been removed
    
    // Also write to existing debug console (debugConsoleContent)
    const consoleContent = document.getElementById('debugConsoleContent');
    if (consoleContent) {
      const entry = document.createElement('div');
      entry.className = `debug-log-entry ${level}`;
      
      const timeSpan = document.createElement('span');
      timeSpan.className = 'debug-log-time';
      timeSpan.textContent = prefix;
      
      const messageSpan = document.createElement('span');
      messageSpan.textContent = typeof message === 'object' ? JSON.stringify(message, null, 2) : message;
      
      entry.appendChild(timeSpan);
      entry.appendChild(messageSpan);
      consoleContent.appendChild(entry);
      
      // Auto-scroll to bottom
      consoleContent.scrollTop = consoleContent.scrollHeight;
      
      // Keep max 100 entries to prevent memory issues
      const entries = consoleContent.querySelectorAll('.debug-log-entry');
      if (entries.length > 100) {
        entries[0].remove();
      }
    }
  }
  
  function clearDebugConsole() {
    const consoleContent = document.getElementById('debugConsoleContent');
    if (consoleContent) {
      consoleContent.innerHTML = '<div class="debug-log-entry success"><span class="debug-log-time"></span>Debug console cleared.</div>';
    }
  }
  
  function copyDebugConsole() {
    const consoleContent = document.getElementById('debugConsoleContent');
    if (!consoleContent) return;
    
    const entries = consoleContent.querySelectorAll('.debug-log-entry');
    const logs = Array.from(entries).map(entry => {
      const time = entry.querySelector('.debug-log-time')?.textContent || '';
      const message = entry.textContent.replace(time, '').trim();
      return `${time} ${message}`;
    }).join('\n');
    
    navigator.clipboard.writeText(logs).then(() => {
      debugLog('‚úÖ Logs copied to clipboard!', 'success');
      setTimeout(() => {
        const lastEntry = consoleContent.querySelector('.debug-log-entry:last-child');
        if (lastEntry && lastEntry.textContent.includes('copied to clipboard')) {
          lastEntry.remove();
        }
      }, 2000);
    }).catch(err => {
      debugLog('‚ùå Failed to copy logs: ' + err.message, 'error');
    });
  }
  
  // Override console methods to also log to debug console (after debugLog is defined)
  console.log = function(...args) {
    originalConsoleLog.apply(console, args);
    const message = args.map(a => {
      if (typeof a === 'object') {
        try {
          return JSON.stringify(a, null, 2);
        } catch (e) {
          return String(a);
        }
      }
      return String(a);
    }).join(' ');
    // Use originalConsoleLog to avoid recursion
    if (message) {
      debugLog(message, 'info');
    }
  };
  
  console.error = function(...args) {
    originalConsoleError.apply(console, args);
    const message = args.map(a => {
      if (typeof a === 'object') {
        try {
          return JSON.stringify(a, null, 2);
        } catch (e) {
          return String(a);
        }
      }
      return String(a);
    }).join(' ');
    // Use originalConsoleError to avoid recursion
    if (message) {
      debugLog(message, 'error');
    }
  };
  
  console.warn = function(...args) {
    originalConsoleWarn.apply(console, args);
    const message = args.map(a => {
      if (typeof a === 'object') {
        try {
          return JSON.stringify(a, null, 2);
        } catch (e) {
          return String(a);
        }
      }
      return String(a);
    }).join(' ');
    // Use originalConsoleWarn to avoid recursion
    if (message) {
      debugLog(message, 'warn');
    }
  };

  // Supabase Configuration
  const SUPABASE_URL = 'https://igzvwbvgvmzvvzoclufx.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnenZ3YnZndm16dnZ6b2NsdWZ4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2Nzc5MjgsImV4cCI6MjA3MzI1MzkyOH0.A9TCmnXKJhDRYBkrO0mAMPiUQeV9enweeyRWKWQ1SZY';
  
  // Initialize Supabase client (wait for library to load)
  let supabase = null;
  let supabaseAvailable = false;
  
  // Wait for Supabase library to load
  function initSupabase() {
    // Check for Supabase library loaded via CDN (UMD build)
    if (typeof window.supabase !== 'undefined' && typeof window.supabase.createClient === 'function') {
      try {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        supabaseAvailable = true;
        console.log('‚úÖ Supabase client initialized successfully');
        
        // Update bulk buttons state when Supabase is available
        updateBulkButtons();
        
        return true;
      } catch (error) {
        console.error('Failed to initialize Supabase client:', error);
      }
    }
    return false;
  }
  
  // Try to initialize when script loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      if (!initSupabase()) {
        // Retry after delays
        setTimeout(initSupabase, 500);
        setTimeout(initSupabase, 1500);
      }
    });
  } else {
    if (!initSupabase()) {
      // Retry after delays
      setTimeout(initSupabase, 500);
      setTimeout(initSupabase, 1500);
    }
  }
  
  // Final retry after all scripts load
  window.addEventListener('load', function() {
    if (!supabaseAvailable) {
      initSupabase();
    }
    // Load auto-run preference
    loadAutoRunPreference();
    // Load auto-save preference
    loadAutoSavePreference();
  });
  
  
  // Progress bar helpers
  function renderProgress(cell) {
    cell.innerHTML = `
      <div class="progress-wrap">
        <div class="progress"><span style="width:0%"></span></div>
        <div class="progress-label">0%</div>
      </div>`;
  }
  
  function setProgress(cell, pct, text) {
    const bar = cell.querySelector('.progress > span');
    const lbl = cell.querySelector('.progress-label');
    if (bar) { bar.style.width = Math.max(0, Math.min(100, pct)) + '%'; }
    if (lbl) { lbl.textContent = (text ? text + ' ¬∑ ' : '') + Math.round(pct) + '%'; }
  }
  
  function markProgressError(cell) {
    const bar = cell.querySelector('.progress > span');
    if (bar) { bar.style.background = 'linear-gradient(90deg,#ff5252,#ff8a80)'; }
  }
  
  // ---- NEW: Modal helpers --------------------------------------
  function openModal(title, html) {
    let modal = document.querySelector('#detail-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'detail-modal';
      modal.innerHTML = `
        <div class="modal-backdrop"></div>
        <div class="modal">
          <div class="modal-head">
            <h3 id="modal-title"></h3>
            <button id="modal-close" aria-label="Close">‚úñ</button>
          </div>
          <div class="modal-body"></div>
        </div>`;
      document.body.appendChild(modal);
      modal.querySelector('#modal-close').onclick = () => modal.remove();
      modal.querySelector('.modal-backdrop').onclick = () => modal.remove();
    }
    modal.querySelector('#modal-title').textContent = title;
    modal.querySelector('.modal-body').innerHTML = html;
  }

  function codeBlock(label, code) {
    return `
      <div class="code-card">
        <div class="code-card-head">
          <strong>${label}</strong>
          <button class="copy-btn" data-code="${encodeURIComponent(code)}">Copy</button>
        </div>
        <pre><code>${escapeHtml(code)}</code></pre>
      </div>`;
  }

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }

  // Copy button handler
  document.addEventListener('click', (e) => {
    const copy = e.target.closest('.copy-btn');
    if (!copy) return;
    const code = decodeURIComponent(copy.dataset.code || '');
    navigator.clipboard.writeText(code).then(() => { 
      copy.textContent = 'Copied'; 
      setTimeout(() => copy.textContent = 'Copy', 1200); 
    });
  });

  // Minimal extractor: same logic you use in the scanner, but HTML-in
  function extractJsonLdBlocksFromHtml(html) {
    const blocks = [];
    const re = /<script[^>]+type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi;
    let m;
    while ((m = re.exec(html))) {
      try {
        const json = JSON.parse(m[1].trim());
        if (Array.isArray(json)) json.forEach(j => blocks.push(j));
        else if (json['@graph']) json['@graph'].forEach(j => blocks.push(j));
        else blocks.push(json);
      } catch {}
    }
    return blocks;
  }

  // Build a single, cleaned-up, recommended schema graph
  function buildEnhancedSchema(blocks) {
    const graph = [];
    const types = t => Array.isArray(t) ? t : [t].filter(Boolean);
    const seen = new Set();
    const add = (node) => {
      const key = JSON.stringify([types(node['@type']).sort(), node['@id'] || node.url || node.name]);
      if (seen.has(key)) return;
      seen.add(key);
      graph.push(node);
    };

    // Merge Organization/LocalBusiness
    const org = {
      '@type': ['Organization','LocalBusiness'],
      '@id': 'https://www.alanranger.com/#org',
      name: 'Alan Ranger Photography',
      url: 'https://www.alanranger.com/',
      telephone: '+44 7817 017994',
      image: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w'
    };

    // Keep existing ItemList/Event/etc., but ensure @id where missing
    blocks.forEach(b => {
      const ts = types(b['@type']);
      if (ts.includes('Organization') || ts.includes('LocalBusiness')) {
        // prefer our canonical org baseline merged
        return;
      }
      if (!b['@id'] && (b.url || b.name)) b['@id'] = (b.url || `#${(b.name||'node').toLowerCase().replace(/\s+/g,'-')}`);
      add(b);
    });

    add(org);

    return { '@context': 'https://schema.org', '@graph': graph };
  }

  // Event delegation for View Details and Generate Enhanced buttons
  document.addEventListener('click', async (e) => {
      // View Details - use new improved modal
      const view = e.target.closest('.btn-view-details, [data-action="view-details"], .view-details-btn');
      if (view) {
        const row = view.closest('tr');
        if (!row) return;
        const rowData = getRowDataFromTr(row);
        openIssuesModal(rowData);
        return;
      }

    // Generate Enhanced
    const gen = e.target.closest('.btn-generate-enhanced, [data-action="generate-enhanced"], .enhance-btn');
    if (gen && (gen.textContent.includes('Generate Enhanced') || gen.id?.includes('genBtn'))) {
      const row = gen.closest('tr');
      const url = row?.dataset?.url || row?.querySelector('a.url-link')?.href;
      if (!url) {
        alert('Could not determine URL for this row.');
        return;
      }
      
      try {
        // Update button state
        const originalText = gen.textContent;
        gen.disabled = true;
        gen.textContent = 'Fetching...';
        
        // Server-side fetch (avoids CORS)
        const res = await fetch(`/api/fetch-html?url=${encodeURIComponent(url)}`, { method: 'GET' });
        if (!res.ok) throw new Error(`Server fetch failed: ${res.status}`);
        const html = await res.text();

        // Extract JSON-LD blocks from HTML
        const blocks = extractJsonLdBlocksFromHtml(html);
        // Build an enhanced consolidated schema suggestion
        const enhanced = buildEnhancedSchema(blocks);

        gen.textContent = originalText;
        gen.disabled = false;
        
        // Use the proper Enhanced Schema modal instead of openModal
        const backdrop = document.getElementById('genBackdrop');
        const metaEl = document.getElementById('genMeta');
        const jsonEl = document.getElementById('genJson');
        const titleEl = document.getElementById('genTitle');
        if (backdrop && metaEl && jsonEl && titleEl) {
          titleEl.textContent = 'Enhanced Schema (suggestion)';
          metaEl.textContent = url;
          jsonEl.textContent = JSON.stringify(enhanced, null, 2);
          // Store URL and JSON for save function
          backdrop.dataset.url = url;
          backdrop.dataset.json = JSON.stringify(enhanced, null, 2);
          backdrop.style.display = 'flex';
          setupCopyButton();
          setupSaveButton();
        } else {
          openModal('Enhanced Schema (suggestion)', codeBlock('Paste this in a single <script type="application/ld+json">', JSON.stringify(enhanced, null, 2)));
        }
      } catch (err) {
        gen.textContent = originalText;
        gen.disabled = false;
        alert(`Enhanced Schema Error: ${escapeHtml(err.message)}\n\nTip: server route must exist at /api/fetch-html.`);
      }
    }
  });
  
  // Helper: Collect existing schema types from the page
  function collectExistingSchemaTypes(jsonLdBlocks) {
    const types = new Set();
    
    if (!jsonLdBlocks || !Array.isArray(jsonLdBlocks)) {
      return [];
    }
    
    jsonLdBlocks.forEach(block => {
      try {
        // Handle @graph structure
        if (block['@graph'] && Array.isArray(block['@graph'])) {
          block['@graph'].forEach(item => {
            if (item['@type']) {
              const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
              itemTypes.forEach(t => types.add(t));
            }
          });
        }
        // Handle array of schemas
        else if (Array.isArray(block)) {
          block.forEach(item => {
            if (item['@type']) {
              const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
              itemTypes.forEach(t => types.add(t));
            }
          });
        }
        // Handle single schema object
        else if (block['@type']) {
          const blockTypes = Array.isArray(block['@type']) ? block['@type'] : [block['@type']];
          blockTypes.forEach(t => types.add(t));
        }
      } catch (e) {
        console.warn('Invalid JSON-LD block ignored:', e);
      }
    });
    
    return Array.from(types);
  }

  // Helper: Determine required schema types based on missing fields
  function determineRequiredSchemaTypes(missingFields, missingRecommended, existingTypes = []) {
    const globalTypes = ['Organization', 'LocalBusiness', 'Person', 'Service', 'WebSite', 'BreadcrumbList'];
    
    // Check which global types already exist
    const existingGlobalTypes = existingTypes.filter(t => globalTypes.includes(t));
    
    const needsOrg = missingFields.some(f => f.includes('Organization')) || 
                    missingRecommended.some(f => f.includes('Organization') || f.includes('url') || f.includes('logo'));
    const needsLocal = missingFields.some(f => f.includes('LocalBusiness')) || 
                       missingRecommended.some(f => f.includes('LocalBusiness') || f.includes('address') || f.includes('telephone'));
    const needsWebSite = missingFields.some(f => f.includes('WebSite')) || 
                         missingRecommended.some(f => f.includes('WebSite'));
    
    const types = [];
    
    // Only add Organization if it doesn't already exist
    if ((needsOrg || needsLocal) && !existingGlobalTypes.includes('Organization')) {
      types.push('Organization');
    }
    
    // Only add LocalBusiness if it doesn't already exist
    if (needsLocal && !existingGlobalTypes.includes('LocalBusiness')) {
      types.push('LocalBusiness');
    }
    
    // Only add WebSite if it doesn't already exist
    if (needsWebSite && !existingGlobalTypes.includes('WebSite')) {
      types.push('WebSite');
    }
    
    // Don't add default types if global schemas already exist
    if (types.length === 0 && existingGlobalTypes.length === 0) {
      types.push('Organization', 'LocalBusiness');
    }
    
    return types;
  }

  // Helper: Add recommended fields to fix object
  function addRecommendedFieldsToFix(fix, missingRecommended, baseUrl) {
    if (missingRecommended.includes('url')) {
      fix["url"] = baseUrl;
    }
    if (missingRecommended.includes('logo')) {
      fix["logo"] = "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w";
    }
    if (missingRecommended.includes('image')) {
      fix["image"] = fix["logo"] || "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w";
    }
    if (missingRecommended.includes('description')) {
      fix["description"] = "UK Landscape Photography Workshops, Private Tuition, and Online Classes by Alan Ranger, Qualified Tutor and Professional Photographer.";
    }
    if (missingRecommended.includes('address')) {
      fix["address"] = {
        "@type": "PostalAddress",
        "streetAddress": "45 Hathaway Road, Tile Hill Village",
        "addressLocality": "Coventry",
        "addressRegion": "West Midlands",
        "postalCode": "CV4 9HW",
        "addressCountry": "GB"
      };
    }
    if (missingRecommended.includes('telephone')) {
      fix["telephone"] = "+44 7817 017994";
    }
    if (missingRecommended.includes('sameAs')) {
      fix["sameAs"] = [
        "https://www.facebook.com/alanrangerphotography",
        "https://www.instagram.com/alanrangerphoto",
        "https://www.youtube.com/@alanrangerphotography"
      ];
    }
  }

  // Helper: Build recommended fix based on missing fields
  function buildRecommendedFix(url, missingFields = [], missingRecommended = [], existingTypes = []) {
    const baseUrl = url.split('#')[0];
    
    const types = determineRequiredSchemaTypes(missingFields, missingRecommended, existingTypes);
    
    // If no types to add (all global types already exist), return null
    if (types.length === 0) {
      return null;
    }
    
    const fix = {
      "@context": "https://schema.org"
    };
    
    fix["@type"] = types.length === 1 ? types[0] : types;
    fix["@id"] = `${baseUrl}#org`;
    fix["name"] = "Alan Ranger Photography";
    
    // Add url if missing
    if (missingRecommended.includes('url') || missingFields.some(f => f.includes('url'))) {
      fix["url"] = baseUrl;
    }
    
    // Add recommended fields
    addRecommendedFieldsToFix(fix, missingRecommended, baseUrl);
    
    // Add address if missing (for LocalBusiness)
    const needsLocal = types.includes('LocalBusiness');
    if (needsLocal && (missingRecommended.includes('address') || missingFields.some(f => f.includes('address')))) {
      if (!fix["address"]) {
        fix["address"] = {
          "@type": "PostalAddress",
          "streetAddress": "45 Hathaway Road, Tile Hill Village",
          "addressLocality": "Coventry",
          "addressRegion": "West Midlands",
          "postalCode": "CV4 9HW",
          "addressCountry": "GB"
        };
      }
    }
    
    return JSON.stringify(fix, null, 2);
  }

  function getRecommendedSchema(url, existingTypes = []) {
    // Use the new buildRecommendedFix function for consistency
    return buildRecommendedFix(url, [], [], existingTypes);
  }

  // Helper: Parse issues list from rowData
  function parseIssuesList(rowData) {
    let issuesList = [];
    try {
      if (rowData.tr && rowData.tr.dataset.issuesList) {
        issuesList = JSON.parse(rowData.tr.dataset.issuesList);
      } else if (rowData.issuesList) {
        issuesList = rowData.issuesList;
      } else if (rowData.tr && rowData.tr.dataset.missingDetail) {
        const missing = JSON.parse(rowData.tr.dataset.missingDetail);
        issuesList = missing.map(m => ({ message: m, type: 'Unknown' }));
      } else if (rowData.missingFields) {
        const missing = Array.isArray(rowData.missingFields) ? rowData.missingFields : String(rowData.missingFields).split(',').map(s => s.trim()).filter(Boolean);
        issuesList = missing.map(m => ({ message: m, type: 'Unknown' }));
      }
    } catch (err) {
      console.warn('Failed to parse issues data:', err);
    }
    return issuesList;
  }

  // Helper: Determine severity badge from issues
  function determineSeverityBadge(issueCount, duplicates) {
    if (duplicates.length > 2 || issueCount > 3) {
      return { severity: 'critical', badgeColor: 'severity-badge critical', badgeLabel: '‚ùå Critical' };
    }
    if (issueCount > 0 || duplicates.length > 0) {
      return { severity: 'warning', badgeColor: 'severity-badge warning', badgeLabel: '‚ö†Ô∏è Issues' };
    }
    return { severity: 'passed', badgeColor: 'severity-badge passed', badgeLabel: '‚úÖ Passed' };
  }

  // Helper: Build human-readable summary for modal
  function buildHumanReadableSummary(blockCount, schemaTypes, duplicates, missingFieldsBadges) {
    const parts = [];
    
    if (blockCount > 0) {
      parts.push(`Found ${blockCount} JSON-LD block${blockCount !== 1 ? 's' : ''}`);
    }
    
    if (schemaTypes && schemaTypes.length > 0) {
      const typesList = Array.isArray(schemaTypes) ? schemaTypes.join(', ') : schemaTypes;
      const uniqueTypesCount = Array.isArray(schemaTypes) ? schemaTypes.length : (schemaTypes.split(',').map(t => t.trim()).filter(Boolean).length);
      parts.push(`${uniqueTypesCount} unique schema type${uniqueTypesCount !== 1 ? 's' : ''}: ${typesList}`);
    }
    
    // Only show duplicate count for non-multi-instance types
    if (duplicates && duplicates.length > 0) {
      const nonMultiInstanceDuplicates = duplicates.filter(d => !MULTI_INSTANCE_ALLOWED_TYPES.includes(d));
      if (nonMultiInstanceDuplicates.length > 0) {
        parts.push(`${nonMultiInstanceDuplicates.length} duplicate${nonMultiInstanceDuplicates.length !== 1 ? 's' : ''} detected`);
      }
    }
    
    if (missingFieldsBadges && missingFieldsBadges.length > 0) {
      parts.push(`${missingFieldsBadges.length} missing field${missingFieldsBadges.length !== 1 ? 's' : ''}`);
    }
    
    return parts.length > 0 ? parts.join('. ') : 'No schema data available.';
  }

  // Helper: Build schema table HTML for modal
  function buildSchemaTableHtml(result) {
    if (!result || !result.schemas || result.schemas.length === 0) {
      return '';
    }
    
    let tableHtml = `
      <div style="margin-top: 1.5rem;">
        <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 600;">Detected Schema Nodes</h4>
        <table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
          <thead>
            <tr style="background: #f3f4f6; border-bottom: 2px solid #d1d5db;">
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Type</th>
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">@id</th>
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Name</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    for (const s of result.schemas) {
      const schema = s.schema || {};
      const isSystem = s.systemInjected ? 'system-node' : '';
      const typeDisplay = Array.isArray(s.type) ? s.type.join(', ') : s.type;
      const idDisplay = schema['@id'] || '‚Äî';
      const nameDisplay = schema.name || '‚Äî';
      
      tableHtml += `
        <tr class="${isSystem}" style="border-bottom: 1px solid #e5e7eb;">
          <td style="padding: 0.5rem;">${typeDisplay}</td>
          <td style="padding: 0.5rem;">${idDisplay}</td>
          <td style="padding: 0.5rem;">${nameDisplay}</td>
        </tr>
      `;
    }
    
    tableHtml += `
          </tbody>
        </table>
      </div>
    `;
    
    return tableHtml;
  }

  // Helper: Check if Organization nodes need recommended fix
  function checkOrganizationNodesForFix(result, missingFieldsBadges, existingTypes = []) {
    const globalTypes = ['Organization', 'LocalBusiness', 'Person', 'Service', 'WebSite', 'BreadcrumbList'];
    const existingGlobalTypes = existingTypes.filter(t => globalTypes.includes(t));
    
    // If global types already exist, don't show recommended fix
    if (existingGlobalTypes.length > 0) {
      return { shouldShowRecommendedFix: false, hasValidOrgNode: true, existingGlobalTypes };
    }
    
    let shouldShowRecommendedFix = false;
    let hasValidOrgNode = false;
    
    if (result && result.schemas) {
      const orgSchemas = result.schemas.filter(s => s.type === 'Organization' || (Array.isArray(s.type) && s.type.includes('Organization')));
      if (orgSchemas.length > 0) {
        const allMissingRequired = orgSchemas.every(s => {
          const schema = s.schema || {};
          const hasName = schema.name && schema.name.trim();
          const hasUrl = schema.url && schema.url.trim();
          const hasId = schema['@id'] && schema['@id'].trim();
          return !hasName && !hasUrl && !hasId;
        });
        hasValidOrgNode = orgSchemas.some(s => {
          const schema = s.schema || {};
          return schema.name && schema.name.trim();
        });
        shouldShowRecommendedFix = allMissingRequired && !hasValidOrgNode;
      } else {
        shouldShowRecommendedFix = true;
      }
    } else {
      const orgMissingFields = missingFieldsBadges.filter(m => m.type === 'Organization');
      const orgMissingRequired = orgMissingFields.some(m => ['name', 'url'].includes(m.field));
      shouldShowRecommendedFix = orgMissingRequired && orgMissingFields.length > 0;
    }
    
    return { shouldShowRecommendedFix, hasValidOrgNode, existingGlobalTypes: [] };
  }

  // Helper: Build recommended fix HTML
  function buildRecommendedFixHtml(shouldShowRecommendedFix, hasValidOrgNode, recommendedFix, existingGlobalTypes = []) {
    if (shouldShowRecommendedFix && recommendedFix) {
      return `
        <div class="recommended-fix-card">
          <h4>Recommended Fix (for Squarespace footer injection)</h4>
          <p>Copy and paste the following schema block into your Squarespace <strong>Settings ‚Üí Advanced ‚Üí Code Injection ‚Üí Footer</strong> section.</p>
          <textarea class="recommended-fix-textarea" readonly id="recommendedSchemaText">${recommendedFix}</textarea>
          <button class="copy-schema-btn" id="copySchemaBtn">üìã Copy Recommended Schema</button>
        </div>
      `;
    }
    if (hasValidOrgNode || existingGlobalTypes.length > 0) {
      const globalTypesList = existingGlobalTypes.length > 0 
        ? existingGlobalTypes.join(', ')
        : 'Organization';
      return `
        <div class="recommended-fix-card" style="background: #f0fdf4; border-color: #10b981;">
          <h4 style="color: #065f46;">‚úÖ Detected global schema types ‚Äî no extra injection required</h4>
          <p style="color: #047857;">Found existing ${globalTypesList} schema${existingGlobalTypes.length > 1 ? 's' : ''} on this page. Your global schema structure is correct. Recommendations will only appear for missing page-specific types (Product, Event, Article, Course, etc.).</p>
        </div>
      `;
    }
    return '';
  }

  // Helper: Setup modal button handlers
  function setupModalButtonHandlers(recommendedFix, json, jsonDetails, rowData) {
    const copyBtn = document.getElementById('copySchemaBtn');
    if (copyBtn) {
      copyBtn.onclick = () => {
        const textarea = document.getElementById('recommendedSchemaText');
        textarea.select();
        navigator.clipboard.writeText(recommendedFix).then(() => {
          copyBtn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            copyBtn.textContent = 'üìã Copy Recommended Schema';
          }, 2000);
        }).catch(err => {
          console.error('Failed to copy:', err);
          copyBtn.textContent = '‚ùå Copy Failed';
          setTimeout(() => {
            copyBtn.textContent = 'üìã Copy Recommended Schema';
          }, 2000);
        });
      };
    }
    
    json.textContent = (rowData.firstJsonLd || '').trim();
    jsonDetails.style.display = rowData.firstJsonLd ? 'block' : 'none';
    
    const copyJsonBtn = document.getElementById('issuesCopyJsonBtn');
    if (copyJsonBtn) {
      copyJsonBtn.onclick = async () => {
        const jsonText = json.textContent.trim();
        if (!jsonText) {
          alert('No JSON-LD content to copy');
          return;
        }
        try {
          await navigator.clipboard.writeText(jsonText);
          copyJsonBtn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            copyJsonBtn.textContent = 'Copy JSON-LD';
          }, 2000);
        } catch (err) {
          const textarea = document.createElement('textarea');
          textarea.value = jsonText;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
            copyJsonBtn.textContent = '‚úÖ Copied!';
            setTimeout(() => {
              copyJsonBtn.textContent = 'Copy JSON-LD';
            }, 2000);
          } catch (e) {
            alert('Failed to copy. Please select and copy manually.');
          }
          textarea.remove();
        }
      };
    }
  }

  // ---- Issues modal helpers ----
  function openIssuesModal(rowData) {
    const backdrop = document.getElementById('issuesBackdrop');
    const meta = document.getElementById('issuesMeta');
    const content = document.getElementById('issuesContent');
    const list = document.getElementById('issuesList');
    const json = document.getElementById('issuesJson');
    const jsonDetails = document.getElementById('issuesJsonDetails');
    const btnSchema = document.getElementById('issuesSchemaOrgBtn');
    const btnGoogle = document.getElementById('issuesGoogleBtn');
    const closeBtn = document.getElementById('issuesCloseBtn');
    const closeXBtn = document.getElementById('issuesCloseXBtn');
    
    // Get cached result data
    const cachedData = ResultCache.get(rowData.url) || {};
    const rowIndex = rowData.tr ? Array.from(rowData.tr.parentNode.children).indexOf(rowData.tr) : -1;
    const result = rowIndex >= 0 ? validationResults[rowIndex] : null;
    
    // Merge cached data with validation result
    const blocks = cachedData.blocks || result?.schemas?.map(s => s.schema).filter(Boolean) || [];
    const issuesList = parseIssuesList(rowData);
    const missingFields = result?.missingFields || cachedData.warnings?.filter(w => w.includes('missing')) || [];
    const warnings = result?.warnings || cachedData.warnings || [];
    const info = result?.info || cachedData.info || [];
    
    meta.textContent = `${rowData.url} ¬∑ Types: ${rowData.schemaType || 'None'}`;
    content.innerHTML = '';
    list.innerHTML = '';
    
    const missingFieldsBadges = result?.missingFieldsBadges || [];
    // Filter duplicates to exclude multi-instance allowed types
    const duplicates = issuesList
      .filter(i => i.message && i.message.includes('DUPLICATE'))
      .map(i => i.type)
      .filter(type => !MULTI_INSTANCE_ALLOWED_TYPES.includes(type));
    const schemaTypes = rowData.schemaType ? rowData.schemaType.split(', ') : (cachedData.schemaTypes || []);
    const issueCount = issuesList.filter(i => i.message && i.message.includes('missing')).length;
    // Use actual block count from result or cached data
    const blockCount = result?.blockCount || blocks.length || result?.schemas?.length || 0;
    
    // Get inferred types from result
    const inferredTypes = result?.inferredTypes || [];
    
    // Collect existing schema types from blocks
    const existingTypes = collectExistingSchemaTypes(blocks);
    
    const severityBadge = determineSeverityBadge(issueCount, duplicates);
    const humanReadableSummary = buildHumanReadableSummary(blockCount, schemaTypes, duplicates, missingFieldsBadges);
    const orgFixCheck = checkOrganizationNodesForFix(result, missingFieldsBadges, existingTypes);
    
    // Build inferred types HTML section
    let inferredTypesHtml = '';
    if (inferredTypes.length > 0) {
      inferredTypesHtml = `
        <div style="margin-top: 1.5rem; padding: 1rem; background: #f9fafb; border-radius: 8px; border-left: 4px solid #6b7280;">
          <h4 style="margin: 0 0 0.75rem 0; font-size: 1rem; font-weight: 600; color: #374151;">Inferred Structured Data Types</h4>
          <p style="margin: 0 0 0.75rem 0; font-size: 0.875rem; color: #6b7280;">Based on schema relationships and patterns:</p>
          <ul style="margin: 0; padding-left: 1.5rem; list-style: disc;">
            ${inferredTypes.map(item => `<li style="margin-bottom: 0.5rem;"><strong>${item.type}</strong> (${item.reason})</li>`).join('')}
          </ul>
        </div>
      `;
    }
    
    // Extract missing recommended fields from warnings
    const missingRecommended = warnings.filter(w => w.includes('Missing recommended:')).map(w => {
      const match = w.match(/Missing recommended: (\w+)/);
      return match ? match[1] : null;
    }).filter(Boolean);
    
    // Extract missing required fields
    const missingRequiredFields = missingFields.filter(f => typeof f === 'string' && f.includes('missing')).map(f => {
      const match = f.match(/(\w+):\s*"(\w+)"\s*missing/);
      return match ? `${match[1]}.${match[2]}` : null;
    }).filter(Boolean);
    
    // Build recommended fix using the new function with existing types
    const recommendedFix = buildRecommendedFix(rowData.url, missingRequiredFields, missingRecommended, existingTypes);
    const recommendedFixHtml = buildRecommendedFixHtml(
      orgFixCheck.shouldShowRecommendedFix || (missingRecommended.length > 0 && recommendedFix !== null), 
      orgFixCheck.hasValidOrgNode, 
      recommendedFix,
      orgFixCheck.existingGlobalTypes || []
    );
    const schemaTableHtml = buildSchemaTableHtml(result);
    
    // Build issues list HTML
    let issuesHtml = '';
    if (issuesList.length === 0 && missingFields.length === 0 && warnings.length === 0) {
      issuesHtml = '<li>None</li>';
    } else {
      if (missingFields.length > 0) {
        issuesHtml += missingFields.map(f => `<li class="missing-entry">‚ùå ${f}</li>`).join('');
      }
      if (warnings.length > 0) {
        issuesHtml += warnings.map(w => `<li class="warning-entry">‚ö†Ô∏è ${w}</li>`).join('');
      }
      if (info.length > 0) {
        issuesHtml += info.map(i => `<li class="info-entry">${i}</li>`).join('');
      }
    }
    
    // Show JSON-LD blocks if available
    let jsonLdHtml = '';
    if (blocks.length > 0) {
      jsonDetails.style.display = 'none'; // Hide the old single block display
      const blocksHtml = blocks.map((block, idx) => {
        const blockJson = JSON.stringify(block, null, 2);
        return `
          <div class="json-block-card" style="margin-bottom: 1rem; border: 1px solid #e2e8f0; border-radius: 8px; overflow: hidden;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem; background: #f7fafc; border-bottom: 1px solid #e2e8f0;">
              <h5 style="margin: 0; font-size: 0.9rem; font-weight: 600;">JSON-LD Block #${idx + 1}</h5>
              <button class="copy-block-btn secondary" data-block-index="${idx}" style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: #2563eb; color: white; border-color: #2563eb; cursor: pointer; border-radius: 4px;">üìã Copy Block ${idx + 1}</button>
            </div>
            <pre style="margin: 0; padding: 1rem; background: #000; color: #fff; overflow-x: auto; font-size: 0.85rem; max-height: 400px; overflow-y: auto;">${escapeHtml(blockJson)}</pre>
          </div>
        `;
      }).join('');
      
      jsonLdHtml = `
        <div style="margin-top: 1.5rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <h4 style="margin: 0; font-size: 1rem; font-weight: 600;">JSON-LD Blocks (${blocks.length})</h4>
            <button class="copy-all-blocks-btn secondary" style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: #2563eb; color: white; border-color: #2563eb; cursor: pointer;">üìã Copy All Blocks</button>
          </div>
          ${blocksHtml}
        </div>
      `;
      
      // Store blocks data for copy functionality
      backdrop.dataset.blocksJson = JSON.stringify(blocks);
    } else {
      jsonDetails.style.display = 'none';
      jsonLdHtml = '<p style="color: #6b7280; font-style: italic; margin-top: 1.5rem;">No JSON-LD blocks captured.</p>';
    }
    
    content.innerHTML = `
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem;">
        <h3 style="margin: 0; font-size: 1.25rem; font-weight: 600;">Schema Analysis Summary</h3>
        <span class="${severityBadge.badgeColor}">${severityBadge.badgeLabel}</span>
      </div>
      
      <div class="summary-card">
        <pre>${humanReadableSummary.trim()}</pre>
      </div>
      
      <div style="margin-top: 1.5rem;">
        <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 600;">Issues</h4>
        <ul class="issues-list" style="list-style: none; padding: 0; margin: 0;">
          ${issuesHtml || '<li>None</li>'}
        </ul>
      </div>
      
      ${recommendedFixHtml}
      
      ${inferredTypesHtml}
      
      ${schemaTableHtml}
      
      ${jsonLdHtml}
      
      <div class="help-link">
        ${orgFixCheck.shouldShowRecommendedFix ? '<p>Need help implementing this? ' : ''}
        ${orgFixCheck.shouldShowRecommendedFix ? '<a href="https://support.squarespace.com/hc/en-us/articles/206543167" target="_blank">View Squarespace injection guide</a></p>' : ''}
        <p style="margin-top: 0.5rem; font-style: italic; color: #6b7280;">
          Diagnostic: ${issueCount} missing field${issueCount !== 1 ? 's' : ''}${duplicates.length > 0 ? `, ${duplicates.length} duplicate type${duplicates.length !== 1 ? 's' : ''} detected` : ''}${result?.multiInstanceCounts && Object.keys(result.multiInstanceCounts).length > 0 ? `. ${Object.entries(result.multiInstanceCounts).map(([type, count]) => `${count} ${type}${count !== 1 ? 's' : ''}`).join(', ')} detected (expected)` : ''}.
        </p>
      </div>
    `;
    
    setupModalButtonHandlers(recommendedFix, json, jsonDetails, rowData);
    
    btnSchema.onclick = () => globalThis.open('https://validator.schema.org/?url=' + encodeURIComponent(rowData.url), '_blank');
    btnGoogle.onclick = () => globalThis.open('https://search.google.com/test/rich-results?url=' + encodeURIComponent(rowData.url), '_blank');
    
    function close() {
      backdrop.close();
      document.removeEventListener('keydown', esc);
    }
    function esc(e) {
      if (e.key === 'Escape') close();
    }
    closeBtn.onclick = close;
    if (closeXBtn) {
      closeXBtn.onclick = close;
    }
    backdrop.onclick = (e) => {
      if (e.target === backdrop) close();
    };
    backdrop.showModal();
    
    // Setup copy button handlers after modal is opened and content is rendered
    setTimeout(() => {
      // Copy individual block buttons
      const copyBlockBtns = backdrop.querySelectorAll('.copy-block-btn');
      console.log(`Found ${copyBlockBtns.length} copy block buttons`);
      copyBlockBtns.forEach(btn => {
        btn.onclick = () => {
          const blockIndex = parseInt(btn.dataset.blockIndex);
          const blocksData = JSON.parse(backdrop.dataset.blocksJson || '[]');
          if (blocksData[blockIndex]) {
            const blockJson = JSON.stringify(blocksData[blockIndex], null, 2);
            navigator.clipboard.writeText(blockJson).then(() => {
              btn.textContent = '‚úÖ Copied!';
              setTimeout(() => {
                btn.textContent = `üìã Copy Block ${blockIndex + 1}`;
              }, 2000);
            }).catch(() => {
              alert('Failed to copy. Please select and copy manually.');
            });
          }
        };
      });
      
      // Copy all blocks button
      const copyAllBtn = backdrop.querySelector('.copy-all-blocks-btn');
      console.log(`Copy all blocks button found: ${!!copyAllBtn}`);
      if (copyAllBtn) {
        copyAllBtn.onclick = () => {
          const blocksData = JSON.parse(backdrop.dataset.blocksJson || '[]');
          const allBlocksJson = JSON.stringify(blocksData, null, 2);
          navigator.clipboard.writeText(allBlocksJson).then(() => {
            copyAllBtn.textContent = '‚úÖ All Copied!';
            setTimeout(() => {
              copyAllBtn.textContent = 'üìã Copy All Blocks';
            }, 2000);
          }).catch(() => {
            alert('Failed to copy. Please select and copy manually.');
          });
        };
      } else {
        console.warn('Copy all blocks button not found in modal');
      }
    }, 300);
  }
  
  // Build a minimal rowData snapshot from a <tr>
  function getRowDataFromTr(tr) {
    const tds = tr.querySelectorAll('td');
    const url = tds[0]?.querySelector('a')?.href || tds[0]?.textContent?.trim() || '';
    // keep a handle to <tr> so we can read dataset fields
    const trRef = tr;
    const schemaType = tds[1]?.textContent?.trim() || '';
    const missing = tds[3]?.textContent?.trim() || '';
    // store first JSON-LD snippet in a dataset if available when row was computed
    const firstJson = tr.dataset.firstJsonld || '';
    // Get index from row to find validation result
    const rowIndex = Array.from(tr.parentNode.children).indexOf(tr);
    const result = validationResults[rowIndex];
    
    let issuesList = [];
    if (result && result.issuesList) {
      issuesList = result.issuesList;
    } else if (tr.dataset.issuesList) {
      try {
        issuesList = JSON.parse(tr.dataset.issuesList);
      } catch (e) {
        console.warn('Failed to parse issuesList:', e);
      }
    }
    
    let missingFields;
    if (result && result.missingFields) {
      missingFields = result.missingFields;
    } else if (missing) {
      missingFields = missing.split(',').map(s => s.trim()).filter(Boolean);
    } else {
      missingFields = [];
    }
    
    return { 
      url, 
      schemaType, 
      missingFields: missingFields, 
      firstJsonLd: firstJson, 
      tr: trRef, 
      issuesList,
      schemaSummary: result && result.schemaSummary ? result.schemaSummary : null
    };
  }
  
  // ---- Schema core fields (minimal, safe set) ----
  const CORE_REQUIRED = {
    WebSite:      ["name", "url"],
    Organization: ["name"],
    LocalBusiness:["name"]   // keep minimal; address/telephone vary a lot
  };
  
  // Flatten any JSON-LD object/array/@graph into a list of typed nodes
  function flattenJsonLd(node, out = []) {
    if (!node) return out;
    if (Array.isArray(node)) { node.forEach(n=>flattenJsonLd(n, out)); return out; }
    if (node['@graph']) { flattenJsonLd(node['@graph'], out); }
    if (node['@type']) out.push(node);
    return out;
  }
  
  // Build a map: type -> array of nodes for that type
  function indexByType(nodes) {
    const idx = {};
    nodes.forEach(n => {
      const types = Array.isArray(n['@type']) ? n['@type'] : [n['@type']];
      types.forEach(t => {
        (idx[t] ||= []).push(n);
      });
    });
    return idx;
  }
  
  // Helper: Check if field is missing for a node
  function isFieldMissing(node, field) {
    return !node.hasOwnProperty(field) || !node[field];
  }

  // Helper: Check if message already exists for this type+field+key combination
  function isAlreadyFlagged(messages, type, field, key) {
    return messages.some(m => m.type === type && m.field === field && m.key === key);
  }

  // Helper: Check if node is system-injected (Squarespace auto-generated)
  function isSystemInjectedNode(type, node) {
    return type === 'Organization' && 
      !node['@id'] && 
      (!node.name || !node.name.trim()) && 
      (!node.url || !node.url.trim());
  }

  // Helper: Process required fields for a node group
  function processRequiredFieldsForNode(messages, type, field, key, firstNode, instances) {
    if (isFieldMissing(firstNode, field) && !isAlreadyFlagged(messages, type, field, key)) {
      messages.push({ 
        type: type, 
        field: field, 
        nodeIndex: instances[0].index,
        key: key,
        instances: instances.length,
        hasId: !!firstNode['@id'],
        systemInjected: isSystemInjectedNode(type, firstNode)
      });
    }
  }

  // Inspect which types are present and which required fields are missing per type
  function computeMissingFields(allNodes) {
    const idx = indexByType(allNodes);
    const messages = [];
    
    Object.keys(idx).forEach(t => {
      if (!CORE_REQUIRED[t]) return;
      
      const required = CORE_REQUIRED[t];
      const nodesByKey = {};
      
      idx[t].forEach((n, nodeIndex) => {
        const key = n['@id'] || JSON.stringify([n['@type'], n.url, n.name]).slice(0, 100);
        if (!nodesByKey[key]) nodesByKey[key] = [];
        nodesByKey[key].push({ node: n, index: nodeIndex });
      });
      
      Object.keys(nodesByKey).forEach(key => {
        const instances = nodesByKey[key];
        const firstNode = instances[0].node;
        
        if (isSystemInjectedNode(t, firstNode)) {
          return;
        }
        
        required.forEach(req => {
          processRequiredFieldsForNode(messages, t, req, key, firstNode, instances);
        });
      });
    });
    
    return messages;
  }
  
  // Try to find a candidate value for a field in OTHER types (so we can suggest)
  function findFieldElsewhere(allNodes, field, exceptType) {
    for (const n of allNodes) {
      const types = Array.isArray(n['@type']) ? n['@type'] : [n['@type']];
      if (types.includes(exceptType)) continue;
      if (n[field]) return { fromType: types.join(','), value: (''+n[field]).slice(0,120) };
    }
    return null;
  }
  
  // ---------- Enhanced Schema Builder ----------
  const asArray = v => Array.isArray(v) ? v : (v ? [v] : []);
  const uniq = arr => [...new Set(arr)];
  function firstNonEmpty(...vals){ for(const v of vals){ if(typeof v==='string' && v.trim()) return v.trim(); } return ''; }
  
  function pageMeta(doc, url){
    const get = s => doc.querySelector(s)?.getAttribute('content') || '';
    return {
      url,
      title: doc.querySelector('h1')?.textContent?.trim() || doc.title || '',
      ogTitle: get('meta[property="og:title"]'),
      ogDesc: get('meta[property="og:description"]'),
      ogImage: get('meta[property="og:image"]'),
      logo: get('meta[itemprop="logo"]') || get('meta[property="og:logo"]') || '',
      siteName: get('meta[property="og:site_name"]')
    };
  }
  
  function ensureId(node, baseUrl, suffix){
    if (!node['@id']) node['@id'] = baseUrl.replace(/#.*$/,'') + '#' + suffix;
    return node;
  }
  
  function dedupeById(nodes){
    const map = new Map();
    nodes.forEach(n=>{
      const key = n['@id'] || JSON.stringify([n['@type'], n.name, n.url]);
      if (!map.has(key)) map.set(key, n);
    });
    return [...map.values()];
  }
  
  function prettyScript(json){
    return `<script type="application/ld+json">\n${JSON.stringify(json, null, 2)}\n<\/script>`;
  }
  
  function buildBreadcrumbs(doc, url){
    // 1) Try semantic breadcrumbs in DOM
    let items = [];
    const nav = doc.querySelector('nav[aria-label="breadcrumb"], .breadcrumbs, ol.breadcrumb, ul.breadcrumb');
    if (nav){
      const links = nav.querySelectorAll('a, [itemprop="item"]');
      let pos=1;
      links.forEach(a=>{
        const href = a.getAttribute('href') || a.getAttribute('content') || '';
        const name = a.textContent?.trim() || a.getAttribute('title') || '';
        if (name) items.push({ "@type":"ListItem", position: pos++, name, item: href.startsWith('http') ? href : new URL(href, url).href });
      });
    }
    // 2) Fallback to URL path
    if (!items.length){
      const u = new URL(url);
      const segs = u.pathname.split('/').filter(Boolean);
      let path=u.origin, pos=1;
      items.push({ "@type":"ListItem", position: pos++, name: "Home", item: u.origin });
      for(const s of segs){
        path += '/' + s;
        items.push({ "@type":"ListItem", position: pos++, name: decodeURIComponent(s.replace(/-/g,' ')).replace(/\b\w/g,m=>m.toUpperCase()), item: path });
      }
    }
    return {
      "@type":"BreadcrumbList",
      "@id": url.replace(/#.*$/,'') + "#breadcrumbs",
      "itemListElement": items
    };
  }
  
  // Helper: Detect global schema patterns
  function detectGlobalPatterns(nodes, baseUrl) {
    const existingIds = new Set();
    for (const n of nodes) {
      if (n['@id']) existingIds.add(n['@id']);
    }
    
    const hasGlobalWebsite = existingIds.has(baseUrl + '#website') || 
                             nodes.some(n => n['@type'] === 'WebSite' && n['@id'] && n['@id'].includes('#website'));
    const hasGlobalOrg = existingIds.has(baseUrl + '#org') ||
                        nodes.some(n => {
                          const types = asArray(n['@type']);
                          return (types.includes('Organization') || types.includes('LocalBusiness')) && 
                                 n['@id'] && n['@id'].includes('#org');
                        });
    const hasGlobalLocal = existingIds.has(baseUrl + '#local') ||
                          nodes.some(n => n['@type'] === 'LocalBusiness' && n['@id'] && n['@id'].includes('#local'));
    
    return { hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal };
  }

  // Helper: Build website node
  function buildWebsiteNode(idx, siteName, meta) {
    const website = (idx.WebSite && idx.WebSite[0]) ? structuredClone(idx.WebSite[0]) : {"@type":"WebSite"};
    website.name = website.name || siteName || "Alan Ranger Photography";
    website.url = website.url || meta.url;
    return website;
  }

  // Helper: Build organization node
  function buildOrgNode(idx, siteName, meta) {
    const org = (idx.Organization && idx.Organization[0]) ? structuredClone(idx.Organization[0]) : {"@type":"Organization"};
    org.name = org.name || siteName || "Alan Ranger Photography";
    org.url = org.url || meta.url;
    if (!org.logo && meta.logo) org.logo = meta.logo;
    if (!org.image && meta.ogImage) org.image = meta.ogImage;
    return org;
  }

  // Helper: Build local business node
  function buildLocalNode(idx, org, siteName, meta) {
    let local = (idx.LocalBusiness && idx.LocalBusiness[0]) ? structuredClone(idx.LocalBusiness[0]) : 
                (idx.Organization && idx.Organization[0] ? structuredClone(idx.Organization[0]) : null);
    
    if (local) {
      local.name = local.name || org.name || siteName;
      local.url = local.url || meta.url;
      if (!local.image && meta.ogImage) local.image = meta.ogImage;
      if (!local['@type']) local['@type'] = 'LocalBusiness';
    }
    
    return local;
  }

  // Helper: Build core schema nodes
  function buildCoreSchemaNodes(idx, meta, url) {
    const siteName = firstNonEmpty(null, meta.siteName, meta.title, "Alan Ranger Photography");
    const website = buildWebsiteNode(idx, siteName, meta);
    const org = buildOrgNode(idx, siteName, meta);
    const local = buildLocalNode(idx, org, siteName, meta);
    return { website, org, local };
  }

  // Helper: Build final schema graph
  function buildSchemaGraph(hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal, website, org, local, breadcrumbs, extras) {
    const graph = [];
    
    if (!hasGlobalWebsite) {
      graph.push(website);
    }
    
    if (!hasGlobalOrg) {
      graph.push(org);
    }
    
    if (local && !hasGlobalLocal) {
      graph.push(local);
    }
    
    if (breadcrumbs.itemListElement && breadcrumbs.itemListElement.length > 0) {
      graph.push(breadcrumbs);
    }
    
    graph.push(...extras);
    
    return dedupeById(graph);
  }

  // Helper: Process schema with fallback (check for existing Product before generating)
  async function processSchemaWithFallback(url, doc, nodes) {
    const meta = pageMeta(doc, url);
    const idx = indexByType(nodes);
    
    // Check for existing Product schema
    const hasExistingProduct = nodes.some(n => {
      const types = asArray(n['@type']);
      return types.includes('Product') || types.includes('Course');
    });
    
    if (hasExistingProduct) {
      debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî skipping Product generation to prevent duplicates`, 'info');
    }
    
    let { website, org, local } = buildCoreSchemaNodes(idx, meta, url);
    
    const baseUrl = url.replace(/#.*$/,'');
    const { hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal } = detectGlobalPatterns(nodes, baseUrl);
    
    if (!hasGlobalWebsite) website = ensureId(website, url, 'website');
    if (!hasGlobalOrg) org = ensureId(org, url, 'org');
    if (local && !hasGlobalLocal) local = ensureId(local, url, 'local');
    
    const breadcrumbs = buildBreadcrumbs(doc, url);
    const keepTypes = ['Product','Event','ItemList','FAQPage','Article','BlogPosting','Course'];
    
    // Only include Product/Course if they don't already exist
    const extras = nodes.filter(n => {
      const types = asArray(n['@type']);
      const hasKeepType = types.some(t => keepTypes.includes(t));
      
      // Skip Product/Course if already exists to prevent duplicates
      if ((types.includes('Product') || types.includes('Course')) && hasExistingProduct) {
        return false; // Don't include Product/Course nodes if we detected existing ones
      }
      
      return hasKeepType;
    });
    
    const finalGraph = buildSchemaGraph(hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal, website, org, local, breadcrumbs, extras);
    
    return { "@context":"https://schema.org", "@graph": finalGraph };
  }

  async function generateEnhancedFor(url){
    const apiBaseUrl = getApiBaseUrl();
    const apiUrl = `${apiBaseUrl}/api/fetch?url=${encodeURIComponent(url)}`;
    
    debugLog(`[Generate Enhanced] Fetching via API: ${apiUrl}`, 'info');
    
    try {
      // Use API proxy for Squarespace pages
      const res = await fetch(apiUrl);
      
      if (!res.ok) {
        const errorText = await res.text().catch(() => 'Unknown error');
        throw new Error(`API returned ${res.status}: ${errorText.substring(0, 100)}`);
      }
      
      const html = await res.text();
      
      if (!html || html.length === 0) {
        throw new Error('API returned empty response');
      }
      
      debugLog(`[Generate Enhanced] Received ${html.length} bytes of HTML`, 'success');
      
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      
      // Find all script tags with JSON-LD (including Squarespace patterns)
      const scripts = findAllJsonLdScripts(doc);
      
      let nodes = [];
      for (const s of scripts) {
        try {
          // Decode HTML entities before parsing
          const decodedText = decodeHTML(s.textContent);
          nodes = flattenJsonLd(JSON.parse(decodedText.trim()), nodes);
        } catch(e) {
          debugLog(`[Generate Enhanced] Failed to parse JSON-LD block: ${e.message}`, 'warning');
        }
      }
      
      // Check for existing Product schema before generating
      const hasExistingProduct = nodes.some(n => {
        const types = asArray(n['@type']);
        return types.includes('Product') || types.includes('Course');
      });
      
      if (hasExistingProduct) {
        debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî will not generate duplicate`, 'info');
      }
      
      debugLog(`[Generate Enhanced] Found ${nodes.length} schema nodes`, 'info');
      
      return await processSchemaWithFallback(url, doc, nodes);
    } catch (error) {
      debugLog(`[Generate Enhanced] API fetch failed: ${error.message}`, 'error');
      
      // Fallback to direct fetch if API fails (will likely fail due to CORS)
      debugLog(`[Generate Enhanced] Attempting direct fetch fallback...`, 'warning');
      
      try {
        const res = await fetch(url, {mode:'cors'});
        if (!res.ok) {
          throw new Error(`Direct fetch returned ${res.status}`);
        }
        const html = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Find all script tags with JSON-LD (including Squarespace patterns)
        const scripts = findAllJsonLdScripts(doc);
        
        let nodes = [];
        for (const s of scripts) {
          try {
            // Decode HTML entities before parsing
            const decodedText = decodeHTML(s.textContent);
            nodes = flattenJsonLd(JSON.parse(decodedText.trim()), nodes);
          } catch(_) {}
        }
        
        // Check for existing Product schema
        const hasExistingProduct = nodes.some(n => {
          const types = asArray(n['@type']);
          return types.includes('Product') || types.includes('Course');
        });
        
        if (hasExistingProduct) {
          debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî will not generate duplicate`, 'info');
        }
        
        return await processSchemaWithFallback(url, doc, nodes);
      } catch (err) {
        const errorMsg = err.message || 'Unknown error';
        debugLog(`[Generate Enhanced] Direct fetch also failed: ${errorMsg}`, 'error');
        throw new Error(`Failed to fetch page: ${errorMsg}. API endpoint: ${apiUrl}`);
      }
    }
  }
  
  // Modal plumbing
  (function initGenModal(){
    // Function to setup save button handler
    function setupSaveButton() {
      const saveBtn = document.getElementById('genSaveBtn');
      const backdrop = document.getElementById('genBackdrop');
      if (saveBtn && backdrop) {
        saveBtn.onclick = async () => {
          try {
            const url = backdrop.dataset.url || '';
            const json = backdrop.dataset.json || document.getElementById('genJson')?.textContent || '';
            
            if (!json || json.trim().length === 0) {
              alert('No content to save');
              return;
            }
            
            // Generate filename from URL
            let filename = 'schema';
            if (url) {
              try {
                const urlObj = new URL(url);
                // Extract pathname and convert to filename-safe string
                const pathParts = urlObj.pathname.split('/').filter(p => p);
                if (pathParts.length > 0) {
                  filename = pathParts[pathParts.length - 1].replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                  // Limit filename length
                  if (filename.length > 50) {
                    filename = filename.substring(0, 50);
                  }
                } else {
                  filename = urlObj.hostname.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                }
              } catch (e) {
                console.warn('Failed to parse URL for filename:', e);
              }
            }
            
            // Add timestamp to ensure uniqueness
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
            const fullFilename = `${filename}-${timestamp}.json`;
            
            // Create blob and download
            const blob = new Blob([json], { type: 'application/json' });
            const blobUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = fullFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(blobUrl);
            
            // Update button feedback
            const originalText = saveBtn.textContent;
            saveBtn.textContent = '‚úÖ Saved!';
            saveBtn.style.background = '#10b981';
            setTimeout(() => {
              saveBtn.textContent = originalText;
              saveBtn.style.background = '#10b981';
            }, 2000);
            
            console.log(`Saved schema to: ${fullFilename}`);
          } catch (err) {
            console.error('Failed to save file:', err);
            alert('Failed to save file: ' + err.message);
          }
        };
      }
    }
    
    // Function to setup copy button handler
    function setupCopyButton() {
      const copyBtn = document.getElementById('genCopyBtn');
      const jsonEl = document.getElementById('genJson');
      if (copyBtn && jsonEl) {
        copyBtn.onclick = async () => {
          try {
            const text = jsonEl.textContent || jsonEl.innerText;
            if (!text || text.trim().length === 0) {
              alert('No content to copy');
              return;
            }
            
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
              copyBtn.textContent = '‚úÖ Copied!';
              setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
            } else {
              // Fallback: use textarea method for older browsers
              const textarea = document.createElement('textarea');
              textarea.value = text;
              textarea.style.position = 'fixed';
              textarea.style.left = '-999999px';
              document.body.appendChild(textarea);
              textarea.select();
              textarea.setSelectionRange(0, 99999); // For mobile devices
              
              try {
                document.execCommand('copy');
                copyBtn.textContent = '‚úÖ Copied!';
                setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
              } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
                debugLog('Copy failed: ' + err.message, 'error');
              } finally {
                document.body.removeChild(textarea);
              }
            }
          } catch (err) {
            alert('Failed to copy to clipboard: ' + err.message);
            debugLog('Copy error: ' + err.message, 'error');
          }
        };
      }
    }
    
    // Setup close button and backdrop
    function setupCloseButton() {
      const backdrop = document.getElementById('genBackdrop');
      const closeBtn = document.getElementById('genCloseBtn');
      if (backdrop && closeBtn) {
        closeBtn.onclick = () => {
          if (backdrop.close) {
            backdrop.close();
          } else {
            backdrop.style.display = 'none';
          }
        };
        backdrop.onclick = (e) => {
          if (e.target === backdrop) {
            if (backdrop.close) {
              backdrop.close();
            } else {
              backdrop.style.display = 'none';
            }
          }
        };
      }
    }
    
    // Try to setup immediately if DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setupCopyButton();
        setupSaveButton();
        setupCloseButton();
      });
    } else {
      setupCopyButton();
      setupSaveButton();
      setupCloseButton();
    }
    
    // Also setup when modal is opened (in case elements weren't ready earlier)
    window.__openGenModal = (url, json)=>{
      const backdropEl = document.getElementById('genBackdrop');
      const metaEl = document.getElementById('genMeta');
      const jsonEl = document.getElementById('genJson');
      if (!backdropEl) {
        alert('Error: Modal element not found. Please refresh the page.');
        return;
      }
      if (metaEl) metaEl.textContent = url;
      if (jsonEl) jsonEl.textContent = prettyScript(json);
      
      // Store URL and JSON for save function
      backdropEl.dataset.url = url;
      backdropEl.dataset.json = json;
      
      // Re-attach copy and save button handlers in case they weren't set up earlier
      setupCopyButton();
      setupSaveButton();
      
      // Use dialog API if available
      if (backdropEl.showModal) {
        backdropEl.showModal();
      } else {
        backdropEl.style.display='flex';
      }
    };
  })();
  
  // Copy to clipboard
  function copyToClipboard(outputId) {
    const element = document.getElementById(outputId);
    if (!element) {
      console.error(`Element with id "${outputId}" not found`);
      showToast('‚ùå Error: Output element not found', 'error');
      return;
    }
    
    const text = element.tagName === 'TEXTAREA' ? element.value : element.textContent;
    
    if (!text || text.trim() === '') {
      showToast('‚ö†Ô∏è Nothing to copy. Please generate schema first.', 'warning');
      return;
    }
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(function() {
        showToast('‚úÖ Schema copied to clipboard!', 'success');
      }, function(err) {
        console.error('Clipboard write failed:', err);
        showToast('‚ùå Failed to copy. Please try selecting and copying manually.', 'error');
      });
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      try {
        document.execCommand('copy');
        showToast('‚úÖ Schema copied to clipboard!', 'success');
      } catch (err) {
        console.error('Fallback copy failed:', err);
        showToast('‚ùå Failed to copy. Please try selecting and copying manually.', 'error');
      }
      document.body.removeChild(textArea);
    }
  }
  
  function showToast(message, type = 'success') {
    const toast = document.createElement('div');
    toast.textContent = message;
    const bgColor = type === 'success' ? '#27AE60' : type === 'error' ? '#E74C3C' : '#E57200';
    toast.style.cssText = `position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white; padding: 14px 24px; border-radius: 8px; z-index: 10000; font-size: 0.875rem; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: slideIn 0.3s ease-out;`;
    document.body.appendChild(toast);
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }

  // Test URL functions
  function testSchemaOrg(inputId) {
    const url = document.getElementById(inputId).value;
    if (!url) {
      alert('Please enter a URL to test');
      return;
    }
    window.open('https://validator.schema.org/#url=' + encodeURIComponent(url), '_blank');
  }

  function testGoogleRichResults(inputId) {
    const url = document.getElementById(inputId).value;
    if (!url) {
      alert('Please enter a URL to test');
      return;
    }
    window.open('https://search.google.com/test/rich-results?url=' + encodeURIComponent(url), '_blank');
  }

  // Helper: Validate URL input
  function validateUrlInput() {
    const urlInput = document.getElementById('singleUrlInput');
    if (!urlInput) {
      console.error('singleUrlInput element not found');
      alert('Error: Input field not found. Please refresh the page.');
      return null;
    }
    
    const url = urlInput.value.trim();
    console.log('URL input:', url);
    
    if (!url) {
      alert('Please enter a URL to validate');
      return null;
    }
    
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      alert('Please enter a valid URL starting with http:// or https://');
      return null;
    }
    
    return { urlInput, url };
  }

  // Helper: Show results table
  function showResultsTable() {
    const resultsDiv = document.getElementById('validatorResults');
    if (resultsDiv) {
      resultsDiv.style.display = 'block';
      return resultsDiv;
    }
    console.error('validatorResults element not found');
    alert('Error: Results table not found. Please refresh the page.');
    return null;
  }

  // Helper: Find or create result index
  function findOrCreateResultIndex(url) {
    if (typeof validationResults === 'undefined') {
      console.error('validationResults array not defined');
      alert('Error: Validation system not initialized. Please refresh the page.');
      return null;
    }
    
    const existingIndex = validationResults.findIndex(r => r.url === url);
    if (existingIndex >= 0) {
      console.log('Updating existing row at index:', existingIndex);
      return existingIndex;
    }
    
    console.log('Creating new row, current length:', validationResults.length);
    const index = validationResults.length;
    
    const placeholderResult = {
      url: url,
      row: index,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null,
      validatorGoogleStatus: 'Not run',
      validatorSchemaOrgStatus: 'Not run',
      notes: '',
      issuesList: []
    };
    
    validationResults.push(placeholderResult);
    console.log('Added placeholder result, new length:', validationResults.length);
    return index;
  }

  // Helper: Initialize validation row UI
  function initializeValidationRow(index, url) {
    if (typeof updateTableRow === 'undefined') {
      console.error('updateTableRow function not defined');
      alert('Error: updateTableRow function not found. Please refresh the page.');
      return false;
    }
    
    updateTableRow(index, {
      url: url,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null,
      validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
      validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
      notes: validationResults[index]?.notes || '',
      issuesList: []
    });
    
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    if (schemaTypeCell) {
      if (typeof renderProgress === 'undefined' || typeof setProgress === 'undefined') {
        console.error('renderProgress or setProgress not defined');
      } else {
        renderProgress(schemaTypeCell);
        setProgress(schemaTypeCell, 5, 'Queued');
      }
    }
    
    return true;
  }

  // Helper: Run external validators if enabled
  async function runExternalValidatorsIfEnabled(index, url) {
    const autoRunCheckbox = document.getElementById('autoRunExternalChecks');
    const shouldAutoRun = autoRunCheckbox ? autoRunCheckbox.checked : true;
    
    if (!shouldAutoRun) {
      return;
    }
    
    // Wait longer for DOM to be fully updated and select elements to be created
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Retry logic - try multiple times if elements aren't found
    let retries = 3;
    let schemaOrgRan = false;
    let richResultsRan = false;
    
    while (retries > 0 && (!schemaOrgRan || !richResultsRan)) {
      try {
        const schemaOrgStatusSelect = document.getElementById(`schemaOrgStatus_${index}`);
        if (schemaOrgStatusSelect && schemaOrgStatusSelect.value === 'Not run' && !schemaOrgRan) {
          if (typeof runSchemaOrgValidator === 'function') {
            try {
              await runSchemaOrgValidator(index, url);
              schemaOrgRan = true;
            } catch (err) {
              console.error(`Schema.org validation failed for ${url}:`, err);
              debugLog(`Schema.org validation failed for ${url}: ${err.message}`, 'error');
              schemaOrgRan = true; // Mark as attempted to prevent retry loop
            }
          } else {
            console.warn(`runSchemaOrgValidator function not found for index ${index}`);
            schemaOrgRan = true;
          }
        } else if (schemaOrgStatusSelect && schemaOrgStatusSelect.value !== 'Not run') {
          schemaOrgRan = true; // Already run
        }
        
        const googleStatusSelect = document.getElementById(`googleStatus_${index}`);
        if (googleStatusSelect && googleStatusSelect.value === 'Not run' && !richResultsRan) {
          if (typeof runRichResultsValidator === 'function') {
            try {
              await runRichResultsValidator(index, url);
              richResultsRan = true;
            } catch (err) {
              console.error(`Rich Results validation failed for ${url}:`, err);
              debugLog(`Rich Results validation failed for ${url}: ${err.message}`, 'error');
              richResultsRan = true; // Mark as attempted to prevent retry loop
            }
          } else {
            console.warn(`runRichResultsValidator function not found for index ${index}`);
            richResultsRan = true;
          }
        } else if (googleStatusSelect && googleStatusSelect.value !== 'Not run') {
          richResultsRan = true; // Already run
        }
        
        // If both ran or both select elements don't exist, break
        if (schemaOrgRan && richResultsRan) {
          break;
        }
        
        // If elements still don't exist after waiting, wait a bit more
        if (retries > 1 && (!schemaOrgStatusSelect || !googleStatusSelect)) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
        
      } catch (error) {
        console.error(`External validation error for ${url}:`, error);
        debugLog(`External validation error for ${url}: ${error.message}`, 'error');
      }
      
      retries--;
      if (retries > 0 && (!schemaOrgRan || !richResultsRan)) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
    
    if (!schemaOrgRan || !richResultsRan) {
      console.warn(`External validations may not have completed for index ${index}, URL: ${url}`);
      debugLog(`External validations may not have completed for index ${index}, URL: ${url}`, 'warning');
    }
  }

  // Helper: Auto-save to Supabase if enabled
  function autoSaveToSupabaseIfEnabled(index, url) {
    const autoSaveCheckbox = document.getElementById('autoSaveToSupabase');
    const shouldAutoSave = autoSaveCheckbox ? autoSaveCheckbox.checked : false;
    
    if (shouldAutoSave && supabaseAvailable && supabase && typeof saveToSupabase === 'function') {
      setTimeout(async () => {
        try {
          await saveToSupabase(index, true);
          debugLog(`Auto-saved to Supabase: ${url}`, 'success');
        } catch (error) {
          debugLog(`Auto-save failed for ${url}: ${error.message}`, 'error');
        }
      }, 2000);
    }
  }

  // Helper: Handle validation error
  function handleValidationError(error, index, url) {
    console.error('Error validating URL:', error);
    console.error('Error stack:', error.stack);
    alert('Error validating URL: ' + error.message + '\n\nCheck console for details.');
    
    if (typeof index !== 'undefined' && validationResults && validationResults[index]) {
      validationResults[index] = {
        url: url || 'Unknown',
        row: index || 0,
        schemaType: null,
        valid: false,
        schemaFound: false,
        missingFields: [],
        warnings: [],
        schemas: [],
        error: error.message,
        validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
        validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
        notes: validationResults[index]?.notes || '',
        issuesList: []
      };
      
      if (typeof updateTableRow === 'function') {
        updateTableRow(index, validationResults[index]);
      }
    }
    
    if (typeof updateBulkButtons === 'function') {
      updateBulkButtons();
    }
  }

  // Single URL validation
  async function runSingleUrlValidation() {
    console.log('runSingleUrlValidation called');
    
    try {
      const urlInputData = validateUrlInput();
      if (!urlInputData) return;
      
      const resultsDiv = showResultsTable();
      if (!resultsDiv) return;
      
      const index = findOrCreateResultIndex(urlInputData.url);
      if (index === null) return;
      
      if (!initializeValidationRow(index, urlInputData.url)) return;
      
      console.log('Starting processUrl...');
      if (typeof processUrl === 'undefined') {
        console.error('processUrl function not defined');
        alert('Error: processUrl function not found. Please refresh the page.');
        return;
      }
      
      const urlData = { url: urlInputData.url, row: index };
      const result = await processUrl(urlData);
      console.log('processUrl completed:', result);
      
      validationResults[index] = {
        ...result,
        validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
        validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
        notes: validationResults[index]?.notes || ''
      };
      
      console.log('Updating table row with results...');
      updateTableRow(index, validationResults[index]);
      
      if (typeof updateBulkButtons === 'function') {
        updateBulkButtons();
      }
      
      await runExternalValidatorsIfEnabled(index, urlInputData.url);
      autoSaveToSupabaseIfEnabled(index, urlInputData.url);
      
      urlInputData.urlInput.value = '';
      
      if (resultsDiv) {
        resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      
    } catch (error) {
      let errorUrl = '';
      try {
        const urlInputData = validateUrlInput();
        errorUrl = urlInputData?.url || '';
      } catch {
        errorUrl = '';
      }
      handleValidationError(error, typeof index !== 'undefined' ? index : undefined, errorUrl);
    }
  }
  
  // Make it globally accessible
  window.runSingleUrlValidation = runSingleUrlValidation;

  // Toggle help block
  function toggleHelpBlock() {
    const helpBlock = document.getElementById('helpBlock');
    const content = document.getElementById('helpBlockContent');
    
    helpBlock.classList.toggle('expanded');
    content.classList.toggle('active');
    helpBlock.setAttribute('aria-expanded', helpBlock.classList.contains('expanded'));
  }

  // Event Schema Generation
  let events = [];

  document.getElementById('eventCsvFile').addEventListener('change', function(e) {
    Papa.parse(e.target.files[0], {
      header: true,
      skipEmptyLines: true,
      complete: function(results) {
        events = results.data;
        
        const categories = [...new Set(
          events.map(e => (e['Category'] || '').split(',')[0].trim()).filter(Boolean)
        )];
        
        const filterSelect = document.getElementById('eventCategoryFilter');
        filterSelect.innerHTML = '<option value="__ALL__">All Categories</option>';
        categories.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          filterSelect.appendChild(opt);
        });
        document.getElementById('eventCategoryFilterContainer').style.display = 'block';
      }
    });
  });

  function parseAddress(locationAddressRaw) {
    if (!locationAddressRaw || typeof locationAddressRaw !== "string") return {
      "@type": "PostalAddress",
      "addressCountry": "GB"
    };

    const parts = locationAddressRaw.split(",").map(p => p.trim()).filter(Boolean).reverse();
    const address = { "@type": "PostalAddress" };

    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];

      if (!address.addressCountry && /^(United Kingdom|UK)$/i.test(part)) {
        address.addressCountry = "GB";
      } else if (!address.postalCode && /^[A-Z]{1,2}\d[A-Z\d]?\s*\d[A-Z]{2}$/i.test(part)) {
        address.postalCode = part.toUpperCase();
      } else if (!address.addressRegion) {
        address.addressRegion = part;
      } else if (!address.addressLocality) {
        address.addressLocality = part;
      } else if (!address.streetAddress) {
        address.streetAddress = part;
      }
    }

    if (!address.addressCountry) address.addressCountry = "GB";
    return address;
  }

  function generateEventSchema() {
    const selectedCategory = document.getElementById('eventCategoryFilter').value;
    const today = new Date().toISOString().split('T')[0];
    const filtered = events.filter(e =>
      (selectedCategory === "__ALL__" || (e['Category'] || '').split(',')[0].trim() === selectedCategory) &&
      e['Start_Date'] >= today &&
      e['Workflow_State'] === 'Published'
    );

    const itemList = {
      "@type": "ItemList",
      "name": selectedCategory === "__ALL__" ? "Events" : selectedCategory + " Events",
      "itemListElement": filtered.map((event, i) => ({
        "@type": "ListItem",
        "position": i + 1,
        "url": event['Event_URL']
      }))
    };

    const eventList = filtered.map(event => ({
      "@type": "Event",
      "name": event['Event_Title'],
      "startDate": event['Start_Date'],
      "endDate": event['End_Date'],
      "eventAttendanceMode": "https://schema.org/OfflineEventAttendanceMode",
      "eventStatus": "https://schema.org/EventScheduled",
      "image": event['Event_Image'],
      "organizer": {
        "@type": "Organization",
        "name": "Alan Ranger Photography",
        "logo": "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w",
        "url": "https://www.alanranger.com"
      },
      "location": {
        "@type": "Place",
        "name": event['Location_Business_Name'],
        "address": parseAddress(event['Location_Address'])
      },
      "performer": {
        "@type": "Person",
        "name": "Alan Ranger"
      },
      "offers": {
        "@type": "Offer",
        "price": "0.00",
        "priceCurrency": "GBP",
        "availability": "https://schema.org/InStock",
        "url": event['Event_URL'],
        "validFrom": event['Start_Date']
      },
      "description": event['Excerpt'],
      "url": event['Event_URL']
    }));

    const fullSchema = {
      "@context": "https://schema.org",
      "@graph": [itemList, ...eventList]
    };

    const json = JSON.stringify(fullSchema, null, 2);
    const scriptEl = document.createElement('script');
    scriptEl.type = 'application/ld+json';
    scriptEl.textContent = json;
    document.getElementById('eventOutput').textContent = scriptEl.outerHTML;
  }

  // Product Schema Generation
  async function generateProductSchema() {
    // Check server status first (skip alert in Electron mode or web deployment)
    const isRunning = await ensureLocalExecutorRunning();
    if (!isRunning && !isElectronMode) {
      const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                              window.location.hostname.includes('localhost') === false;
      
      if (isWebDeployment) {
        const output = document.getElementById('productOutput');
        if (output) {
          output.value = '‚ÑπÔ∏è Local server features require Electron app or local development.\n';
          output.value += '   Download the Electron app for full automation.\n';
          output.value += '   Or run locally: npm run start-local\n';
        }
        return;
      }
      
      alert('Local server is not running. Please run "npm run start-local" in your terminal first.');
      return;
    }
    
    const fileInput = document.getElementById('productCsvFile');
    const step3Input = document.getElementById('file-step3');
    const output = document.getElementById('productOutput');
    const successMsg = document.getElementById('productSchemaSuccess');

    // Use file from Step 3 input if available, otherwise use hidden input
    const fileToProcess = (step3Input && step3Input.files.length > 0) ? step3Input.files[0] : 
                          (fileInput && fileInput.files.length > 0) ? fileInput.files[0] : null;

    if (!fileToProcess) {
      alert("Please upload a product Excel file (from Step 3) first.");
      return;
    }

    const fileName = fileToProcess.name;
    
    // Check if file needs to be saved to workflow directory first
    if (!fileName.includes('products_with_review_data_final') && !fileName.includes('03')) {
      const proceed = confirm(
        "The uploaded file doesn't match the expected name (03 ‚Äì products_with_review_data_final.xlsx).\n\n" +
        "Please ensure the file from Step 3 is saved in /inputs-files/workflow/ as:\n" +
        "03 ‚Äì products_with_review_data_final.xlsx\n\n" +
        "Click OK to continue with preview, or Cancel to upload the correct file."
      );
      if (!proceed) return;
    }

    // Use local task runner for schema generation
    await runLocalTask('schema', 4, '‚öôÔ∏è Generating Product Schema...', () => {
      output.value = "Schema generation complete. Check /outputs/ folder for individual files and /workflow/ for combined CSV.";
      if (successMsg) {
        successMsg.style.display = 'block';
        successMsg.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      
      // Optionally stop the server after completion (commented out by default)
      // fetch("http://localhost:8000/exit").then(() => console.log("üßπ Local executor stopped."));
    });
  }

  // File upload handler for validator tab
  function onFileUpload() {
    const fileInput = document.getElementById('validatorCsvFile');
    if (fileInput.files.length > 0) {
      const fileName = fileInput.files[0].name;
      console.log('CSV file selected:', fileName);
      // File is ready for validation
    }
  }

  // Download template CSV file
  function downloadTemplateCSV() {
    const csvContent = 'URL,Page Name,Category\nhttps://www.example.com/product-1,Product One,Products\nhttps://www.example.com/product-2,Product Two,Products\nhttps://www.example.com/event-1,Event One,Events\nhttps://www.example.com/event-2,Event Two,Events';
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'validator-urls-template.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // ---- NEW: Central cache the scanner already fills ------------
  const ResultCache = new Map(); // key: url, value: { blocks, issues, warnings, info, rawHtml? }
  
  // Call this right after you complete analysis for a URL
  function cacheResult(url, payload) {
    ResultCache.set(url, payload);
  }

  // Schema Validator Tab Logic
  const SCHEMA_REQUIREMENTS = {
    WebSite: {
      required: ['name', 'url'],
      recommended: ['description', 'image', 'publisher']
    },
    Product: {
      required: ['name', 'url'],
      recommended: ['description', 'image', 'brand', 'offers', 'aggregateRating', 'review']
    },
    Event: {
      required: ['name', 'startDate'],
      recommended: ['endDate', 'location', 'organizer', 'offers', 'image', 'description', 'performer']
    },
    Organization: {
      required: ['name'],
      recommended: ['url', 'logo', 'address', 'contactPoint', 'telephone', 'description', 'image']
    },
    BreadcrumbList: {
      required: ['itemListElement'],
      recommended: []
    },
    ItemList: {
      required: ['itemListElement'],
      recommended: ['name']
    },
    LocalBusiness: {
      required: ['name'],
      recommended: ['address', 'telephone', 'url', 'openingHours', 'description', 'image']
    }
  };

  const DEFAULT_VALUES = {
    Product: {
      brand: { '@type': 'Brand', name: '[REPLACE WITH BRAND NAME]' },
      offers: {
        '@type': 'Offer',
        price: '[REPLACE WITH PRICE]',
        priceCurrency: 'GBP',
        availability: 'https://schema.org/InStock',
        url: '[AUTO-INFERRED FROM PAGE URL]'
      },
      description: '[REPLACE WITH PRODUCT DESCRIPTION]',
      image: '[REPLACE WITH PRODUCT IMAGE URL]'
    },
    Event: {
      organizer: {
        '@type': 'Organization',
        name: 'Alan Ranger Photography',
        logo: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w',
        url: 'https://www.alanranger.com'
      },
      performer: {
        '@type': 'Person',
        name: 'Alan Ranger'
      },
      location: {
        '@type': 'Place',
        name: '[REPLACE WITH VENUE NAME]',
        address: {
          '@type': 'PostalAddress',
          addressCountry: 'GB'
        }
      },
      offers: {
        '@type': 'Offer',
        price: '0.00',
        priceCurrency: 'GBP',
        availability: 'https://schema.org/InStock',
        validFrom: '[AUTO-INFERRED FROM START DATE]'
      },
      description: '[REPLACE WITH EVENT DESCRIPTION]',
      image: '[REPLACE WITH EVENT IMAGE URL]'
    }
  };

  let validationResults = [];

  // Parse CSV and extract URLs
  function parseCSVForValidation(csvFile) {
    return new Promise((resolve, reject) => {
      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        complete: function(results) {
          const urls = [];
          const headers = results.meta.fields || [];
          
          const urlColumn = headers.find(h => 
            h.toLowerCase() === 'url' || h.toLowerCase() === 'link' || h.toLowerCase() === 'website'
          );
          
          if (!urlColumn) {
            reject(new Error('No URL column found. Expected column name: URL, Link, or Website'));
            return;
          }
          
          results.data.forEach((row, index) => {
            const url = row[urlColumn];
            if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
              const trimmedUrl = url.trim();
              // Deduplicate URLs - only add if not already in array
              if (!urls.find(u => u.url === trimmedUrl)) {
                urls.push({
                  url: trimmedUrl,
                  row: urls.length, // Use current array index, not CSV row number
                  allFields: row
                });
              }
            }
          });
          
          resolve(urls);
        },
        error: function(error) {
          reject(error);
        }
      });
    });
  }

  // Server fallback: Fetch JSON-LD via server when client-side fails
  async function fetchPageSchemaServer(url) {
    try {
      // Determine API base URL (use deployed API when running locally)
      const apiBaseUrl = getApiBaseUrl();
      
      const apiUrl = `${apiBaseUrl}/api/fetch-jsonld?url=${encodeURIComponent(url)}`;
      debugLog(`Calling server fallback API: ${apiUrl}`, 'info');
      
      const response = await fetch(apiUrl);
      if (!response.ok) {
        throw new Error(`Server API returned ${response.status}`);
      }
      
      const data = await response.json();
      
      if (!data.ok) {
        throw new Error(data.error || 'Server API error');
      }
      
      debugLog(`Server fallback: found ${data.count} JSON-LD blocks`, data.count > 0 ? 'success' : 'warn');
      
      // Process scripts to extract types and detect duplicates
      const allNodes = [];
      const typeMap = new Map(); // type -> @id -> count
      
      data.scripts.forEach(block => {
        try {
          const nodes = flattenJsonLd(block, []);
          nodes.forEach(node => {
            allNodes.push(node);
            const types = asArray(node['@type']);
            types.forEach(type => {
              const idKey = node['@id'] || 'NO_ID';
              const mapKey = `${type}|${idKey}`;
              typeMap.set(mapKey, (typeMap.get(mapKey) || 0) + 1);
            });
          });
        } catch (e) {
          debugLog(`Error processing server block: ${e.message}`, 'warn');
        }
      });
      
      // Extract unique types
      const uniqueTypes = new Set();
      allNodes.forEach(node => {
        const types = asArray(node['@type']);
        types.forEach(t => uniqueTypes.add(t));
      });
      
      // Detect duplicates (excluding global injections)
      const globalPatterns = ['website', 'org', 'local', 'breadcrumbs'];
      const duplicateWarnings = [];
      
      typeMap.forEach((count, mapKey) => {
        if (count > 1) {
          const [type, idKey] = mapKey.split('|');
          const isGlobal = idKey !== 'NO_ID' && globalPatterns.some(p => idKey.includes(p));
          if (!isGlobal) {
            const idLabel = idKey === 'NO_ID' ? 'NO_ID' : `#${idKey.split('#')[1]}`;
            duplicateWarnings.push(`‚ö†Ô∏è DUPLICATE: ${type} (${idLabel}) √ó ${count}`);
          }
        }
      });
      
      return {
        url,
        jsonLd: data.scripts,
        schemaFound: data.count > 0,
        schemaType: Array.from(uniqueTypes).join(', '),
        serverFallback: true,
        duplicateWarnings: duplicateWarnings,
        blockCount: data.count
      };
      
    } catch (error) {
      debugLog(`Server fallback failed: ${error.message}`, 'error');
      throw error;
    }
  }

  // Helper: Detect Google Merchant Listing pattern in Product schema
  function detectMerchantListing(json) {
    // Check if this is a Product schema
    const isProduct = json['@type'] === 'Product' || 
                     (Array.isArray(json['@type']) && json['@type'].includes('Product'));
    
    if (!isProduct) {
      return false;
    }
    
    // Check for required Merchant Center fields
    // offers can be an object or array
    const offers = json.offers;
    if (!offers) {
      debugLog(`[MerchantListing] Product schema missing 'offers' field`, 'info');
      return false;
    }
    
    // Handle offers as object or array
    const offer = Array.isArray(offers) ? offers[0] : offers;
    
    // Check for price: can be direct price OR AggregateOffer with lowPrice/highPrice
    const hasPrice = offer && (
      offer.price || 
      (offer.lowPrice && offer.highPrice) || // AggregateOffer pattern
      (offer.lowPrice && offer.lowPrice === offer.highPrice) // Single price in AggregateOffer
    );
    
    const hasPriceCurrency = offer && offer.priceCurrency;
    const hasAvailability = offer && offer.availability;
    
    // Check for hasMerchantReturnPolicy at Product level OR inside offers object
    const hasReturnPolicy = json.hasMerchantReturnPolicy || (offer && offer.hasMerchantReturnPolicy);
    
    const hasMerchantListingFields = 
      hasPrice &&
      hasPriceCurrency &&
      hasAvailability &&
      hasReturnPolicy;
    
    if (!hasMerchantListingFields) {
      const missingFields = [];
      if (!hasPrice) missingFields.push('price (or lowPrice/highPrice for AggregateOffer)');
      if (!hasPriceCurrency) missingFields.push('priceCurrency');
      if (!hasAvailability) missingFields.push('availability');
      if (!hasReturnPolicy) missingFields.push('hasMerchantReturnPolicy (at Product or Offer level)');
      debugLog(`[MerchantListing] Product schema missing Merchant Center fields: ${missingFields.join(', ')}`, 'info');
    } else {
      debugLog(`[MerchantListing] ‚úÖ Product schema has all Merchant Center fields!`, 'success');
    }
    
    return hasMerchantListingFields;
  }

  // Helper: Extract types from JSON-LD block
  function extractTypesFromBlock(json, blockInfo, scriptIndex) {
    const blockTypes = [];
    
    if (json['@type']) {
      const types = Array.isArray(json['@type']) ? json['@type'] : [json['@type']];
      blockTypes.push(...types);
    }
    
    if (json['@graph']) {
      for (const item of json['@graph']) {
        if (item['@type']) {
          const types = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
          blockTypes.push(...types);
        }
      }
    }
    
    if (blockTypes.length > 0) {
      blockInfo.push({
        index: scriptIndex,
        types: blockTypes,
        hasId: !!json['@id'] || !!(json['@graph'] && json['@graph'].some(n => n['@id'])),
        isGraph: !!json['@graph']
      });
    }
    
    return blockTypes;
  }

  // Helper: Parse JSON-LD blocks from scripts
  // Helper: Decode HTML entities to normal JSON (Squarespace-compatible)
  function decodeHTML(str) {
    if (!str) return str;
    return str
      .replace(/&quot;/g, '"')
      .replace(/&apos;/g, "'")
      .replace(/&amp;/g, '&')
      .replace(/&#x2F;/g, '/')
      .replace(/&#x2f;/g, '/')
      .replace(/\\\//g, '/') // Also handle escaped forward slashes
      .trim();
  }

  // Helper: Find all JSON-LD script tags (including Squarespace patterns)
  function findAllJsonLdScripts(doc) {
    const scripts = [];
    
    // Standard pattern: script[type="application/ld+json"]
    const standardScripts = doc.querySelectorAll('script[type="application/ld+json"]');
    scripts.push(...Array.from(standardScripts));
    
    // Squarespace pattern: script[data-type="application/ld+json"]
    const squarespaceScripts = doc.querySelectorAll('script[data-type="application/ld+json"]');
    scripts.push(...Array.from(squarespaceScripts));
    
    // Also check noscript tags for JSON-LD content
    const noscriptTags = doc.querySelectorAll('noscript');
    for (const noscript of noscriptTags) {
      const noscriptStandard = noscript.querySelectorAll('script[type="application/ld+json"]');
      const noscriptSquarespace = noscript.querySelectorAll('script[data-type="application/ld+json"]');
      scripts.push(...Array.from(noscriptStandard));
      scripts.push(...Array.from(noscriptSquarespace));
    }
    
    // Deduplicate scripts (in case a script appears in multiple queries)
    const uniqueScripts = [];
    const seenScripts = new Set();
    for (const script of scripts) {
      if (!seenScripts.has(script)) {
        seenScripts.add(script);
        uniqueScripts.push(script);
      }
    }
    
    return uniqueScripts;
  }

  // Helper: Parse JSON-LD blocks with improved detection
  function parseJsonLdBlocks(scripts, schemaTypeCell) {
    const jsonLdBlocks = [];
    let detectedTypes = [];
    const blockInfo = [];
    const productCount = { total: 0, blocks: [] };
    
    for (let scriptIndex = 0; scriptIndex < scripts.length; scriptIndex++) {
      const script = scripts[scriptIndex];
      try {
        // Decode escaped content before parsing
        const decodedText = decodeHTML(script.textContent);
        const json = JSON.parse(decodedText);
        
        jsonLdBlocks.push(json);
        const blockTypes = extractTypesFromBlock(json, blockInfo, scriptIndex);
        detectedTypes.push(...blockTypes);
        
        // Track Product schemas specifically
        const hasProduct = blockTypes.includes('Product');
        if (hasProduct) {
          productCount.total++;
          productCount.blocks.push(scriptIndex);
        }
      } catch (e) {
        // Try parsing after decoding if initial parse failed
        try {
          const decodedText = decodeHTML(script.textContent);
          const json = JSON.parse(decodedText);
          jsonLdBlocks.push(json);
          const blockTypes = extractTypesFromBlock(json, blockInfo, scriptIndex);
          detectedTypes.push(...blockTypes);
          
          const hasProduct = blockTypes.includes('Product');
          if (hasProduct) {
            productCount.total++;
            productCount.blocks.push(scriptIndex);
          }
        } catch (e2) {
          console.warn('Failed to parse JSON-LD:', e);
          debugLog(`Failed to parse JSON-LD block ${scriptIndex}: ${e.message}`, 'error');
        }
      }
    }
    
    // Log duplicate Product detection
    if (productCount.total > 1) {
      debugLog(`Duplicate Product schemas detected (${productCount.total} found) ‚Äî first retained, subsequent skipped.`, 'warn');
      debugLog(`Product schemas found in blocks: ${productCount.blocks.join(', ')}`, 'info');
    }
    
    return { jsonLdBlocks, detectedTypes, blockInfo };
  }

  // Helper: Detect and log duplicate types
  function detectDuplicateTypes(detectedTypes, blockInfo) {
    const typeCounts = {};
    for (const t of detectedTypes) {
      typeCounts[t] = (typeCounts[t] || 0) + 1;
    }
    
    const duplicates = Object.keys(typeCounts).filter(t => typeCounts[t] > 1);
    
    if (duplicates.length > 0) {
      // Log duplicate detection as info (expected for multi-instance schemas like Event, Product)
      debugLog(`Duplicate schema types detected: ${duplicates.map(t => `${t} (${typeCounts[t]}x)`).join(', ')}`, 'info');
      debugLog(`Block details: ${blockInfo.map(b => `Block ${b.index}: ${b.types.join(',')}${b.hasId ? ' (has @id)' : ''}${b.isGraph ? ' (@graph)' : ''}`).join('; ')}`, 'info');
    }
    
    return { duplicates, typeCounts };
  }

  // Helper: Extract types from JSON-LD data
  function extractTypesFromJsonLd(data, detectedTypes) {
    if (data['@type']) {
      if (Array.isArray(data['@type'])) {
        detectedTypes.push(...data['@type']);
      } else {
        detectedTypes.push(data['@type']);
      }
    }
    if (data['@graph']) {
      for (const item of data['@graph']) {
        if (item['@type']) {
          if (Array.isArray(item['@type'])) {
            detectedTypes.push(...item['@type']);
          } else {
            detectedTypes.push(item['@type']);
          }
        }
      }
    }
  }

  // Helper: Parse JSON-LD blocks from scripts (with Squarespace pattern support)
  function parseJsonLdBlocksFromScripts(scripts) {
    const jsonLdBlocks = [];
    for (const script of scripts) {
      try {
        // Decode HTML entities before parsing
        const decodedText = decodeHTML(script.textContent);
        const json = JSON.parse(decodedText);
        jsonLdBlocks.push(json);
      } catch (e) {
        console.warn('Failed to parse JSON-LD:', e);
      }
    }
    return jsonLdBlocks;
  }

  // Helper: Extract detected types from scripts (with Squarespace pattern support)
  function extractDetectedTypes(scripts) {
    const detectedTypes = [];
    for (const s of scripts) {
      try {
        // Decode HTML entities before parsing
        const decodedText = decodeHTML(s.textContent.trim());
        const data = JSON.parse(decodedText);
        extractTypesFromJsonLd(data, detectedTypes);
      } catch (err) {
        console.warn('Invalid JSON-LD block', err);
      }
    }
    return detectedTypes;
  }

  // Helper: Handle direct fetch fallback
  async function handleDirectFetchFallback(url, schemaTypeCell) {
    if (schemaTypeCell) setProgress(schemaTypeCell, 15, 'Fetching');
    const response = await fetch(url, { mode: 'cors' });
    const htmlText = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlText, 'text/html');
    
    if (schemaTypeCell) setProgress(schemaTypeCell, 40, 'Fetched');
    
    // Find all JSON-LD script tags (including Squarespace patterns)
    const scripts = findAllJsonLdScripts(doc);
    const detectedTypes = extractDetectedTypes(scripts);
    
    if (schemaTypeCell) {
      const uniqueTypes = [...new Set(detectedTypes)];
      const schemaType = uniqueTypes.length ? uniqueTypes.join(', ') : 'None';
      setProgress(schemaTypeCell, uniqueTypes.length ? 85 : 70, uniqueTypes.length ? 'Detected' : 'Scanning');
    }
    
    const uniqueTypes = [...new Set(detectedTypes)];
    const schemaType = uniqueTypes.length ? uniqueTypes.join(', ') : 'None';
    const jsonLdBlocks = parseJsonLdBlocksFromScripts(scripts);
    
    return {
      url,
      jsonLd: jsonLdBlocks,
      schemaFound: jsonLdBlocks.length > 0,
      schemaType: schemaType
    };
  }

  // Helper: Handle server fallback
  async function handleServerFallback(url, schemaTypeCell) {
    debugLog(`Local parse failed for ${url}, trying server fallback...`, 'info');
    if (schemaTypeCell) {
      setProgress(schemaTypeCell, 10, 'Server fallback...');
    }
    
    try {
      const serverData = await fetchPageSchemaServer(url);
      
      if (schemaTypeCell) {
        setProgress(schemaTypeCell, 100, 'Done');
        setTimeout(() => {
          const schemaTypeText = serverData.schemaType || '‚Äî';
          schemaTypeCell.textContent = serverData.schemaFound ? `${schemaTypeText} (server)` : '‚Äî';
        }, 500);
      }
      
      serverData.parsePath = 'server';
      serverData.localParseFailed = true;
      
      return serverData;
    } catch (serverError) {
      if (schemaTypeCell) {
        markProgressError(schemaTypeCell);
        setProgress(schemaTypeCell, 100, 'Error');
      }
      throw serverError;
    }
  }

  // Helper: Process fetched HTML and extract schema (also check noscript tags and Squarespace patterns)
  function processFetchedHtml(html, schemaTypeCell, url) {
    if (schemaTypeCell) setProgress(schemaTypeCell, 40, 'Fetched');
    
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Find all JSON-LD script tags (including Squarespace patterns)
    const scripts = findAllJsonLdScripts(doc);
    
    if (schemaTypeCell) setProgress(schemaTypeCell, 60, 'Parsed DOM');
    
    const { jsonLdBlocks, detectedTypes, blockInfo } = parseJsonLdBlocks(scripts, schemaTypeCell);
    detectDuplicateTypes(detectedTypes, blockInfo);
    
    // Diagnostic log for detected blocks
    console.info(`Detected ${jsonLdBlocks.length} JSON-LD blocks (including Squarespace code blocks)`);
    debugLog(`Found ${scripts.length} JSON-LD script blocks, detected types: ${detectedTypes.length > 0 ? [...new Set(detectedTypes)].join(', ') : 'None'} (${detectedTypes.length} total, ${[...new Set(detectedTypes)].length} unique)`, detectedTypes.length > 0 ? 'success' : 'warn');
    
    if (schemaTypeCell) {
      const uniqueTypes = [...new Set(detectedTypes)];
      const schemaType = uniqueTypes.length ? uniqueTypes.join(', ') : 'None';
      setProgress(schemaTypeCell, uniqueTypes.length ? 85 : 70, uniqueTypes.length ? 'Detected' : 'Scanning');
    }
    
    return {
      url,
      jsonLd: jsonLdBlocks,
      schemaFound: jsonLdBlocks.length > 0,
      schemaType: detectedTypes.length ? [...new Set(detectedTypes)].join(', ') : 'None'
    };
  }

  // Helper: Handle fetch errors with fallbacks
  async function handleFetchErrors(error, url, schemaTypeCell) {
    try {
      return await handleDirectFetchFallback(url, schemaTypeCell);
    } catch (err) {
      if (schemaTypeCell) {
        markProgressError(schemaTypeCell);
        setProgress(schemaTypeCell, 100, 'Error');
      }
      return await handleServerFallback(url, schemaTypeCell);
    }
  }

  // Fetch page and extract JSON-LD
  async function fetchPageSchema(url, progressIndex) {
    const schemaTypeCell = progressIndex !== undefined ? document.getElementById(`schemaTypeCell_${progressIndex}`) : null;
    
    try {
      const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
      
      if (schemaTypeCell) setProgress(schemaTypeCell, 15, 'Fetching');
      const response = await fetch(proxyUrl);
      const data = await response.json();
      const html = data.contents;
      
      return processFetchedHtml(html, schemaTypeCell, url);
    } catch (error) {
      return await handleFetchErrors(error, url, schemaTypeCell);
    }
  }

  // Extract schema types
  function extractSchemaTypes(jsonLdBlocks) {
    const types = new Set();
    
    jsonLdBlocks.forEach(block => {
      if (Array.isArray(block)) {
        block.forEach(item => {
          if (item['@type']) {
            const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
            itemTypes.forEach(t => types.add(t));
          }
        });
      } else if (block['@type']) {
        const blockTypes = Array.isArray(block['@type']) ? block['@type'] : [block['@type']];
        blockTypes.forEach(t => types.add(t));
      } else if (block['@graph']) {
        block['@graph'].forEach(item => {
          if (item['@type']) {
            const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
            itemTypes.forEach(t => types.add(t));
          }
        });
      }
    });
    
    return Array.from(types);
  }

  // Helper: Split combined schema type string into individual types
  function splitSchemaType(schemaType) {
    if (typeof schemaType === 'string') {
      // Handle comma-separated types like "Organization,LocalBusiness"
      return schemaType.split(',').map(t => t.trim()).filter(Boolean);
    }
    if (Array.isArray(schemaType)) {
      return schemaType;
    }
    return [schemaType];
  }

  // Helper: Check if a field exists in any of the combined schema types
  function fieldExistsInCombinedTypes(schema, field, combinedTypes) {
    // Check if field exists directly in schema
    if (schema[field]) {
      return true;
    }
    
    // For combined types, check if field exists in schema (already checked above)
    // This function is used to determine if a recommended field should be downgraded to info
    // If the field is in the schema, it exists, so return true
    // If not, check if any of the combined types typically have this field
    // and if so, it might be inherited, so we'll downgrade to info instead of warning
    
    // Check if any of the combined types have this field in their recommended list
    // If so, and the field doesn't exist, it means it's truly missing but expected
    // However, for combined types like Organization,LocalBusiness, if url exists
    // for Organization, it satisfies LocalBusiness requirement too
    return false; // Field doesn't exist, will be handled by caller
  }

  // Helper: Check if any combined type is known
  function hasAnyKnownType(combinedTypes) {
    for (const type of combinedTypes) {
      if (SCHEMA_REQUIREMENTS[type]) {
        return true;
      }
    }
    return false;
  }

  // Helper: Collect all required and recommended fields from combined types
  function collectFieldsFromTypes(combinedTypes) {
    const allRequiredFields = new Set();
    const allRecommendedFields = new Set();
    
    for (const type of combinedTypes) {
      const requirements = SCHEMA_REQUIREMENTS[type];
      if (requirements) {
        requirements.required.forEach(f => allRequiredFields.add(f));
        requirements.recommended.forEach(f => allRecommendedFields.add(f));
      }
    }
    
    return { allRequiredFields, allRecommendedFields };
  }

  // Helper: Check required fields and add to missingFields
  function checkRequiredFields(schema, allRequiredFields, missingFields) {
    for (const field of allRequiredFields) {
      if (!schema[field]) {
        missingFields.push(field);
      }
    }
  }

  // Helper: Check recommended fields and categorize as warnings or info
  function checkRecommendedFields(schema, allRecommendedFields, combinedTypes, warnings, info) {
    for (const field of allRecommendedFields) {
      if (!schema[field]) {
        const typesRequiringField = combinedTypes.filter(type => {
          const req = SCHEMA_REQUIREMENTS[type];
          return req && req.recommended.includes(field);
        });
        
        if (typesRequiringField.length > 1) {
          info.push(`‚ÑπÔ∏è Recommended field "${field}" not present, but acceptable for combined schema types`);
        } else {
          warnings.push(`Missing recommended: ${field}`);
        }
      }
    }
  }

  // Validate schema fields
  function validateSchemaFields(schema, schemaType) {
    const missingFields = [];
    const warnings = [];
    const info = [];
    
    // Handle combined types like "Organization,LocalBusiness" or arrays
    const combinedTypes = splitSchemaType(schemaType);
    
    // Skip "Unknown" warning if any of the types are known
    if (!hasAnyKnownType(combinedTypes)) {
      warnings.push(`Unknown schema type: ${schemaType}`);
      return { missingFields, warnings, info };
    }
    
    // Collect fields from all types
    const { allRequiredFields, allRecommendedFields } = collectFieldsFromTypes(combinedTypes);
    
    // Check required fields
    checkRequiredFields(schema, allRequiredFields, missingFields);
    
    // Check recommended fields
    checkRecommendedFields(schema, allRecommendedFields, combinedTypes, warnings, info);
    
    return { missingFields, warnings, info };
  }

  // Analyze schemas
  function analyzeSchemas(jsonLdBlocks, url) {
    const analysis = {
      schemaFound: jsonLdBlocks.length > 0,
      schemaTypes: [],
      schemas: [],
      missingFields: [],
      warnings: [],
      info: [],
      valid: false
    };
    
    if (jsonLdBlocks.length === 0) {
      analysis.warnings.push('No schema markup found');
      return analysis;
    }
    
    analysis.schemaTypes = extractSchemaTypes(jsonLdBlocks);
    
    jsonLdBlocks.forEach((block, index) => {
      let schemas = [];
      
      if (block['@graph']) {
        schemas = block['@graph'];
      } else if (Array.isArray(block)) {
        schemas = block;
      } else {
        schemas = [block];
      }
      
      schemas.forEach(schema => {
        const schemaType = schema['@type'];
        if (schemaType) {
          // Skip Squarespace system-injected Organization nodes
          const types = Array.isArray(schemaType) ? schemaType : [schemaType];
          const isSystemInjected = types.includes('Organization') &&
            !schema['@id'] &&
            !schema.url &&
            !schema.name &&
            (schema.email || schema.telephone);
          
          if (isSystemInjected) {
            console.log('Skipping Squarespace auto Organization node ‚Äî no @id, name, or url');
            schema.systemInjected = true;
            // Add to schemas array for display (grayed out), but don't count in missing fields
            analysis.schemas.push({
              type: schemaType,
              schema: schema,
              missingFields: [],
              warnings: [],
              systemInjected: true
            });
            return; // Skip field validation and missing field counting
          }
          
          // Normalize schemaType to handle arrays - convert to comma-separated string
          const normalizedType = Array.isArray(schemaType) ? schemaType.join(',') : schemaType;
          const fieldValidation = validateSchemaFields(schema, normalizedType);
          analysis.schemas.push({
            type: schemaType,
            schema: schema,
            missingFields: fieldValidation.missingFields,
            warnings: fieldValidation.warnings,
            info: fieldValidation.info || [],
            systemInjected: false
          });
          
          // CRITICAL: Ensure arrays exist before pushing
          if (!analysis.missingFields || !Array.isArray(analysis.missingFields)) {
            analysis.missingFields = [];
          }
          if (!analysis.warnings || !Array.isArray(analysis.warnings)) {
            analysis.warnings = [];
          }
          if (!analysis.info || !Array.isArray(analysis.info)) {
            analysis.info = [];
          }
          
          if (fieldValidation.missingFields && Array.isArray(fieldValidation.missingFields)) {
            analysis.missingFields.push(...fieldValidation.missingFields);
          }
          if (fieldValidation.warnings && Array.isArray(fieldValidation.warnings)) {
            analysis.warnings.push(...fieldValidation.warnings);
          }
          if (fieldValidation.info && Array.isArray(fieldValidation.info) && fieldValidation.info.length > 0) {
            analysis.info.push(...fieldValidation.info);
          }
        }
      });
    });
    
    analysis.valid = analysis.schemaFound && 
                     analysis.missingFields.length === 0 && 
                     analysis.schemaTypes.length > 0;
    
    return analysis;
  }

  // Helper: Process placeholder value and replace with inferred data
  function processPlaceholderValue(value, field, url) {
    if (typeof value === 'string' && value.includes('[AUTO-INFERRED')) {
      return (field === 'url' && url) ? url : value;
    }
    
    if (typeof value === 'object' && value !== null) {
      const cloned = JSON.parse(JSON.stringify(value));
      if (field === 'offers' && cloned.url && cloned.url.includes('[AUTO-INFERRED')) {
        cloned.url = url;
      }
      return cloned;
    }
    
    return value;
  }

  // Helper: Fill a single field with default or placeholder
  function fillFieldValue(enhanced, field, defaults, url, isRequired) {
    if (enhanced[field] && (!Array.isArray(enhanced[field]) || enhanced[field].length > 0)) {
      return; // Field already has value
    }
    
    if (field === 'url' && url) {
      enhanced[field] = url;
      return;
    }
    
    if (defaults[field] !== undefined) {
      enhanced[field] = processPlaceholderValue(defaults[field], field, url);
      return;
    }
    
    if (isRequired) {
      enhanced[field] = `[REPLACE WITH ${field.toUpperCase()}]`;
    }
  }

  // Helper: Ensure basic schema structure
  function ensureBasicSchemaStructure(enhanced, schemaType, url) {
    if (!enhanced['@context']) {
      enhanced['@context'] = 'https://schema.org/';
    }
    if (!enhanced['@type'] && schemaType) {
      enhanced['@type'] = schemaType;
    }
    if (!enhanced.url && url) {
      enhanced.url = url;
    }
  }

  // Helper: Apply schema-specific enhancements
  function applySchemaSpecificEnhancements(enhanced, schemaType, url) {
    if (schemaType === 'Product' && enhanced.offers && typeof enhanced.offers === 'object' && !enhanced.offers.url && url) {
      enhanced.offers.url = url;
    }
    
    if (schemaType === 'Event' && enhanced.location && typeof enhanced.location === 'object' && !enhanced.location.address) {
      enhanced.location.address = DEFAULT_VALUES.Event.location.address;
    }
  }

  // Enhance schema with missing fields
  function enhanceSchema(schema, schemaType, url) {
    const enhanced = JSON.parse(JSON.stringify(schema));
    const defaults = DEFAULT_VALUES[schemaType] || {};
    const requirements = SCHEMA_REQUIREMENTS[schemaType];
    
    if (!requirements) {
      ensureBasicSchemaStructure(enhanced, schemaType, url);
      return enhanced;
    }
    
    ensureBasicSchemaStructure(enhanced, schemaType, url);
    
    // Fill missing required fields
    requirements.required.forEach(field => {
      fillFieldValue(enhanced, field, defaults, url, true);
    });
    
    // Fill missing recommended fields
    requirements.recommended.forEach(field => {
      fillFieldValue(enhanced, field, defaults, url, false);
    });
    
    applySchemaSpecificEnhancements(enhanced, schemaType, url);
    
    return enhanced;
  }

  // Helper: Build missing field messages
  function buildMissingFieldMessages(missingDetails, allNodes) {
    const missingMessages = [];
    for (const m of missingDetails) {
      const elsewhere = findFieldElsewhere(allNodes, m.field, m.type);
      let nodeLocation = '';
      if (m.hasId && m.key && m.key.includes('#')) {
        const idPart = m.key.split('#')[1];
        nodeLocation = ` (in node with @id: ${idPart})`;
      } else if (!m.hasId) {
        nodeLocation = ` (in node WITHOUT @id - likely needs fixing)`;
      }
      
      const duplicateInfo = m.instances > 1 ? ` [${m.instances} duplicate instances]` : '';
      if (elsewhere) {
        missingMessages.push(`${m.type}: "${m.field}" missing${nodeLocation}${duplicateInfo}. Found in ${elsewhere.fromType}: "${elsewhere.value}". Copy it into ${m.type}.`);
      } else {
        missingMessages.push(`${m.type}: "${m.field}" missing${nodeLocation}${duplicateInfo} (add this property to the ${m.type} node).`);
      }
    }
    return missingMessages;
  }

  // Helper: Build duplicate groups from nodes
  function buildDuplicateGroups(allNodes) {
    const duplicateGroups = {};
    for (let idx = 0; idx < allNodes.length; idx++) {
      const n = allNodes[idx];
      const types = asArray(n['@type']);
      for (const t of types) {
        if (!duplicateGroups[t]) duplicateGroups[t] = [];
        const key = n['@id'] || JSON.stringify([n['@type'], n.url, n.name]).slice(0, 100);
        duplicateGroups[t].push({ index: idx, key, hasId: !!n['@id'], node: n });
      }
    }
    return duplicateGroups;
  }

  // Helper: Count keys for duplicate detection
  function countKeysForType(nodes) {
    const keyCounts = {};
    const keyDetails = {};
    for (const n of nodes) {
      keyCounts[n.key] = (keyCounts[n.key] || 0) + 1;
      if (!keyDetails[n.key]) {
        keyDetails[n.key] = { hasId: n.hasId, node: n.node };
      }
    }
    return { keyCounts, keyDetails };
  }

  // Helper: Build duplicate warning for a key
  function buildDuplicateWarningForKey(t, key, keyCounts, keyDetails) {
    const keyName = key.includes('#') ? key.split('#')[1] : 'root';
    const label = key.includes('#') ? ` (@id: ${keyName})` : ' (no @id - likely duplicate)';
    return {
      warning: `${t}: ${keyCounts[key]} instances found${label}`,
      object: { type: t, id: keyName, count: keyCounts[key] }
    };
  }

  // Helper: Detect footer-injected schema patterns
  function detectFooterInjectedSchema(node) {
    const id = node['@id'] || '';
    const idLower = id.toLowerCase();
    const footerPatterns = ['footer', 'site-footer', 'footer-injection', 'footer-schema'];
    return footerPatterns.some(pattern => idLower.includes(pattern));
  }

  // Helper: Detect BreadcrumbList nodes globally
  function detectBreadcrumbListNodes(allNodes) {
    return allNodes.filter(n => {
      const types = asArray(n['@type']);
      return types.includes('BreadcrumbList');
    });
  }

  // Helper: Check if duplicate should be skipped
  function shouldSkipDuplicate(key, t, keyDetails, globalPatterns) {
    const isGlobal = key.includes('#') && globalPatterns.some(p => key.includes(p));
    const isBreadcrumb = t === 'BreadcrumbList';
    const isMultiInstanceAllowed = MULTI_INSTANCE_ALLOWED_TYPES.includes(t);
    const nodeData = keyDetails[key];
    const isFooterInjected = nodeData?.node ? detectFooterInjectedSchema(nodeData.node) : false;
    
    // Skip if it's a global schema, breadcrumb, multi-instance allowed type, or footer-injected
    return isGlobal || isFooterInjected || isBreadcrumb || isMultiInstanceAllowed;
  }

  // Helper: Process duplicate warnings
  function processDuplicateWarnings(duplicateGroups, globalPatterns) {
    const duplicateWarnings = [];
    const duplicateWarningsObjects = [];
    
    for (const t of Object.keys(duplicateGroups)) {
      const nodes = duplicateGroups[t];
      const { keyCounts, keyDetails } = countKeysForType(nodes);
      
      for (const key of Object.keys(keyCounts)) {
        if (keyCounts[key] > 1) {
          if (!shouldSkipDuplicate(key, t, keyDetails, globalPatterns)) {
            const { warning, object } = buildDuplicateWarningForKey(t, key, keyCounts, keyDetails);
            duplicateWarnings.push(warning);
            duplicateWarningsObjects.push(object);
          }
        }
      }
    }
    
    return { duplicateWarnings, duplicateWarningsObjects };
  }

  // Helper: Count keys for a type
  function countKeysForTypeSimple(nodes) {
    const keyCounts = {};
    for (const n of nodes) {
      keyCounts[n.key] = (keyCounts[n.key] || 0) + 1;
    }
    return keyCounts;
  }

  // Helper: Build global duplicate entry
  function buildGlobalDuplicateEntry(t, key, keyCounts) {
    const keyName = key.includes('#') ? key.split('#')[1] : 'root';
    return `${t}: ${keyCounts[key]}x (@id: ${keyName})`;
  }

  // Helper: Log global duplicates
  function logGlobalDuplicates(duplicateGroups, globalPatterns) {
    const globalDuplicates = [];
    for (const t of Object.keys(duplicateGroups)) {
      const nodes = duplicateGroups[t];
      const keyCounts = countKeysForTypeSimple(nodes);
      
      for (const key of Object.keys(keyCounts)) {
        if (keyCounts[key] > 1) {
          const isGlobal = key.includes('#') && globalPatterns.some(p => key.includes(p));
          if (isGlobal) {
            globalDuplicates.push(buildGlobalDuplicateEntry(t, key, keyCounts));
          }
        }
      }
    }
    
    if (globalDuplicates.length > 0) {
      debugLog(`Global injections detected (expected): ${globalDuplicates.join(', ')}`, 'info');
    }
  }

  // Helper: Log Organization nodes missing name
  function logOrgNodesMissingName(allNodes) {
    const orgNodes = allNodes.filter(n => {
      const types = asArray(n['@type']);
      return types.includes('Organization');
    });
    
    const orgNodesMissingName = orgNodes.filter(n => !n.name || !n.name.trim());
    if (orgNodesMissingName.length > 0) {
      // Log as info - these are typically Squarespace-injected nodes without @id, expected behavior
      debugLog(`Found ${orgNodesMissingName.length} Organization node(s) missing 'name' (likely Squarespace-injected):`, 'info');
      for (let idx = 0; idx < orgNodesMissingName.length; idx++) {
        const n = orgNodesMissingName[idx];
        const idInfo = n['@id'] ? `@id: ${n['@id']}` : 'no @id';
        const urlInfo = n.url ? `url: ${n.url}` : 'no url';
        debugLog(`  Organization ${idx + 1}: ${idInfo}, ${urlInfo}`, 'info');
      }
    }
  }

  // Helper: Update schema type cell UI
  function updateSchemaTypeCellUI(urlData, pageData, analysis) {
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${urlData.row}`);
    if (schemaTypeCell && schemaTypeCell.querySelector('.progress')) {
      setProgress(schemaTypeCell, 100, 'Done');
      setTimeout(() => {
        // Only update if cell still has progress indicator (hasn't been replaced by updateTableRow yet)
        const currentCell = document.getElementById(`schemaTypeCell_${urlData.row}`);
        if (currentCell && currentCell.querySelector('.progress')) {
          const uniqueTypes = [...new Set((pageData.schemaType || analysis.schemaTypes.join(', ') || '‚Äî').split(',').map(t => t.trim()))];
          
          // Get inferred types from result if available
          const resultIndex = validationResults.findIndex(r => r.url === urlData.url);
          const inferredTypes = resultIndex >= 0 && validationResults[resultIndex]?.inferredTypes || [];
          
          // Format with inferred types
          const schemaTypeText = formatSchemaTypesWithInferred(uniqueTypes, inferredTypes);
          const serverBadge = pageData.serverFallback ? ' (server)' : '';
          
          // Use innerHTML to render HTML (for italic styling)
          currentCell.innerHTML = schemaTypeText + serverBadge;
        }
      }, 500);
    }
  }

  // Helper: Add parse note to result
  function addParseNote(result, noteText, checkText) {
    if (!result.notes) {
      result.notes = noteText;
    } else if (!result.notes.includes(checkText)) {
      result.notes = noteText + '\n' + result.notes;
    }
  }

  // Helper: Append parse note to result
  function appendParseNote(result, noteText, checkText) {
    if (!result.notes || !result.notes.includes(checkText)) {
      result.notes = (result.notes || '') + (result.notes ? '\n' : '') + noteText;
    }
  }

  // Helper: Build result notes
  function buildResultNotes(result, pageData) {
    if (result.localParseFailed && result.serverFallback) {
      const parseNote = `Local parse: blocked. Server parse: success (${result.blockCount} blocks).`;
      addParseNote(result, parseNote, 'Server parse');
    } else if (!result.localParseFailed && result.schemaFound) {
      const parseNote = 'Local parse: success.';
      appendParseNote(result, parseNote, 'Local parse');
    } else if (result.serverFallback && !result.schemaFound) {
      const parseNote = 'Server fallback: no JSON-LD found.';
      appendParseNote(result, parseNote, 'Server fallback');
    }
    
    if (pageData.duplicateWarnings && pageData.duplicateWarnings.length > 0) {
      debugLog(`Server fallback detected duplicates: ${pageData.duplicateWarnings.join('; ')}`, 'info');
    }
  }

  // ---- Schema Extraction and Result Construction Fix ----
  
  // --- Schema Detection Utilities ---
  function extractSchemaTypeValue(typeValue) {
    if (!typeValue) return [];
    if (Array.isArray(typeValue)) return typeValue.map(t => t.trim());
    if (typeof typeValue === 'string') return typeValue.split(',').map(t => t.trim());
    return [];
  }

  // 2Ô∏è‚É£ Re-enable row-level progress
  function updateRowProgress(url, percent) {
    const row = document.querySelector(`[data-url="${url}"]`);
    if (!row) return;
    let bar = row.querySelector('.progress-inner');
    if (!bar) {
      const cell = row.querySelector('.status-cell') || row.querySelector(`#statusCell_${row.dataset.rowIndex || ''}`);
      if (!cell) return;
      const wrapper = document.createElement('div');
      wrapper.className = 'progress';
      bar = document.createElement('div');
      bar.className = 'progress-inner';
      wrapper.appendChild(bar);
      cell.appendChild(wrapper);
    }
    bar.style.width = percent + '%';
  }

  function buildAnalysisResult(url, blocks, issuesList = []) {
    const schemaTypes = [
      ...new Set(blocks.flatMap(b => extractSchemaTypeValue(b['@type'])).filter(Boolean))
    ];
    const schemaFound = schemaTypes.length > 0;

    // Ensure schemaFound stays true if any valid blocks exist
    if (!schemaFound && blocks && blocks.length > 0) {
      console.log(`[‚úì] Schema detected via fallback: ${blocks.map(b => b['@type'] || 'unknown').join(', ')}`);
    }

    const analysisResult = {
      url,
      schemaFound: schemaFound || (blocks && blocks.length > 0),
      schemaTypes,
      missingFields: issuesList.filter(i => i.severity === 'missing'),
      warnings: issuesList.filter(i => i.severity === 'warning'),
      info: issuesList.filter(i => i.severity === 'info'),
      timestamp: new Date().toISOString(),
    };

    cacheResult(url, analysisResult);
    
    // Store persistently in validationResults array by URL
    const resultIndex = validationResults.findIndex(r => r.url === url);
    if (resultIndex >= 0) {
      // Update existing result with schemaFound and schemaTypes
      validationResults[resultIndex].schemaFound = analysisResult.schemaFound;
      validationResults[resultIndex].schemaTypes = analysisResult.schemaTypes;
    } else {
      // If not found, push to array (though this should rarely happen)
      validationResults.push(analysisResult);
    }
    
    updateResultRow(url, analysisResult);
    return analysisResult;
  }

  // 4Ô∏è‚É£ Update table cells safely with enhanced status badges
  function updateResultRow(url, result) {
    const row = document.querySelector(`[data-url="${url}"]`);
    if (!row) return;
    
    // Extract row index from row ID or dataset
    const rowMatch = row.id?.match(/row_(\d+)/);
    const rowIndex = rowMatch ? rowMatch[1] : (row.dataset?.rowIndex || '');
    
    if (!rowIndex) return; // Can't update without index
    
    // Find cells by ID
    const schemaCell = document.getElementById(`schemaTypeCell_${rowIndex}`);
    const statusCell = document.getElementById(`statusCell_${rowIndex}`);
    const missingFieldsCell = document.getElementById(`missingFieldsCell_${rowIndex}`);
    const warningsCell = document.getElementById(`warningsCell_${rowIndex}`);
    const infoCell = document.getElementById(`infoCell_${rowIndex}`);
    
    // Update schema type cell
    if (schemaCell && result.schemaTypes) {
      // Preserve inferred types when updating cell
      const inferredTypes = result.inferredTypes || [];
      const types = result.schemaTypes.join(', ') || '‚Äî';
      
      if (inferredTypes.length > 0) {
        const formattedTypes = formatSchemaTypesWithInferred(result.schemaTypes, inferredTypes);
        schemaCell.innerHTML = formattedTypes;
      } else {
        schemaCell.textContent = types;
      }
    }
    
    // Update status cell with progress-aware badge
    if (statusCell) {
      const progressBar = row.querySelector('.progress-inner');
      const progress = progressBar ? Number.parseInt(progressBar.style.width) || 0 : 100;
      
      let statusHtml;
      if (!result.schemaFound && progress < 10) {
        statusHtml = '<span class="chip-queued">‚è≥ Queued</span>';
      } else if (!result.schemaFound && progress < 50) {
        statusHtml = '<span class="chip-fetching">üîÑ Fetching</span>';
      } else if (result.schemaFound) {
        const hasCritical = result.missingFields && result.missingFields.length > 0;
        if (hasCritical && result.missingFields.length > 3) {
          statusHtml = '<span class="chip-critical">‚ùå Critical</span>';
        } else if (hasCritical) {
          statusHtml = '<span class="chip-issues">‚ö†Ô∏è Issues</span>';
        } else {
          statusHtml = '<span class="chip-valid">‚úÖ Valid</span>';
        }
      } else {
        statusHtml = '<span class="status-badge no-schema">‚ùå No Schema</span>';
      }
      
      statusCell.innerHTML = statusHtml;
    }
    
    // Update Missing Fields column (with suppression)
    if (missingFieldsCell && result.missingFields) {
      const filteredMissingFields = filterSuppressedMissingFields(result.missingFields, result.schemaType || '', result.url || '');
      if (filteredMissingFields.length > 0) {
        missingFieldsCell.innerHTML = filteredMissingFields.map(f => `<div class="missing-entry">‚ùå ${f}</div>`).join('');
      } else {
        missingFieldsCell.textContent = '‚Äî';
      }
    }
    
    // Update Warnings column (with suppression)
    if (warningsCell && result.warnings) {
      const filteredWarnings = filterSuppressedWarnings(result.warnings, result.url || '');
      if (filteredWarnings.length > 0) {
        warningsCell.innerHTML = filteredWarnings.map(w => `<div class="warning-entry">‚ö†Ô∏è ${w}</div>`).join('');
      } else {
        warningsCell.textContent = '‚Äî';
      }
    }
    
    // Update Info column (with suppression)
    if (infoCell && result.info) {
      const filteredInfo = filterSuppressedInfo(result.info, result.url || '');
      if (filteredInfo.length > 0) {
        infoCell.innerHTML = filteredInfo.map(i => `<div class="info-entry">${i}</div>`).join('');
      } else {
        infoCell.textContent = '‚Äî';
      }
    }
  }

  // Helper: Suppress redundant Event blocks injected by Squarespace
  function suppressRedundantEventBlocks(jsonLdBlocks) {
    if (!jsonLdBlocks || !Array.isArray(jsonLdBlocks)) return jsonLdBlocks;
    
    let suppressedCount = 0;
    const processedBlocks = [];
    const eventGroups = new Map(); // key: "name|startDate" -> array of block indices
    
    // First pass: Identify all Event nodes and group by name/startDate
    jsonLdBlocks.forEach((block, blockIndex) => {
      // Check if this block contains Event nodes (but skip if inside ItemList)
      const nodes = flattenJsonLd(block, []);
      const eventNodes = nodes.filter(n => {
        const types = asArray(n['@type']);
        return types.includes('Event');
      });
      
      // Skip if Event is inside ItemList
      const hasItemList = nodes.some(n => {
        const types = asArray(n['@type']);
        return types.includes('ItemList');
      });
      
      if (eventNodes.length > 0 && !hasItemList) {
        // Extract key from first Event node in block
        const firstEvent = eventNodes[0];
        const name = firstEvent.name || '';
        const startDate = firstEvent.startDate || '';
        const key = `${name}|${startDate}`;
        
        if (!eventGroups.has(key)) {
          eventGroups.set(key, []);
        }
        eventGroups.get(key).push({
          blockIndex,
          block,
          eventNodes,
          name,
          startDate
        });
      }
    });
    
    // Second pass: Process blocks - keep first Event of each group, suppress duplicates
    const suppressedIndices = new Set();
    
    eventGroups.forEach((group, key) => {
      if (group.length > 1) {
        // Multiple Events with same name/startDate - keep first, suppress others
        for (let i = 1; i < group.length; i++) {
          suppressedIndices.add(group[i].blockIndex);
          suppressedCount++;
        }
        debugLog(`[SUPPRESSION] Found ${group.length} duplicate Event blocks with name="${group[0].name}", startDate="${group[0].startDate}" - keeping first, suppressing ${group.length - 1}`, 'info');
      } else {
        // Single Event with this key - check if there are other Event blocks
        // If there are multiple Event blocks total, suppress all but the first one
        const allEventBlocks = [];
        eventGroups.forEach((g) => {
          g.forEach(item => allEventBlocks.push(item));
        });
        allEventBlocks.sort((a, b) => a.blockIndex - b.blockIndex);
        
        if (allEventBlocks.length > 1 && group[0].blockIndex !== allEventBlocks[0].blockIndex) {
          suppressedIndices.add(group[0].blockIndex);
          suppressedCount++;
        }
      }
    });
    
    // Build filtered blocks array - mark suppressed blocks
    jsonLdBlocks.forEach((block, blockIndex) => {
      if (suppressedIndices.has(blockIndex)) {
        // Mark as suppressed by adding a flag
        const processedBlock = { ...block, _suppressed: true };
        processedBlocks.push(processedBlock);
      } else {
        processedBlocks.push(block);
      }
    });
    
    if (suppressedCount > 0) {
      debugLog(`[SUPPRESSION] Collapsed duplicate Event nodes (${suppressedCount} suppressed)`, 'info');
    }
    
    return processedBlocks;
  }

  // Helper: Filter out suppressed blocks before processing
  function filterSuppressedBlocks(jsonLdBlocks) {
    if (!jsonLdBlocks || !Array.isArray(jsonLdBlocks)) return jsonLdBlocks;
    return jsonLdBlocks.filter(block => !block._suppressed);
  }

  // Helper: Process schema nodes and build issues list
  function processSchemaNodes(pageData) {
    // Filter out suppressed blocks before processing
    const filteredBlocks = filterSuppressedBlocks(pageData.jsonLd);
    let allNodes = [];
    for (const block of filteredBlocks) {
      try {
        allNodes = flattenJsonLd(block, allNodes);
      } catch(_) {}
    }
    
    const missingDetails = computeMissingFields(allNodes);
    debugLog(`Computed missing fields: ${missingDetails.length} issue(s) found`, missingDetails.length > 0 ? 'warn' : 'success');
    if (missingDetails.length > 0) {
      debugLog(`Missing fields details: ${JSON.stringify(missingDetails)}`, 'warn');
    }
    
    return { allNodes, missingDetails };
  }

  // Helper: Process duplicate detection
  function processDuplicateDetection(allNodes) {
    const globalPatterns = ['website', 'org', 'local', 'breadcrumbs'];
    const duplicateGroups = buildDuplicateGroups(allNodes);
    const { duplicateWarnings, duplicateWarningsObjects } = processDuplicateWarnings(duplicateGroups, globalPatterns);
    
    if (duplicateWarnings.length > 0) {
      debugLog(`Duplicate schema detected: ${duplicateWarnings.join('; ')}`, 'warn');
    }
    
    return { duplicateGroups, duplicateWarningsObjects, globalPatterns };
  }

  // Helper: Build and categorize issues
  function buildAndCategorizeIssues(missingDetails, duplicateWarningsObjects, allNodes, analysis, url = '') {
    const issuesList = buildUnifiedIssuesList(missingDetails, duplicateWarningsObjects, allNodes);
    debugLog(`‚úÖ Built issuesList: ${issuesList.length} issue(s)`, 'success');
    if (issuesList.length > 0) {
      debugLog(`issuesList contents: ${JSON.stringify(issuesList, null, 2)}`);
    }
    
    // Split issuesList into missingFields, warnings, and info (with suppression)
    const buckets = splitIssuesIntoBuckets(issuesList, allNodes, url);
    
    // Add info from analysis (e.g., downgraded "Missing recommended" messages)
    if (analysis.info && analysis.info.length > 0) {
      if (!buckets.info) buckets.info = [];
      const filteredInfo = filterSuppressedInfo(Array.isArray(analysis.info) ? analysis.info : [], url);
      buckets.info.push(...filteredInfo);
    }
    
    // Apply suppression filters to buckets
    buckets.warnings = filterSuppressedWarnings(buckets.warnings, url);
    buckets.info = filterSuppressedInfo(buckets.info, url);
    
    return { issuesList, buckets };
  }

  // Helper: Add informational detections
  function addInformationalDetections(allNodes, result, url = '') {
    try {
      if (!result.info) result.info = [];
      
      // Detect BreadcrumbList nodes
      const breadcrumbNodes = detectBreadcrumbListNodes(allNodes);
      if (breadcrumbNodes.length > 0) {
        debugLog(`Detected ${breadcrumbNodes.length} BreadcrumbList node(s)`, 'info');
        const infoMessage = `‚ÑπÔ∏è BreadcrumbList detected (${breadcrumbNodes.length} node${breadcrumbNodes.length !== 1 ? 's' : ''}) - normal navigation schema`;
        if (!shouldSuppressInfo(infoMessage, url)) {
          result.info.push(infoMessage);
        }
      }
      
      // Add friendly messages for multi-instance allowed types
      MULTI_INSTANCE_ALLOWED_TYPES.forEach(type => {
        const typeNodes = allNodes.filter(n => {
          const types = asArray(n['@type']);
          return types.includes(type);
        });
        
        if (typeNodes.length > 1) {
          const infoMessage = `‚úÖ Multiple ${type} schemas detected (${typeNodes.length}) ‚Äî expected for ${type.toLowerCase()} listings.`;
          // Only add if not already present (to avoid duplicates)
          if (!result.info.some(msg => msg.includes(`${type} schemas detected`))) {
            result.info.push(infoMessage);
            debugLog(`Added multi-instance info: ${type} (${typeNodes.length} instances)`, 'info');
          }
        }
      });
    } catch (error) {
      console.error('[‚ö†] Error in addInformationalDetections:', error);
      // Ensure result.info exists even if error occurs
      if (!result.info) result.info = [];
    }
  }

  // Helper: Set result metadata
  function setResultMetadata(result, pageData, analysis, duplicateGroups) {
    result.parsePath = pageData.parsePath || 'local';
    result.localParseFailed = pageData.localParseFailed || false;
    result.serverFallback = pageData.serverFallback || false;
    result.blockCount = pageData.blockCount || pageData.jsonLd.length;
    
    // Calculate unique schema types (excluding multi-instance allowed types from duplicate count)
    const allUniqueTypes = Object.keys(duplicateGroups);
    const multiInstanceCounts = {};
    let totalMultiInstanceNodes = 0;
    
    MULTI_INSTANCE_ALLOWED_TYPES.forEach(type => {
      if (duplicateGroups[type]) {
        multiInstanceCounts[type] = duplicateGroups[type].length;
        totalMultiInstanceNodes += duplicateGroups[type].length;
      }
    });
    
    result.uniqueSchemaTypes = allUniqueTypes.length;
    result.multiInstanceCounts = multiInstanceCounts;
    
    debugLog(`Total JSON-LD blocks: ${result.blockCount}, unique schema types: ${allUniqueTypes.length}, multi-instance nodes: ${totalMultiInstanceNodes}`, 'info');
    debugLog(`Schema type from pageData: ${pageData.schemaType || 'none'}, from analysis: ${analysis.schemaTypes.join(', ') || 'none'}`, 'info');
  }

  // Helper: Format schema types with inferred types visually differentiated
  function formatSchemaTypesWithInferred(explicitTypes, inferredTypes = []) {
    const explicit = explicitTypes.length > 0 ? explicitTypes.join(', ') : '';
    if (inferredTypes.length === 0) {
      return explicit || '‚Äî';
    }
    
    const inferred = inferredTypes.map(item => {
      // Special formatting for MerchantListing (Google) with green background and white checkmark
      if (item.type === 'MerchantListing (Google)') {
        return `<span style="display: inline-block; background-color: #27AE60; color: white; padding: 1px 4px; border-radius: 3px; font-style: normal; font-weight: 500; font-size: 0.85em; white-space: nowrap;">‚úÖ ${item.type} (inferred)</span>`;
      }
      return `<span style="font-style: italic; color: #6b7280;">*${item.type} (inferred)*</span>`;
    }).join(', ');
    
    if (explicit) {
      return `${explicit}, ${inferred}`;
    }
    return inferred;
  }

  // Helper: Update schema type display
  function updateSchemaTypeDisplay(result, pageData, analysis, urlData) {
    updateSchemaTypeCellUI(urlData, pageData, analysis);
    
    // CRITICAL: NEVER overwrite schemaFound if it's already true or if blocks exist
    const hasBlocks = pageData.jsonLd && pageData.jsonLd.length > 0;
    if (hasBlocks && result.schemaFound === false) {
      // Only set to true if blocks exist and it was false
      result.schemaFound = true;
      console.log(`[‚úì] Restored schemaFound=true (blocks exist: ${pageData.jsonLd.length})`);
    } else if (hasBlocks && result.schemaFound === true) {
      // Keep it true - don't change
      result.schemaFound = true;
    } else if (!hasBlocks) {
      // Only set to false if no blocks exist
      result.schemaFound = false;
    }
    // Otherwise, leave schemaFound as-is (don't overwrite if already set correctly)
    
    // CRITICAL: Use result.schemaTypes (from initialAnalysis) if available, otherwise fall back to analysis or pageData
    const schemaTypesFromResult = result.schemaTypes || [];
    const schemaTypesFromAnalysis = analysis.schemaTypes || [];
    const schemaTypeFromPageData = pageData.schemaType || '';
    
    // Combine all sources and deduplicate
    const allTypes = [
      ...schemaTypesFromResult,
      ...schemaTypesFromAnalysis,
      ...(schemaTypeFromPageData ? schemaTypeFromPageData.split(',').map(t => t.trim()) : [])
    ];
    
    const uniqueTypes = [...new Set(allTypes.filter(Boolean))];
    
    // Get inferred types from result
    const inferredTypes = result.inferredTypes || [];
    
    // Store both explicit and inferred separately
    result.schemaType = uniqueTypes.length > 0 ? uniqueTypes.join(', ') : '‚Äî';
    result.inferredTypes = inferredTypes;
    
    console.log(`[‚úì] Updated schemaType: "${result.schemaType}" (from result.schemaTypes: [${schemaTypesFromResult.join(', ')}], analysis.schemaTypes: [${schemaTypesFromAnalysis.join(', ')}], pageData.schemaType: "${schemaTypeFromPageData}")`);
    if (inferredTypes.length > 0) {
      console.log(`[‚úì] Inferred types: ${inferredTypes.map(t => t.type).join(', ')}`);
    }
  }

  // Helper: Merge analysis results into result object
  function mergeAnalysisResults(result, analysis) {
    // CRITICAL: Ensure arrays are initialized before spreading
    result.missingFields = result.missingFields || [];
    result.warnings = result.warnings || [];
    result.info = result.info || [];
    
    analysis.missingFields = analysis.missingFields || [];
    analysis.warnings = analysis.warnings || [];
    analysis.info = analysis.info || [];
    
    try {
      result.missingFields = [...new Set([...result.missingFields, ...analysis.missingFields])];
      result.warnings = [...new Set([...result.warnings, ...analysis.warnings])];
      if (analysis.info && analysis.info.length > 0) {
        result.info = [...new Set([...result.info, ...analysis.info])];
      }
    } catch (error) {
      console.error('[‚ö†] Error merging analysis results:', error);
      // Fallback: just assign directly
      result.missingFields = [...result.missingFields || [], ...analysis.missingFields || []];
      result.warnings = [...result.warnings || [], ...analysis.warnings || []];
      if (analysis.info && analysis.info.length > 0) {
        result.info = [...result.info || [], ...analysis.info];
      }
    }
    
    result.valid = analysis.valid;
    result.schemas = analysis.schemas || [];
    
    // CRITICAL: Preserve schemaFound - never overwrite if it's already true
    if (result.schemaFound === true) {
      result.schemaFound = true; // Keep it true
    } else if (analysis.schemaFound === true) {
      result.schemaFound = true; // Set from analysis if result was false
    }
    // Don't set to false here - only if no blocks exist at all
  }

  // Process a single URL
  async function processUrl(urlData) {
    // Use index if provided, otherwise fall back to row
    const resultIndex = urlData.index !== undefined ? urlData.index : (urlData.row !== undefined ? urlData.row : 0);
    const result = {
      url: urlData.url,
      row: resultIndex, // Store the correct index
      schemaType: null,
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      info: [],
      schemas: [],
      error: null
    };
    
    let initialAnalysis = null; // Declare outside try-catch so it's accessible in catch
    
    try {
      // Stage 1: Fetch page data (~20%)
      updateRowProgress(urlData.url, 20);
      const pageData = await fetchPageSchema(urlData.url, resultIndex);
      debugLog(`Fetched page data for ${urlData.url}: found ${pageData.jsonLd.length} JSON-LD blocks, schemaType: ${pageData.schemaType}`, 'info');
      
      // Apply Event suppression before processing
      pageData.jsonLd = suppressRedundantEventBlocks(pageData.jsonLd);
      
      // Stage 2: Build initial analysis result (~40%)
      updateRowProgress(urlData.url, 40);
      initialAnalysis = buildAnalysisResult(urlData.url, pageData.jsonLd, []);
      debugLog(`[‚úì] Schema Types: ${initialAnalysis.schemaTypes.join(', ') || 'none'}`, 'info');
      debugLog(`[‚úì] schemaFound: ${initialAnalysis.schemaFound}`, 'info');
      
      // CRITICAL: Set schemaFound from initialAnalysis immediately - don't let it be overwritten
      result.schemaFound = initialAnalysis.schemaFound;
      result.schemaTypes = initialAnalysis.schemaTypes;
      console.log(`[‚úì] Set result.schemaFound=${result.schemaFound} from initialAnalysis`);
      
      // Stage 3: Analyze schemas (~50%)
      updateRowProgress(urlData.url, 50);
      const analysis = analyzeSchemas(pageData.jsonLd, urlData.url);
      debugLog(`Analysis complete: schemaFound=${analysis.schemaFound}, schemaTypes=[${analysis.schemaTypes?.join(', ') || 'none'}], valid=${analysis.valid}`, 'info');
      
      // CRITICAL: Ensure analysis has schemaTypes array
      if (!analysis.schemaTypes || !Array.isArray(analysis.schemaTypes)) {
        analysis.schemaTypes = initialAnalysis.schemaTypes || [];
        console.log(`[‚úì] Restored analysis.schemaTypes from initialAnalysis: [${analysis.schemaTypes.join(', ')}]`);
      }
      
      // CRITICAL: Ensure analysis arrays are initialized
      if (!analysis.info || !Array.isArray(analysis.info)) {
        analysis.info = [];
      }
      if (!analysis.warnings || !Array.isArray(analysis.warnings)) {
        analysis.warnings = [];
      }
      if (!analysis.missingFields || !Array.isArray(analysis.missingFields)) {
        analysis.missingFields = [];
      }
      
      // Ensure schemaFound stays true if blocks exist
      if (pageData.jsonLd && pageData.jsonLd.length > 0) {
        result.schemaFound = true;
        console.log(`[‚úì] Confirmed result.schemaFound=true (${pageData.jsonLd.length} blocks exist)`);
      }
      
      // Stage 4: Process schema nodes (~60%)
      updateRowProgress(urlData.url, 60);
      const { allNodes, missingDetails } = processSchemaNodes(pageData);
      
      // Detect inferred types from allNodes
      const inferredTypes = detectInferredTypes(allNodes);
      result.inferredTypes = inferredTypes;
      if (inferredTypes.length > 0) {
        debugLog(`Detected ${inferredTypes.length} inferred type(s): ${inferredTypes.map(t => t.type).join(', ')}`, 'info');
        console.log(`[DEBUG] processUrl: Detected inferred types for ${urlData.url}:`, inferredTypes);
      } else {
        const eventCount = allNodes.filter(n => {
          const types = asArray(n['@type']);
          return types.includes('Event');
        }).length;
        const productCount = allNodes.filter(n => {
          const types = asArray(n['@type']);
          return types.includes('Product');
        }).length;
        const courseCount = allNodes.filter(n => {
          const types = asArray(n['@type']);
          return types.includes('Course');
        }).length;
        console.log(`[DEBUG] processUrl: No inferred types detected for ${urlData.url} (Event count: ${eventCount}, Product count: ${productCount}, Course count: ${courseCount})`);
      }
      
      // Stage 5: Process duplicate detection (~70%)
      updateRowProgress(urlData.url, 70);
      const { duplicateGroups, duplicateWarningsObjects, globalPatterns } = processDuplicateDetection(allNodes);
      
      // Stage 6: Build and categorize issues (~80%)
      updateRowProgress(urlData.url, 80);
      const { issuesList, buckets } = buildAndCategorizeIssues(missingDetails, duplicateWarningsObjects, allNodes, analysis, urlData.url);
      
      result.issuesList = issuesList;
      result.missingFields = buckets.missingFields;
      result.warnings = buckets.warnings;
      result.info = buckets.info;
      
      // Stage 7: Update analysis result with full issuesList (~90%)
      updateRowProgress(urlData.url, 90);
      const mappedIssues = issuesList.map(i => ({
        severity: i.message?.includes('missing') ? 'missing' : 
                 i.message?.includes('DUPLICATE') || i.message?.includes('‚ö†Ô∏è') ? 'warning' : 'info',
        ...i
      }));
      buildAnalysisResult(urlData.url, pageData.jsonLd, mappedIssues);
      
      // Stage 8: Finalize result (~95%)
      updateRowProgress(urlData.url, 95);
      
      // Ensure arrays are initialized before adding informational detections
      if (!result.info) result.info = [];
      if (!result.warnings) result.warnings = [];
      if (!result.missingFields) result.missingFields = [];
      
      addInformationalDetections(allNodes, result, urlData.url);
      
      // Log diagnostics
      logGlobalDuplicates(duplicateGroups, globalPatterns);
      logOrgNodesMissingName(allNodes);
      
      // Set result metadata
      setResultMetadata(result, pageData, analysis, duplicateGroups);
      
      // Update schema type display
      updateSchemaTypeDisplay(result, pageData, analysis, urlData);
      
      // Merge analysis results
      mergeAnalysisResults(result, analysis);
      
      buildResultNotes(result, pageData);
      
      // Cache result for View Details button (already cached by buildAnalysisResult, but update with final data)
      cacheResult(result.url, {
        blocks: pageData.jsonLd || [],
        issues: result.issuesList || [],
        warnings: result.warnings || [],
        info: result.info || [],
        schemaTypes: result.schemaType ? result.schemaType.split(',').map(t => t.trim()) : [],
        schemaFound: result.schemaFound || false
      });
      
      // Stage 9: Complete (~100%)
      updateRowProgress(urlData.url, 100);
      
      // Log final result confirmation
      console.log(`[‚úì] Final Result: ${result.url} | SchemaFound=${result.schemaFound} | Types: ${result.schemaType || 'none'} | MissingFields: ${result.missingFields?.length || 0} | Warnings: ${result.warnings?.length || 0} | Info: ${result.info?.length || 0}`);
      
      // CRITICAL: Store result in validationResults BEFORE calling updateTableRow
      // resultIndex is already declared at the top of the function
      validationResults[resultIndex] = {
        ...result,
        schemaFound: result.schemaFound, // Ensure schemaFound is preserved
        schemaType: result.schemaType || (initialAnalysis.schemaTypes.join(', ') || '‚Äî'), // Ensure schemaType is set from initialAnalysis if missing
        inferredTypes: result.inferredTypes || [], // Ensure inferredTypes are preserved
        missingFields: result.missingFields || [],
        warnings: result.warnings || [],
        info: result.info || [],
        error: null // Explicitly clear error if validation succeeded
      };
      
      console.log(`[‚úì] Stored result at index ${resultIndex}: schemaFound=${validationResults[resultIndex].schemaFound}, schemaType="${validationResults[resultIndex].schemaType}", error=${validationResults[resultIndex].error}`);
      if (validationResults[resultIndex].inferredTypes && validationResults[resultIndex].inferredTypes.length > 0) {
        console.log(`[DEBUG] processUrl: Stored inferredTypes in validationResults[${resultIndex}]:`, validationResults[resultIndex].inferredTypes);
      }
      
      // Update table row with final result (will restore schemaFound in determineStatusHtml if needed)
      updateTableRow(resultIndex, validationResults[resultIndex]);
      
      // Don't call updateResultRow - it causes duplicate updates
      
    } catch (error) {
      // Update progress to show error state
      updateRowProgress(urlData.url, 100);
      // resultIndex is already declared at the top of the function
      const schemaTypeCell = document.getElementById(`schemaTypeCell_${resultIndex}`);
      if (schemaTypeCell && schemaTypeCell.querySelector('.progress')) {
        markProgressError(schemaTypeCell);
        setProgress(schemaTypeCell, 100, 'Error');
      }
      result.error = error.message;
      
      // CRITICAL: Even if there's an error, try to preserve schemaType from initialAnalysis
      if (initialAnalysis && initialAnalysis.schemaTypes && initialAnalysis.schemaTypes.length > 0) {
        result.schemaType = initialAnalysis.schemaTypes.join(', ');
        result.schemaFound = initialAnalysis.schemaFound || false;
        console.log(`[‚úì] Preserved schemaType from initialAnalysis despite error: ${result.schemaType}`);
      }
      
      // Ensure arrays are initialized
      result.missingFields = result.missingFields || [];
      result.warnings = result.warnings || [];
      result.info = result.info || [];
      
      // Store result even on error at correct index
      validationResults[resultIndex] = {
        ...result,
        schemaType: result.schemaType || (initialAnalysis?.schemaTypes?.join(', ') || '‚Äî'),
        schemaFound: result.schemaFound || initialAnalysis?.schemaFound || false,
        missingFields: result.missingFields || [],
        warnings: result.warnings || [],
        info: result.info || []
      };
      
      updateTableRow(resultIndex, validationResults[resultIndex]);
    }
    
    return result;
  }

  // Helper: Classify duplicate issues as warnings or info
  function classifyDuplicateIssue(item, allNodes) {
    const schemaType = item.type || 'Unknown';
    
    // Check if this is a multi-instance allowed type
    if (MULTI_INSTANCE_ALLOWED_TYPES.includes(schemaType)) {
      const typeNodes = allNodes.filter(n => {
        const types = asArray(n['@type']);
        return types.includes(schemaType);
      });
      const totalCount = typeNodes.length;
      const cleanMessage = item.message.replace('‚ö†Ô∏è DUPLICATE:', '').replace('‚ö†Ô∏è', '').trim();
      return { 
        type: 'info', 
        message: `‚úÖ Multiple ${schemaType} schemas detected (${totalCount}) ‚Äî expected for ${schemaType.toLowerCase()} listings.`,
        isMultiInstance: true
      };
    }
    
    // For other types, check if they have unique IDs or multiple types
    const typeNodes = allNodes.filter(n => {
      const types = asArray(n['@type']);
      return types.includes(schemaType);
    });
    const hasUniqueIds = typeNodes.some(n => n['@id']);
    const uniqueTypes = new Set(typeNodes.map(n => {
      const types = asArray(n['@type']);
      return types.join(',');
    }));
    const hasMultipleTypes = uniqueTypes.size > 1;
    
    if (hasUniqueIds || hasMultipleTypes) {
      const cleanMessage = item.message.replace('‚ö†Ô∏è DUPLICATE:', '').replace('‚ö†Ô∏è', '').trim();
      return { type: 'info', message: `‚ÑπÔ∏è Multi-instance ${schemaType} schemas detected (${cleanMessage})` };
    }
    return { type: 'warning', message: item.message };
  }

  // Helper: Split issuesList into missingFields, warnings, and info
  function splitIssuesIntoBuckets(issuesList, allNodes, url = '') {
    const buckets = { missingFields: [], warnings: [], info: [] };
    let suppressedCount = { missingFields: 0, warnings: 0, info: 0 };
    
    for (const item of issuesList) {
      const isDuplicate = item.message?.includes('DUPLICATE');
      const isMissing = item.message?.toLowerCase().includes('missing');
      
      if (isMissing) {
        // Check if we should suppress this missing field
        const schemaType = item.type || 'Unknown';
        if (!shouldSuppressMissingField(item.field || '', schemaType, url)) {
          buckets.missingFields.push(item.message);
        } else {
          suppressedCount.missingFields++;
        }
      } else if (isDuplicate) {
        const classified = classifyDuplicateIssue(item, allNodes);
        // Apply suppression for duplicates
        if (shouldDowngradeDuplicate(item.type || 'Unknown')) {
          // Downgrade to info if configured
          buckets.info.push(classified.message);
        } else if (classified.type === 'info') {
          if (!shouldSuppressInfo(classified.message, url)) {
            buckets.info.push(classified.message);
          } else {
            suppressedCount.info++;
          }
        } else {
          // Check if warning should be suppressed
          if (!shouldSuppressWarning(classified.message, url)) {
            buckets.warnings.push(classified.message);
          } else {
            suppressedCount.warnings++;
          }
        }
      }
    }
    
    if (suppressedCount.missingFields > 0 || suppressedCount.warnings > 0 || suppressedCount.info > 0) {
      debugLog(`[SUPPRESSION] Suppressed: ${suppressedCount.missingFields} missing fields, ${suppressedCount.warnings} warnings, ${suppressedCount.info} info`, 'info');
    }
    
    return buckets;
  }

  // Helper: Build unified issues list from missing fields and duplicates
  function buildUnifiedIssuesList(missingDetails, duplicateWarnings, allNodes) {
    const issuesList = [];
    
    // Add missing field issues with exact format: includes (no @id) when applicable
    for (const f of missingDetails) {
      // Check if any node of this type has an @id
      const hasId = allNodes.some(n => {
        const types = asArray(n['@type']);
        return types.includes(f.type) && n['@id'];
      });
      const message = `${f.type}: "${f.field}" missing${hasId ? '' : ' (no @id)'}`;
      issuesList.push({
        type: f.type,
        field: f.field,
        message: message
      });
    }
    
    // Add duplicate issues with exact format specified
    for (const d of duplicateWarnings) {
      issuesList.push({
        type: d.type,
        message: `‚ö†Ô∏è DUPLICATE: ${d.type} (${d.id || 'NO_ID'}) √ó ${d.count}`
      });
    }
    
    return issuesList;
  }

  // Helper: Mark as "reviewing" when external validator is opened
  function markReviewing(index, which) {
    const label = which === 'schema' ? 'Schema.org' : 'Rich Results';
    const notesEl = document.getElementById(`notes_${index}`);
    if (notesEl) {
      notesEl.value = `üëÄ Opened ${label} (reviewing)‚Ä¶`;
      updateValidationNotes(index, notesEl.value);
      
      // Auto-clear after 5s if still pending
      setTimeout(() => {
        const currentNotes = notesEl.value || '';
        if (currentNotes.includes('reviewing')) {
          notesEl.value = currentNotes.replace(/üëÄ Opened .* \(reviewing\)‚Ä¶\s*/g, '').trim();
          updateValidationNotes(index, notesEl.value);
        }
      }, 5000);
    }
  }

  // Helper: Apply external validator results and finalize row status
  function applyExternalResult(index, richResult, schemaOrgResult) {
    const result = validationResults[index];
    if (!result) return;
    
    // Get current DOM elements
    const statusCell = document.getElementById(`statusCell_${index}`);
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    const notesEl = document.getElementById(`notes_${index}`);
    
    // Clean up "reviewing" notes
    if (notesEl) {
      let notes = notesEl.value || '';
      if (richResult) notes = notes.replace(/üëÄ Opened Rich Results.*\n?/g, '').trim();
      if (schemaOrgResult) notes = notes.replace(/üëÄ Opened Schema\.org.*\n?/g, '').trim();
      notesEl.value = notes;
      updateValidationNotes(index, notes);
    }
    
    // Finalize status based on external results
    finalizeRowStatus(index, result, richResult, schemaOrgResult);
  }

  // Helper: Finalize row status prioritizing external validators
  // Helper: Determine Schema.org status from API response
  function determineSchemaOrgStatus(schemaOrg) {
    if (schemaOrg?.status === 'passed') {
      return 'passed';
    }
    if (schemaOrg?.status === 'failed' && schemaOrg?.errors && schemaOrg.errors.length === 0 && 
        schemaOrg?.warnings && schemaOrg.warnings.length === 0) {
      return 'passed';
    }
    if (schemaOrg?.status === 'failed' && schemaOrg?.errors && schemaOrg.errors.length === 0 && 
        schemaOrg?.warnings && schemaOrg.warnings.length > 0) {
      return 'warning';
    }
    return schemaOrg ? 'failed' : 'not-run';
  }

  // Helper: Format schema type with server badge
  function formatSchemaTypeWithBadge(localParse) {
    let types = localParse?.schemaType || localParse?.types?.join(', ') || '‚Äî';
    types = types.replace(/\s*\(server\)\s*$/, '');
    if (localParse?.serverFallback) {
      types = types + ' (server)';
    }
    return types;
  }

  // Helper: Attach click handler to status chip
  function attachStatusChipHandler(chip, row) {
    if (chip && row) {
      chip.onclick = () => openIssuesModal(getRowDataFromTr(row));
    }
  }

  // Helper: Update external status selects
  function updateExternalStatusSelects(index, richPassed, schemaOrgStatus, rich) {
    const richSelect = document.getElementById(`googleStatus_${index}`);
    const schemaSelect = document.getElementById(`schemaOrgStatus_${index}`);
    
    if (richSelect) {
      setSelect(richSelect, richPassed ? '‚úÖ Passed' : (rich ? '‚ùå Failed' : 'Not run'));
    }
    
    if (schemaSelect) {
      let statusValue = 'Not run';
      if (schemaOrgStatus === 'passed') {
        statusValue = '‚úÖ Passed';
      } else if (schemaOrgStatus === 'warning') {
        statusValue = '‚ö†Ô∏è Warning';
      } else if (schemaOrgStatus === 'failed') {
        statusValue = '‚ùå Failed';
      }
      setSelect(schemaSelect, statusValue);
    }
  }

  // Helper: Handle external validators passed case
  function handleExternalPassedCase(index, localParse, richPassed, schemaOrgStatus, missing, statusCell, schemaTypeCell, notesEl, row) {
    const realIssues = missing.filter(m => {
      if (typeof m === 'string') {
        return !m.includes('DUPLICATE') && !m.includes('‚ö†Ô∏è DUPLICATE');
      }
      return true;
    });
    const hasRealIssues = realIssues.length > 0;
    
    const statusHtml = hasRealIssues ? '<span class="chip-issues" title="View details">‚ö†Ô∏è Issues</span>' : '<span class="chip-ok">‚úÖ Valid</span>';
    if (statusCell) {
      statusCell.innerHTML = statusHtml;
      if (hasRealIssues) {
        const chip = statusCell.querySelector('.chip-issues');
        attachStatusChipHandler(chip, row);
      }
    }
    
    if (schemaTypeCell) {
      // Preserve inferred types when updating cell
      const result = validationResults[index];
      const inferredTypes = result?.inferredTypes || [];
      const types = formatSchemaTypeWithBadge(localParse);
      
      if (inferredTypes.length > 0) {
        // Split types and format with inferred types
        const explicitTypes = types.replace(/\s*\(server\)\s*$/, '').split(',').map(t => t.trim()).filter(Boolean);
        const formattedTypes = formatSchemaTypesWithInferred(explicitTypes, inferredTypes);
        schemaTypeCell.innerHTML = formattedTypes + (localParse?.serverFallback ? ' (server)' : '');
      } else {
        schemaTypeCell.textContent = types;
      }
    }
    
    if (notesEl) {
      let noteText = '';
      if (localParse?.localParseFailed && localParse?.serverFallback) {
        noteText = `Local parse: blocked. Server parse: success (${localParse.blockCount || 0} blocks). External validation passed ‚úÖ`;
      } else {
        noteText = 'Local parse skipped (cached or blocked). External validation passed ‚úÖ';
      }
      notesEl.value = noteText;
      updateValidationNotes(index, noteText);
    }
    
    if (validationResults[index]) {
      validationResults[index].validatorGoogleStatus = '‚úÖ Passed';
      validationResults[index].validatorSchemaOrgStatus = '‚úÖ Passed';
      validationResults[index].statusOverride = 'external-passed';
    }
  }

  // Helper: Handle local result case
  function handleLocalResultCase(index, localParse, missingCount, statusCell, schemaTypeCell, row) {
    const hasMissing = missingCount > 0;
    const statusHtml = hasMissing 
      ? '<span class="chip-issues" title="View details">‚ö†Ô∏è Issues</span>'
      : '<span class="chip-ok">‚úÖ Valid</span>';
    
    if (statusCell) {
      statusCell.innerHTML = statusHtml;
      if (hasMissing) {
        const chip = statusCell.querySelector('.chip-issues');
        attachStatusChipHandler(chip, row);
      }
    }
    
    if (schemaTypeCell) {
      // Preserve inferred types when updating cell
      const result = validationResults[index];
      const inferredTypes = result?.inferredTypes || [];
      const types = formatSchemaTypeWithBadge(localParse);
      
      if (inferredTypes.length > 0) {
        // Split types and format with inferred types
        const explicitTypes = types.replace(/\s*\(server\)\s*$/, '').split(',').map(t => t.trim()).filter(Boolean);
        const formattedTypes = formatSchemaTypesWithInferred(explicitTypes, inferredTypes);
        schemaTypeCell.innerHTML = formattedTypes + (localParse?.serverFallback ? ' (server)' : '');
      } else {
        schemaTypeCell.textContent = types;
      }
    }
    
    if (validationResults[index]) {
      validationResults[index].statusOverride = 'local';
    }
  }

  // Helper: Finalize row status prioritizing external validators
  function finalizeRowStatus(index, localParse, rich, schemaOrg) {
    const richPassed = rich?.status === 'eligible' && rich?.verdict === 'PASS';
    const schemaOrgStatus = determineSchemaOrgStatus(schemaOrg);
    const schemaOrgPassed = schemaOrgStatus === 'passed';
    
    const missing = localParse?.missingFieldsDetails || localParse?.missingFieldsBadges || localParse?.missingFields || [];
    const missingCount = Array.isArray(missing) ? missing.length : (missing ? 1 : 0);
    
    const statusCell = document.getElementById(`statusCell_${index}`);
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    const notesEl = document.getElementById(`notes_${index}`);
    const row = document.getElementById('resultsTableBody')?.children[index];
    
    updateExternalStatusSelects(index, richPassed, schemaOrgStatus, rich);
    
    if (richPassed && schemaOrgPassed) {
      handleExternalPassedCase(index, localParse, richPassed, schemaOrgStatus, missing, statusCell, schemaTypeCell, notesEl, row);
      return;
    }
    
    if (localParse?.schemaFound || localParse?.schemaType) {
      handleLocalResultCase(index, localParse, missingCount, statusCell, schemaTypeCell, row);
    } else {
      if (statusCell) statusCell.innerHTML = '<span class="status-badge no-schema">‚ùå No Schema</span>';
      // Preserve inferred types even when no schema found
      if (schemaTypeCell) {
        const result = validationResults[index];
        const inferredTypes = result?.inferredTypes || [];
        if (inferredTypes.length > 0) {
          const formattedTypes = formatSchemaTypesWithInferred([], inferredTypes);
          schemaTypeCell.innerHTML = formattedTypes;
        } else {
          schemaTypeCell.textContent = 'None';
        }
      }
      if (validationResults[index]) {
        validationResults[index].statusOverride = 'local';
      }
    }
  }

  // Helper: Set select dropdown value
  function setSelect(selectEl, value) {
    if (!selectEl) return;
    // Find the option that matches (by value or text)
    for (let option of selectEl.options) {
      if (option.value === value || option.textContent === value) {
        selectEl.value = option.value;
        updateValidationStatus(
          parseInt(selectEl.id.match(/\d+/)?.[0] || '0'),
          selectEl.id.includes('google') ? 'google' : 'schemaorg',
          option.value
        );
        break;
      }
    }
  }

  // Helper: Generate human-readable status explanation
  // Helper: Extract field name from issue object
  function extractFieldName(issue) {
    if (issue.field && issue.type) {
      debugLog(`Using direct field property: ${issue.type}.${issue.field}`);
      return `${issue.type}.${issue.field}`;
    }
    // Fallback: parse from message
    const match = issue.message?.match(/(\w+):\s*"(\w+)"\s*missing/);
    if (match) {
      debugLog(`Parsed from message pattern 1: ${match[1]}.${match[2]}`);
      return `${match[1]}.${match[2]}`;
    }
    // Try alternative pattern
    const altMatch = issue.message?.match(/(\w+).*?"(\w+)".*?missing/i);
    if (altMatch) {
      debugLog(`Parsed from message pattern 2: ${altMatch[1]}.${altMatch[2]}`);
      return `${altMatch[1]}.${altMatch[2]}`;
    }
    debugLog(`WARNING: Could not extract field name from: ${issue.message}`);
    return issue.field ? `${issue.type || 'Unknown'}.${issue.field}` : 'Unknown field';
  }

  // Helper: Build missing fields explanation text
  function buildMissingFieldsExplanation(missingCount, fieldNames) {
    if (missingCount === 1) {
      return `1 optional field missing ‚Äì ${fieldNames[0]}`;
    }
    if (missingCount === 2) {
      return `2 optional fields missing ‚Äì ${fieldNames.join(', ')}`;
    }
    return `${missingCount} optional fields missing ‚Äì ${fieldNames.join(', ')}${missingCount > 2 ? '...' : ''}`;
  }

  // Helper: Build duplicate explanation text
  function buildDuplicateExplanation(duplicateCount) {
    const plural = duplicateCount === 1 ? '' : 's';
    return `${duplicateCount} duplicate${plural} detected ‚Äî likely normal Squarespace Events`;
  }

  function generateStatusExplanation(result) {
    debugLog(`Generating explanation for ${result.url}: issuesList.length=${result.issuesList?.length || 0}, schemaFound=${result.schemaFound}, error=${result.error}`);
    
    // CRITICAL: Only treat as error if error is explicitly set AND it's not null/empty/undefined
    if (result.error && result.error !== null && result.error !== 'null' && result.error !== undefined && String(result.error).trim() !== '') {
      console.log(`[‚ö†] Error explanation requested: ${result.error}`);
      return 'Error occurred during validation';
    }
    
    if (!result.schemaFound) {
      return 'No schema found on page';
    }
    
    // Ensure issuesList exists (fallback to empty array)
    const issuesList = result.issuesList || [];
    
    // Debug: Show full issuesList contents
    debugLog(`issuesList contents: ${JSON.stringify(issuesList, null, 2)}`);
    
    if (issuesList.length === 0) {
      debugLog(`No issues found - returning "All required fields present"`);
      return 'All required fields present';
    }
    
    const duplicates = issuesList.filter(i => i.message && i.message.includes('DUPLICATE'));
    const missingFields = issuesList.filter(i => i.message && i.message.includes('missing'));
    const duplicateCount = duplicates.length;
    const missingCount = missingFields.length;
    
    debugLog(`Filtered: missingCount=${missingCount}, duplicateCount=${duplicateCount}`);
    debugLog(`Missing fields items: ${JSON.stringify(missingFields.map(m => ({ type: m.type, field: m.field, message: m.message })), null, 2)}`);
    
    const parts = [];
    if (missingCount > 0) {
      const fieldNames = missingFields.slice(0, 2).map(extractFieldName);
      parts.push(buildMissingFieldsExplanation(missingCount, fieldNames));
    }
    
    if (duplicateCount > 0) {
      parts.push(buildDuplicateExplanation(duplicateCount));
    }
    
    const explanation = parts.length > 0 ? parts.join(' ‚Ä¢ ') : 'Minor issues detected';
    debugLog(`FINAL EXPLANATION: "${explanation}"`);
    return explanation;
  }

  // Helper: Count skipped (system-injected) schemas
  function countSkippedSchemas(result) {
    return result.schemas ? result.schemas.filter(s => s.systemInjected).length : 0;
  }

  // Helper: Check if all schemas are skipped
  function isAllSchemasSkipped(result, skippedCount) {
    return skippedCount > 0 && result.schemas && result.schemas.every(s => s.systemInjected);
  }

  // Helper: Build skipped note text
  function buildSkippedNote(skippedCount) {
    return skippedCount > 0 ? ` (${skippedCount} auto-skipped)` : '';
  }

  // Helper: Build passed status HTML
  function buildPassedStatusHtml(result, skippedCount) {
    const explanation = generateStatusExplanation(result);
    const allSkipped = isAllSchemasSkipped(result, skippedCount);
    const explanationText = allSkipped ? 'All required fields present (Squarespace auto-schema ignored)' : explanation;
    return { 
      class: 'valid', 
      html: `<span class="chip-passed">‚úÖ Passed</span>`
    };
  }

  // Helper: Build issues status HTML (for duplicates and minor issues)
  function buildIssuesStatusHtml(result, skippedCount) {
    const explanation = generateStatusExplanation(result);
    const skippedNote = buildSkippedNote(skippedCount);
    
    // Check if this is primarily duplicates (should show as Warning)
    const duplicates = result.issuesList ? result.issuesList.filter(i => i.message && i.message.includes('DUPLICATE')) : [];
    const isDuplicateOnly = duplicates.length > 0 && 
                            (!result.issuesList || result.issuesList.filter(i => i.message && i.message.includes('missing')).length === 0);
    
    if (isDuplicateOnly) {
      const plural = duplicates.length === 1 ? '' : 's';
      return { 
        class: 'issues', 
        html: `<span class="chip-issues" title="Click to view details">‚ö†Ô∏è Warning${skippedNote}</span>`
      };
    }
    
    return { 
      class: 'issues', 
      html: `<span class="chip-issues" title="Click to view details">‚ö†Ô∏è Issues${skippedNote}</span>`
    };
  }

  // Helper: Build critical status HTML
  function buildCriticalStatusHtml(result, skippedCount) {
    const explanation = generateStatusExplanation(result);
    const skippedNote = buildSkippedNote(skippedCount);
    return { 
      class: 'critical', 
      html: `<span class="chip-critical" title="Click to view details">‚ùå Critical${skippedNote}</span>`
    };
  }

  // Helper: Build error status HTML
  function buildErrorStatusHtml(result) {
    const explanation = generateStatusExplanation(result);
    return { 
      class: 'error', 
      html: `<span class="chip-critical" title="Click to view details">‚ùå Critical</span>`
    };
  }

  // Helper: Check if status should be critical (only missing fields > 3)
  function isCriticalStatus(result) {
    const missingCount = result.missingFields ? result.missingFields.length : 0;
    return missingCount > 3;
  }

  // Helper: Build info-only status HTML
  function buildInfoOnlyStatusHtml(infoCount) {
    const plural = infoCount > 1 ? 's' : '';
    return { 
      class: 'valid', 
      html: `<span class="chip-passed" title="Click to view details">‚úÖ Passed</span>`
    };
  }

  // Helper: Build warnings-only status HTML
  function buildWarningsOnlyStatusHtml(warningsCount) {
    const plural = warningsCount > 1 ? 's' : '';
    return { 
      class: 'issues', 
      html: `<span class="chip-issues" title="Click to view details">‚ö†Ô∏è Warning</span>`
    };
  }

  // Helper: Check if result has only info (no warnings or missing fields)
  function hasOnlyInfo(result) {
    return result.info && result.info.length > 0 && 
           (!result.warnings || result.warnings.length === 0) && 
           (!result.missingFields || result.missingFields.length === 0);
  }

  // Helper: Check if result has only warnings (no missing fields)
  function hasOnlyWarnings(result) {
    return result.warnings && result.warnings.length > 0 && 
           (!result.missingFields || result.missingFields.length === 0);
  }

  // Helper: Determine status HTML from result with color-coded badges and explanations
  function determineStatusHtml(result) {
    // Apply suppression: if treatWarningsAsPass is enabled and only warnings exist, treat as pass
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    if (sup.treatWarningsAsPass && hasOnlyWarnings(result) && result.schemaFound) {
      debugLog(`[SUPPRESSION] Applying treatWarningsAsPass: converting warnings-only result to Passed for ${result.url}`, 'info');
      return buildPassedStatusHtml(result, countSkippedSchemas(result));
    }
    debugLog(`Status determination for ${result.url}: missingFields=${result.missingFields?.length || 0}, warnings=${result.warnings?.length || 0}, info=${result.info?.length || 0}, schemaFound=${result.schemaFound}, error=${result.error}`);
    
    // CRITICAL: Only treat as error if error is explicitly set AND it's not null/empty
    if (result.error && result.error !== null && result.error !== 'null' && result.error.trim() !== '') {
      console.log(`[‚ö†] Error detected: ${result.error}`);
      return buildErrorStatusHtml(result);
    }
    
    // CRITICAL: Restore schemaFound if ANY evidence of schema exists
    if (!result.schemaFound) {
      // Check if schemas exist
      if (result.schemas && result.schemas.length > 0) {
        result.schemaFound = true;
        console.log("[‚úì] Restored schemaFound=true (schema blocks exist)");
      }
      // Check if schemaType is set
      else if (result.schemaType && result.schemaType !== 'null' && result.schemaType !== 'Processing...' && result.schemaType !== '‚Äî') {
        result.schemaFound = true;
        console.log(`[‚úì] Restored schemaFound=true (schemaType exists: ${result.schemaType})`);
      }
      // Check validationResults array
      else {
        const resultIndex = validationResults.findIndex(r => r.url === result.url);
        if (resultIndex >= 0 && validationResults[resultIndex].schemaFound === true) {
          result.schemaFound = true;
          console.log("[‚úì] Restored schemaFound=true (from validationResults array)");
        }
      }
      
      // Update in validationResults array if found
      if (result.schemaFound) {
        const resultIndex = validationResults.findIndex(r => r.url === result.url);
        if (resultIndex >= 0) {
          validationResults[resultIndex].schemaFound = true;
        }
      }
    }
    
    const skippedCount = countSkippedSchemas(result);
    
    // If only info exists (no warnings, no missing fields), show as Passed
    if (hasOnlyInfo(result) && result.schemaFound) {
      return buildInfoOnlyStatusHtml(result.info.length);
    }
    
    // If warnings exist but no missing fields, show as Warning
    if (hasOnlyWarnings(result) && result.schemaFound) {
      return buildWarningsOnlyStatusHtml(result.warnings.length);
    }
    
    // If no issues at all, show as Passed
    if ((!result.missingFields || result.missingFields.length === 0) && 
        (!result.warnings || result.warnings.length === 0) && 
        result.schemaFound) {
      return buildPassedStatusHtml(result, skippedCount);
    }
    
    if (result.schemaFound) {
      // Check for critical status (missing fields > 3)
      if (isCriticalStatus(result)) {
        return buildCriticalStatusHtml(result, skippedCount);
      }
      
      // If missing fields exist, show as Issues
      if (result.missingFields && result.missingFields.length > 0) {
        return buildIssuesStatusHtml(result, skippedCount);
      }
      
      return buildPassedStatusHtml(result, skippedCount);
    }
    
    // Final default return: check schemaFound first
    if (result.schemaFound) {
      return { class: 'valid', html: '<span class="chip-valid">‚úÖ Valid</span>' };
    } else if (result.missingFields && result.missingFields.length > 0) {
      return { class: 'critical', html: '<span class="chip-critical">‚ùå Critical</span>' };
    } else {
      return { class: 'no-schema', html: '<span class="status-badge no-schema">‚ùå No Schema</span>' };
    }
  }
  
  // Helper: Store row data attributes
  function storeRowDataAttributes(row, result) {
    if (result.schemas && result.schemas.length > 0 && result.schemas[0].schema) {
      try {
        const firstJson = JSON.stringify(result.schemas[0].schema, null, 2);
        row.dataset.firstJsonld = firstJson.slice(0, 6000);
      } catch (error) {
        console.warn('Failed to store JSON-LD data:', error);
      }
    }
    if (result.issuesList && result.issuesList.length > 0) {
      row.dataset.issuesList = JSON.stringify(result.issuesList);
    }
    if (result.schemaSummary) {
      row.dataset.schemaSummary = result.schemaSummary;
    }
    if (result.missingFieldsDetails) {
      row.dataset.missingDetail = JSON.stringify(result.missingFieldsDetails);
    }
  }
  
  // Helper: Generate missing fields HTML
  function generateMissingFieldsHtml(result) {
    if (result.missingFields && result.missingFields.length > 0) {
      const filtered = filterSuppressedMissingFields(result.missingFields, result.schemaType || '', result.url || '');
      if (filtered.length > 0) {
        return filtered.map(f => `<div class="missing-entry">‚ùå ${f}</div>`).join('');
      }
    }
    return '‚Äî';
  }

  // Helper: Generate warnings HTML
  function generateWarningsHtml(result) {
    if (result.warnings && result.warnings.length > 0) {
      const filtered = filterSuppressedWarnings(result.warnings, result.url || '');
      if (filtered.length > 0) {
        return filtered.map(w => `<div class="warning-entry">‚ö†Ô∏è ${w}</div>`).join('');
      }
    }
    return '‚Äî';
  }

  // Helper: Generate info HTML
  function generateInfoHtml(result) {
    if (result.info && result.info.length > 0) {
      const filtered = filterSuppressedInfo(result.info, result.url || '');
      if (filtered.length > 0) {
        return filtered.map(i => `<div class="info-entry">${i}</div>`).join('');
      }
    }
    return '‚Äî';
  }
  
  // Helper: Generate schema type HTML
  function generateSchemaTypeHtml(result) {
    if (result.schemaType === 'Processing...') {
      return '<div class="progress-wrap"><div class="progress"><span style="width:0%"></span></div><div class="progress-label">0%</div></div>';
    }
    
    // Get explicit types
    const explicitTypes = result.schemaType ? result.schemaType.split(',').map(t => t.trim()).filter(Boolean) : [];
    
    // Get inferred types
    const inferredTypes = result.inferredTypes || [];
    
    // Debug logging
    if (inferredTypes.length > 0) {
      console.log(`[DEBUG] generateSchemaTypeHtml: Found ${inferredTypes.length} inferred types for ${result.url}:`, inferredTypes);
    }
    
    // Format with inferred types
    const formatted = formatSchemaTypesWithInferred(explicitTypes, inferredTypes) || 'None';
    
    // Debug logging
    if (inferredTypes.length > 0) {
      console.log(`[DEBUG] generateSchemaTypeHtml: Formatted output:`, formatted);
    }
    
    return formatted;
  }
  
  // Helper: Generate status select HTML
  function generateStatusSelectHtml(index, existingStatus, statusType) {
    const options = ['‚úÖ Passed', '‚ö†Ô∏è Warning', '‚ùå Failed', 'üëÄ Opened (reviewing)', 'üîÑ Running...', 'Not run'];
    return options.map(opt => {
      const selected = existingStatus === opt ? 'selected' : '';
      return `<option value="${opt}" ${selected}>${opt}</option>`;
    }).join('');
  }
  
  // Helper: Generate actions column HTML
  function generateActionsColumnHtml(index, result) {
    const enhanceBtn = result.schemas && result.schemas.length > 0 
      ? `<button class="enhance-btn btn-generate-enhanced" data-action="generate-enhanced" id="genBtn_${index}">Generate Enhanced</button><br>` 
      : '';
    
    const supabaseBtn = supabaseAvailable 
      ? `<br><button class="save-btn" onclick="saveToSupabase(${index})" id="saveBtn_${index}">Save to Supabase</button>`
      : '<br><span style="color: #a0aec0; font-size: 0.875rem;">Supabase not available</span>';
    
    // Add "View Details" button with data attributes for event handler
    const viewDetailsBtn = `<button class="enhance-btn view-details-btn btn-view-details" data-action="view-details" data-row-index="${index}" style="background: #2563eb; color: white; border-color: #2563eb; margin-bottom: 0.5rem;">View Details</button><br>`;
    
    return `${viewDetailsBtn}${enhanceBtn}
        <div style="margin-top: 0.5rem;">
          <button class="enhance-btn secondary" id="schemaOrgBtn_${index}" style="font-size: 0.75rem; padding: 0.375rem 0.75rem;">Schema.org</button>
          <button class="enhance-btn secondary" id="richResultsBtn_${index}" style="font-size: 0.75rem; padding: 0.375rem 0.75rem; margin-left: 0.25rem;">Rich Results</button>
        </div>
        ${supabaseBtn}`;
  }
  
  // Helper: Add summary line to notes if not already present
  function addSummaryLineIfNeeded(notesWithSummary, summaryLine, checkText) {
    if (notesWithSummary && !notesWithSummary.includes(checkText)) {
      return notesWithSummary + '\n' + summaryLine;
    }
    return notesWithSummary || summaryLine;
  }

  // Helper: Build missing fields summary line
  function buildMissingFieldsSummary(missingCount) {
    return `Missing: ${missingCount} field${missingCount !== 1 ? 's' : ''}.`;
  }

  // Helper: Build warnings summary line
  function buildWarningsSummary(warningsCount) {
    return `Warnings: ${warningsCount} duplicate${warningsCount !== 1 ? 's' : ''}.`;
  }

  // Helper: Build info summary line
  function buildInfoSummary(infoCount) {
    return `Info: ${infoCount} multi-instance schema${infoCount !== 1 ? 's' : ''} detected.`;
  }

  // Helper: Build notes summary from result buckets
  function buildNotesSummary(result, existingNotes = '') {
    let notesWithSummary = existingNotes;
    
    if (result.missingFields && result.missingFields.length > 0) {
      notesWithSummary = addSummaryLineIfNeeded(notesWithSummary, buildMissingFieldsSummary(result.missingFields.length), 'Missing:');
    }
    if (result.warnings && result.warnings.length > 0) {
      notesWithSummary = addSummaryLineIfNeeded(notesWithSummary, buildWarningsSummary(result.warnings.length), 'Warnings:');
    }
    if (result.info && result.info.length > 0) {
      notesWithSummary = addSummaryLineIfNeeded(notesWithSummary, buildInfoSummary(result.info.length), 'Info:');
    }
    
    return notesWithSummary;
  }

  // Helper: Generate row HTML
  function generateRowHtml(index, result, statusHtml, rowOptions) {
    const { existingGoogleStatus, existingSchemaOrgStatus, existingNotes } = rowOptions;
    const missingFieldsHtml = generateMissingFieldsHtml(result);
    const warningsHtml = generateWarningsHtml(result);
    const infoHtml = generateInfoHtml(result);
    const schemaTypeHtml = generateSchemaTypeHtml(result);
    const googleSelectHtml = generateStatusSelectHtml(index, existingGoogleStatus, 'google');
    const schemaOrgSelectHtml = generateStatusSelectHtml(index, existingSchemaOrgStatus, 'schemaorg');
    const actionsHtml = generateActionsColumnHtml(index, result);
    const notesWithSummary = buildNotesSummary(result, existingNotes);
    
    const schemaOrgUrl = 'https://validator.schema.org/#url=' + encodeURIComponent(result.url);
    const googleUrl = result.richResultsReportUrl || 'https://search.google.com/test/rich-results?url=' + encodeURIComponent(result.url);
    
    return `
      <td><a href="${result.url}" target="_blank" class="url-link">${result.url}</a></td>
      <td id="schemaTypeCell_${index}">${schemaTypeHtml}</td>
      <td id="statusCell_${index}" style="white-space: normal; line-height: 1.6;">${statusHtml}</td>
      <td class="missing-fields" id="missingFieldsCell_${index}">${missingFieldsHtml}</td>
      <td id="warningsCell_${index}">${warningsHtml}</td>
      <td id="infoCell_${index}">${infoHtml}</td>
      <td>
        <select class="status-select" id="googleStatus_${index}" title="Google Rich Results Status" onchange="updateValidationStatus(${index}, 'google', this.value)">
          ${googleSelectHtml}
        </select>
      </td>
      <td>
        <select class="status-select" id="schemaOrgStatus_${index}" title="Schema.org Validator Status" onchange="updateValidationStatus(${index}, 'schemaorg', this.value)">
          ${schemaOrgSelectHtml}
        </select>
      </td>
      <td>
        <textarea class="notes-textarea" id="notes_${index}" placeholder="Add notes..." onchange="updateValidationNotes(${index}, this.value)">${notesWithSummary}</textarea>
      </td>
      <td style="white-space: normal; min-width: 250px;">
        ${actionsHtml}
      </td>
    `;
  }
  
  // Helper: Setup button handlers
  function setupRowButtonHandlers(index, result, schemaOrgUrl, googleUrl, statusClass, row) {
    const schemaOrgBtn = document.getElementById(`schemaOrgBtn_${index}`);
    const richResultsBtn = document.getElementById(`richResultsBtn_${index}`);
    const genBtn = document.getElementById(`genBtn_${index}`);
    const viewDetailsBtn = document.querySelector(`.view-details-btn[data-row-index="${index}"]`);
    const statusCell = document.getElementById(`statusCell_${index}`);
    
    if (schemaOrgBtn) {
      schemaOrgBtn.onclick = () => {
        globalThis.open(schemaOrgUrl, '_blank');
        const statusSelect = document.getElementById(`schemaOrgStatus_${index}`);
        if (statusSelect) {
          statusSelect.value = 'üëÄ Opened (reviewing)';
          updateValidationStatus(index, 'schemaorg', 'üëÄ Opened (reviewing)');
        }
        markReviewing(index, 'schema');
      };
    }
    
    if (richResultsBtn) {
      richResultsBtn.onclick = () => {
        globalThis.open(googleUrl, '_blank');
        const statusSelect = document.getElementById(`googleStatus_${index}`);
        if (statusSelect) {
          statusSelect.value = 'üëÄ Opened (reviewing)';
          updateValidationStatus(index, 'google', 'üëÄ Opened (reviewing)');
        }
        markReviewing(index, 'google');
      };
    }
    
    if (genBtn) {
      genBtn.onclick = () => generateEnhancedSchema(index);
    }
    
    if (viewDetailsBtn) {
      viewDetailsBtn.onclick = () => {
        const rowData = getRowDataFromTr(row);
        openIssuesModal(rowData);
      };
    }
    
    // Make all status badges clickable to open issues modal
    if (statusCell) {
      const chips = statusCell.querySelectorAll('.chip-issues, .chip-critical, .chip-passed, .chip-ok, .status-badge');
      for (const chip of chips) {
        chip.style.cursor = 'pointer';
        chip.onclick = () => {
          const rowData = getRowDataFromTr(row);
          openIssuesModal(rowData);
        };
      }
    }
  }

  // Update table row with result
  function updateTableRow(index, result) {
    const tableBody = document.getElementById('resultsTableBody');
    let row = tableBody.children[index];
    
    if (!row) {
      row = document.createElement('tr');
      tableBody.appendChild(row);
    }
    
    // Show debug panel when validation starts - REMOVED, using bottom debug console only
    // Remove this section - debug panel above table has been removed
    
    const { class: statusClass, html: statusHtml } = determineStatusHtml(result);
    debugLog(`Generated statusHtml for ${result.url}: ${statusHtml.substring(0, 200)}...`);
    debugLog(`Full statusHtml: ${statusHtml}`);
    debugLog(`Status class: ${statusClass}`);
    
    // Ensure row exists and has data-url attribute
    if (!row) {
      row = document.createElement('tr');
      row.id = `row_${index}`;
      tableBody.appendChild(row);
    }
    row.dataset.url = result.url;
    row.dataset.rowIndex = index.toString();
    
    storeRowDataAttributes(row, result);
    
    const existingGoogleStatus = result.validatorGoogleStatus || 'Not run';
    const existingSchemaOrgStatus = result.validatorSchemaOrgStatus || 'Not run';
    const existingNotes = result.notes || '';
    const schemaOrgUrl = 'https://validator.schema.org/#url=' + encodeURIComponent(result.url);
    const googleUrl = result.richResultsReportUrl || 'https://search.google.com/test/rich-results?url=' + encodeURIComponent(result.url);
    
    row.innerHTML = generateRowHtml(index, result, statusHtml, {
      existingGoogleStatus,
      existingSchemaOrgStatus,
      existingNotes
    });
    
    // CRITICAL: Update schema type cell with inferred types if they exist
    // This ensures inferred types persist even after row.innerHTML replacement
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    if (schemaTypeCell) {
      // Always update the cell to ensure inferred types are shown
      const explicitTypes = result.schemaType ? result.schemaType.split(',').map(t => t.trim()).filter(Boolean) : [];
      const inferredTypes = result.inferredTypes || [];
      
      if (inferredTypes.length > 0) {
        console.log(`[DEBUG] updateTableRow: Updating schema type cell with ${inferredTypes.length} inferred types for index ${index}`);
        const formattedTypes = formatSchemaTypesWithInferred(explicitTypes, inferredTypes);
        schemaTypeCell.innerHTML = formattedTypes;
        console.log(`[DEBUG] updateTableRow: Set cell innerHTML to:`, formattedTypes);
      } else {
        // Even if no inferred types, ensure the cell shows the correct content
        if (result.schemaType && result.schemaType !== 'Processing...') {
          schemaTypeCell.innerHTML = result.schemaType || '‚Äî';
        }
      }
    }
    
    // Verify the status cell was updated correctly
    const statusCell = document.getElementById(`statusCell_${index}`);
    if (statusCell) {
      debugLog(`Status cell innerHTML after update: ${statusCell.innerHTML.substring(0, 200)}...`);
      debugLog(`Full status cell HTML: ${statusCell.innerHTML}`);
      
      // Check if explanation element exists (null-safe fallback)
      const explanationEl = statusCell.querySelector('.status-explanation');
      if (!explanationEl) {
        // This is expected for some status types (e.g., "Valid" or "No Schema") - only log in debug mode
        debugLog(`Status explanation not found for ${result.url} (this is normal for some status types)`, 'info');
      } else {
        debugLog(`Explanation element text: "${explanationEl.textContent}"`);
        debugLog(`Explanation element HTML: ${explanationEl.outerHTML}`);
      }
    }
    
    // Setup button handlers
    setupRowButtonHandlers(index, result, schemaOrgUrl, googleUrl, statusClass, row);
    
    // Store validation status in result object
    if (!result.validatorGoogleStatus) {
      result.validatorGoogleStatus = 'Not run';
    }
    if (!result.validatorSchemaOrgStatus) {
      result.validatorSchemaOrgStatus = 'Not run';
    }
    if (!result.notes) {
      result.notes = '';
    }
    
    // CRITICAL: Ensure error is explicitly null if validation succeeded
    if (!result.error || result.error === 'null' || String(result.error).trim() === '') {
      result.error = null;
    }
    
    // CRITICAL: Store result in validationResults array with correct schemaFound
    // Ensure schemaFound is preserved from determineStatusHtml restoration
    validationResults[index] = {
      ...result,
      schemaFound: result.schemaFound, // Use the restored value from determineStatusHtml
      schemaType: result.schemaType || '‚Äî', // Ensure schemaType is never null
      inferredTypes: result.inferredTypes || [], // Preserve inferredTypes
      error: null // Explicitly clear error
    };
    
    console.log(`[‚úì] Stored result in validationResults[${index}]: schemaFound=${validationResults[index].schemaFound}, schemaType=${validationResults[index].schemaType}, error=${validationResults[index].error}`);
    if (validationResults[index].inferredTypes && validationResults[index].inferredTypes.length > 0) {
      console.log(`[DEBUG] updateTableRow: Stored inferredTypes in validationResults[${index}]:`, validationResults[index].inferredTypes);
    }
    
    // Add click handler to status cell if it has issues or error (statusCell already declared above)
    if (statusCell && (statusClass === 'issues' || statusClass === 'error')) {
      const chip = statusCell.querySelector('.chip-issues');
      if (chip) {
        chip.onclick = () => openIssuesModal(getRowDataFromTr(row));
      }
    }
    
    // Add click handler to Generate Enhanced button
    const genBtn = document.getElementById(`genBtn_${index}`);
    if (genBtn) {
      genBtn.onclick = async () => {
        const url = result.url;
        const originalText = genBtn.textContent;
        const originalDisabled = genBtn.disabled;
        
        try {
          // Update button state immediately
          genBtn.disabled = true;
          genBtn.innerHTML = '<span style="display:inline-block;animation:spin 1s linear infinite;">‚è≥</span> Fetching page...';
          genBtn.style.opacity = '0.7';
          genBtn.style.cursor = 'wait';
          
          // Force UI update
          await new Promise(resolve => setTimeout(resolve, 50));
          
          debugLog(`Starting enhanced schema generation for: ${url}`, 'info');
          
          // Update progress
          genBtn.innerHTML = '<span style="display:inline-block;animation:spin 1s linear infinite;">‚è≥</span> Parsing schema...';
          debugLog('Fetching page HTML...', 'info');
          
          const json = await generateEnhancedFor(url);
          
          debugLog('Schema generation completed successfully', 'success');
          
          genBtn.innerHTML = '<span style="display:inline-block;">‚úÖ</span> Opening modal...';
          
          // Small delay to show success state
          await new Promise(resolve => setTimeout(resolve, 300));
          
          if (window.__openGenModal) {
            window.__openGenModal(url, json);
          } else {
            alert('Error: Modal function not initialized. Please refresh the page.');
          }
        } catch (e) {
          debugLog('Generate Enhanced error: ' + e.message, 'error');
          debugLog('Error stack: ' + (e.stack || 'No stack trace'), 'error');
          alert('Failed to generate enhanced schema: ' + e.message);
        } finally {
          // Reset button state
          genBtn.disabled = false;
          genBtn.textContent = originalText;
          genBtn.style.opacity = '1';
          genBtn.style.cursor = 'pointer';
        }
      };
    }
  }
  
  // Update validation status in memory
  function updateValidationStatus(index, type, value) {
    if (validationResults[index]) {
      if (type === 'google') {
        validationResults[index].validatorGoogleStatus = value;
      } else if (type === 'schemaorg') {
        validationResults[index].validatorSchemaOrgStatus = value;
      }
    }
  }
  
  // Helper: Get API base URL based on current hostname
  function getApiBaseUrl() {
    // Always use local origin when running locally (try vercel dev first, fallback to production)
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      return window.location.origin; // Try local vercel dev first
    }
    if (window.location.hostname.includes('schema-tools-six.vercel.app')) {
      return 'https://schema-tools-six.vercel.app';
    }
    return window.location.origin;
  }

  // Helper: Map Schema.org API status to dropdown value
  function mapSchemaOrgStatus(data, statusSelect) {
    switch (data.status) {
      case 'passed':
        return '‚úÖ Passed';
      case 'warnings':
        return '‚ö†Ô∏è Warning';
      case 'failed':
        // If status is "failed" but errors.length === 0 AND warnings.length === 0, treat as passed
        if (data.errors && data.errors.length === 0 && data.warnings && data.warnings.length === 0) {
          debugLog(`Schema.org returned "failed" but no errors and no warnings - treating as Passed`, 'info');
          return '‚úÖ Passed';
        }
        if (data.errors && data.errors.length === 0) {
          debugLog(`Schema.org returned "failed" but errors array is empty - treating as Warning`, 'warn');
          return '‚ö†Ô∏è Warning';
        }
        return '‚ùå Failed';
      case 'unreachable':
        if (statusSelect.title) {
          statusSelect.title = 'API unreachable';
        }
        return 'Not run';
      default:
        return 'Not run';
    }
  }

  // Helper: Handle Schema.org validator error
  function handleSchemaOrgError(error, index, statusSelect) {
    console.error('Schema.org validator API error:', error);
    console.error('Error stack:', error.stack);
    statusSelect.value = 'Not run';
    statusSelect.title = 'API unreachable: ' + error.message;
    updateValidationStatus(index, 'schemaorg', 'Not run');
    
    // Add error note to Notes cell
    const notesEl = document.getElementById(`notes_${index}`);
    if (notesEl) {
      const currentNotes = notesEl.value || '';
      const notePrefix = currentNotes.includes('Schema.org:') ? '' : 'Schema.org: ';
      const errorMsg = error.message.length > 100 ? error.message.substring(0, 100) + '...' : error.message;
      notesEl.value = currentNotes + (currentNotes ? '\n' : '') + notePrefix + errorMsg;
      updateValidationNotes(index, notesEl.value);
    }
  }

  // Call Schema.org validator API and update dropdown
  async function runSchemaOrgValidator(index, url) {
    const statusSelect = document.getElementById(`schemaOrgStatus_${index}`);
    if (!statusSelect) return;
    
    // Set to "Running..." while waiting
    statusSelect.value = 'üîÑ Running...';
    updateValidationStatus(index, 'schemaorg', 'üîÑ Running...');
    
    try {
      const apiBaseUrl = getApiBaseUrl();
      const apiUrl = `${apiBaseUrl}/api/validator/schemaorg?url=${encodeURIComponent(url)}`;
      
      console.log('Calling Schema.org API:', apiUrl);
      
      const response = await fetch(apiUrl);
      console.log('Schema.org API response status:', response.status, response.statusText);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Schema.org API error response:', errorText);
        throw new Error(`API returned ${response.status}: ${errorText}`);
      }
      
      const data = await response.json();
      console.log('Schema.org API response:', data);
      
      // Map API status to dropdown value
      const dropdownValue = mapSchemaOrgStatus(data, statusSelect);
      
      // Update dropdown
      statusSelect.value = dropdownValue;
      updateValidationStatus(index, 'schemaorg', dropdownValue);
      
      // Remove tooltip if status is not unreachable
      if (data.status !== 'unreachable') {
        statusSelect.removeAttribute('title');
      }
      
      // Store schema.org data in result
      if (validationResults[index]) {
        validationResults[index].schemaOrgData = data;
      }
      
      // Apply external result to finalize status
      const richResult = validationResults[index]?.richResultsData;
      applyExternalResult(index, richResult, data);
      
    } catch (error) {
      handleSchemaOrgError(error, index, statusSelect);
    }
  }
  
  // Helper: Map Rich Results API status to dropdown value
  function mapRichResultsStatus(data, statusSelect) {
    switch (data.status) {
      case 'eligible':
        return '‚úÖ Passed';
      case 'warnings':
        return '‚ö†Ô∏è Warning';
      case 'ineligible':
        return '‚ùå Failed';
      case 'unknown':
      default:
        statusSelect.title = 'Status unknown';
        return 'Not run';
    }
  }

  // Helper: Handle Rich Results error response
  function handleRichResultsErrorResponse(data, index, statusSelect) {
    const errorMsg = data.error || 'Unknown error';
    statusSelect.value = 'Not run';
    statusSelect.title = errorMsg;
    updateValidationStatus(index, 'google', 'Not run');
    
    // Add error note to Notes cell
    const notesEl = document.getElementById(`notes_${index}`);
    if (notesEl) {
      const currentNotes = notesEl.value || '';
      const notePrefix = currentNotes.includes('Rich Results:') ? '' : 'Rich Results: ';
      notesEl.value = currentNotes + (currentNotes ? '\n' : '') + notePrefix + errorMsg;
      updateValidationNotes(index, notesEl.value);
    }
  }

  // Helper: Handle Rich Results validator error
  function handleRichResultsError(error, index, statusSelect) {
    console.error('Rich Results validator API error:', error);
    console.error('Error stack:', error.stack);
    statusSelect.value = 'Not run';
    statusSelect.title = 'API error: ' + error.message;
    updateValidationStatus(index, 'google', 'Not run');
    
    // Add error note to Notes cell
    const notesEl = document.getElementById(`notes_${index}`);
    if (notesEl) {
      const currentNotes = notesEl.value || '';
      const notePrefix = currentNotes.includes('Rich Results:') ? '' : 'Rich Results: ';
      const errorMsg = error.message.length > 100 ? error.message.substring(0, 100) + '...' : error.message;
      notesEl.value = currentNotes + (currentNotes ? '\n' : '') + notePrefix + errorMsg;
      updateValidationNotes(index, notesEl.value);
    }
  }

  // Call Google Rich Results validator API and update dropdown
  async function runRichResultsValidator(index, url) {
    const statusSelect = document.getElementById(`googleStatus_${index}`);
    if (!statusSelect) return;
    
    // Set to "Running..." while waiting
    statusSelect.value = 'üîÑ Running...';
    updateValidationStatus(index, 'google', 'üîÑ Running...');
    
    try {
      const apiBaseUrl = getApiBaseUrl();
      const apiUrl = `${apiBaseUrl}/api/validator/richresults`;
      
      console.log('Calling Rich Results API:', apiUrl, 'for URL:', url);
      
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ url: url })
      });
      
      console.log('Rich Results API response status:', response.status, response.statusText);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Rich Results API error response:', errorText);
        throw new Error(`API returned ${response.status}: ${errorText}`);
      }
      
      const data = await response.json();
      console.log('Rich Results API response:', data);
      
      if (!data.ok) {
        handleRichResultsErrorResponse(data, index, statusSelect);
        return;
      }
      
      // Map API status to dropdown value
      const dropdownValue = mapRichResultsStatus(data, statusSelect);
      
      // Update dropdown
      statusSelect.value = dropdownValue;
      updateValidationStatus(index, 'google', dropdownValue);
      
      // Store reportUrl and data in result for later use
      if (validationResults[index]) {
        validationResults[index].richResultsReportUrl = data.reportUrl;
        validationResults[index].richResultsData = data;
      }
      
      // Apply external result to finalize status
      const schemaOrgResult = validationResults[index]?.schemaOrgData;
      applyExternalResult(index, data, schemaOrgResult);
      
      // Remove tooltip if status is not unknown
      if (data.status !== 'unknown') {
        statusSelect.removeAttribute('title');
      }
      
    } catch (error) {
      handleRichResultsError(error, index, statusSelect);
    }
  }
  
  // Save auto-save preference to localStorage
  function saveAutoSavePreference() {
    const checkbox = document.getElementById('autoSaveToSupabase');
    if (checkbox) {
      localStorage.setItem('validator.autoSave', checkbox.checked ? '1' : '0');
    }
  }
  
  // Load auto-save preference from localStorage
  function loadAutoSavePreference() {
    const checkbox = document.getElementById('autoSaveToSupabase');
    if (checkbox) {
      const stored = localStorage.getItem('validator.autoSave');
      checkbox.checked = stored === '1'; // Default to false if not set
    }
  }
  
  // Save auto-run preference to localStorage
  function saveAutoRunPreference() {
    const checkbox = document.getElementById('autoRunExternalChecks');
    if (checkbox) {
      localStorage.setItem('validator.autoExternal', checkbox.checked ? '1' : '0');
    }
  }
  
  // Load auto-run preference from localStorage
  function loadAutoRunPreference() {
    const stored = localStorage.getItem('validator.autoExternal');
    const checkbox = document.getElementById('autoRunExternalChecks');
    if (checkbox) {
      checkbox.checked = stored !== '0'; // Default to true if not set
    }
  }
  
  // Update notes in memory
  function updateValidationNotes(index, value) {
    if (validationResults[index]) {
      validationResults[index].notes = value;
    }
  }
  
  // Bulk helper: Set all external status dropdowns to a specific value
  function setAllExternalStatusTo(status) {
    const statusValue = status === 'Passed' ? '‚úÖ Passed' : status;
    const rows = document.querySelectorAll('#resultsTableBody tr');
    let updatedCount = 0;
    
    rows.forEach((row) => {
      // Get index from row's first cell's ID or dataset
      const firstCell = row.querySelector('td');
      if (!firstCell) return;
      
      // Find the index by checking the status select IDs
      const googleSelect = row.querySelector('select[id^="googleStatus_"]');
      const schemaOrgSelect = row.querySelector('select[id^="schemaOrgStatus_"]');
      
      if (googleSelect) {
        const index = parseInt(googleSelect.id.replace('googleStatus_', ''));
        if (!isNaN(index) && googleSelect.value === 'Not run') {
          googleSelect.value = statusValue;
          updateValidationStatus(index, 'google', statusValue);
          updatedCount++;
        }
      }
      
      if (schemaOrgSelect) {
        const index = parseInt(schemaOrgSelect.id.replace('schemaOrgStatus_', ''));
        if (!isNaN(index) && schemaOrgSelect.value === 'Not run') {
          schemaOrgSelect.value = statusValue;
          updateValidationStatus(index, 'schemaorg', statusValue);
          updatedCount++;
        }
      }
    });
    
    showToast(`‚úÖ Updated ${updatedCount} "Not run" status${updatedCount !== 1 ? 'es' : ''} to ${statusValue}`);
  }
  
  // Bulk helper: Reset all external status dropdowns to "Not run"
  function resetAllExternalStatus() {
    const rows = document.querySelectorAll('#resultsTableBody tr');
    let updatedCount = 0;
    
    rows.forEach((row) => {
      const googleSelect = row.querySelector('select[id^="googleStatus_"]');
      const schemaOrgSelect = row.querySelector('select[id^="schemaOrgStatus_"]');
      
      if (googleSelect) {
        const index = parseInt(googleSelect.id.replace('googleStatus_', ''));
        if (!isNaN(index)) {
          googleSelect.value = 'Not run';
          updateValidationStatus(index, 'google', 'Not run');
          updatedCount++;
        }
      }
      
      if (schemaOrgSelect) {
        const index = parseInt(schemaOrgSelect.id.replace('schemaOrgStatus_', ''));
        if (!isNaN(index)) {
          schemaOrgSelect.value = 'Not run';
          updateValidationStatus(index, 'schemaorg', 'Not run');
          updatedCount++;
        }
      }
    });
    
    showToast(`‚úÖ Reset ${updatedCount} external status${updatedCount !== 1 ? 'es' : ''} to "Not run"`);
  }
  
  // Helper: Prepare schema JSON for Supabase insertion
  function prepareSchemaJsonForSupabase(result) {
    if (!result.schemas || result.schemas.length === 0) {
      return null;
    }
    if (result.schemas.length === 1) {
      return result.schemas[0].schema;
    }
    return {
      '@context': 'https://schema.org',
      '@graph': result.schemas.map(s => s.schema)
    };
  }

  // Helper: Get validation statuses from DOM
  function getValidationStatusesFromDOM(index, result) {
    const googleStatusEl = document.getElementById(`googleStatus_${index}`);
    const schemaOrgStatusEl = document.getElementById(`schemaOrgStatus_${index}`);
    const notesEl = document.getElementById(`notes_${index}`);
    
    return {
      googleStatus: googleStatusEl ? googleStatusEl.value : result.validatorGoogleStatus || 'Not run',
      schemaOrgStatus: schemaOrgStatusEl ? schemaOrgStatusEl.value : result.validatorSchemaOrgStatus || 'Not run',
      notes: notesEl ? notesEl.value : result.notes || ''
    };
  }

  // Helper: Update save button UI after save
  function updateSaveButtonAfterSave(saveBtn, silent) {
    if (saveBtn && !silent) {
      saveBtn.textContent = '‚úÖ Saved';
      setTimeout(() => {
        saveBtn.textContent = 'Save to Supabase';
        saveBtn.disabled = false;
      }, 2000);
    }
  }

  // Helper: Validate Supabase save prerequisites
  function validateSupabaseSave(index, silent) {
    if (!supabaseAvailable || !supabase) {
      const msg = 'Supabase client not initialized. Please refresh the page.';
      if (!silent) showToast(msg, true);
      debugLog(msg, 'error');
      return { valid: false };
    }
    
    const result = validationResults[index];
    if (!result) {
      const msg = 'Error: No result found for this row';
      if (!silent) showToast(msg, true);
      debugLog(msg, 'error');
      return { valid: false };
    }
    
    return { valid: true, result };
  }

  // Helper: Prepare save button UI
  function prepareSaveButtonUI(index, silent) {
    const saveBtn = document.getElementById(`saveBtn_${index}`);
    if (saveBtn && !silent) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    return saveBtn;
  }

  // Helper: Log save operation details
  function logSaveOperation(result, statuses) {
    debugLog(`Saving to Supabase: ${result.url}`, 'info');
    debugLog(`  Google Status: ${statuses.googleStatus}`, 'info');
    debugLog(`  Schema.org Status: ${statuses.schemaOrgStatus}`, 'info');
    debugLog(`  Schema Type: ${result.schemaType || 'null'}`, 'info');
  }

  // Helper: Handle save success
  function handleSaveSuccess(result, data, silent) {
    if (!silent) {
      showToast(`‚úÖ Saved to Supabase: ${result.url}`);
      debugLog('Successfully saved to Supabase:', data);
    } else {
      debugLog(`‚úÖ Auto-saved to Supabase: ${result.url}`, 'success');
    }
  }

  // Helper: Handle save error
  function handleSaveError(error, result, saveBtn, silent) {
    const errorMsg = error.message || error.code || JSON.stringify(error);
    const errorCode = error.code || '';
    
    // Suppress RLS policy errors if they're just informational (policy exists but may need adjustment)
    const isRLSError = errorCode === '42501' || errorMsg.includes('row-level security policy');
    
    if (isRLSError && silent) {
      // Silently skip RLS errors for auto-save - they're likely due to policy configuration
      debugLog(`Auto-save skipped (RLS policy): ${result.url}`, 'warn');
      return;
    }
    
    debugLog(`Error saving to Supabase: ${errorMsg}`, 'error');
    if (!isRLSError) {
      debugLog(`Full error object: ${JSON.stringify(error)}`, 'error');
    }
    console.error('Error saving to Supabase:', error);
    
    if (!silent) {
      if (isRLSError) {
        showToast(`‚ö†Ô∏è RLS policy issue: Please check Supabase policies for schema_audit_logs table`, true);
      } else {
        showToast(`‚ùå Error saving to Supabase: ${errorMsg}`, true);
      }
    } else {
      debugLog(`Auto-save error for ${result.url}: ${errorMsg}`, 'error');
    }
    
    if (saveBtn && !silent) {
      saveBtn.textContent = 'Save to Supabase';
      saveBtn.disabled = false;
    }
  }

  // Helper: Insert data into Supabase
  async function insertIntoSupabase(result, statuses, schemaJsonRaw) {
    const { data, error } = await supabase
      .from('schema_audit_logs')
      .upsert({
        url: result.url,
        timestamp: new Date().toISOString(),
        validator_google_status: statuses.googleStatus,
        validator_schemaorg_status: statuses.schemaOrgStatus,
        schema_type_detected: result.schemaType || null,
        schema_json_raw: schemaJsonRaw,
        schema_notes: statuses.notes || null
      }, {
        onConflict: 'url',
        ignoreDuplicates: false
      });
    
    if (error) {
      const errorCode = error.code || '';
      const isRLSError = errorCode === '42501' || error.message?.includes('row-level security policy');
      
      if (isRLSError) {
        debugLog(`Supabase RLS error (code ${errorCode}): ${error.message}`, 'warn');
        debugLog(`  Hint: Anonymous inserts may require RLS policy adjustment`, 'warn');
      } else {
        debugLog(`Supabase error: ${JSON.stringify(error)}`, 'error');
        debugLog(`  Code: ${error.code}, Message: ${error.message}, Details: ${JSON.stringify(error.details)}`, 'error');
      }
      throw error;
    }
    
    return data;
  }

  // Save to Supabase
  async function saveToSupabase(index, silent = false) {
    const validation = validateSupabaseSave(index, silent);
    if (!validation.valid) return;
    
    const result = validation.result;
    const saveBtn = prepareSaveButtonUI(index, silent);
    
    try {
      const statuses = getValidationStatusesFromDOM(index, result);
      const schemaJsonRaw = prepareSchemaJsonForSupabase(result);
      
      logSaveOperation(result, statuses);
      const data = await insertIntoSupabase(result, statuses, schemaJsonRaw);
      
      handleSaveSuccess(result, data, silent);
      updateSaveButtonAfterSave(saveBtn, silent);
      return data;
      
    } catch (error) {
      handleSaveError(error, result, saveBtn, silent);
      throw error;
    }
  }
  
  // Show toast notification
  function showToast(message, isError = false) {
    const toast = document.createElement('div');
    toast.className = `toast ${isError ? 'error' : ''}`;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateX(100%)';
      setTimeout(() => {
        document.body.removeChild(toast);
      }, 300);
    }, 3000);
  }

  // Helper: Initialize validation UI
  function initializeValidationUI(urls, progressDiv, progressBar, progressText, resultsDiv, tableBody) {
    progressDiv.style.display = 'block';
    resultsDiv.style.display = 'block';
    tableBody.innerHTML = '';
    validationResults = [];
    
    // Initialize rows with processing status
    urls.forEach((urlData, index) => {
      const placeholderResult = {
        url: urlData.url,
        row: urlData.row,
        schemaType: null,
        valid: false,
        schemaFound: false,
        missingFields: [],
        warnings: [],
        schemas: [],
        error: null,
        validatorGoogleStatus: 'Not run',
        validatorSchemaOrgStatus: 'Not run',
        notes: '',
        processing: true
      };
      validationResults.push(placeholderResult);
      updateTableRow(index, {
        ...placeholderResult,
        schemaType: 'Processing...',
        error: null
      });
      const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
      if (schemaTypeCell) {
        renderProgress(schemaTypeCell);
        setProgress(schemaTypeCell, 10, 'Queued');
      }
    });
  }

  // Helper: Process URL in batch with progress updates
  async function processUrlInBatch(urlData, index, urls, progressBar, progressText) {
    // Update global progress
    progressText.textContent = `Processing ${index + 1} of ${urls.length}: ${urlData.url}`;
    progressBar.style.width = `${((index + 1) / urls.length) * 100}%`;
    
    // Initialize row with processing status
    updateTableRow(index, {
      url: urlData.url,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null
    });
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    if (schemaTypeCell) {
      renderProgress(schemaTypeCell);
      setProgress(schemaTypeCell, 10, 'Queued');
    }
    
    // Start row-level progress (progress updates now happen INSIDE processUrl)
    updateRowProgress(urlData.url, 5);
    
    // Process URL (this will update row progress internally at each stage)
    // Pass index to processUrl so it uses the correct index
    urlData.index = index;
    const result = await processUrl(urlData);
    // Result is already stored at correct index inside processUrl
    // Just ensure table is updated if needed
    if (!validationResults[index]) {
      validationResults[index] = result;
    }
    updateTableRow(index, validationResults[index]);
    
    // Auto-run external validators if enabled
    try {
      await runExternalValidatorsIfEnabled(index, urlData.url);
    } catch (error) {
      console.error(`Failed to run external validators for ${urlData.url}:`, error);
      debugLog(`Failed to run external validators for ${urlData.url}: ${error.message}`, 'error');
    }
    
    // Auto-save to Supabase if enabled (same as single URL validation)
    autoSaveToSupabaseIfEnabled(index, urlData.url);
    
    // Small delay to allow UI to update
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  // Start validation process
  async function startValidation() {
    // Clear all cache and storage BEFORE starting validation
    try {
      // Clear ResultCache if it exists
      if (typeof ResultCache !== 'undefined') {
        if (ResultCache instanceof Map) {
          ResultCache.clear();
        } else if (ResultCache.clear && typeof ResultCache.clear === 'function') {
          ResultCache.clear();
        }
      }
      // Clear validationResults array
      if (typeof validationResults !== 'undefined' && Array.isArray(validationResults)) {
        validationResults.length = 0;
      }
      // Clear localStorage and sessionStorage
      localStorage.removeItem('schemaValidatorResults');
      localStorage.removeItem('schemaValidatorCache');
      sessionStorage.removeItem('schemaValidatorResults');
      sessionStorage.removeItem('schemaValidatorCache');
    } catch (e) {
      console.warn('Failed to clear storage:', e);
    }
    
    // Clear the results table
    const tableBody = document.getElementById('resultsTableBody');
    if (tableBody) {
      tableBody.innerHTML = '';
    }
    
    const fileInput = document.getElementById('validatorCsvFile');
    if (!fileInput.files.length) {
      alert('Please upload a CSV file first');
      return;
    }
    
    const progressDiv = document.getElementById('validatorProgress');
    const progressBar = document.getElementById('progressBarFill');
    const progressText = document.getElementById('progressText');
    const resultsDiv = document.getElementById('validatorResults');
    
    try {
      // Parse CSV
      const urls = await parseCSVForValidation(fileInput.files[0]);
      
      if (urls.length === 0) {
        alert('No valid URLs found in CSV file');
        return;
      }
      
      // Initialize UI
      const tableBody = document.getElementById('resultsTableBody');
      initializeValidationUI(urls, progressDiv, progressBar, progressText, resultsDiv, tableBody);
      
      // Process each URL
      for (let i = 0; i < urls.length; i++) {
        await processUrlInBatch(urls[i], i, urls, progressBar, progressText);
      }
      
      progressText.textContent = `Completed: ${validationResults.length} URLs processed`;
      progressBar.style.width = '100%';
      
      // Enable bulk action buttons
      updateBulkButtons();
      
    } catch (error) {
      alert('Error: ' + error.message);
      progressDiv.style.display = 'none';
      console.error('Validation error:', error);
    }
  }
  
  // Make functions globally available for onclick handlers
  if (typeof window !== 'undefined') {
    window.startValidation = startValidation;
    window.onFileUpload = onFileUpload;
  }
  
  // Update bulk action buttons state
  function updateBulkButtons() {
    const exportBtn = document.getElementById('exportAllBtn');
    const saveAllBtn = document.getElementById('saveAllBtn');
    
    const hasResults = validationResults && validationResults.length > 0;
    
    if (exportBtn) {
      exportBtn.disabled = !hasResults;
    }
    
    if (saveAllBtn) {
      saveAllBtn.disabled = !hasResults || !supabaseAvailable;
    }
    
    console.log('Bulk buttons updated:', { hasResults, supabaseAvailable, exportEnabled: hasResults, saveEnabled: hasResults && supabaseAvailable });
  }
  
  // Export all enhanced schemas
  async function exportAllEnhanced() {
    const exportBtn = document.getElementById('exportAllBtn');
    if (!exportBtn || exportBtn.disabled) return;
    
    if (!validationResults || validationResults.length === 0) {
      alert('No validation results to export');
      return;
    }
    
    exportBtn.disabled = true;
    exportBtn.textContent = 'Generating...';
    
    try {
      const pages = [];
      const processedUrls = new Set();
      
      for (const result of validationResults) {
        if (!result.url || processedUrls.has(result.url)) continue;
        processedUrls.add(result.url);
        
        try {
          const json = await generateEnhancedFor(result.url);
          pages.push({
            url: result.url,
            json: json
          });
        } catch (error) {
          console.warn(`Failed to generate enhanced schema for ${result.url}:`, error);
          // Continue with other URLs
        }
      }
      
      const payload = {
        createdAt: new Date().toISOString(),
        pages: pages
      };
      
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      a.download = `enhanced-schema-batch-${timestamp}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast(`‚úÖ Exported ${pages.length} enhanced schemas`);
      
    } catch (error) {
      console.error('Export error:', error);
      alert('Error exporting enhanced schemas: ' + error.message);
    } finally {
      exportBtn.disabled = false;
      exportBtn.textContent = 'Export All Enhanced';
    }
  }
  
  // Helper: Save single result to Supabase (for batch save)
  async function saveSingleResultToSupabase(result, index) {
    const statuses = getValidationStatusesFromDOM(index, result);
    const schemaJsonRaw = prepareSchemaJsonForSupabase(result);
    
    // Upsert into Supabase (update if exists, insert if not)
    const { data, error } = await supabase
      .from('schema_audit_logs')
      .upsert({
        url: result.url,
        timestamp: new Date().toISOString(),
        validator_google_status: statuses.googleStatus || 'üö´ Skipped',
        validator_schemaorg_status: statuses.schemaOrgStatus || 'üö´ Skipped',
        schema_type_detected: result.schemaType || null,
        schema_json_raw: schemaJsonRaw,
        schema_notes: statuses.notes || null
      }, {
        onConflict: 'url',
        ignoreDuplicates: false
      });
    
    if (error) {
      throw error;
    }
    
    return data;
  }

  // Helper: Show save result summary
  function showSaveResultToast(successCount, errorCount) {
    if (successCount > 0) {
      showToast(`‚úÖ Saved ${successCount} result${successCount !== 1 ? 's' : ''} to Supabase${errorCount > 0 ? ` (${errorCount} failed)` : ''}`);
    } else {
      showToast(`‚ùå Failed to save results: ${errorCount} error${errorCount !== 1 ? 's' : ''}`, true);
    }
  }

  // Save all results to Supabase
  async function saveAllToSupabase() {
    const saveAllBtn = document.getElementById('saveAllBtn');
    if (!saveAllBtn || saveAllBtn.disabled) return;
    
    if (!supabaseAvailable || !supabase) {
      showToast('Supabase client not initialized. Please refresh the page.', true);
      return;
    }
    
    if (!validationResults || validationResults.length === 0) {
      alert('No validation results to save');
      return;
    }
    
    saveAllBtn.disabled = true;
    saveAllBtn.textContent = 'Saving...';
    
    let successCount = 0;
    let errorCount = 0;
    
    try {
      for (let i = 0; i < validationResults.length; i++) {
        const result = validationResults[i];
        if (!result || !result.url) continue;
        
        try {
          await saveSingleResultToSupabase(result, i);
          successCount++;
        } catch (error) {
          console.error(`Failed to save ${result.url}:`, error);
          errorCount++;
        }
      }
      
      showSaveResultToast(successCount, errorCount);
      
    } catch (error) {
      console.error('Save all error:', error);
      showToast('Error saving results: ' + error.message, true);
    } finally {
      saveAllBtn.disabled = false;
      saveAllBtn.textContent = 'Save All to Supabase';
    }
  }

  // Generate enhanced schema
  function generateEnhancedSchema(index) {
    const result = validationResults[index];
    if (!result || !result.schemas || result.schemas.length === 0) {
      alert('No schema found to enhance');
      return;
    }
    
    // Enhance all schemas if multiple exist
    const enhancedSchemas = result.schemas.map(schemaData => {
      return enhanceSchema(schemaData.schema, schemaData.type, result.url);
    });
    
    // If single schema, download as single JSON
    // If multiple schemas, create @graph structure
    let jsonData;
    if (enhancedSchemas.length === 1) {
      jsonData = JSON.stringify(enhancedSchemas[0], null, 2);
    } else {
      // Use @graph structure for multiple schemas
      const graphSchema = {
        '@context': 'https://schema.org',
        '@graph': enhancedSchemas
      };
      jsonData = JSON.stringify(graphSchema, null, 2);
    }
    
    // Create downloadable JSON
    const blob = new Blob([jsonData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const sanitizedUrl = result.url.replace(/https?:\/\//g, '').replace(/[^a-z0-9]/gi, '-').toLowerCase();
    a.download = `enhanced-schema-${sanitizedUrl}-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Also create HTML script tag version as .txt file
    const txtBlob = new Blob([`<script type="application/ld+json">\n${jsonData}\n<\/script>`], { type: 'text/plain' });
    const txtUrl = URL.createObjectURL(txtBlob);
    const txtA = document.createElement('a');
    txtA.href = txtUrl;
    txtA.download = `enhanced-schema-${sanitizedUrl}-${Date.now()}.txt`;
    setTimeout(() => {
      document.body.appendChild(txtA);
      txtA.click();
      document.body.removeChild(txtA);
      URL.revokeObjectURL(txtUrl);
    }, 500);
  }
  
  // Table sorting and filtering functionality
  let currentSortColumn = -1;
  let currentSortDirection = 'asc';
  let originalRows = [];
  
  // Initialize sorting and filtering
  function initTableSortingAndFiltering() {
    const tableBody = document.getElementById('resultsTableBody');
    if (!tableBody) return;
    
    // Store original rows
    originalRows = Array.from(tableBody.children);
    
    // Setup sortable headers
    document.querySelectorAll('.sortable-header').forEach(header => {
      header.style.cursor = 'pointer';
      header.onclick = () => {
        const column = parseInt(header.dataset.column);
        sortTable(column);
      };
    });
    
    // Setup filter inputs
    document.querySelectorAll('.filter-input').forEach(input => {
      input.addEventListener('input', () => {
        filterTable();
      });
    });
  }
  
  // Sort table by column
  function sortTable(columnIndex) {
    const tableBody = document.getElementById('resultsTableBody');
    if (!tableBody) return;
    
    const rows = Array.from(tableBody.children);
    
    // Toggle sort direction if clicking same column
    if (currentSortColumn === columnIndex) {
      currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
    } else {
      currentSortColumn = columnIndex;
      currentSortDirection = 'asc';
    }
    
    // Update sort indicators
    document.querySelectorAll('.sort-indicator').forEach(indicator => {
      indicator.classList.remove('sorted-asc', 'sorted-desc');
    });
    const clickedHeader = document.querySelector(`.sortable-header[data-column="${columnIndex}"]`);
    if (clickedHeader) {
      const indicator = clickedHeader.nextElementSibling;
      if (indicator && indicator.classList.contains('sort-indicator')) {
        indicator.classList.add(currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
      }
    }
    
    // Sort rows
    rows.sort((a, b) => {
      const aCell = a.children[columnIndex];
      const bCell = b.children[columnIndex];
      if (!aCell || !bCell) return 0;
      
      const aText = aCell.textContent.trim().toLowerCase();
      const bText = bCell.textContent.trim().toLowerCase();
      
      let comparison = 0;
      if (aText < bText) comparison = -1;
      else if (aText > bText) comparison = 1;
      
      return currentSortDirection === 'asc' ? comparison : -comparison;
    });
    
    // Re-append sorted rows
    rows.forEach(row => tableBody.appendChild(row));
    
    // Re-apply filters after sorting
    filterTable();
  }
  
  // Filter table rows
  function filterTable() {
    const tableBody = document.getElementById('resultsTableBody');
    if (!tableBody) return;
    
    const filterInputs = document.querySelectorAll('.filter-input');
    const filters = Array.from(filterInputs).map(input => ({
      column: parseInt(input.dataset.column),
      value: input.value.trim().toLowerCase()
    }));
    
    const rows = Array.from(tableBody.children);
    
    rows.forEach(row => {
      let show = true;
      
      filters.forEach(filter => {
        if (filter.value) {
          const cell = row.children[filter.column];
          if (cell) {
            const cellText = cell.textContent.trim().toLowerCase();
            if (!cellText.includes(filter.value)) {
              show = false;
            }
          }
        }
      });
      
      row.style.display = show ? '' : 'none';
    });
    
    // Ensure at least 5 rows are visible (if possible)
    const visibleRows = rows.filter(row => row.style.display !== 'none');
    if (visibleRows.length > 0 && visibleRows.length < 5) {
      // Show message if less than 5 rows visible
      console.log(`Showing ${visibleRows.length} row(s) after filtering`);
    }
  }
  
  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTableSortingAndFiltering);
  } else {
    initTableSortingAndFiltering();
  }
  
  // Re-initialize when new rows are added
  const originalAppendChild = Node.prototype.appendChild;
  Node.prototype.appendChild = function(child) {
    const result = originalAppendChild.call(this, child);
    if (this.id === 'resultsTableBody' && child.tagName === 'TR') {
      originalRows = Array.from(this.children);
    }
    return result;
  };
</script>
<!-- Generated Schema Modal -->
  <div id="genBackdrop" class="issues-backdrop" style="display:none" role="dialog" aria-modal="true" aria-labelledby="genTitle">
    <div class="issues-modal gen-enhanced-modal" style="width:min(880px,94vw)">
      <div class="gen-enhanced-header">
        <h3 id="genTitle">Enhanced Schema (suggestion)</h3>
      </div>
      <div class="issues-meta" id="genMeta"></div>
      <div id="genSquarespaceInstructions" style="margin: 1rem 0; padding: 1rem; background: #1e293b; border-left: 4px solid #3b82f6; border-radius: 4px; color: #e2e8f0; font-size: 0.9rem;">
        <strong style="color: #fff;">üìã Where to paste in Squarespace:</strong>
        <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
          <li><strong>Page Header:</strong> Settings ‚Üí Advanced ‚Üí Code Injection ‚Üí Page Header Code</li>
          <li><strong>Page Footer:</strong> Settings ‚Üí Advanced ‚Üí Code Injection ‚Üí Footer</li>
          <li><strong>Code Block:</strong> Add a Code Block ‚Üí Paste the JSON-LD inside &lt;script type="application/ld+json"&gt; tags</li>
        </ul>
        <p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #94a3b8;">üí° Tip: Use Page Header for page-specific schema, Footer for site-wide schema.</p>
      </div>
      <pre id="genJson" class="issues-json" style="max-height:48vh"></pre>
      <div class="gen-enhanced-actions">
        <button class="secondary gen-copy-btn" id="genCopyBtn">Copy to Clipboard</button>
        <button class="secondary gen-save-btn" id="genSaveBtn" style="background: #10b981; color: white; border-color: #10b981;">üíæ Save to File</button>
        <button class="primary gen-close-btn" id="genCloseBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Issues Modal -->
  <dialog id="issuesBackdrop" class="issues-backdrop" aria-labelledby="issuesTitle">
    <div class="issues-modal">
      <div class="issues-modal-header">
        <h3 id="issuesTitle">Schema Details</h3>
        <button id="issuesCloseXBtn" class="issues-close-x" aria-label="Close">√ó</button>
      </div>
      <div id="issuesMeta" class="issues-meta"></div>
      <div id="issuesContent" class="issues-content"></div>
      <ul id="issuesList" class="issues-list" style="display: none;"></ul>
      <details id="issuesJsonDetails" style="display: none;">
        <summary>Preview first JSON-LD block on page</summary>
        <div style="margin-top: 0.5rem; margin-bottom: 0.5rem;">
          <button class="secondary" id="issuesCopyJsonBtn" style="font-size: 0.85rem; padding: 0.4rem 0.8rem;">Copy JSON-LD</button>
        </div>
        <pre id="issuesJson" class="issues-json"></pre>
      </details>
      <div class="issues-actions">
        <button class="secondary" id="issuesSchemaOrgBtn">Open Schema.org</button>
        <button class="secondary" id="issuesGoogleBtn">Open Rich Results</button>
        <button class="primary" id="issuesCloseBtn">Close</button>
      </div>
    </div>
  </dialog>

  <!-- Product Schema Workflow Controller -->
  <script>
    // Server status check - disabled in Electron mode (server always runs)
    let serverStatus = 'running'; // Assume running in Electron
    let isElectronMode = false;
    
    // Detect if running in Electron (check for Electron user agent or window properties)
    // This runs immediately, but initLocalExecutor will do a more thorough check
    function detectElectronMode() {
      if (navigator.userAgent.toLowerCase().indexOf('electron') > -1) {
        isElectronMode = true;
        console.log("‚úÖ Electron detected via user agent");
        serverStatus = 'running';
        return true;
      } else if (window.electronAPI && window.electronAPI.isElectron) {
        isElectronMode = true;
        console.log("‚úÖ Electron detected via preload API");
        serverStatus = 'running';
        return true;
      } else if (window.process && window.process.versions && window.process.versions.electron) {
        isElectronMode = true;
        console.log("‚úÖ Electron detected via process.versions");
        serverStatus = 'running';
        return true;
      }
      return false;
    }
    
    // Try immediate detection
    detectElectronMode();
    
    // Also check after a short delay (in case preload script loads late)
    setTimeout(() => {
      if (!isElectronMode) {
        if (detectElectronMode()) {
          console.log("‚úÖ Electron detected after delay");
        }
      }
    }, 500);
    
    async function ensureLocalExecutorRunning() {
      // In Electron mode, server is always running
      if (isElectronMode) {
        console.log("‚úÖ Local executor running (Electron mode)");
        serverStatus = 'running';
        return true;
      }
      
      // Browser mode: check server status
      try {
        const res = await fetch("http://localhost:8000/health");
        const data = await res.json();
        if (data.status === "ok") {
          console.log("‚úÖ Local executor already running.");
          serverStatus = 'running';
          return true;
        }
      } catch (err) {
        console.log("‚ö†Ô∏è Local executor not running.");
        console.log("üí° To start the server, run in terminal: npm run start-local");
        serverStatus = 'stopped';
        
        // Check if running on Vercel/web deployment
        const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                                window.location.hostname.includes('localhost') === false;
        
        // Show a helpful message in the UI (only in browser mode)
        if (!isElectronMode) {
          if (isWebDeployment) {
            // On web deployment, show info message instead of warning
            const firstStep = document.querySelector('#file-step1')?.parentElement;
            if (firstStep && !document.getElementById('serverStatusWarning')) {
              const statusDiv = document.createElement('div');
              statusDiv.id = 'serverStatusWarning';
              statusDiv.style.cssText = 'margin-top: 1rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; color: #1565c0; font-size: 0.875rem;';
              statusDiv.innerHTML = `
                <strong>‚ÑπÔ∏è Web Deployment Mode</strong><br>
                Local server features require the Electron app or local development.<br>
                <strong>For full automation:</strong> Download the Electron desktop app or run locally with <code style="background: #f0f0f0; padding: 4px 8px; border-radius: 4px;">npm run start-local</code><br>
                <small>The web version is read-only for validation purposes.</small>
              `;
              firstStep.insertBefore(statusDiv, firstStep.firstChild);
            }
          } else {
            // Local browser mode: show warning
            const firstStep = document.querySelector('#file-step1')?.parentElement;
            if (firstStep && !document.getElementById('serverStatusWarning')) {
              const statusDiv = document.createElement('div');
              statusDiv.id = 'serverStatusWarning';
              statusDiv.style.cssText = 'margin-top: 1rem; padding: 1rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; color: #856404; font-size: 0.875rem;';
              statusDiv.innerHTML = `
                <strong>‚ö†Ô∏è Local Server Not Running</strong><br>
                Start the local executor server first:<br>
                <code style="background: #f0f0f0; padding: 4px 8px; border-radius: 4px;">npm run start-local</code><br>
                <small>Then refresh this page and try again.</small>
              `;
              firstStep.insertBefore(statusDiv, firstStep.firstChild);
            }
          }
        }
        return false;
      }
    }

    // Auto-chain steps automatically
    function chainNextStep(nextStepFunction, delay = 2000) {
      setTimeout(() => {
        console.log(`‚è© Automatically continuing to next step...`);
        if (nextStepFunction) {
          nextStepFunction();
        }
      }, delay);
    }

    // Step 0: Initialize Local Executor
    async function initLocalExecutor() {
      const consoleOutput = document.getElementById("executorConsole");
      const status = document.getElementById("executorStatus");
      const startBtn = document.getElementById("startLocalBtn");
      const copyBtn = document.getElementById("copyCommandBtn");
      
      const log = (msg) => {
        if (consoleOutput) {
          consoleOutput.style.display = 'block';
          consoleOutput.textContent += msg + '\n';
          consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }
      };
      
      if (!status) return;
      
      // Detect Electron - check multiple methods with fallback
      let isElectron = false;
      
      // Method 1: Check preload API (most reliable)
      if (window.electronAPI && window.electronAPI.isElectron) {
        isElectron = true;
        log("‚úÖ Electron detected via preload API");
      }
      // Method 2: Check user agent
      else if (navigator.userAgent.toLowerCase().indexOf('electron') > -1) {
        isElectron = true;
        log("‚úÖ Electron detected via user agent");
      }
      // Method 3: Check process.versions (if available)
      else if (typeof window !== 'undefined' && window.process && window.process.versions && window.process.versions.electron) {
        isElectron = true;
        log("‚úÖ Electron detected via process.versions");
      }
      
      // If still not detected, wait a bit for preload script to load
      if (!isElectron) {
        log("‚è≥ Waiting for Electron API to load...");
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Retry detection
        if (window.electronAPI && window.electronAPI.isElectron) {
          isElectron = true;
          log("‚úÖ Electron detected after delay");
        } else if (navigator.userAgent.toLowerCase().indexOf('electron') > -1) {
          isElectron = true;
          log("‚úÖ Electron detected via user agent after delay");
        }
      }
      
      log("üîç Detecting environment...");
      
      if (isElectron) {
        log("‚úÖ Electron desktop app detected!");
        log("‚öôÔ∏è Local server auto-started by Electron.");
        status.textContent = "‚úÖ Electron Mode Active ‚Äì Local server running automatically";
        status.style.background = "#d4edda";
        status.style.borderColor = "#c3e6cb";
        status.style.color = "#155724";
        
        try {
          // Give server a moment to start (main.js spawns it)
          await new Promise(resolve => setTimeout(resolve, 1500));
          
          const res = await fetch("http://localhost:8000/health").catch(() => null);
          if (res && res.ok) {
            status.textContent = "‚úÖ Electron Mode Active ‚Äì Ready for automation";
            log("‚úÖ Local executor active and ready.");
            log("‚úÖ All steps (1‚Üí2‚Üí3a‚Üí3b‚Üí4) will run automatically!");
            serverStatus = 'running';
            updateStepStatus('0', 'complete', 'Electron Active');
            unlockStep1();
            updateStepStatus('1', 'waiting', 'Ready');
          } else {
            log("‚öôÔ∏è Waiting for built-in local server to start...");
            // Retry after another delay
            setTimeout(async () => {
              const retryRes = await fetch("http://localhost:8000/health").catch(() => null);
              if (retryRes && retryRes.ok) {
                status.textContent = "‚úÖ Electron Mode Active ‚Äì Ready for automation";
                log("‚úÖ Local executor ready.");
                log("‚úÖ All steps (1‚Üí2‚Üí3a‚Üí3b‚Üí4) will run automatically!");
                serverStatus = 'running';
                updateStepStatus('0', 'complete', 'Electron Active');
                unlockStep1();
                updateStepStatus('1', 'waiting', 'Ready');
              } else {
                status.textContent = "‚ö†Ô∏è Electron Mode ‚Äì Server starting... (check console)";
                status.style.background = "#fff3cd";
                status.style.borderColor = "#ffc107";
                status.style.color = "#856404";
                log("‚ö†Ô∏è Server may still be starting. If issue persists, check Electron console.");
              }
            }, 2000);
          }
        } catch (err) {
          status.textContent = "‚ùå Electron Mode ‚Äì Error starting executor";
          status.style.background = "#f8d7da";
          status.style.borderColor = "#f5c6cb";
          status.style.color = "#721c24";
          log(`‚ùå Error: ${err.message}`);
        }
      } else {
        // Browser mode
        const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                                window.location.hostname.includes('localhost') === false;
        
        if (isWebDeployment) {
          status.textContent = "‚ÑπÔ∏è Web Mode ‚Äì Use Electron App for Full Automation";
          status.style.background = "#e3f2fd";
          status.style.borderColor = "#2196f3";
          status.style.color = "#1565c0";
          log("üåê Web Mode: Read-only validation. Download Electron app for full automation.");
          log("üí° To use Electron: Run 'npm start' in your project folder.");
          
          // Show web mode notices on Steps 2-4
          const step2Notice = document.getElementById('step2WebModeNotice');
          const step3aNotice = document.getElementById('step3aWebModeNotice');
          const step3bNotice = document.getElementById('step3bWebModeNotice');
          const step4Notice = document.getElementById('step4WebModeNotice');
          
          if (step2Notice) step2Notice.style.display = 'block';
          if (step3aNotice) step3aNotice.style.display = 'block';
          if (step3bNotice) step3bNotice.style.display = 'block';
          if (step4Notice) step4Notice.style.display = 'block';
          
          // Disable buttons in web mode
          const fetchBtn = document.getElementById('fetchGoogleReviews');
          const mergeBtn = document.getElementById('mergeReviewsBtn');
          const schemaBtn = document.getElementById('run-step4');
          
          if (fetchBtn) {
            fetchBtn.disabled = true;
            fetchBtn.style.opacity = '0.5';
            fetchBtn.style.cursor = 'not-allowed';
          }
          if (mergeBtn) {
            mergeBtn.disabled = true;
            mergeBtn.style.opacity = '0.5';
            mergeBtn.style.cursor = 'not-allowed';
          }
          if (schemaBtn) {
            schemaBtn.disabled = true;
            schemaBtn.style.opacity = '0.5';
            schemaBtn.style.cursor = 'not-allowed';
          }
          
          // Add a button to proceed anyway in web mode
          if (startBtn) {
            startBtn.style.display = 'inline-block';
            startBtn.textContent = "‚úÖ Continue in Web Mode (Read-Only)";
            startBtn.style.background = "#2196f3";
            startBtn.onmouseover = function() { this.style.background = '#1976d2'; };
            startBtn.onmouseout = function() { this.style.background = '#2196f3'; };
            startBtn.onclick = () => {
              status.textContent = "‚úÖ Web Mode Active ‚Äì Step 1 unlocked for validation.";
              status.style.background = "#d4edda";
              status.style.borderColor = "#c3e6cb";
              status.style.color = "#155724";
              unlockStep1();
              updateStepStatus('1', 'waiting', 'Ready');
              if (startBtn) startBtn.style.display = 'none';
            };
          }
          
          // Auto-unlock Step 1 after a short delay in web mode
          setTimeout(() => {
            unlockStep1();
          }, 2000);
        } else {
          status.textContent = "üåê Web mode ‚Äì manual start required.";
          status.style.background = "#fff3cd";
          status.style.borderColor = "#ffc107";
          status.style.color = "#856404";
          log("üîç Browser mode detected.");
          log("üìã Run the following command in your project folder:");
          log("   npm run start-local");
          
          if (copyBtn) {
            copyBtn.style.display = 'inline-block';
            copyBtn.onclick = () => {
              navigator.clipboard.writeText("npm run start-local").then(() => {
                status.textContent = "üìã Command copied! Now run it in your terminal.";
                setTimeout(() => {
                  checkServerStatus();
                }, 500);
              });
            };
          }
          
          if (startBtn) {
            startBtn.style.display = 'inline-block';
            startBtn.textContent = "üîÑ Check Server Status";
            startBtn.onclick = () => {
              checkServerStatus();
            };
          }
          
          // Auto-check server status
          checkServerStatus();
        }
      }
      
      async function checkServerStatus() {
        log("üîÑ Checking server status...");
        try {
          const res = await fetch("http://localhost:8000/health");
          const data = await res.json();
          if (data.status === "ok") {
            status.textContent = "‚úÖ Local executor running and ready!";
            status.style.background = "#d4edda";
            status.style.borderColor = "#c3e6cb";
            status.style.color = "#155724";
            log("‚úÖ Server is running.");
            serverStatus = 'running';
            unlockStep1();
            if (startBtn) startBtn.style.display = 'none';
            if (copyBtn) copyBtn.style.display = 'none';
          }
        } catch (err) {
          log("‚ö†Ô∏è Server not running yet.");
          log("üí° Run 'npm run start-local' in your terminal, then click 'Check Server Status'.");
          status.textContent = "‚è≥ Waiting for local server...";
        }
      }
    }
    
    function unlockStep1() {
      const step1 = document.getElementById('file-step1');
      if (step1) {
        step1.disabled = false;
        step1.style.opacity = '1';
        step1.style.cursor = 'pointer';
      }
      const step1Card = step1 ? step1.closest('div[style*="border-radius"]') : null;
      if (step1Card) {
        step1Card.style.opacity = '1';
        step1Card.style.pointerEvents = 'auto';
      }
      // Hide the "Complete Step 0 first" message
      const lockMessage = document.getElementById('step1LockMessage');
      if (lockMessage) {
        lockMessage.style.display = 'none';
      }
    }
    
    function lockStep1() {
      const step1 = document.getElementById('file-step1');
      if (step1) {
        step1.disabled = true;
        step1.style.opacity = '0.5';
        step1.style.cursor = 'not-allowed';
      }
      const step1Card = step1?.closest('div[style*="border-radius"]');
      if (step1Card) {
        step1Card.style.opacity = '0.7';
      }
    }
    
    // Check server status on page load (only in browser mode)
    window.addEventListener("DOMContentLoaded", async () => {
      // Lock Step 1 initially
      lockStep1();
      
      // Initialize Step 0
      try {
        await initLocalExecutor();
      } catch (err) {
        console.error("Error initializing local executor:", err);
        const status = document.getElementById("executorStatus");
        if (status) {
          status.textContent = "‚ùå Error initializing executor. Check console for details.";
          status.style.background = "#f8d7da";
          status.style.borderColor = "#f5c6cb";
          status.style.color = "#721c24";
        }
      }
    });
    // Update step status dashboard
    function updateStepStatus(stepId, status, message) {
      const card = document.getElementById(`step-status-${stepId}`);
      const text = document.getElementById(`step-status-text-${stepId}`);
      const badge = document.getElementById(`step${stepId}-badge`);
      
      if (!card) return;
      
      // Update card
      if (status === 'complete') {
        card.style.background = 'rgba(39, 174, 96, 0.25)'; // Green tint
        card.style.opacity = '1';
        card.querySelector('div').textContent = '‚úÖ';
        if (text) text.textContent = message || 'Complete';
      } else if (status === 'running') {
        card.style.background = 'rgba(229, 114, 0, 0.25)'; // Orange tint
        card.style.opacity = '1';
        card.querySelector('div').textContent = 'üîÑ';
        if (text) text.textContent = message || 'Running';
      } else if (status === 'error') {
        card.style.background = 'rgba(231, 76, 60, 0.25)'; // Red tint
        card.style.opacity = '1';
        card.querySelector('div').textContent = '‚ùå';
        if (text) text.textContent = message || 'Error';
      } else {
        card.style.background = 'rgba(255,255,255,0.1)';
        card.style.opacity = '0.5';
        card.querySelector('div').textContent = '‚è∏Ô∏è';
        if (text) text.textContent = message || 'Waiting';
      }
      
      // Update badge on step card
      if (badge) {
        if (status === 'complete') {
          badge.textContent = '‚úÖ';
          badge.style.background = '#27AE60';
          badge.style.color = 'white';
        } else if (status === 'running') {
          badge.textContent = 'üîÑ';
          badge.style.background = '#E57200';
          badge.style.color = 'white';
        } else if (status === 'error') {
          badge.textContent = '‚ùå';
          badge.style.background = '#E74C3C';
          badge.style.color = 'white';
        } else {
          badge.textContent = '‚è∏Ô∏è';
          badge.style.background = '#e2e8f0';
        }
      }
    }

    function updateStatus(step, msg, percent) {
      const stepNum = step === '3a' ? '3a' : step === '3b' ? '3b' : String(step);
      updateStepStatus(stepNum, 'running', msg);
      
      const bar = document.querySelector(`#progress-step${step} .progress-bar`);
      const wrap = document.querySelector(`#progress-step${step}`);
      const statusEl = document.querySelector(`#status-step${step}`);
      
      if (wrap && bar) {
        wrap.style.display = 'block';
        bar.style.width = percent + '%';
      }
      
      if (statusEl) {
        statusEl.textContent = msg;
        statusEl.style.color = '#4a5568';
      }
    }

    function markComplete(step, msg) {
      const stepNum = step === '3a' ? '3a' : step === '3b' ? '3b' : String(step);
      updateStepStatus(stepNum, 'complete', msg);
      
      const bar = document.querySelector(`#progress-step${step} .progress-bar`);
      if (bar) {
        bar.style.background = '#27AE60'; // Green for complete
      }
      updateStatus(step, '‚úÖ ' + msg, 100);
    }

    function resetProgress(step) {
      const bar = document.querySelector(`#progress-step${step} .progress-bar`);
      const wrap = document.querySelector(`#progress-step${step}`);
      const status = document.querySelector(`#status-step${step}`);
      
      if (bar) {
        bar.style.background = '#E57200'; // Reset to orange
        bar.style.width = '0%';
      }
      if (wrap) wrap.style.display = 'none';
      if (status) status.textContent = '';
    }

    // Local task runner - executes Python scripts via local server
    async function runLocalTask(task, stepId, statusMessage, onComplete) {
      const consoleOutput = document.getElementById(stepId === 2 ? 'cleanConsoleOutput' : 
                                                      stepId === '3a' ? 'googleConsoleOutput' : 
                                                      stepId === '3b' ? 'mergeConsoleOutput' : 
                                                      stepId === 4 ? 'productOutput' : null);
      const progressBar = document.querySelector(`#progress-step${stepId} .progress-bar`);
      
      // Show console output area
      if (consoleOutput) {
        consoleOutput.style.display = 'block';
        consoleOutput.textContent = '';
      }
      
      // Show progress
      updateStatus(stepId, statusMessage, 10);
      
      if (progressBar) {
        progressBar.style.background = '#E57200'; // Orange during execution
        progressBar.style.width = '25%';
      }
      
      const log = (msg) => {
        if (consoleOutput) {
          consoleOutput.textContent += msg;
          consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }
      };
      
      try {
        log(`üöÄ Starting ${task} task...\n`);
        
        const response = await fetch(`http://localhost:8000/run?task=${task}`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        // Stream response text
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ''; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (line.trim()) {
              log(line + '\n');
              // Update progress based on keywords
              if (line.includes('‚úÖ') || line.includes('complete')) {
                if (progressBar) {
                  progressBar.style.width = '90%';
                }
              }
            }
          }
        }
        
        // Process remaining buffer
        if (buffer.trim()) {
          log(buffer + '\n');
        }
        
        // Complete progress
        if (progressBar) {
          progressBar.style.width = '100%';
        }
        
        if (onComplete) {
          onComplete();
        }
        
        markComplete(stepId, statusMessage.replace('üîÑ ', '‚úÖ '));
        
      } catch (err) {
        log(`\n‚ùå Task '${task}' failed: ${err.message}\n`);
        log(`üí° Make sure the local server is running: npm run start-local\n`);
        
        if (progressBar) {
          progressBar.style.background = '#E57200'; // Reset to orange on error
        }
        
        resetProgress(stepId);
        
        // Hide server status warning if it exists
        const warning = document.getElementById('serverStatusWarning');
        if (warning) {
          warning.style.display = 'block';
        }
      }
    }

    // Step 1: File upload detection and auto-trigger Step 2
    document.getElementById('file-step1')?.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const fileName = e.target.files[0].name;
        if (fileName.includes('01') && (fileName.includes('products') || fileName.includes('product'))) {
          updateStatus(1, 'Uploading raw CSV...', 40);
          setTimeout(() => {
            markComplete(1, 'Step 1 complete ‚Äì raw file ready');
            updateStepStatus('1', 'complete', 'Complete');
            // Auto-trigger Step 2 cleaning
            setTimeout(() => {
              autoCleanProducts();
            }, 800);
          }, 1200);
        }
      }
    });

    // Step 2: Auto-clean products (triggered automatically after Step 1)
    async function autoCleanProducts() {
      // Always show UI elements for feedback
      const consoleOutput = document.getElementById('cleanConsoleOutput');
      const progressBar = document.querySelector('#progress-step2');
      const progressBarFill = document.querySelector('#progress-step2 .progress-bar');
      const statusText = document.getElementById('status-step2');
      
      // Show console and progress bar immediately
      if (consoleOutput) {
        consoleOutput.style.display = 'block';
        consoleOutput.textContent = 'üîÑ Checking local server status...\n';
      }
      if (progressBar) {
        progressBar.style.display = 'block';
      }
      if (progressBarFill) {
        progressBarFill.style.width = '10%';
        progressBarFill.style.background = '#E57200';
      }
      if (statusText) {
        statusText.textContent = 'üîÑ Checking server...';
        statusText.style.color = '#4a5568';
      }
      
      // Check server status first (skip alert in Electron mode or web deployment)
      const isRunning = await ensureLocalExecutorRunning();
      if (!isRunning && !isElectronMode) {
        // Check if running on Vercel/web (don't show blocking alert)
        const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                                window.location.hostname.includes('localhost') === false;
        
        if (isWebDeployment) {
          // On web deployment, show simple info message
          if (consoleOutput) {
            consoleOutput.textContent = '‚ÑπÔ∏è Web Mode: Steps 2-4 require Electron app for automation.\n';
            consoleOutput.textContent += '   Download Electron desktop app for full automation.\n';
          }
          if (progressBarFill) {
            progressBarFill.style.width = '0%';
            progressBarFill.style.background = '#e2e8f0';
          }
          if (statusText) {
            statusText.textContent = '‚è∏Ô∏è Step 2 requires local server (not available on web)';
            statusText.style.color = '#667eea';
          }
          // Show instructions box
          const instructionsBox = document.getElementById('localServerInstructions');
          if (instructionsBox) {
            instructionsBox.style.display = 'block';
          }
          return;
        }
        
        // Local browser mode: show warning and instructions
        if (consoleOutput) {
          consoleOutput.textContent = '‚ö†Ô∏è Local Server Not Running\n';
          consoleOutput.textContent += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
          consoleOutput.textContent += 'To run Step 2 automatically:\n';
          consoleOutput.textContent += '   1. Open your terminal in the project folder\n';
          consoleOutput.textContent += '   2. Run: npm run start-local\n';
          consoleOutput.textContent += '   3. Wait for: "‚ö° Local executor running at http://localhost:8000"\n';
          consoleOutput.textContent += '   4. Refresh this page\n';
          consoleOutput.textContent += '   5. Upload the file again\n';
          consoleOutput.textContent += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
        }
        if (progressBarFill) {
          progressBarFill.style.width = '0%';
          progressBarFill.style.background = '#ffc107';
        }
        if (statusText) {
          statusText.textContent = '‚ö†Ô∏è Local server required - run "npm run start-local" first';
          statusText.style.color = '#856404';
        }
        // Show instructions box
        const instructionsBox = document.getElementById('localServerInstructions');
        if (instructionsBox) {
          instructionsBox.style.display = 'block';
        }
        
        // Only show alert in local browser mode (not on web)
        if (!isWebDeployment) {
          alert('Local server is not running. Please run "npm run start-local" in your terminal first.');
        }
        return;
      }
      
      // Hide server warning if visible
      const warning = document.getElementById('serverStatusWarning');
      if (warning) warning.style.display = 'none';
      
      // Server is running - proceed with task
      await runLocalTask('clean', 2, 'üßπ Cleaning product data...', () => {
        const now = new Date();
        const dateStr = now.toLocaleDateString('en-GB', {day: '2-digit', month: 'short', year: 'numeric'}).replace(' ', '-');
        const timeStr = now.toLocaleTimeString('en-GB', {hour: '2-digit', minute: '2-digit'});
        if (consoleOutput) {
          consoleOutput.textContent += `\nüïì Cleaned on ${dateStr} @ ${timeStr}\n`;
          consoleOutput.textContent += '\nüí° Next step: Proceed to Step 3a - Fetch Google Reviews\n';
        }
        
        // Auto-chain to Step 3a
        chainNextStep(runGoogleReviewsFetcher, 2000);
      });
    }

    // Step 2: File upload detection (legacy - for manual uploads)
    document.getElementById('file-step2')?.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const fileName = e.target.files[0].name;
        if (fileName.includes('02') || fileName.includes('products_cleaned')) {
          updateStatus(2, 'Uploading cleaned file...', 40);
          setTimeout(() => markComplete(2, 'Step 2 complete ‚Äì cleaned file ready'), 1200);
        }
      }
    });
    // Step 3a: Google Reviews Fetcher
    async function runGoogleReviewsFetcher() {
      // Check server status first (skip alert in Electron mode or web deployment)
      const isRunning = await ensureLocalExecutorRunning();
      if (!isRunning && !isElectronMode) {
        const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                                window.location.hostname.includes('localhost') === false;
        
        if (isWebDeployment) {
          const consoleOutput = document.getElementById('googleConsoleOutput');
          if (consoleOutput) {
            consoleOutput.style.display = 'block';
            consoleOutput.textContent = '‚ÑπÔ∏è Web Mode: Requires Electron app for automation.\n';
          }
          return;
        }
        
        alert('Local server is not running. Please run "npm run start-local" in your terminal first.');
        return;
      }
      
      await runLocalTask('fetch', '3a', 'üîÑ Fetching Google reviews...', () => {
        const consoleOutput = document.getElementById('googleConsoleOutput');
        if (consoleOutput) {
          const now = new Date();
          const dateStr = now.toLocaleDateString('en-GB', {day: '2-digit', month: 'short', year: 'numeric'}).replace(' ', '-');
          consoleOutput.textContent += `\nüìä Total reviews: Check file\n`;
          consoleOutput.textContent += `üìÖ Date: ${dateStr}\n`;
          consoleOutput.textContent += `üìÅ File: 03b ‚Äì google_reviews.csv\n`;
          consoleOutput.textContent += `üí° Next: Merge with Trustpilot reviews in Step 3b\n`;
        }
        
        // Auto-chain to Step 3b
        chainNextStep(runMergeReviews, 2000);
      });
    }

    // Step 3b: Merge Reviews
    async function runMergeReviews() {
      // Check server status first (skip alert in Electron mode or web deployment)
      const isRunning = await ensureLocalExecutorRunning();
      if (!isRunning && !isElectronMode) {
        const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                                window.location.hostname.includes('localhost') === false;
        
        if (isWebDeployment) {
          const consoleOutput = document.getElementById('mergeConsoleOutput');
          if (consoleOutput) {
            consoleOutput.style.display = 'block';
            consoleOutput.textContent = '‚ÑπÔ∏è Web Mode: Requires Electron app for automation.\n';
          }
          return;
        }
        
        alert('Local server is not running. Please run "npm run start-local" in your terminal first.');
        return;
      }
      
      await runLocalTask('merge', '3b', 'üîÑ Merging Trustpilot + Google reviews...', () => {
        const consoleOutput = document.getElementById('mergeConsoleOutput');
        if (consoleOutput) {
          consoleOutput.textContent += '\nüìä Merge Summary:\n';
          consoleOutput.textContent += '   - Trustpilot + Google reviews combined\n';
          consoleOutput.textContent += '   - Low ratings filtered out\n';
          consoleOutput.textContent += '   - Reviews mapped to products\n';
          consoleOutput.textContent += '   - Duplicates removed\n';
          consoleOutput.textContent += '\nüí° Next step: Proceed to Step 4 - Generate Product Schema\n';
        }
        
        // Auto-chain to Step 4
        chainNextStep(generateProductSchema, 2000);
      });
    }

    // Step 3: File upload detection (for Step 3c)
    document.getElementById('file-step3')?.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const fileName = e.target.files[0].name;
        // Also sync with hidden productCsvFile for backward compatibility
        const hiddenInput = document.getElementById('productCsvFile');
        if (hiddenInput) {
          const dataTransfer = new DataTransfer();
          dataTransfer.items.add(e.target.files[0]);
          hiddenInput.files = dataTransfer.files;
        }
        
        if (fileName.includes('03') || fileName.includes('products_with_review_data_final')) {
          updateStatus(3, 'Uploading merged dataset...', 40);
          setTimeout(() => markComplete(3, 'Step 3c complete ‚Äì merged dataset ready'), 1200);
        }
      }
    });

  </script>

</body>
</html>
