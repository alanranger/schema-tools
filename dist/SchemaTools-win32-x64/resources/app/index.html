<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unified Schema Generator v4.3 - Smart Enriched Schema Generator (Event ‚Üî Series Backlinking)</title>
  <!--
    CHANGELOG v4.3 Smart Enriched Schema Generator (Backlinks)
    ==========================================================
    
    Changes from v4.2:
    - Assigned stable @id to every Event and EventSeries
    - Added Event.superEvent ‚Üí EventSeries(@id)
    - Added EventSeries.subEvent ‚Üí [Event(@id)]
    - Extended Field Verification Summary + console debug for linkage
    - Kept v4.2 detection & enrichment intact; no UI changes
    
    CHANGELOG v4.2 Smart Enriched Schema Generator (EventSeries Optimization)
    =========================================================================
    
    Changes from v4.1:
    - Added detectEventSeries() for repeat workshop patterns
    - Groups multi-instance Bluebell & Batsford workshops into EventSeries
    - Adds eventSchedule + subjectOf ItemList linkage
    - Includes grouping summary in console + UI
    
    Changes from v4:
    - Added intelligent region + geo inference for workshops/lessons
    - Added full PostalAddress reconstruction with region map matching
    - Added availabilityStarts and itemCondition for Merchant Center
    - Added performer.sameAs LinkedIn/YouTube links
    - Added courseMode hybrid logic (InPerson/Online detection)
    - Added location verification summary with coverage stats
    - Added UI toggles for enrichment options (location enrichment, availabilityStarts)
    - Enhanced eventType and material fields for SEO context
    
    Changes from v3.5:
    - Enhanced address parsing with full PostalAddress structure (streetAddress, addressLocality, addressRegion, postalCode, addressCountry)
    - Added toggle options: Include Reviews, Include Performer, Group Repeating Events, Include Merchant Center Fields
    - localStorage persistence for toggle states
    - Enhanced organizer/provider blocks with full address and sameAs (Instagram, Facebook, LinkedIn)
    - Enhanced performer block with sameAs link
    - Enhanced offers with hasMerchantReturnPolicy (when merchant fields enabled)
    - Review injection: top 5 reviews trimmed to 300 chars (toggleable)
    - Event schedule grouping: detects repeating weekly events and creates EventSeries with eventSchedule
    - SEO metadata enhancers: potentialAction, isFamilyFriendly, learningResourceType, typicalAgeRange, courseMode, subjectOf
    - Enhanced keywords: combines tags + category + location + topic words
    - "about" field: auto-generated topic summary
    - identifier field: slug from URL
    - sameAs array: event URL + product URL
    - CSV type detection: auto-detects Lessons vs Workshops
    - Enhanced validation summary with statistics (events with reviews, performer, offers)
    - Merchant Center feed export (Phase 6): JSON feed download when toggle enabled
    - Timezone: scheduleTimezone set to "Europe/London" for eventSchedule
    - EventSeries type for superEvent (not Event)
    
    Technical improvements:
    - All processing remains client-side (no server/API calls)
    - Schema Suppressor v1.3 only in Product Schema tab (removed from Event Schema)
    - Empty/invalid fields are omitted (not emitted as empty strings)
    - Past events automatically skipped
    - Offers only included when price > 0
  -->
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      margin: 0;
    }
    .container {
      max-width: 95vw;
      width: 100%;
      margin: 0 auto;
      background: white;
      padding: 2.5rem;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.15);
      position: relative;
    }
    .version-badge {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 600;
      z-index: 10;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }
    .version-badge .version {
      display: block;
      font-size: 1rem;
    }
    .version-badge .date {
      display: block;
      font-size: 0.75rem;
      opacity: 0.9;
      margin-top: 0.25rem;
    }
    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
      color: #2d3748;
      padding-right: 150px;
      font-weight: 700;
    }
    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      border-bottom: 2px solid #e2e8f0;
    }
    .tab {
      padding: 0.875rem 1.75rem;
      background: #f7fafc;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      border-radius: 8px 8px 0 0;
      transition: all 0.3s ease;
      color: #4a5568;
      border-bottom: 3px solid transparent;
    }
    .tab:hover {
      background: #edf2f7;
      color: #2d3748;
    }
    .tab.active {
      background: white;
      color: #667eea;
      border-bottom-color: #667eea;
      font-weight: 600;
    }
    .tab-content {
      display: none !important;
      padding: 20px;
      border-top: none;
    }
    .tab-content.active {
      display: block !important;
    }
    .tab-content h2 {
      color: #2d3748;
      font-size: 1.75rem;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }
    .tab-content h3 {
      color: #4a5568;
      font-size: 1.25rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    .tab-content p {
      color: #4a5568;
      line-height: 1.7;
      margin-bottom: 1rem;
    }
    .tab-content ul {
      color: #4a5568;
      line-height: 1.8;
      margin-bottom: 1.5rem;
      padding-left: 1.5rem;
    }
    .tab-content li {
      margin-bottom: 0.5rem;
    }
    .tab-content code {
      background: #f7fafc;
      padding: 0.2rem 0.4rem;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #667eea;
    }
    .instructions {
      background: linear-gradient(135deg, #f6f8fb 0%, #edeff2 100%);
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 1.5rem;
      line-height: 1.7;
      border-left: 4px solid #667eea;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      color: #4a5568;
    }
    .instructions h2 {
      color: #2d3748;
      font-size: 1.75rem;
      margin-top: 0;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }
    .instructions h3 {
      color: #4a5568;
      font-size: 1.25rem;
      margin-top: 1.5rem;
      margin-bottom: 0.75rem;
      font-weight: 600;
    }
    .instructions p {
      color: #4a5568;
      margin-bottom: 1rem;
    }
    .instructions ul {
      color: #4a5568;
      margin-bottom: 1.5rem;
      padding-left: 1.5rem;
    }
    .instructions li {
      margin-bottom: 0.5rem;
    }
    .instructions strong {
      display: block;
      margin-bottom: 0.75rem;
      color: #2d3748;
      font-size: 1.1rem;
    }
    /* Ensure Tab Guide is hidden by default and only shows when active */
    #guideTab.tab-content {
      display: none !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
    }
    #guideTab.tab-content.active {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
    }
    #guideTab .instructions {
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
    }
    .instructions pre {
      background: #ffffff;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 0.9rem;
      border: 1px solid #e2e8f0;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
    }
    input[type="file"], select {
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      width: 100%;
      max-width: 400px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      transition: all 0.2s;
      background: white;
    }
    input[type="file"]:hover, select:hover {
      border-color: #667eea;
    }
    input[type="file"]:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    button {
      margin-top: 1rem;
      padding: 0.875rem 1.75rem;
      font-size: 1rem;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
    }
    button:active {
      transform: translateY(0);
    }
    button.secondary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      box-shadow: 0 4px 12px rgba(245, 87, 108, 0.3);
      margin-left: 0.5rem;
    }
    button.secondary:hover {
      box-shadow: 0 6px 16px rgba(245, 87, 108, 0.4);
    }
    textarea {
      width: 100%;
      height: 400px;
      margin-top: 1rem;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      padding: 1.25rem;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      transition: all 0.2s;
      background: #fafbfc;
      line-height: 1.6;
    }
    textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      background: white;
    }
    pre {
      background: #fafbfc;
      padding: 1.25rem;
      overflow-x: auto;
      border: 2px solid #e2e8f0;
      border-radius: 10px;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      line-height: 1.6;
    }
    #categoryFilterContainer {
      margin-top: 1rem;
    }
    .test-url-section {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 2px solid #e2e8f0;
    }
    .test-url-section input {
      width: 100%;
      max-width: 600px;
      padding: 0.75rem 1rem;
      margin-right: 0.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
      transition: all 0.2s;
    }
    .test-url-section input:hover {
      border-color: #667eea;
    }
    .test-url-section input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }
    .test-url-section .button-group {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .warning {
      color: #e53e3e;
      font-weight: 600;
    }
    label {
      display: block;
      margin-top: 1.5rem;
      font-weight: 600;
      color: #2d3748;
      font-size: 0.95rem;
    }
    h3 {
      color: #2d3748;
      font-weight: 600;
      margin-top: 2rem;
      margin-bottom: 0.5rem;
    }
    h4 {
      color: #4a5568;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .results-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1.5rem;
      background: white;
      border-radius: 8px;
      overflow: visible;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      table-layout: auto;
    }
    .results-table th {
      background: #f7fafc;
      padding: 1rem;
      text-align: left;
      font-weight: 600;
      color: #2d3748;
      border-bottom: 2px solid #e2e8f0;
      white-space: normal;
      line-height: 1.4;
      position: sticky;
      top: 0;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    .results-table thead {
      position: sticky;
      top: 0;
      z-index: 10;
      background: #fff;
    }
    .filter-row th {
      background: #f9fafb;
      padding: 0.5rem;
    }
    .filter-input {
      width: 100%;
      padding: 0.375rem 0.5rem;
      font-size: 0.875rem;
      border: 1px solid #e2e8f0;
      border-radius: 4px;
      background: #fff;
    }
    .filter-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .sortable-header {
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
    }
    .sortable-header:hover {
      color: #667eea;
    }
    .sort-indicator {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-left: 0.25rem;
    }
    .sort-indicator.sorted-asc::after {
      content: ' ‚Üë';
      color: #667eea;
    }
    .sort-indicator.sorted-desc::after {
      content: ' ‚Üì';
      color: #667eea;
    }
    .scrollable-container {
      max-height: calc(100vh - 400px);
      min-height: 600px;
      overflow-y: auto;
    }
    .results-table th:nth-child(1) { min-width: 250px; } /* Page URL */
    .results-table th:nth-child(2) { min-width: 200px; } /* Schema Type */
    .results-table th:nth-child(3) { min-width: 80px; max-width: 100px; width: 100px; } /* Status - narrower */
    .results-table th:nth-child(4) { min-width: 220px; } /* Missing Fields - wider */
    .results-table th:nth-child(5) { min-width: 220px; } /* Warnings - wider */
    .results-table th:nth-child(6) { min-width: 220px; } /* Info - wider */
    .results-table th:nth-child(7) { min-width: 140px; max-width: 160px; } /* Rich Results Status (external) */
    .results-table th:nth-child(8) { min-width: 140px; max-width: 160px; } /* Schema.org Status (external) */
    .results-table th:nth-child(9) { min-width: 200px; } /* Notes */
    .results-table th:nth-child(10) { min-width: 280px; } /* Actions */
    
    th:nth-child(4), td:nth-child(4) { background: #fff8f8; }    /* Missing */
    th:nth-child(5), td:nth-child(5) { background: #fffaf2; }    /* Warnings */
    th:nth-child(6), td:nth-child(6) { background: #f4fff7; }    /* Info */
    
    .missing-entry { color: #c00; font-weight: 500; margin: 0.25rem 0; }
    .warning-entry { 
      color: #b47f00; 
      font-weight: 500; 
      margin: 0.125rem 0; 
      font-size: 0.75rem;
      line-height: 1.3;
      max-height: 3rem;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .warning-entry:hover {
      max-height: none;
      overflow: visible;
      -webkit-line-clamp: unset;
    }
    .info-entry { color: #006b3b; font-weight: 500; margin: 0.25rem 0; }
    .status-badge.no-schema {
      background: #e2e8f0;
      color: #4a5568;
    }
    .status-select {
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      background: white;
      min-width: 120px;
    }
    .status-select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .notes-textarea {
      width: 100%;
      min-width: 180px;
      max-width: 220px;
      height: 3rem;
      min-height: 2.5rem;
      max-height: 4rem;
      padding: 0.375rem 0.5rem;
      font-size: 0.75rem;
      line-height: 1.3;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      font-family: inherit;
      resize: vertical;
      overflow-y: auto;
    }
    .notes-textarea:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
    }
    .save-btn {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      margin: 0.25rem 0;
      background: #48bb78;
      color: white;
    }
    .save-btn:hover {
      background: #38a169;
    }
    .save-btn:disabled {
      background: #a0aec0;
      cursor: not-allowed;
    }
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 1rem 1.5rem;
      background: #48bb78;
      color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10000;
      animation: slideIn 0.3s ease;
    }
    .toast.error {
      background: #e53e3e;
    }
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    .results-table td {
      padding: 0.75rem 1rem;
      vertical-align: top;
    }
    .results-table td:nth-child(1) { 
      white-space: normal; 
      word-break: break-all;
      min-width: 250px;
      max-width: 350px;
    } /* Page URL */
    .results-table td:nth-child(2) { 
      white-space: normal; 
      min-width: 200px;
      max-width: 300px;
    } /* Schema Type */
    .results-table td:nth-child(3) { 
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-width: 80px;
      max-width: 100px;
      width: 100px;
    } /* Status */
    .results-table td:nth-child(3) .status-explanation {
      display: none; /* Hide explanation text to prevent column expansion */
    }
    .results-table td:nth-child(4) { 
      white-space: normal; 
      min-width: 180px;
      max-width: 250px;
    } /* Missing Fields */
    .results-table td:nth-child(5) { 
      white-space: normal; 
      min-width: 150px;
      max-width: 200px;
      font-size: 0.875rem;
      padding: 0.5rem 0.75rem;
      vertical-align: top;
    } /* Warnings */
    .results-table td:nth-child(6) { 
      white-space: normal; 
      min-width: 180px;
      max-width: 250px;
    } /* Info */
    .results-table td.missing-fields {
      white-space: normal;
      min-width: 180px;
      max-width: 250px;
    }
    .results-table td:last-child {
      white-space: normal;
      min-width: 280px;
      width: auto;
    }
    .results-table td:last-child .enhance-btn,
    .results-table td:last-child .save-btn {
      display: inline-block;
      white-space: nowrap;
      margin: 0.25rem 0;
    }
    .results-table tr:hover {
      background: #f9fafb;
    }
    .status-valid {
      color: #38a169;
      font-weight: 600;
    }
    .status-invalid {
      color: #e53e3e;
      font-weight: 600;
    }
    .status-processing {
      color: #667eea;
      font-weight: 600;
    }
    .enhance-btn {
      padding: 0.5rem 1rem;
      font-size: 0.875rem;
      margin: 0.25rem 0;
    }
    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e2e8f0;
      border-radius: 4px;
      overflow: hidden;
      margin-top: 1rem;
    }
    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
    }
    .missing-fields {
      font-size: 0.875rem;
      color: #e53e3e;
    }
    .scrollable-container {
      max-height: calc(100vh - 400px);
      min-height: 600px;
      overflow-y: auto;
      margin-top: 1rem;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      background: #fafbfc;
    }
    .url-link {
      color: #667eea;
      text-decoration: none;
      word-break: break-all;
    }
    .url-link:hover {
      text-decoration: underline;
    }
    .status-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 12px;
      font-size: 0.875rem;
      font-weight: 600;
    }
    .status-badge.valid {
      background: #c6f6d5;
      color: #22543d;
    }
    .status-badge.issues {
      background: #feebc8;
      color: #744210;
    }
    .status-badge.error {
      background: #fed7d7;
      color: #742a2a;
    }
    .status-badge.no-schema {
      background: #e2e8f0;
      color: #4a5568;
    }
    .single-url-section {
      background: #f7fafc;
      padding: 1.5rem;
      border-radius: 10px;
      margin-bottom: 2rem;
      border: 2px solid #e2e8f0;
    }
    .single-url-section label {
      margin-top: 0;
      font-weight: 600;
      color: #2d3748;
    }
    .single-url-section input {
      width: 100%;
      max-width: 600px;
      padding: 0.75rem 1rem;
      margin-top: 0.5rem;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      font-size: 1rem;
    }
    .help-block {
      background: #f0f7ff;
      border-left: 4px solid #667eea;
      padding: 1rem 1.5rem;
      margin-top: 1.5rem;
      border-radius: 6px;
      cursor: pointer;
    }
    .help-block-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 0.5rem;
    }
    .help-block-content {
      display: none;
      margin-top: 1rem;
      color: #4a5568;
      line-height: 1.7;
    }
    .help-block-content.active {
      display: block;
    }
    .help-block-icon {
      transition: transform 0.3s ease;
    }
    .help-block.expanded .help-block-icon {
      transform: rotate(180deg);
    }
    .batch-section {
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 2px solid #e2e8f0;
    }
    .progress-wrap {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .progress {
      width: 160px;
      height: 8px;
      background: #eee;
      border-radius: 999px;
      overflow: hidden;
    }
    .progress > span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #7c4dff, #4fc3f7);
      transition: width 0.25s ease;
    }
    .progress-label {
      font-size: 0.85rem;
      color: #555;
      min-width: 72px;
    }
    
    /* --- Row Progress Bars --- */
    .progress {
      position: relative;
      width: 100%;
      height: 6px;
      background: #f0f0f0;
      border-radius: 3px;
      overflow: hidden;
      margin-top: 4px;
      display: block;
    }
    
    .progress-inner {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #00b67a, #e57200);
      border-radius: 3px;
      transition: width 0.3s ease;
      max-height: 6px;
    }
    
    /* === Status Badge Styling === */
    .chip-queued {
      background: linear-gradient(90deg, #cfd9df 0%, #e2ebf0 100%);
      color: #555;
      border-radius: 8px;
      padding: 4px 10px;
      font-size: 13px;
      font-weight: 600;
      display: inline-block;
    }
    
    .chip-fetching {
      background: linear-gradient(90deg, #ffe259 0%, #ffa751 100%);
      color: #333;
      border-radius: 8px;
      padding: 4px 10px;
      font-size: 13px;
      font-weight: 600;
      display: inline-block;
    }
    
    .chip-valid {
      background: #27AE60;
      color: white;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    .chip-valid:hover {
      background: #229954;
    }
    
    .chip-critical {
      background: #E74C3C;
      color: white;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    .chip-critical:hover {
      background: #C0392B;
    }
    
    .status-badge.no-schema {
      background: linear-gradient(90deg, #e0eafc 0%, #cfdef3 100%);
      color: #333;
      border-radius: 6px;
      padding: 0.2rem 0.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
    }
    
    /* Issues Modal */
    .issues-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(20, 20, 33, 0.45);
      align-items: center;
      justify-content: center;
      z-index: 9999;
      border: none;
      padding: 0;
    }
    .issues-backdrop::backdrop {
      background: rgba(20, 20, 33, 0.45);
    }
    .issues-modal {
      width: min(760px, 94vw);
      max-height: 80vh;
      overflow: auto;
      background: #fff;
      border-radius: 14px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
      padding: 1.25rem 1.5rem;
    }
    .issues-modal h3 {
      margin: 0.2rem 0 0.8rem 0;
      font-size: 1.15rem;
    }
    .issues-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: #1a202c;
      margin: -1.25rem -1.5rem 1rem -1.5rem;
      border-radius: 14px 14px 0 0;
    }
    .issues-modal-header h3 {
      color: #fff;
      margin: 0;
    }
    .issues-close-x {
      background: #fff;
      border: 2px solid #fff;
      font-size: 1.5rem;
      color: #1a202c;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      border-radius: 6px;
      transition: all 0.2s;
      font-weight: bold;
    }
    .issues-close-x:hover {
      background-color: #ef4444;
      color: #fff;
      border-color: #ef4444;
    }
    .issues-close-x:active {
      background-color: #dc2626;
    }
    .issues-meta {
      font-size: 0.9rem;
      color: #555;
      margin: 0.5rem 0 1rem;
    }
    .issues-list {
      margin: 0.25rem 0 0.75rem 1rem;
    }
    .issues-list li {
      margin: 0.2rem 0;
    }
    .issues-json {
      background: #000000 !important;
      color: #ffffff !important;
      border-radius: 10px;
      padding: 0.75rem;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.82rem;
    }
    .gen-enhanced-modal {
      background: #1e293b;
      color: #e2e8f0;
    }
    .gen-enhanced-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: #0f172a;
      margin: -1.25rem -1.5rem 1rem -1.5rem;
      border-radius: 14px 14px 0 0;
      border-bottom: 2px solid #334155;
    }
    .gen-enhanced-header h3 {
      color: #fff;
      margin: 0;
      font-size: 1.15rem;
      font-weight: 600;
    }
    .gen-enhanced-actions {
      display: flex;
      gap: 0.75rem;
      justify-content: flex-end;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #334155;
    }
    .gen-copy-btn {
      background: #3b82f6;
      color: #fff;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gen-copy-btn:hover {
      background: #2563eb;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
    .gen-close-btn {
      background: #64748b;
      color: #fff;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .gen-close-btn:hover {
      background: #475569;
      box-shadow: 0 4px 12px rgba(100, 116, 139, 0.4);
    }
    .gen-enhanced-modal .issues-meta {
      color: #94a3b8;
    }
    .severity-badge {
      display: inline-flex;
      align-items: center;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 600;
      color: white;
    }
    .severity-badge.passed {
      background-color: #10b981;
    }
    .severity-badge.warning {
      background-color: #f59e0b;
    }
    .severity-badge.critical {
      background-color: #ef4444;
    }
    .summary-card {
      padding: 1rem;
      background: #f3f4f6;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .summary-card pre {
      white-space: pre-wrap;
      font-size: 0.875rem;
      color: #374151;
      margin: 0;
      font-family: inherit;
    }
    .recommended-fix-card {
      padding: 1rem;
      background: #fffbeb;
      border: 1px solid #fbbf24;
      border-radius: 8px;
      margin: 1rem 0;
    }
    .recommended-fix-card h4 {
      font-size: 1rem;
      font-weight: 600;
      color: #92400e;
      margin: 0 0 0.5rem 0;
    }
    .recommended-fix-card p {
      font-size: 0.875rem;
      color: #374151;
      margin: 0 0 0.75rem 0;
    }
    .recommended-fix-textarea {
      width: 100% !important;
      height: 18rem !important;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
      font-size: 0.75rem !important;
      background: #000000 !important;
      color: #ffffff !important;
      padding: 0.75rem !important;
      border-radius: 6px !important;
      border: 1px solid #333 !important;
      resize: vertical;
      overflow: auto;
    }
    .copy-schema-btn {
      margin-top: 0.75rem;
      background: #d97706;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.875rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .copy-schema-btn:hover {
      background: #b45309;
    }
    .system-node {
      opacity: 0.5;
      filter: grayscale(0.6);
    }
    .system-node td:first-child::after {
      content: " (Squarespace auto-schema)";
      font-style: italic;
      color: #888;
      margin-left: 0.5rem;
    }
    .help-link {
      font-size: 0.75rem;
      color: #6b7280;
      margin-top: 0.75rem;
    }
    .help-link a {
      color: #2563eb;
      text-decoration: underline;
    }
    .help-link a:hover {
      color: #1d4ed8;
    }
    .chip-issues {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #F5B041;
      color: black;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      border: 1px solid #E67E22;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-issues:hover {
      background: #E67E22;
    }
    .chip-issues::after {
      content: " (non-critical)";
      font-size: 0.8em;
      opacity: 0.7;
    }
    .duplicate-warning {
      color: #b47f00;
      font-weight: 500;
    }
    .chip-critical {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #E74C3C;
      color: white;
      border: 1px solid #C0392B;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-critical:hover {
      background: #C0392B;
    }
    .chip-passed {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-passed:hover {
      background: #229954;
    }
    .status-explanation {
      display: inline-block;
      margin-left: 0.75rem;
      font-size: 0.875rem;
      color: #6b7280;
      font-style: italic;
      vertical-align: middle;
    }
    #statusCell_0, #statusCell_1, #statusCell_2, [id^="statusCell_"] {
      white-space: normal;
      line-height: 1.5;
    }
    .status-legend {
      display: flex;
      gap: 1rem;
      margin-bottom: 0.75rem;
      padding: 0.75rem;
      background: #2d3748;
      border-radius: 8px;
      font-size: 0.875rem;
      flex-wrap: wrap;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .status-legend-item {
      color: #fff;
    }
    .status-legend-item span:not(.chip-sample):not(.info-entry) {
      color: #e2e8f0;
    }
    .status-legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .status-legend-item .chip-sample {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.5rem;
      border-radius: 8px;
      font-size: 0.75rem;
      font-weight: 600;
    }
    .chip-sample.passed {
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
    }
    .chip-sample.issues {
      background: #F5B041;
      color: black;
      border: 1px solid #E67E22;
    }
    .chip-sample.critical {
      background: #E74C3C;
      color: white;
      border: 1px solid #C0392B;
    }
    .chip-sample.info {
      background: #5DADE2;
      color: white;
      border: 1px solid #3498DB;
    }
    .chip-info {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #5DADE2;
      color: white;
      border: 1px solid #3498DB;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-info:hover {
      background: #3498DB;
    }
    .chip-ok {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      background: #27AE60;
      color: white;
      border: 1px solid #229954;
      border-radius: 8px;
      padding: 0.2rem 0.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
    }
    .chip-ok:hover {
      background: #229954;
    }
    .badge {
      display: inline-block;
      padding: 0.15rem 0.4rem;
      border-radius: 0.5rem;
      background: #fff3cd;
      color: #7a5b00;
      border: 1px solid #ffe08a;
      margin: 0.1rem 0.15rem;
      font-size: 0.8rem;
    }
    /* Debug Console Styles */
    .debug-console {
      margin-top: 1.5rem;
      border: 1px solid #cbd5e0;
      border-radius: 8px;
      background: #f7fafc;
      max-height: 400px;
      overflow-y: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
    }
    .debug-console-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      background: #edf2f7;
      border-bottom: 1px solid #cbd5e0;
      border-radius: 8px 8px 0 0;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .debug-console-actions {
      display: flex;
      gap: 0.5rem;
    }
    .debug-console-content {
      padding: 1rem;
      line-height: 1.6;
      color: #2d3748;
    }
    .debug-log-entry {
      margin: 0.25rem 0;
      padding: 0.25rem 0.5rem;
      border-left: 3px solid #4299e1;
      background: #fff;
    }
    .debug-log-entry.error {
      border-left-color: #f56565;
      background: #fed7d7;
    }
    .debug-log-entry.warn {
      border-left-color: #ed8936;
      background: #feebc8;
    }
    .debug-log-entry.success {
      border-left-color: #48bb78;
      background: #c6f6d5;
    }
    .debug-log-time {
      color: #718096;
      font-size: 0.75rem;
      margin-right: 0.5rem;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Modal styling */
    #detail-modal { position: fixed; inset: 0; z-index: 9999; }
    #detail-modal .modal-backdrop { position:absolute; inset:0; background:rgba(0,0,0,.45); }
    #detail-modal .modal { position: absolute; top: 8%; left: 50%; transform: translateX(-50%); width: min(1100px, 92vw); background:#fff; border-radius:12px; box-shadow: 0 10px 40px rgba(0,0,0,.2); }
    #detail-modal .modal-head { display:flex; align-items:center; justify-content:space-between; padding:14px 18px; border-bottom:1px solid #eee; }
    #detail-modal .modal-body { padding:18px; max-height:70vh; overflow:auto; }
    #detail-modal #modal-close { background:none; border:none; font-size:1.5rem; cursor:pointer; padding:0; width:30px; height:30px; display:flex; align-items:center; justify-content:center; }
    #detail-modal #modal-close:hover { color:#f00; }
    .code-card { border:1px solid #eee; border-radius:10px; margin-bottom:12px; }
    .code-card-head { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; background:#fafafa; border-bottom:1px solid #eee; }
    .code-card pre { margin:0; padding:12px; overflow:auto; background:#000; color:#fff; }
    .code-card pre code { color:#fff; }
    .code-card .copy-btn { background:#2563eb; color:#fff; border:none; padding:0.375rem 0.75rem; border-radius:4px; cursor:pointer; font-size:0.875rem; }
    .code-card .copy-btn:hover { background:#1d4ed8; }
    .grid.grid-two { display:grid; grid-template-columns: 1fr 1fr; gap:16px; }
    @media (max-width: 768px) {
      .grid.grid-two { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="version-badge">
    <span class="version">v4.3</span>
    <span class="date">Smart Enriched Schema Generator ‚Äî Event ‚Üî Series Backlinking</span>
  </div>
  <h1>Unified Schema Generator - Events & Products</h1>

  <div class="tabs">
    <button class="tab active" onclick="switchTab('event')">Event Schema</button>
    <button class="tab" onclick="switchTab('product')">Product Schema</button>
    <button class="tab" onclick="switchTab('validator')">Schema Validator</button>
    <button class="tab" onclick="switchTab('guide')">üß† Tab Guide</button>
  </div>

  <!-- Event Tab Content -->
  <div id="eventTab" class="tab-content active">
    <div class="instructions">
      <strong>üìÖ Event Schema Generator v4 - Smart Enriched Schema Generator</strong><br>
      1. Upload your event CSV file (exported from Squarespace Events).<br>
      2. Ensure it includes these fields: <code>Event_Title</code>, <code>Start_Date</code>, <code>Start_Time</code>, <code>End_Date</code>, <code>End_Time</code>, <code>Event_URL</code>, <code>Event_Image</code>, <code>Location_Business_Name</code>, <code>Location_Address</code>, <code>Location_City_State_ZIP</code>, <code>Excerpt</code>, <code>Category</code>, <code>Workflow_State</code>, <code>Tags</code>, <code>Price</code>, <code>Published_Date</code>.<br>
      3. Configure enrichment options below.<br>
      4. Select a category filter (or "All Categories") to generate schema for specific event types.<br>
      5. Click <b>Generate Event Schema</b> to create valid JSON-LD blocks.<br><br>
      
      ‚úÖ This tool works entirely offline in your browser.<br>
      ‚úÖ Only includes structured data compliant with Google Rich Results.<br>
      ‚úÖ Only published events with future start dates are included automatically.<br>
      ‚úÖ <strong>v4 Features:</strong> Enhanced address parsing, full organizer/provider blocks, SEO metadata, event scheduling, review enrichment, breadcrumbs, and comprehensive validation.<br>
      ‚úÖ Schema includes organizer, performer, location with parsed address, duration, aggregateRating, offers, and SEO enhancers.<br><br>

      <strong>üìÑ Data Workflow Summary:</strong><br>
      <pre>
Step 1: Export events from Squarespace ‚Üí events_export.csv
     ‚Üì
Step 2: Verify CSV contains all required fields
     ‚Üì
Step 3: Upload CSV and select category filter
     ‚Üì
Step 4: Generate JSON-LD schema blocks
     ‚Üì
Step 5: Paste schema into Squarespace event page (see instructions below)
      </pre>

      <strong>üìå Squarespace Instructions:</strong><br>
      ‚Ä¢ Open your event page in Squarespace.<br>
      ‚Ä¢ Navigate to <b>Page Settings ‚Üí Advanced ‚Üí Header Code Injection</b><br>
      ‚Ä¢ OR insert a <b>Code Block</b> onto the event page.<br>
      ‚Ä¢ <b>Paste the entire generated schema block</b> (includes both ItemList and Event schemas).<br>
      ‚Ä¢ The schema will include all events matching your selected category filter.<br>
      ‚Ä¢ <span class="warning">‚ö†Ô∏è Best Practice:</span> Paste the schema on a main events listing page (e.g., "All Workshops" or category archive page) rather than individual event pages.<br>
      ‚Ä¢ For individual event pages, you can generate schema for a single category containing just that event.<br>
      ‚Ä¢ Always validate your schema after deployment using the test URL tools below.
    </div>

    <label for="eventCsvFile">Upload Event CSV File:</label>
    <input type="file" id="eventCsvFile" accept=".csv" aria-label="Event CSV file upload">
    
    <div style="margin-top: 1rem; padding: 1rem; background: #fff3cd; border-radius: 8px; border: 1px solid #ffc107;">
      <h4 style="margin-top: 0; color: #856404;">üìé Optional Enrichment Files:</h4>
      <label for="reviewsCsvFile" style="display: block; margin-bottom: 0.5rem;">
        Reviews CSV (03 ‚Äì combined_product_reviews.csv):
        <input type="file" id="reviewsCsvFile" accept=".csv" style="margin-left: 0.5rem;">
      </label>
      <label for="mappingsCsvFile" style="display: block;">
        Event-Product Mappings CSV (event-product-mappings-*.csv):
        <input type="file" id="mappingsCsvFile" accept=".csv" style="margin-left: 0.5rem;">
      </label>
      <p style="margin: 0.5rem 0 0 0; font-size: 0.875rem; color: #856404;">
        ‚ÑπÔ∏è These files are required for review enrichment and product mapping. Upload them to enable reviews and offers.
      </p>
    </div>
    
    <div id="eventOptionsContainer" style="display:none; margin-top: 1rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
      <h4 style="margin-top: 0;">‚öôÔ∏è Enrichment Options:</h4>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="includeReviews" checked style="margin-right: 0.5rem;">
        <span>Include Reviews (from product mappings)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="includePerformer" checked style="margin-right: 0.5rem;">
        <span>Include Performer (Alan Ranger)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="groupRepeatingEvents" style="margin-right: 0.5rem;">
        <span>Group Repeating Events (EventSchedule)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="includeMerchantFields" style="margin-right: 0.5rem;">
        <span>Include Merchant Center Fields (Phase 6)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="toggleLocationEnrichment" checked style="margin-right: 0.5rem;">
        <span>Auto-Enrich Locations (Geo + Region Fallbacks)</span>
      </label>
      <label style="display: flex; align-items: center; margin-bottom: 0.5rem;">
        <input type="checkbox" id="toggleAvailabilityStarts" style="margin-right: 0.5rem;">
        <span>Include AvailabilityStarts (Merchant+)</span>
      </label>
    </div>
    
    <div id="eventCategoryFilterContainer" style="margin-top: 1rem;">
      <p>Select category to generate schema for:</p>
      <select id="eventCategoryFilter" aria-label="Event category filter" style="display:none;"></select>
      <button onclick="generateEventSchema()" style="background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500;">Generate Event Schema</button>
    </div>

    <h3>Generated JSON-LD Schema:</h3>
    <div id="eventOutputContainer" style="position: relative; z-index: 1; margin-bottom: 1rem;">
      <button id="copySchemaButtonTop" onclick="copyToClipboard('eventOutput')" style="margin-bottom: 0.75rem; background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; position: relative; z-index: 10; display: inline-block; visibility: visible; opacity: 1;">üìã Copy Schema to Clipboard</button>
      <pre id="eventOutput" style="position: relative; z-index: 1; max-height: 600px; overflow-y: auto; margin-bottom: 0.75rem;"></pre>
      <button id="copySchemaButton" onclick="copyToClipboard('eventOutput')" style="margin-top: 0; background: #667eea; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; position: relative; z-index: 10; display: inline-block; visibility: visible; opacity: 1;">üìã Copy Schema to Clipboard</button>
    </div>
    
    <div id="debugLogContainer" style="display:none; margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6; max-height: 400px; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
        <h4 style="margin: 0;">üîç Debug Log:</h4>
        <button onclick="copyDebugLog(this)" style="padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
          üìã Copy Debug Log
        </button>
      </div>
      <pre id="debugLog" style="margin: 0; font-size: 0.875rem; white-space: pre-wrap; word-wrap: break-word;"></pre>
    </div>
    
    <div id="summaryPanel" style="display:none; margin-top: 1rem; padding: 1rem; background: #e8f4f8; border-radius: 8px; border: 1px solid #3182ce;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
        <h4 style="margin: 0; color: #2c5282;">üìä Schema Generation Summary</h4>
        <button onclick="showFieldVerificationModal()" style="padding: 0.5rem 1rem; background: #48bb78; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem;">
          üîç View Field Verification
        </button>
      </div>
      <div id="summaryContent" style="font-size: 0.875rem; line-height: 1.6;"></div>
    </div>
    
    <div id="schemaExportContainer" style="display:none; margin-top: 1rem; padding: 1rem; background: #f0f9ff; border-radius: 8px; border: 1px solid #0ea5e9;">
      <h4 style="margin-top: 0; color: #0369a1;">üì¶ Schema Export & Squarespace Integration</h4>
      <div id="schemaExportContent" style="margin-top: 0.75rem;"></div>
      
      <!-- GitHub Hosting Verification Panel -->
      <div id="githubHostingVerification" style="margin-top: 1.5rem; padding: 1rem; background: white; border-radius: 6px; border: 1px solid #e5e7eb;">
        <h4 style="margin: 0 0 0.75rem 0; font-size: 1rem; font-weight: 600; color: #1f2937;">üîç GitHub Schema Hosting Verification</h4>
        <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: #f0f9ff; border-radius: 4px; border-left: 3px solid #0369a1;">
          <p style="margin: 0 0 0.5rem 0; font-size: 0.875rem; color: #1e40af; font-weight: 500;"><strong>üìÅ Save Location:</strong></p>
          <p style="margin: 0; font-size: 0.8rem; color: #1e3a8a; font-family: monospace; word-break: break-all;">
            G:\Dropbox\alan ranger photography\Website Code\Schema Tools\alanranger-schema
          </p>
          <p style="margin: 0.5rem 0 0 0; font-size: 0.8rem; color: #475569;">
            Save <code style="background: #e0e7ff; padding: 2px 4px; border-radius: 2px;">lessons-schema.json</code> and <code style="background: #e0e7ff; padding: 2px 4px; border-radius: 2px;">workshops-schema.json</code> to this folder for GitHub Pages hosting.
          </p>
        </div>
        <button id="pingGitHub" style="padding: 0.5rem 1rem; background: #0369a1; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500; margin-right: 0.5rem;">
          üöÄ Ping GitHub
        </button>
        <button id="exportToGitHubFolderBtn" onclick="exportUnminifiedToGitHubFolder()" style="padding: 0.5rem 1rem; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.875rem; font-weight: 500;">
          üì• Export Unminified JSON to GitHub Folder
        </button>
        <div id="pingResults" style="margin-top: 10px; font-family: monospace; font-size: 0.875rem; color: #374151; line-height: 1.6;"></div>
        <div id="schemaLinks" style="margin-top: 15px; display: none;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #1f2937; font-size: 0.875rem;"><strong>Validation Links:</strong></p>
          <ul style="margin: 0; padding-left: 1.5rem; color: #374151; font-size: 0.875rem;">
            <li style="margin-bottom: 0.25rem;"><a href="https://validator.schema.org/#url=https://schema.alanranger.com/lessons-schema.json" target="_blank" style="color: #0369a1; text-decoration: none;">Lessons Schema Validator</a></li>
            <li style="margin-bottom: 0.25rem;"><a href="https://validator.schema.org/#url=https://schema.alanranger.com/workshops-schema.json" target="_blank" style="color: #0369a1; text-decoration: none;">Workshops Schema Validator</a></li>
            <li style="margin-bottom: 0.25rem;"><a href="https://search.google.com/test/rich-results?url=https://www.alanranger.com/beginners-photography-lessons" target="_blank" style="color: #0369a1; text-decoration: none;">Google Rich Results ‚Äì Lessons</a></li>
            <li style="margin-bottom: 0.25rem;"><a href="https://search.google.com/test/rich-results?url=https://www.alanranger.com/photographic-workshops-near-me" target="_blank" style="color: #0369a1; text-decoration: none;">Google Rich Results ‚Äì Workshops</a></li>
          </ul>
        </div>
      </div>
      
      <div style="margin-top: 1rem;">
        <button id="exportSchemaJsonBtn" onclick="exportSchemaToJson()" style="padding: 0.75rem 1.5rem; background: #0ea5e9; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; margin-right: 0.5rem;">
          üì• Export JSON File
        </button>
        <button id="copySquarespaceScriptBtn" onclick="copySquarespaceScript()" style="padding: 0.75rem 1.5rem; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
          üìã Copy Squarespace Script src Tag
        </button>
      </div>
    </div>

    <div style="margin-top: 1rem; padding: 0.75rem; background: #f9fafb; border-radius: 6px; font-size: 0.9em; color: #6b7280;">
      Schema auto-hosted via <a href="https://github.com/alanranger/alanranger-schema" target="_blank" style="color: #0369a1;">GitHub Pages</a> ‚Ä¢ Custom domain: <b>schema.alanranger.com</b> ‚Ä¢ Auto-sync: <b>Enabled</b>
    </div>

    <div id="merchantFeedContainer" style="display:none; margin-top: 1rem;">
      <button id="exportMerchantFeedBtn" onclick="exportMerchantFeed()" style="padding: 0.5rem 1rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">
        üì• Export Merchant Center Feed (.json)
      </button>
    </div>

    <div class="test-url-section">
      <h4>Test Generated Schema:</h4>
      <p>Paste a URL containing your schema to validate it:</p>
      <label for="eventTestUrl">Test URL:</label>
      <input type="text" id="eventTestUrl" placeholder="https://example.com/page-with-schema" aria-label="Event test URL">
      <div class="button-group">
        <button onclick="testSchemaOrg('eventTestUrl')">Test on Schema.org Validator</button>
        <button onclick="testGoogleRichResults('eventTestUrl')" class="secondary">Test on Google Rich Results</button>
      </div>
    </div>
  </div>

  <!-- Field Verification Modal -->
  <div id="fieldVerificationModal" style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); overflow-y: auto;" onclick="if(event.target.id === 'fieldVerificationModal') closeFieldVerificationModal();">
    <div style="background-color: white; margin: 2% auto; padding: 2rem; border-radius: 12px; width: 90%; max-width: 900px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); position: relative;" onclick="event.stopPropagation();">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; border-bottom: 2px solid #e2e8f0; padding-bottom: 1rem;">
        <h2 style="margin: 0; color: #2d3748;">üîç Field Verification Summary</h2>
        <button onclick="closeFieldVerificationModal()" style="background: #f56565; color: white; border: none; border-radius: 6px; padding: 0.5rem 1rem; cursor: pointer; font-size: 1rem;">‚úï Close</button>
      </div>
      <div id="fieldVerificationModalContent"></div>
    </div>
  </div>

  <!-- Product Tab Content -->
  <div id="productTab" class="tab-content">
    <div class="instructions">
      <strong>üõ† Product Schema Generator</strong><br><br>
      
      ‚úÖ This tool works entirely offline in your browser.<br>
      ‚úÖ Only includes structured data compliant with Google Rich Results and Merchant Center policies.<br>
      ‚úÖ Automatically includes Schema Suppressor v1.3 to prevent duplicate Squarespace Product schemas.<br><br>

      <!-- Desktop App Launch Button (Web Mode Only) -->
      <div id="desktop-launch" style="display:none; margin-bottom:1rem; padding:1.5rem; border:2px dashed #ccc; border-radius:12px; background:#fffbe6;">
        <h3 style="margin-bottom:0.5rem; color:#2d3748; text-align:center;">üíª Want Automated Steps?</h3>
        <p style="margin-bottom:1rem; color:#4a5568; text-align:center;">This web version runs in read-only mode. The desktop app can automatically chain steps 2‚Üí3a‚Üí3b‚Üí4 after you upload a file.</p>
        
        <div style="background:#f7fafc; padding:1rem; border-radius:8px; margin-bottom:1rem; border:1px solid #e2e8f0;">
          <p style="margin:0 0 0.75rem 0; font-weight:600; color:#2d3748;">üìã How to use the desktop app:</p>
          <ol style="margin:0; padding-left:1.5rem; color:#4a5568; line-height:1.8;">
            <li>Open your project folder in a terminal</li>
            <li>Run: <code style="background:#edf2f7; padding:2px 6px; border-radius:4px; font-family:monospace;">npm run build:desktop</code></li>
            <li>Navigate to: <code style="background:#edf2f7; padding:2px 6px; border-radius:4px; font-family:monospace;" id="exePathDisplay">%LOCALAPPDATA%\SchemaTools\SchemaTools-win32-x64\SchemaTools.exe</code></li>
            <li>Double-click <strong>SchemaTools.exe</strong> to launch</li>
          </ol>
          <p style="margin:0.75rem 0 0 0; padding:0.75rem; background:#e8f4f8; border-radius:6px; font-size:0.875rem; color:#2c5282; border-left:3px solid #3182ce;">
            <strong>‚ÑπÔ∏è Note:</strong> The built app (.exe) is saved to <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">%LOCALAPPDATA%</code> to avoid Dropbox file locks. 
            <strong>All input/output files remain in your Dropbox project folder</strong> (<code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">inputs-files/</code> and <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">outputs/</code>).
          </p>
        </div>
        
        <div style="text-align:center;">
          <button id="copyPathBtn" style="padding:0.75rem 1.5rem; font-size:1rem; border:none; border-radius:8px; background:#0078D4; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-right:0.5rem; margin-bottom:0.5rem;" onmouseover="this.style.background='#005a9e'" onmouseout="this.style.background='#0078D4'">
            üìã Copy Build Command
          </button>
          <button id="openFolderBtn" style="padding:0.75rem 1.5rem; font-size:1rem; border:none; border-radius:8px; background:#27AE60; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-right:0.5rem; margin-bottom:0.5rem;" onmouseover="this.style.background='#229954'" onmouseout="this.style.background='#27AE60'">
            üìÅ Open PowerShell Here
          </button>
          <button id="showInstructionsBtn" style="padding:0.75rem 1.5rem; font-size:1rem; border:1px solid #0078D4; border-radius:8px; background:white; color:#0078D4; cursor:pointer; font-weight:600; transition:background 0.2s; margin-right:0.5rem; margin-bottom:0.5rem;" onmouseover="this.style.background='#f0f7ff'" onmouseout="this.style.background='white'">
            ‚ÑπÔ∏è Show Full Path
          </button>
          <button id="openExeBtnWeb" style="padding:0.75rem 1.5rem; font-size:1rem; border:none; border-radius:8px; background:#9b59b6; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-bottom:0.5rem;" onmouseover="this.style.background='#8e44ad'" onmouseout="this.style.background='#9b59b6'">
            ‚ñ∂Ô∏è Open Electron App (if built)
          </button>
        </div>
      </div>

      <!-- Build Desktop App Section (Electron Mode Only) -->
      <div id="build-desktop-section" style="display:none; margin-bottom:1rem; padding:1.5rem; border:2px solid #27AE60; border-radius:12px; background:#f0fdf4;">
        <h3 style="margin-bottom:0.5rem; color:#2d3748; text-align:center;">üî® Build Desktop App</h3>
        <p style="margin-bottom:1rem; color:#4a5568; text-align:center;">Build the Windows .exe file directly from this app.</p>
        
        <div style="text-align:center; margin-bottom:1rem;">
          <button id="buildDesktopBtn" style="padding:1rem 2rem; font-size:1.2rem; border:none; border-radius:8px; background:#27AE60; color:white; cursor:pointer; font-weight:600; transition:background 0.2s;" onmouseover="this.style.background='#229954'" onmouseout="this.style.background='#27AE60'">
            üî® Build Desktop App (npm run build:desktop)
          </button>
          <button id="openExeBtn" style="display:none; padding:1rem 2rem; font-size:1.2rem; border:none; border-radius:8px; background:#0078D4; color:white; cursor:pointer; font-weight:600; transition:background 0.2s; margin-left:0.5rem;" onmouseover="this.style.background='#005a9e'" onmouseout="this.style.background='#0078D4'">
            ‚ñ∂Ô∏è Open Built App (SchemaTools.exe)
          </button>
        </div>
        
        <div id="buildOutput" style="display:none; margin-top:1rem; padding:1rem; background:#1e1e1e; color:#d4d4d4; border-radius:8px; font-family:'Courier New', monospace; font-size:0.75rem; max-height:300px; overflow-y:auto; white-space:pre-wrap;"></div>
      </div>

      <!-- ===================== COMBINED DEBUG LOG ===================== -->
      <div id="combined-debug-log-section" style="margin-top: 2rem; margin-bottom: 1.5rem; padding: 1.5rem; background: #1e1e1e; border: 2px solid #4a5568; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
          <h3 style="color: #d4d4d4; margin: 0; font-size: 1.25rem; font-weight: 600;">üìã Combined Debug Log (All Steps)</h3>
          <div>
            <button id="clearCombinedLogBtn" onclick="clearCombinedLog()" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: 1px solid #4a5568; border-radius: 6px; background: #2d3748; color: #d4d4d4; cursor: pointer; margin-right: 0.5rem; transition: background 0.2s;" onmouseover="this.style.background='#4a5568'" onmouseout="this.style.background='#2d3748'">
              üóëÔ∏è Clear Log
            </button>
            <button id="copyCombinedLogBtn" onclick="copyCombinedLog()" style="padding: 0.5rem 1rem; font-size: 0.875rem; border: none; border-radius: 6px; background: #667eea; color: white; cursor: pointer; font-weight: 600; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
              üìã Copy All Logs
            </button>
          </div>
        </div>
        <div id="combinedDebugLog" style="padding: 1rem; background: #0d1117; color: #d4d4d4; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 500px; overflow-y: auto; white-space: pre-wrap; border: 1px solid #30363d;">No logs yet. Step outputs will appear here as they run...</div>
      </div>

      <!-- ===================== STATUS DASHBOARD ===================== -->
      <div id="workflow-status-dashboard" style="margin-top: 1rem; margin-bottom: 1.5rem; padding: 1.5rem; background: #f5f5f5; border: 1px solid #e0e0e0; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
        <h3 style="color: #2d3748; margin: 0 0 1rem 0; font-size: 1.25rem; font-weight: 600;">üìä Workflow Status Dashboard</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem;">
          <div id="step-status-0" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.05); border-radius: 8px; text-align: center; color: #2d3748;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è≥</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 0</div>
            <div id="step-status-text-0" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Initializing</div>
          </div>
          <div id="step-status-1" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 1</div>
            <div id="step-status-text-1" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-2" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 2</div>
            <div id="step-status-text-2" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-3a" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 3a</div>
            <div id="step-status-text-3a" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-3b" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 3b</div>
            <div id="step-status-text-3b" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
          <div id="step-status-4" class="step-status-card" style="padding: 0.75rem; background: rgba(0,0,0,0.03); border-radius: 8px; text-align: center; color: #2d3748; opacity: 0.5;">
            <div style="font-size: 1.5rem; margin-bottom: 0.25rem;">‚è∏Ô∏è</div>
            <div style="font-size: 0.75rem; font-weight: 600;">Step 4</div>
            <div id="step-status-text-4" style="font-size: 0.65rem; margin-top: 0.25rem; opacity: 0.9;">Waiting</div>
          </div>
        </div>
      </div>

      <!-- ===================== PRODUCT SCHEMA WORKFLOW ===================== -->
      <section id="product-schema-workflow" style="display: flex; flex-direction: column; gap: 1.5rem; margin-top: 1.5rem;">

        <!-- STEP 0: Initialize Local Executor -->
        <div id="step0-init" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step0-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è≥</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">‚öôÔ∏è Step 0 ‚Äì Setup Check</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Checking your setup and unlocking the workflow. This happens automatically.
          </p>
          <div id="executorStatus" style="margin-top: 0.75rem; padding: 0.75rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; color: #856404; font-size: 0.875rem; font-weight: 500;">
            üîç Checking your setup...
          </div>
          <div id="executorActions" style="margin-top: 0.75rem; display: flex; gap: 0.75rem; flex-wrap: wrap;">
            <button id="startLocalBtn" style="display: none; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
              ‚ö° Start Local Server
            </button>
            <button id="copyCommandBtn" style="display: none; background: #718096; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#4a5568'" onmouseout="this.style.background='#718096'">
              üìã Copy CLI Command
            </button>
          </div>
          <pre id="executorConsole" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 150px; overflow-y: auto; white-space: pre-wrap;"></pre>
        </div>

        <!-- STEP 1 -->
        <div id="step1-container" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step1-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è∏Ô∏è</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">üßæ Step 1 ‚Äì Squarespace Product Export Setup</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What to do:</strong> Export your products from Squarespace ‚Üí <strong>Commerce ‚Üí Products ‚Üí Export CSV</strong>.<br>
            Then upload the CSV file below. <strong>After upload, Step 2 will start automatically.</strong>
          </p>
          <input type="file" id="file-step1" accept=".csv" style="margin-top: 0.75rem; display: block; font-size: 0.875rem; opacity: 0.5; cursor: not-allowed;" disabled />
          <p id="step1LockMessage" style="font-size: 0.75rem; color: #718096; margin-top: 0.5rem; font-style: italic;">
            ‚è≥ Step 0 is checking your setup... this will unlock automatically.
          </p>
          <div id="progress-step1" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step1" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
        </div>

        <!-- STEP 2 -->
        <div id="step2-container" style="border-radius: 12px; border: 2px solid #e2e8f0; padding: 1rem; background: #f7fafc; position: relative;">
          <div id="step2-badge" style="position: absolute; top: 1rem; right: 1rem; width: 32px; height: 32px; border-radius: 50%; background: #e2e8f0; display: flex; align-items: center; justify-content: center; font-size: 1.25rem;">‚è∏Ô∏è</div>
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0; padding-right: 2.5rem;">üßπ Step 2 ‚Äì Clean and Normalize CSV</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> This step formats your Squarespace export for schema generation.<br>
            <strong>When:</strong> Runs automatically after Step 1 upload completes.<br>
            <strong>You don't need to do anything</strong> - just wait for it to finish. Step 3a will start automatically next.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Triggered automatically after Step 1 upload</li>
            <li>Normalizes column names and trims invalid rows</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">02 ‚Äì products_cleaned.xlsx</code></li>
          </ul>
          <div id="step2WebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Web Mode:</strong> Steps 2-4 require Electron app or local execution.<br>
            <small>Download Electron desktop app for full automation.</small>
          </div>
          <div id="progress-step2" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step2" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="cleanConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3a: Fetch Google Reviews -->
        <div id="step3a-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì• Step 3a ‚Äì Fetch Google Reviews</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> Connects to your Google My Business account and retrieves all customer reviews.<br>
            <strong>When:</strong> Runs automatically after Step 2 completes.<br>
            <strong>First time:</strong> A browser window will open for OAuth authorization - just approve it.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires valid OAuth JSON in <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">/inputs-files/workflow/credentials/</code></li>
            <li>First time: Browser will open for OAuth authorization</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03b ‚Äì google_reviews.csv</code></li>
          </ul>
          <div id="step3aWebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="fetchGoogleReviews" onclick="runGoogleReviewsFetcher()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            üì• Fetch Google Reviews (Local)
          </button>
          <div id="progress-step3a" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3a" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="googleConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3b: Merge Reviews -->
        <div id="step3b-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üîó Step 3b ‚Äì Merge Trustpilot and Google Reviews</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> Combines both review sources into one clean dataset ready for schema generation.<br>
            <strong>When:</strong> Runs automatically after Step 3a completes.<br>
            <strong>You don't need to do anything</strong> - just wait for it to finish. Step 4 will start automatically next.
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03a ‚Äì trustpilot_historical_reviews.csv</code> and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03b ‚Äì google_reviews.csv</code></li>
            <li>Filters out reviews below 4‚òÖ</li>
            <li>Automatically maps reviews to product names</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì combined_product_reviews.csv</code></li>
          </ul>
          <div id="step3bWebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="mergeReviewsBtn" onclick="runMergeReviews()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            üîó Merge Reviews
          </button>
          <div id="progress-step3b" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3b" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="mergeConsoleOutput" style="display: none; margin-top: 0.75rem; padding: 0.75rem; background: #1e1e1e; color: #d4d4d4; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; white-space: pre-wrap;"></div>
        </div>

        <!-- STEP 3c: Upload Merged Dataset (for Step 4) -->
        <div style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì§ Step 3c ‚Äì Upload Merged Dataset</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            After merging reviews, upload the final merged file for schema generation.<br>
            File: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì products_with_review_data_final.xlsx</code>
          </p>
          <input type="file" id="file-step3" accept=".xlsx" style="margin-top: 0.75rem; display: block; font-size: 0.875rem;" />
          <div id="progress-step3" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step3" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
        </div>

        <!-- STEP 4 -->
        <div id="step4-container" style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">‚öôÔ∏è Step 4 ‚Äì Generate Product Schema</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            <strong>What happens:</strong> Generates JSON-LD schema files from your merged review data.<br>
            <strong>When:</strong> Runs automatically after Step 3b completes.<br>
            <strong>What you need to do:</strong> Nothing - just wait for it to finish. Your schema files will be ready!
          </p>
          <ul style="margin-left: 1.5rem; margin-top: 0.5rem; margin-bottom: 0.75rem; font-size: 0.875rem; color: #4a5568; line-height: 1.6;">
            <li>Requires <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">02 ‚Äì products_cleaned.xlsx</code> and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">03 ‚Äì combined_product_reviews.csv</code></li>
            <li>Generates one HTML file per product with embedded reviews</li>
            <li>Includes aggregate ratings and individual review data</li>
            <li>‚úÖ <strong>Automatically includes Schema Suppressor v1.3</strong> - removes duplicate Squarespace Product schemas</li>
            <li>Output: <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">/outputs/</code> folder (HTML files) and <code style="background: #edf2f7; padding: 2px 6px; border-radius: 4px;">04 ‚Äì alanranger_product_schema_FINAL_WITH_REVIEW_RATINGS.csv</code></li>
          </ul>
          <div id="step4WebModeNotice" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; font-size: 0.875rem; color: #1565c0;">
            <strong>‚ÑπÔ∏è Requires Local Execution:</strong> Python scripts need file system access.<br>
            <small>Use Electron app or run locally.</small>
          </div>
          <button id="run-step4" onclick="generateProductSchema()" style="margin-top: 0.75rem; background: #667eea; color: white; font-size: 0.875rem; font-weight: 500; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='#5568d3'" onmouseout="this.style.background='#667eea'">
            Generate Schema (Step 4)
          </button>
          <div id="progress-step4" class="progress" style="display: none; margin-top: 0.75rem; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden;">
            <div class="progress-bar" style="height: 8px; background: #E57200; border-radius: 4px; transition: width 0.3s ease; width: 0%;"></div>
          </div>
          <p id="status-step4" style="font-size: 0.875rem; color: #4a5568; margin-top: 0.5rem;"></p>
          <div id="step4MatchStatus" style="display:none; margin-top: 0.75rem; padding: 0.75rem; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px; font-size: 0.875rem; color: #0c4a6e;">
            <strong>üìä Products Matched:</strong> <span id="step4MatchCount">0</span> products have reviews embedded in their schema
          </div>
          <div id="productSchemaSuccess" style="display:none; margin-top: 1rem; padding: 1rem; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; color: #155724;">
            ‚úÖ Schema generation complete.<br>
            Files saved in your project folder: <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">/outputs/</code> (individual JSON/HTML files) and <code style="background:#cbd5e0; padding:2px 4px; border-radius:3px;">/inputs-files/workflow/</code> (combined CSV).
          </div>
        </div>

        <!-- STEP 5 -->
        <div style="border-radius: 12px; border: 1px solid #e2e8f0; padding: 1rem; background: #f7fafc;">
          <h3 style="font-weight: 600; font-size: 1.125rem; color: #2d3748; margin: 0 0 0.5rem 0;">üì• Step 5 ‚Äì Insert Schema into Squarespace</h3>
          <p style="font-size: 0.875rem; color: #4a5568; margin: 0.25rem 0; line-height: 1.6;">
            Open your product page ‚Üí <strong>Code Block</strong> ‚Üí paste generated schema.<br>
            Validate using <a href="https://search.google.com/test/rich-results" target="_blank" style="color: #667eea; text-decoration: underline;">Rich Results Test</a>.
          </p>
        </div>

      </section>

    </div>

    <h3 style="margin-top: 2rem;">Generated JSON-LD Schema:</h3>
    <p style="color: #4a5568; font-size: 0.9rem; margin-bottom: 0.5rem;">Preview of JSON-LD schema blocks for each product:</p>
    <textarea id="productOutput" readonly style="min-height: 400px; font-family: 'Courier New', monospace; font-size: 0.85rem; width: 100%; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px;"></textarea>
    <button onclick="copyToClipboard('productOutput')" style="margin-top: 0.75rem; background: #667eea; color: white; padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer;">Copy to Clipboard</button>
    
    <!-- Hidden file input for Step 4 (backward compatibility) -->
    <input type="file" id="productCsvFile" accept=".csv,.xlsx" style="display: none;" aria-label="Product CSV/XLSX file upload">

    <div class="test-url-section">
      <h4>Test Generated Schema:</h4>
      <p>Paste a URL containing your schema to validate it:</p>
      <label for="productTestUrl">Test URL:</label>
      <input type="text" id="productTestUrl" placeholder="https://example.com/page-with-schema" aria-label="Product test URL">
      <div class="button-group">
        <button onclick="testSchemaOrg('productTestUrl')">Test on Schema.org Validator</button>
        <button onclick="testGoogleRichResults('productTestUrl')" class="secondary">Test on Google Rich Results</button>
      </div>
    </div>
  </div>

  <!-- Schema Validator Tab Content -->
  <div id="validatorTab" class="tab-content">
    <div class="instructions">
      <strong>üîç Schema Validator</strong><br><button class='secondary' style='float:right;margin-top:-0.25rem' onclick='switchTab("guide")'>Open Tab Guide ‚Üí</button>
      Validate schema markup on your pages using industry-standard validators. Choose single URL validation or batch processing from CSV.<br><br>
      
      ‚úÖ Works entirely in your browser (no server required).<br>
      ‚úÖ Validates Product, Event, Organization, and other schema types.<br>
      ‚úÖ Identifies missing fields and provides enhancement suggestions.<br><br>
      
      <strong>‚ö†Ô∏è Note:</strong> Cross-origin restrictions may prevent fetching some URLs. Use URLs from the same domain or enable CORS if testing locally.
    </div>

    <!-- Single URL Validator Section -->
    <div class="single-url-section">
      <label for="singleUrlInput">Validate a Single URL:</label>
      <input type="text" id="singleUrlInput" placeholder="https://www.example.com/page-with-schema" aria-label="Single URL to validate">
      <button onclick="runSingleUrlValidation()" style="margin-top: 0.75rem;">Run Validation</button>
      <p style="margin-top: 0.75rem; color: #4a5568; font-size: 0.9rem;">This will process the URL and display validation results in the table below. Use the validator buttons in the table to open external validators.</p>
      <label style="margin-top: 0.75rem; display: flex; align-items: center; gap: 0.5rem; font-weight: normal;">
        <input type="checkbox" id="autoSaveToSupabase" style="width: auto; margin: 0;" onchange="saveAutoSavePreference()">
        <span>Auto-save to Supabase</span>
      </label>
    </div>

    <!-- Batch CSV Validator Section -->
    <div class="batch-section">
      <label for="validatorCsvFile" style="margin-top: 0;">Upload CSV File with URLs:</label>
      <p style="margin-top: 0.5rem; margin-bottom: 1rem; color: #4a5568; font-size: 0.95rem; font-style: italic;">
        Use this to batch validate multiple URLs from your site for schema health.
      </p>
      <input type="file" id="validatorCsvFile" accept=".csv" aria-label="Validator CSV file upload" onchange="onFileUpload()">
      <button onclick="startValidation()">Validate URLs</button>
      <button onclick="downloadTemplateCSV()" class="secondary" style="margin-left: 0.5rem;">Download Template CSV</button>
      <button id="exportAllBtn" onclick="exportAllEnhanced()" class="secondary" style="margin-left: 0.5rem;" disabled>Export All Enhanced</button>
      <button id="saveAllBtn" onclick="saveAllToSupabase()" class="secondary" style="margin-left: 0.5rem;" disabled>Save All to Supabase</button>

    <div id="validatorProgress" style="display:none; margin-top: 1.5rem;">
      <div class="progress-bar">
        <div id="progressBarFill" class="progress-bar-fill" style="width: 0%;"></div>
      </div>
      <p id="progressText" style="margin-top: 0.75rem; color: #4a5568; font-size: 0.95rem;">Processing...</p>
    </div>

    <div id="validatorResults" style="display:none; margin-top: 2rem;">
      <h3>Validation Results</h3>
      <p style="margin-top: 0.5rem; margin-bottom: 1rem; color: #4a5568; font-size: 0.9rem; font-style: italic;">
        External validators open in a new tab. Due to cross-origin limits, results can't be read automatically ‚Äî set the status after reviewing.
      </p>
      <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
        <button onclick="setAllExternalStatusTo('Passed')" class="secondary" style="font-size: 0.875rem; padding: 0.5rem 1rem;">Set all Not run ‚Üí Passed</button>
        <button onclick="resetAllExternalStatus()" class="secondary" style="font-size: 0.875rem; padding: 0.5rem 1rem;">Reset all to Not run</button>
      </div>
      
      <!-- Status Legend -->
      <div class="status-legend">
        <div class="status-legend-item">
          <span class="chip-sample passed">‚úÖ Passed</span>
          <span>All valid; no missing fields</span>
        </div>
        <div class="status-legend-item">
          <span class="chip-sample issues">‚ö†Ô∏è Warning</span>
          <span>Duplicate or redundant schema nodes (non-critical)</span>
        </div>
        <div class="status-legend-item">
          <span class="info-entry">‚ÑπÔ∏è Info</span>
          <span>Legitimate multi-instance schemas (normal for Events, Products, FAQs)</span>
        </div>
        <div class="status-legend-item">
          <span class="chip-sample critical">‚ùå Critical</span>
          <span>Structural or required field errors</span>
        </div>
        <div class="status-legend-item" style="margin-left: auto;">
          <span style="color: #6b7280;">üí° Click any badge or "View Details" to see full analysis</span>
        </div>
      </div>
      
      <div class="scrollable-container">
        <table class="results-table">
          <thead>
            <tr>
              <th><span class="sortable-header" data-column="0">Page URL</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="1">Schema Type</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="2">Status</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="3">Missing Fields</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="4">Warnings</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="5">Info</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="6">Rich Results<br>Status (external)</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="7">Schema.org<br>Status (external)</span><span class="sort-indicator"> ‚Üï</span></th>
              <th><span class="sortable-header" data-column="8">Notes</span><span class="sort-indicator"> ‚Üï</span></th>
              <th>Actions</th>
            </tr>
            <tr class="filter-row">
              <th><input type="text" class="filter-input" data-column="0" placeholder="Filter URL..."></th>
              <th><input type="text" class="filter-input" data-column="1" placeholder="Filter Type..."></th>
              <th><input type="text" class="filter-input" data-column="2" placeholder="Filter Status..."></th>
              <th><input type="text" class="filter-input" data-column="3" placeholder="Filter Missing..."></th>
              <th><input type="text" class="filter-input" data-column="4" placeholder="Filter Warnings..."></th>
              <th><input type="text" class="filter-input" data-column="5" placeholder="Filter Info..."></th>
              <th><input type="text" class="filter-input" data-column="6" placeholder="Filter Rich Results..."></th>
              <th><input type="text" class="filter-input" data-column="7" placeholder="Filter Schema.org..."></th>
              <th><input type="text" class="filter-input" data-column="8" placeholder="Filter Notes..."></th>
              <th></th>
            </tr>
          </thead>
          <tbody id="resultsTableBody">
          </tbody>
        </table>
      </div>
    </div>

    </div>

    <!-- Help Block -->
    <div class="help-section" style="margin-top:1rem;padding:1rem;background:#f9f9f9;border-radius:8px;">
      <strong>‚ÑπÔ∏è How to Read Results:</strong>
      <ul style="margin-top:0.5rem;">
        <li><b>Schema Type</b>: Type(s) detected from JSON-LD (<code>@type</code> values).</li>
        <li><b>Status</b>: "Error" means fetch failed; "OK" means schema was found.</li>
        <li><b>Skipped</b>: Offline mode‚Äîexternal validators not queried.</li>
        <li><b>Schema.org / Google Buttons</b>: Open page in respective validators for manual checks.</li>
        <li><b>Save to Supabase</b>: (Optional) Stores results if DB logging is enabled.</li>
      </ul>
    </div>

    <div class="help-block" onclick="toggleHelpBlock()" onkeydown="if(event.key==='Enter'||event.key===' ')toggleHelpBlock()" role="button" tabindex="0" aria-expanded="false" id="helpBlock">
      <div class="help-block-header">
        <span>‚ÑπÔ∏è About Schema Validators</span>
        <span class="help-block-icon">‚ñº</span>
      </div>
      <div class="help-block-content" id="helpBlockContent">
        <strong>Schema.org Validator:</strong><br>
        Validates that your schema markup follows the Schema.org vocabulary specifications. Checks for correct syntax, required fields, and proper structure. Essential for ensuring your schema is semantically correct.<br><br>
        
        <strong>Google Rich Results Test:</strong><br>
        Tests whether your schema qualifies for Google's rich results (enhanced search listings). Shows which rich result types are detected and any issues that might prevent them from appearing in search results.<br><br>
        
        <strong>Results:</strong><br>
        Validation results are displayed in the table above. For detailed analysis, you'll need to manually review the validator pages opened in new tabs. When Supabase integration is connected, results can be automatically captured and stored for analysis.<br><br>
        
        <strong>Note:</strong> Both validators open in new browser tabs so you can review the detailed results while keeping this tool open.
      </div>
    </div>

    <!-- Debug Console -->
    <div class="debug-console">
      <div class="debug-console-header">
        <span>üîç Debug Console</span>
        <div class="debug-console-actions">
          <button onclick="clearDebugConsole()" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Clear</button>
          <button onclick="copyDebugConsole()" class="secondary" style="padding: 0.25rem 0.75rem; font-size: 0.85rem;">Copy Logs</button>
        </div>
      </div>
      <div class="debug-console-content" id="debugConsoleContent">
        <div class="debug-log-entry success">
          <span class="debug-log-time"></span>Debug console ready. Logs will appear here when validation runs.
        </div>
      </div>
    </div>
  </div>

  <!-- Tab Guide Tab Content -->
  <div id="guideTab" class="tab-content">
    <div class="instructions" style="max-width: 100%;">
      <h2>üß† Tool Guide: What Each Tab Does</h2>

      <p>This tool contains several tabs, each with a specific use:</p>

      <h3>üü¢ Event Schema</h3>
      <ul>
        <li>Use this tab to generate JSON-LD Event schema from a CSV of your photography workshops.</li>
        <li>Supports <code>location</code>, <code>performer</code>, <code>offers</code>, and <code>organizer</code> fields.</li>
        <li>Paste the resulting schema into a code block on your Squarespace event page.</li>
      </ul>

      <h3>üîµ Product Schema</h3>
      <ul>
        <li>Generates <code>Product</code> schema from a CSV of lessons, vouchers, or services.</li>
        <li>Automatically filters out products with weak or missing reviews.</li>
        <li>‚úÖ <strong>Includes Schema Suppressor v1.3</strong> - automatically removes duplicate Squarespace Product schemas to prevent conflicts.</li>
        <li>Paste the JSON-LD into product pages on Squarespace.</li>
      </ul>

      <h3>üü° Schema Validator</h3>
      <ul>
        <li>Enter one or more live URLs (CSV or single entry support coming).</li>
        <li>Fetches the page content and validates all structured data inside it.</li>
        <li>Flags missing or invalid fields and optionally builds an enhanced schema block you can download.</li>
        <li>Use this to <strong>audit</strong>, <strong>debug</strong>, or <strong>improve</strong> existing Squarespace pages.</li>
      </ul>

      <h3>üìå Best Practices</h3>
      <ul>
        <li>Only insert schema relevant to the page (don't paste every product on every product page).</li>
        <li>Always validate using the <strong>Schema Validator</strong> before and after injecting schema.</li>
        <li>Use <code>&lt;script type="application/ld+json"&gt;</code> inside a code block on Squarespace pages.</li>
      </ul>

      <h3>üîß Upcoming Features</h3>
      <ul>
        <li>Support for validating a single URL directly (no CSV needed).</li>
        <li>Supabase integration to track schema versions and history.</li>
        <li>AI suggestions for schema fixes.</li>
      </ul>
    </div>
  </div>

</div>

<script>
  // Tab switching - MUST be absolutely first, before any other code
  function switchTab(mode) {
    // Clear cache and storage when switching tabs
    try {
      // Clear ResultCache if it exists
      if (typeof ResultCache !== 'undefined') {
        if (ResultCache instanceof Map) {
          ResultCache.clear();
        } else if (ResultCache.clear && typeof ResultCache.clear === 'function') {
          ResultCache.clear();
        }
      }
      // Clear validationResults if it exists
      if (typeof validationResults !== 'undefined' && Array.isArray(validationResults)) {
        validationResults.length = 0;
      }
      // Clear localStorage and sessionStorage
      localStorage.removeItem('schemaValidatorResults');
      localStorage.removeItem('schemaValidatorCache');
      sessionStorage.removeItem('schemaValidatorResults');
      sessionStorage.removeItem('schemaValidatorCache');
    } catch (e) {
      console.warn('Failed to clear storage:', e);
    }
    
    // Clear the results table
    const tableBody = document.getElementById('resultsTableBody');
    if (tableBody) {
      tableBody.innerHTML = '';
    }
    
    // Reset all active tabs and contents
    const tabs = document.querySelectorAll('.tab');
    const contents = document.querySelectorAll('.tab-content');
    
    for (const tab of tabs) {
      tab.classList.remove('active');
    }
    for (const content of contents) {
      content.classList.remove('active');
    }
    
    // Activate correct tab based on mode
    const tabMap = {
      'event': { tabIndex: 0, contentId: 'eventTab' },
      'product': { tabIndex: 1, contentId: 'productTab' },
      'validator': { tabIndex: 2, contentId: 'validatorTab' },
      'guide': { tabIndex: 3, contentId: 'guideTab' }
    };
    
    const config = tabMap[mode];
    if (config && tabs[config.tabIndex] && tabs[config.tabIndex] !== null) {
      tabs[config.tabIndex].classList.add('active');
      const content = document.getElementById(config.contentId);
      if (content) {
        content.classList.add('active');
      }
    }
  }
  
  // Make it globally available
  window.switchTab = switchTab;
</script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<script>
  // Override console methods to also log to debug console (MUST be before debugLog)
  const originalConsoleLog = console.log.bind(console);
  const originalConsoleError = console.error.bind(console);
  const originalConsoleWarn = console.warn.bind(console);
  
  // Schema Validator Suppression Configuration
  const SUPPRESSION_CONFIG = {
    suppressions: {
      global: {
        ignoreSchemaTypes: [
          "BreadcrumbList",
          "SearchAction",
          "Person",
          "Event",
          "ItemList",
          "Article",
          "Product"
        ],
        ignoreRecommendedFields: [
          "publisher",
          "telephone",
          "url",
          "description",
          "image",
          "logo",
          "contactPoint"
        ],
        ignoreWarningsContaining: [
          "Duplicate Event",
          "Duplicate BreadcrumbList",
          "Recommended field",
          "Unknown schema type",
          "Missing recommended",
          "normal navigation schema",
          "acceptable for combined schema types"
        ],
        ignoreInfoContaining: [
          "BreadcrumbList detected",
          "Recommended field",
          "Legitimate multi-instance schemas",
          "cached or blocked"
        ],
        ignoreUrlsMatching: [
          "/photographic-workshops-near-me",
          "/photography-classes",
          "/photography-services",
          "/photography-workshops",
          "/shop"
        ],
        downgradeDuplicates: true,
        collapseMultiInstanceEvents: true,
        hideSquarespaceInjectedBlocks: true,
        treatWarningsAsPass: true
      },
      rules: {
        Organization: {
          suppressMissingRecommended: true,
          ignoreExtraNodes: true
        },
        LocalBusiness: {
          suppressMissingRecommended: true,
          ignoreExtraNodes: true
        },
        WebSite: {
          suppressMissingRecommended: true,
          requireOnly: ["url", "name"]
        },
        Person: {
          ignoreUnknownType: true
        },
        BreadcrumbList: {
          collapseDuplicates: true
        },
        Event: {
          allowMultiple: true,
          collapseDuplicates: true
        },
        Product: {
          allowMultiple: true,
          ignoreNoReview: true
        }
      }
    }
  };

  // Multi-instance allowed schema types (expected to appear multiple times on a page)
  const MULTI_INSTANCE_ALLOWED_TYPES = ['Event', 'Product', 'Course', 'Article', 'Review', 'FAQPage', 'ListItem', 'Offer'];

  // Helper: Detect inferred schema types based on patterns in JSON-LD
  function detectInferredTypes(allNodes) {
    const inferredTypes = [];
    const typeCounts = {};
    
    // Count occurrences of each type
    allNodes.forEach(node => {
      const types = asArray(node['@type']);
      types.forEach(type => {
        typeCounts[type] = (typeCounts[type] || 0) + 1;
      });
    });
    
    // Rule 1: Carousel inference
    // If ‚â•3 Event items exist ‚Üí infer Carousel
    const eventCount = typeCounts['Event'] || 0;
    if (eventCount >= 3) {
      inferredTypes.push({ type: 'Carousel', reason: `from ${eventCount} Event schemas` });
    }
    
    // Rule 2: Carousel inference from Product/Course
    // If multiple Product or Course schemas exist ‚Üí also infer Carousel
    const productCount = typeCounts['Product'] || 0;
    const courseCount = typeCounts['Course'] || 0;
    if ((productCount + courseCount) >= 3) {
      inferredTypes.push({ type: 'Carousel', reason: `from ${productCount + courseCount} Product/Course schemas` });
    }
    
    // Rule 3: ReviewSnippet inference
    // If any item contains aggregateRating or review ‚Üí infer ReviewSnippet
    const hasReviews = allNodes.some(node => {
      return node.aggregateRating || 
             (node.review && Array.isArray(node.review) && node.review.length > 0) ||
             node.reviews;
    });
    
    if (hasReviews) {
      const reviewCount = allNodes.filter(node => {
        return node.aggregateRating || 
               (node.review && Array.isArray(node.review) && node.review.length > 0) ||
               node.reviews;
      }).length;
      inferredTypes.push({ type: 'ReviewSnippet', reason: `from ${reviewCount} item${reviewCount !== 1 ? 's' : ''} with reviews` });
    }
    
    // Rule 4: MerchantListing (Google) inference
    // If any Product schema contains all Merchant Center fields ‚Üí infer MerchantListing (Google)
    const productNodes = allNodes.filter(node => {
      const types = asArray(node['@type']);
      return types.includes('Product');
    });
    
    console.log(`[MerchantListing] Checking ${productNodes.length} Product node(s) for Merchant Center fields`);
    debugLog(`[MerchantListing] Checking ${productNodes.length} Product node(s) for Merchant Center fields`, 'info');
    
    // Debug: Log Product node details
    productNodes.forEach((node, idx) => {
      console.log(`[MerchantListing] Product node ${idx + 1}:`, {
        '@type': node['@type'],
        hasOffers: !!node.offers,
        offersType: node.offers ? (Array.isArray(node.offers) ? 'array' : 'object') : 'none',
        hasPriceCurrency: !!node.offers?.priceCurrency || !!node.offers?.[0]?.priceCurrency,
        hasPrice: !!node.offers?.price || !!node.offers?.[0]?.price,
        hasAvailability: !!node.offers?.availability || !!node.offers?.[0]?.availability,
        hasMerchantReturnPolicy: !!node.hasMerchantReturnPolicy
      });
    });
    
    const hasMerchantListing = productNodes.some(node => {
      const detected = detectMerchantListing(node);
      if (detected) {
        console.log(`[MerchantListing] ‚úÖ Detected MerchantListing in Product node:`, node);
        debugLog(`[MerchantListing] ‚úÖ Detected MerchantListing in Product node: ${JSON.stringify({ '@type': node['@type'], hasOffers: !!node.offers, hasReturnPolicy: !!node.hasMerchantReturnPolicy })}`, 'success');
      }
      return detected;
    });
    
    if (hasMerchantListing) {
      inferredTypes.push({ type: 'MerchantListing (Google)', reason: 'Product schema contains all Merchant Center fields (offers, price, priceCurrency, availability, hasMerchantReturnPolicy)' });
      console.log(`[MerchantListing] ‚úÖ Added MerchantListing (Google) to inferred types. Total inferred types:`, inferredTypes);
      debugLog(`[MerchantListing] ‚úÖ Added MerchantListing (Google) to inferred types`, 'success');
    } else {
      console.log(`[MerchantListing] ‚ùå No Product schemas found with all Merchant Center fields`);
      debugLog(`[MerchantListing] ‚ùå No Product schemas found with all Merchant Center fields`, 'info');
    }
    
    // Deduplicate inferred types (e.g., if Carousel appears twice)
    const uniqueInferred = [];
    const seenTypes = new Set();
    inferredTypes.forEach(item => {
      if (!seenTypes.has(item.type)) {
        seenTypes.add(item.type);
        uniqueInferred.push(item);
      }
    });
    
    return uniqueInferred;
  }

  // Suppression Filtering Functions
  function shouldSuppressWarning(message, url = '') {
    if (!message) return false;
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing warning by URL pattern: ${message}`, 'info');
      return true;
    }
    
    // Check message content
    if (sup.ignoreWarningsContaining.some(pattern => message.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing warning by pattern: ${message}`, 'info');
      return true;
    }
    
    return false;
  }

  function shouldSuppressInfo(message, url = '') {
    if (!message) return false;
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing info by URL pattern: ${message}`, 'info');
      return true;
    }
    
    // Check message content
    if (sup.ignoreInfoContaining.some(pattern => message.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing info by pattern: ${message}`, 'info');
      return true;
    }
    
    return false;
  }

  function shouldSuppressMissingField(field, schemaType, url = '') {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    const rule = SUPPRESSION_CONFIG.suppressions.rules[schemaType];
    
    // Check URL patterns
    if (url && sup.ignoreUrlsMatching.some(pattern => url.includes(pattern))) {
      debugLog(`[SUPPRESSION] Suppressing missing field by URL pattern: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check if schema type should be ignored
    if (sup.ignoreSchemaTypes.includes(schemaType)) {
      debugLog(`[SUPPRESSION] Suppressing missing field by schema type: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check if field is in ignoreRecommendedFields
    if (sup.ignoreRecommendedFields.includes(field)) {
      debugLog(`[SUPPRESSION] Suppressing missing field by recommended field list: ${schemaType}.${field}`, 'info');
      return true;
    }
    
    // Check type-specific rules
    if (rule) {
      if (rule.suppressMissingRecommended && field.toLowerCase().includes('recommended')) {
        debugLog(`[SUPPRESSION] Suppressing missing field by type rule (suppressMissingRecommended): ${schemaType}.${field}`, 'info');
        return true;
      }
      if (rule.requireOnly && !rule.requireOnly.includes(field)) {
        debugLog(`[SUPPRESSION] Suppressing missing field by type rule (requireOnly): ${schemaType}.${field}`, 'info');
        return true;
      }
    }
    
    return false;
  }

  function shouldSuppressSchemaType(schemaType) {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    return sup.ignoreSchemaTypes.includes(schemaType);
  }

  function shouldDowngradeDuplicate(schemaType) {
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    const rule = SUPPRESSION_CONFIG.suppressions.rules[schemaType];
    
    if (sup.downgradeDuplicates) {
      return true;
    }
    
    if (rule && rule.collapseDuplicates) {
      return true;
    }
    
    return false;
  }

  function filterSuppressedWarnings(warnings, url = '') {
    if (!warnings || !Array.isArray(warnings)) return [];
    return warnings.filter(w => !shouldSuppressWarning(w, url));
  }

  function filterSuppressedInfo(info, url = '') {
    if (!info || !Array.isArray(info)) return [];
    return info.filter(i => !shouldSuppressInfo(i, url));
  }

  function filterSuppressedMissingFields(missingFields, schemaType, url = '') {
    if (!missingFields || !Array.isArray(missingFields)) return [];
    
    return missingFields.filter(field => {
      // Extract field name from different formats
      const fieldName = typeof field === 'string' 
        ? field.split(':')[1]?.trim().replace(/["\s]/g, '') || field.split('.')[1] || field
        : field.field || field;
      
      return !shouldSuppressMissingField(fieldName, schemaType, url);
    });
  }

  // Debug Console Logging Functions - MUST be first
  function debugLog(message, level = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    const prefix = `[${timestamp}]`;
    
    // Console logging - use original methods to avoid recursion
    if (level === 'error') {
      originalConsoleError(`${prefix} ‚ùå ${message}`);
    } else if (level === 'warn') {
      originalConsoleWarn(`${prefix} ‚ö†Ô∏è ${message}`);
    } else if (level === 'success') {
      originalConsoleLog(`${prefix} ‚úÖ ${message}`);
    } else {
      originalConsoleLog(`${prefix} ${message}`);
    }
    
    // Also write to visible debug panel (statusDebugPanel) - REMOVED, using bottom debug console only
    // Remove this section - debug panel above table has been removed
    
    // Also write to existing debug console (debugConsoleContent)
    const consoleContent = document.getElementById('debugConsoleContent');
    if (consoleContent) {
      const entry = document.createElement('div');
      entry.className = `debug-log-entry ${level}`;
      
      const timeSpan = document.createElement('span');
      timeSpan.className = 'debug-log-time';
      timeSpan.textContent = prefix;
      
      const messageSpan = document.createElement('span');
      messageSpan.textContent = typeof message === 'object' ? JSON.stringify(message, null, 2) : message;
      
      entry.appendChild(timeSpan);
      entry.appendChild(messageSpan);
      consoleContent.appendChild(entry);
      
      // Auto-scroll to bottom
      consoleContent.scrollTop = consoleContent.scrollHeight;
      
      // Keep max 100 entries to prevent memory issues
      const entries = consoleContent.querySelectorAll('.debug-log-entry');
      if (entries.length > 100) {
        entries[0].remove();
      }
    }
  }
  
  function clearDebugConsole() {
    const consoleContent = document.getElementById('debugConsoleContent');
    if (consoleContent) {
      consoleContent.innerHTML = '<div class="debug-log-entry success"><span class="debug-log-time"></span>Debug console cleared.</div>';
    }
  }
  
  function copyDebugConsole() {
    const consoleContent = document.getElementById('debugConsoleContent');
    if (!consoleContent) return;
    
    const entries = consoleContent.querySelectorAll('.debug-log-entry');
    const logs = Array.from(entries).map(entry => {
      const time = entry.querySelector('.debug-log-time')?.textContent || '';
      const message = entry.textContent.replace(time, '').trim();
      return `${time} ${message}`;
    }).join('\n');
    
    navigator.clipboard.writeText(logs).then(() => {
      debugLog('‚úÖ Logs copied to clipboard!', 'success');
      setTimeout(() => {
        const lastEntry = consoleContent.querySelector('.debug-log-entry:last-child');
        if (lastEntry && lastEntry.textContent.includes('copied to clipboard')) {
          lastEntry.remove();
        }
      }, 2000);
    }).catch(err => {
      debugLog('‚ùå Failed to copy logs: ' + err.message, 'error');
    });
  }
  
  // Override console methods to also log to debug console (after debugLog is defined)
  // Ensure originalConsole methods are available (they're defined earlier in this script block)
  if (typeof originalConsoleLog !== 'undefined') {
    console.log = function(...args) {
      try {
        originalConsoleLog.apply(console, args);
        const message = args.map(a => {
          if (typeof a === 'object') {
            try {
              return JSON.stringify(a, null, 2);
            } catch (e) {
              return String(a);
            }
          }
          return String(a);
        }).join(' ');
        // Use originalConsoleLog to avoid recursion
        if (message && typeof debugLog === 'function') {
          debugLog(message, 'info');
        }
      } catch (e) {
        // Fallback to native console if override fails
        console.log.apply(console, args);
      }
    };
  }
  
  if (typeof originalConsoleError !== 'undefined') {
    console.error = function(...args) {
      try {
        originalConsoleError.apply(console, args);
        const message = args.map(a => {
          if (typeof a === 'object') {
            try {
              return JSON.stringify(a, null, 2);
            } catch (e) {
              return String(a);
            }
          }
          return String(a);
        }).join(' ');
        // Use originalConsoleError to avoid recursion
        if (message && typeof debugLog === 'function') {
          debugLog(message, 'error');
        }
      } catch (e) {
        // Fallback to native console if override fails
        console.error.apply(console, args);
      }
    };
  }
  
  if (typeof originalConsoleWarn !== 'undefined') {
    console.warn = function(...args) {
      try {
        originalConsoleWarn.apply(console, args);
        const message = args.map(a => {
          if (typeof a === 'object') {
            try {
              return JSON.stringify(a, null, 2);
            } catch (e) {
              return String(a);
            }
          }
          return String(a);
        }).join(' ');
        // Use originalConsoleWarn to avoid recursion
        if (message && typeof debugLog === 'function') {
          debugLog(message, 'warn');
        }
      } catch (e) {
        // Fallback to native console if override fails
        console.warn.apply(console, args);
      }
    };
  }

  // Supabase Configuration
  const SUPABASE_URL = 'https://igzvwbvgvmzvvzoclufx.supabase.co';
  const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImlnenZ3YnZndm16dnZ6b2NsdWZ4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc2Nzc5MjgsImV4cCI6MjA3MzI1MzkyOH0.A9TCmnXKJhDRYBkrO0mAMPiUQeV9enweeyRWKWQ1SZY';
  
  // Initialize Supabase client (wait for library to load)
  let supabase = null;
  let supabaseAvailable = false;
  
  // Wait for Supabase library to load
  function initSupabase() {
    // Check for Supabase library loaded via CDN (UMD build)
    if (typeof window.supabase !== 'undefined' && typeof window.supabase.createClient === 'function') {
      try {
        supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        supabaseAvailable = true;
        console.log('‚úÖ Supabase client initialized successfully');
        
        // Update bulk buttons state when Supabase is available
        updateBulkButtons();
        
        return true;
      } catch (error) {
        console.error('Failed to initialize Supabase client:', error);
      }
    }
    return false;
  }
  
  // Try to initialize when script loads
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function() {
      if (!initSupabase()) {
        // Retry after delays
        setTimeout(initSupabase, 500);
        setTimeout(initSupabase, 1500);
      }
    });
  } else {
    if (!initSupabase()) {
      // Retry after delays
      setTimeout(initSupabase, 500);
      setTimeout(initSupabase, 1500);
    }
  }
  
  // Final retry after all scripts load
  window.addEventListener('load', function() {
    if (!supabaseAvailable) {
      initSupabase();
    }
    // Load auto-run preference
    loadAutoRunPreference();
    // Load auto-save preference
    loadAutoSavePreference();
  });
  
  
  // Progress bar helpers
  function renderProgress(cell) {
    cell.innerHTML = `
      <div class="progress-wrap">
        <div class="progress"><span style="width:0%"></span></div>
        <div class="progress-label">0%</div>
      </div>`;
  }
  
  function setProgress(cell, pct, text) {
    const bar = cell.querySelector('.progress > span');
    const lbl = cell.querySelector('.progress-label');
    if (bar) { bar.style.width = Math.max(0, Math.min(100, pct)) + '%'; }
    if (lbl) { lbl.textContent = (text ? text + ' ¬∑ ' : '') + Math.round(pct) + '%'; }
  }
  
  function markProgressError(cell) {
    const bar = cell.querySelector('.progress > span');
    if (bar) { bar.style.background = 'linear-gradient(90deg,#ff5252,#ff8a80)'; }
  }
  
  // ---- NEW: Modal helpers --------------------------------------
  function openModal(title, html) {
    let modal = document.querySelector('#detail-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'detail-modal';
      modal.innerHTML = `
        <div class="modal-backdrop"></div>
        <div class="modal">
          <div class="modal-head">
            <h3 id="modal-title"></h3>
            <button id="modal-close" aria-label="Close">‚úñ</button>
          </div>
          <div class="modal-body"></div>
        </div>`;
      document.body.appendChild(modal);
      modal.querySelector('#modal-close').onclick = () => modal.remove();
      modal.querySelector('.modal-backdrop').onclick = () => modal.remove();
    }
    modal.querySelector('#modal-title').textContent = title;
    modal.querySelector('.modal-body').innerHTML = html;
  }

  // Step completion modals
  function showStepSuccessModal(stepNumber, stepName, message, nextStepInstructions, fileLocation) {
    const html = `
      <div style="padding: 1.5rem;">
        <div style="text-align: center; margin-bottom: 1.5rem;">
          <div style="font-size: 4rem; margin-bottom: 1rem;">‚úÖ</div>
          <h2 style="color: #27AE60; margin: 0 0 0.5rem 0;">Step ${stepNumber} Complete!</h2>
          <p style="color: #4a5568; font-size: 1.1rem; margin: 0;">${stepName}</p>
        </div>
        
        <div style="background: #f7fafc; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #2d3748;">What happened:</p>
          <p style="margin: 0; color: #4a5568; line-height: 1.6;">${message}</p>
          ${fileLocation ? `<p style="margin: 1rem 0 0 0; color: #2d3748;"><strong>üìÅ File saved:</strong> <code style="background: #e2e8f0; padding: 2px 6px; border-radius: 4px;">${fileLocation}</code></p>` : ''}
        </div>
        
        ${nextStepInstructions ? `
        <div style="background: #e6f3ff; padding: 1rem; border-left: 4px solid #007bff; border-radius: 4px; margin-bottom: 1rem;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #004085;">üí° What's Next:</p>
          <p style="margin: 0; color: #004085; line-height: 1.6;">${nextStepInstructions}</p>
        </div>
        ` : ''}
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="document.querySelector('#detail-modal').remove()" style="padding: 0.75rem 2rem; background: #667eea; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer;">
            Got it!
          </button>
        </div>
      </div>
    `;
    openModal(`‚úÖ Step ${stepNumber} Complete`, html);
  }

  function showStepErrorModal(stepNumber, stepName, errorMessage, troubleshootingSteps) {
    const html = `
      <div style="padding: 1.5rem;">
        <div style="text-align: center; margin-bottom: 1.5rem;">
          <div style="font-size: 4rem; margin-bottom: 1rem;">‚ùå</div>
          <h2 style="color: #E74C3C; margin: 0 0 0.5rem 0;">Step ${stepNumber} Failed</h2>
          <p style="color: #4a5568; font-size: 1.1rem; margin: 0;">${stepName}</p>
        </div>
        
        <div style="background: #fff5f5; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; border-left: 4px solid #E74C3C;">
          <p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #c53030;">Error:</p>
          <p style="margin: 0; color: #742a2a; line-height: 1.6; font-family: monospace; background: #fff; padding: 0.5rem; border-radius: 4px;">${escapeHtml(errorMessage)}</p>
        </div>
        
        ${troubleshootingSteps ? `
        <div style="background: #fffbf0; padding: 1rem; border-radius: 8px; border-left: 4px solid #f59e0b;">
          <p style="margin: 0 0 0.75rem 0; font-weight: 600; color: #92400e;">üîß Troubleshooting:</p>
          <ul style="margin: 0; padding-left: 1.5rem; color: #78350f; line-height: 1.8;">
            ${troubleshootingSteps.map(step => `<li>${step}</li>`).join('')}
          </ul>
        </div>
        ` : ''}
        
        <div style="text-align: center; margin-top: 1.5rem;">
          <button onclick="document.querySelector('#detail-modal').remove()" style="padding: 0.75rem 2rem; background: #E74C3C; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer;">
            Close
          </button>
        </div>
      </div>
    `;
    openModal(`‚ùå Step ${stepNumber} Failed`, html);
  }

  function showFinalCompletionModal() {
    if (!window.completedSteps) {
      return;
    }
    
    const steps = window.completedSteps;
    const stepNames = {
      2: 'Step 2 - Clean and Normalize CSV',
      '3a': 'Step 3a - Fetch Google Reviews',
      '3b': 'Step 3b - Merge Reviews',
      4: 'Step 4 - Generate Product Schema'
    };
    
    let summaryHtml = '<div style="padding: 1.5rem;">';
    summaryHtml += '<div style="text-align: center; margin-bottom: 1.5rem;">';
    summaryHtml += '<div style="font-size: 4rem; margin-bottom: 1rem;">üéâ</div>';
    summaryHtml += '<h2 style="color: #27AE60; margin: 0 0 0.5rem 0;">All Steps Complete!</h2>';
    summaryHtml += '<p style="color: #4a5568; font-size: 1.1rem; margin: 0;">Your product schemas are ready</p>';
    summaryHtml += '</div>';
    
    summaryHtml += '<div style="background: #f7fafc; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">';
    summaryHtml += '<p style="margin: 0 0 1rem 0; font-weight: 600; color: #2d3748;">üìä Step Summary:</p>';
    
    const stepOrder = [2, '3a', '3b', 4];
    let allSuccess = true;
    
    for (const stepId of stepOrder) {
      const step = steps[stepId];
      const stepName = stepNames[stepId] || `Step ${stepId}`;
      
      if (step) {
        summaryHtml += `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: #d4edda; border-left: 4px solid #27AE60; border-radius: 4px;">`;
        summaryHtml += `<p style="margin: 0; font-weight: 600; color: #155724;">‚úÖ ${stepName}</p>`;
        summaryHtml += `<p style="margin: 0.25rem 0 0 0; color: #155724; font-size: 0.9rem;">${step.message}</p>`;
        if (step.file) {
          summaryHtml += `<p style="margin: 0.25rem 0 0 0; color: #155724; font-size: 0.85rem;"><code style="background: #c3e6cb; padding: 2px 6px; border-radius: 3px;">${step.file}</code></p>`;
        }
        summaryHtml += `</div>`;
      } else {
        allSuccess = false;
        summaryHtml += `<div style="padding: 0.75rem; margin-bottom: 0.5rem; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">`;
        summaryHtml += `<p style="margin: 0; font-weight: 600; color: #856404;">‚ö†Ô∏è ${stepName}</p>`;
        summaryHtml += `<p style="margin: 0.25rem 0 0 0; color: #856404; font-size: 0.9rem;">Status unknown</p>`;
        summaryHtml += `</div>`;
      }
    }
    
    summaryHtml += '</div>';
    
    // Add Schema Generation Summary if Step 4 data is available
    const step4 = steps[4];
    if (step4 && (step4.totalProducts !== null || step4.matchCount !== null || step4.mappedGoogleCount !== null)) {
      summaryHtml += '<div style="background: #fff9e6; padding: 1rem; border-left: 4px solid #ff9800; border-radius: 4px; margin-bottom: 1rem;">';
      summaryHtml += '<p style="margin: 0 0 0.75rem 0; font-weight: 600; color: #e65100; font-size: 1rem;">üìä Schema Generation Summary:</p>';
      summaryHtml += '<div style="font-size: 0.9rem; color: #5d4037;">';
      
      // Product counts
      summaryHtml += '<div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #ffe0b2;">';
      if (step4.totalProducts !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Total products:</strong> ${step4.totalProducts}</div>`;
      }
      if (step4.matchCount !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Products with reviews:</strong> <span style="color: #27AE60; font-weight: 600;">${step4.matchCount}</span></div>`;
      }
      if (step4.productsWithoutReviews !== null) {
        summaryHtml += `<div><strong>Products without reviews:</strong> ${step4.productsWithoutReviews}</div>`;
      }
      summaryHtml += '</div>';
      
      // Mapped reviews section
      summaryHtml += '<div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #ffe0b2;">';
      summaryHtml += '<div style="font-weight: 600; margin-bottom: 0.5rem; color: #e65100;">üìä Mapped Reviews:</div>';
      
      // Google reviews
      if (step4.mappedGoogleCount !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;">`;
        summaryHtml += `<strong>Google reviews mapped:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.mappedGoogleCount}</span>`;
        if (step4.googleReviewsCount !== null && step4.googleReviewsCount !== step4.mappedGoogleCount) {
          summaryHtml += ` <span style="color: #757575; font-size: 0.85em;">(of ${step4.googleReviewsCount} total)</span>`;
        }
        summaryHtml += `</div>`;
        if (step4.latestGoogleDate) {
          summaryHtml += `<div style="margin-left: 1.5rem; margin-bottom: 0.25rem; color: #757575; font-size: 0.85em;">Latest: ${step4.latestGoogleDate}</div>`;
        }
      } else if (step4.googleReviewsCount !== null) {
        // Fallback to old format
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Google reviews:</strong> ${step4.googleReviewsCount}</div>`;
      }
      
      // Trustpilot reviews
      if (step4.mappedTrustpilotCount !== null) {
        summaryHtml += `<div style="margin-bottom: 0.25rem;">`;
        summaryHtml += `<strong>Trustpilot reviews mapped:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.mappedTrustpilotCount}</span>`;
        if (step4.trustpilotReviewsCount !== null && step4.trustpilotReviewsCount !== step4.mappedTrustpilotCount) {
          summaryHtml += ` <span style="color: #757575; font-size: 0.85em;">(of ${step4.trustpilotReviewsCount} total)</span>`;
        }
        summaryHtml += `</div>`;
        if (step4.latestTrustpilotDate) {
          summaryHtml += `<div style="margin-left: 1.5rem; margin-bottom: 0.25rem; color: #757575; font-size: 0.85em;">Latest: ${step4.latestTrustpilotDate}</div>`;
        }
      } else if (step4.trustpilotReviewsCount !== null) {
        // Fallback to old format
        summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Trustpilot reviews:</strong> ${step4.trustpilotReviewsCount}</div>`;
      }
      
      // Total mapped reviews
      if (step4.totalMappedReviews !== null) {
        summaryHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ffe0b2;"><strong>Total mapped reviews:</strong> <span style="color: #27AE60; font-weight: 600;">${step4.totalMappedReviews}</span></div>`;
      }
      
      // Overall latest review date (if available and different from individual dates)
      if (step4.latestReviewDate && (!step4.latestGoogleDate || !step4.latestTrustpilotDate || step4.latestReviewDate !== step4.latestGoogleDate || step4.latestReviewDate !== step4.latestTrustpilotDate)) {
        summaryHtml += `<div style="margin-top: 0.25rem; color: #757575; font-size: 0.85em;">Overall latest review: ${step4.latestReviewDate}</div>`;
      }
      
      summaryHtml += '</div>';
      
      // Reviews included in schema section
      if (step4.includedGoogleCount !== null || step4.includedTrustpilotCount !== null || step4.totalExcludedReviews !== null) {
        summaryHtml += '<div style="margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #ffe0b2;">';
        summaryHtml += '<div style="font-weight: 600; margin-bottom: 0.5rem; color: #e65100;">üì¶ Reviews Included in Schema:</div>';
        summaryHtml += '<div style="font-size: 0.85em; color: #757575; margin-bottom: 0.5rem;">(Capped at 25 reviews per product for optimal schema performance)</div>';
        
        if (step4.includedGoogleCount !== null) {
          summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Google reviews included:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.includedGoogleCount}</span></div>`;
        }
        if (step4.includedTrustpilotCount !== null) {
          summaryHtml += `<div style="margin-bottom: 0.25rem;"><strong>Trustpilot reviews included:</strong> <span style="color: #1976d2; font-weight: 600;">${step4.includedTrustpilotCount}</span></div>`;
        }
        if (step4.totalIncludedReviews !== null) {
          summaryHtml += `<div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #ffe0b2;"><strong>Total included:</strong> <span style="color: #27AE60; font-weight: 600;">${step4.totalIncludedReviews}</span></div>`;
        }
        if (step4.totalExcludedReviews !== null && step4.totalExcludedReviews > 0) {
          summaryHtml += `<div style="margin-top: 0.25rem; color: #f57c00; font-weight: 500;">Reviews excluded due to 25-review cap: <span style="color: #e65100;">${step4.totalExcludedReviews}</span></div>`;
        }
        if (step4.newestReviewDateIncluded) {
          summaryHtml += `<div style="margin-top: 0.25rem; color: #757575; font-size: 0.85em;">Newest review date included: <strong>${step4.newestReviewDateIncluded}</strong></div>`;
        }
        
        summaryHtml += '</div>';
      }
      summaryHtml += '</div>';
      summaryHtml += '</div>';
    }
    
    summaryHtml += '<div style="background: #e6f3ff; padding: 1rem; border-left: 4px solid #007bff; border-radius: 4px; margin-bottom: 1rem;">';
    summaryHtml += '<p style="margin: 0 0 0.5rem 0; font-weight: 600; color: #004085;">üí° Next Steps:</p>';
    summaryHtml += '<ul style="margin: 0; padding-left: 1.5rem; color: #004085; line-height: 1.8;">';
    summaryHtml += '<li>Find your schema files in the <code style="background: #cbd5e0; padding: 2px 4px; border-radius: 3px;">outputs/</code> folder</li>';
    summaryHtml += '<li>Each product has a Squarespace-ready HTML file</li>';
    summaryHtml += '<li>Copy-paste the HTML into Squarespace Code Blocks</li>';
    summaryHtml += '<li>Validate with <a href="https://search.google.com/test/rich-results" target="_blank" style="color: #007bff; text-decoration: underline;">Google Rich Results Test</a></li>';
    summaryHtml += '</ul>';
    summaryHtml += '</div>';
    
    summaryHtml += '<div style="text-align: center; margin-top: 1.5rem;">';
    summaryHtml += '<button onclick="document.querySelector(\'#detail-modal\').remove()" style="padding: 0.75rem 2rem; background: #27AE60; color: white; border: none; border-radius: 6px; font-size: 1rem; font-weight: 600; cursor: pointer;">';
    summaryHtml += 'Got it!';
    summaryHtml += '</button>';
    summaryHtml += '</div>';
    summaryHtml += '</div>';
    
    openModal('üéâ Workflow Complete!', summaryHtml);
  }

  function codeBlock(label, code) {
    return `
      <div class="code-card">
        <div class="code-card-head">
          <strong>${label}</strong>
          <button class="copy-btn" data-code="${encodeURIComponent(code)}">Copy</button>
        </div>
        <pre><code>${escapeHtml(code)}</code></pre>
      </div>`;
  }

  function escapeHtml(s) {
    return (s || '').replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
  }

  // Copy button handler
  document.addEventListener('click', (e) => {
    const copy = e.target.closest('.copy-btn');
    if (!copy) return;
    const code = decodeURIComponent(copy.dataset.code || '');
    navigator.clipboard.writeText(code).then(() => { 
      copy.textContent = 'Copied'; 
      setTimeout(() => copy.textContent = 'Copy', 1200); 
    });
  });

  // Minimal extractor: same logic you use in the scanner, but HTML-in
  function extractJsonLdBlocksFromHtml(html) {
    const blocks = [];
    const re = /<script[^>]+type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi;
    let m;
    while ((m = re.exec(html))) {
      try {
        const json = JSON.parse(m[1].trim());
        if (Array.isArray(json)) json.forEach(j => blocks.push(j));
        else if (json['@graph']) json['@graph'].forEach(j => blocks.push(j));
        else blocks.push(json);
      } catch {}
    }
    return blocks;
  }

  // Build a single, cleaned-up, recommended schema graph
  function buildEnhancedSchema(blocks) {
    const graph = [];
    const types = t => Array.isArray(t) ? t : [t].filter(Boolean);
    const seen = new Set();
    const add = (node) => {
      const key = JSON.stringify([types(node['@type']).sort(), node['@id'] || node.url || node.name]);
      if (seen.has(key)) return;
      seen.add(key);
      graph.push(node);
    };

    // Merge Organization/LocalBusiness
    const org = {
      '@type': ['Organization','LocalBusiness'],
      '@id': 'https://www.alanranger.com/#org',
      name: 'Alan Ranger Photography',
      url: 'https://www.alanranger.com/',
      telephone: '+44 7817 017994',
      image: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w'
    };

    // Keep existing ItemList/Event/etc., but ensure @id where missing
    blocks.forEach(b => {
      const ts = types(b['@type']);
      if (ts.includes('Organization') || ts.includes('LocalBusiness')) {
        // prefer our canonical org baseline merged
        return;
      }
      if (!b['@id'] && (b.url || b.name)) b['@id'] = (b.url || `#${(b.name||'node').toLowerCase().replace(/\s+/g,'-')}`);
      add(b);
    });

    add(org);

    return { '@context': 'https://schema.org', '@graph': graph };
  }

  // Event delegation for View Details and Generate Enhanced buttons
  document.addEventListener('click', async (e) => {
      // View Details - use new improved modal
      const view = e.target.closest('.btn-view-details, [data-action="view-details"], .view-details-btn');
      if (view) {
        const row = view.closest('tr');
        if (!row) return;
        const rowData = getRowDataFromTr(row);
        openIssuesModal(rowData);
        return;
      }

    // Generate Enhanced
    const gen = e.target.closest('.btn-generate-enhanced, [data-action="generate-enhanced"], .enhance-btn');
    if (gen && (gen.textContent.includes('Generate Enhanced') || gen.id?.includes('genBtn'))) {
      const row = gen.closest('tr');
      const url = row?.dataset?.url || row?.querySelector('a.url-link')?.href;
      if (!url) {
        alert('Could not determine URL for this row.');
        return;
      }
      
      try {
        // Update button state
        const originalText = gen.textContent;
        gen.disabled = true;
        gen.textContent = 'Fetching...';
        
        // Server-side fetch (avoids CORS)
        const res = await fetch(`/api/fetch-html?url=${encodeURIComponent(url)}`, { method: 'GET' });
        if (!res.ok) throw new Error(`Server fetch failed: ${res.status}`);
        const html = await res.text();

        // Extract JSON-LD blocks from HTML
        const blocks = extractJsonLdBlocksFromHtml(html);
        // Build an enhanced consolidated schema suggestion
        const enhanced = buildEnhancedSchema(blocks);

        gen.textContent = originalText;
        gen.disabled = false;
        
        // Use the proper Enhanced Schema modal instead of openModal
        const backdrop = document.getElementById('genBackdrop');
        const metaEl = document.getElementById('genMeta');
        const jsonEl = document.getElementById('genJson');
        const titleEl = document.getElementById('genTitle');
        if (backdrop && metaEl && jsonEl && titleEl) {
          titleEl.textContent = 'Enhanced Schema (suggestion)';
          metaEl.textContent = url;
          jsonEl.textContent = JSON.stringify(enhanced, null, 2);
          // Store URL and JSON for save function
          backdrop.dataset.url = url;
          backdrop.dataset.json = JSON.stringify(enhanced, null, 2);
          backdrop.style.display = 'flex';
          setupCopyButton();
          setupSaveButton();
        } else {
          openModal('Enhanced Schema (suggestion)', codeBlock('Paste this in a single <script type="application/ld+json">', JSON.stringify(enhanced, null, 2)));
        }
      } catch (err) {
        gen.textContent = originalText;
        gen.disabled = false;
        alert(`Enhanced Schema Error: ${escapeHtml(err.message)}\n\nTip: server route must exist at /api/fetch-html.`);
      }
    }
  });
  
  // Helper: Collect existing schema types from the page
  function collectExistingSchemaTypes(jsonLdBlocks) {
    const types = new Set();
    
    if (!jsonLdBlocks || !Array.isArray(jsonLdBlocks)) {
      return [];
    }
    
    jsonLdBlocks.forEach(block => {
      try {
        // Handle @graph structure
        if (block['@graph'] && Array.isArray(block['@graph'])) {
          block['@graph'].forEach(item => {
            if (item['@type']) {
              const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
              itemTypes.forEach(t => types.add(t));
            }
          });
        }
        // Handle array of schemas
        else if (Array.isArray(block)) {
          block.forEach(item => {
            if (item['@type']) {
              const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
              itemTypes.forEach(t => types.add(t));
            }
          });
        }
        // Handle single schema object
        else if (block['@type']) {
          const blockTypes = Array.isArray(block['@type']) ? block['@type'] : [block['@type']];
          blockTypes.forEach(t => types.add(t));
        }
      } catch (e) {
        console.warn('Invalid JSON-LD block ignored:', e);
      }
    });
    
    return Array.from(types);
  }

  // Helper: Determine required schema types based on missing fields
  function determineRequiredSchemaTypes(missingFields, missingRecommended, existingTypes = []) {
    const globalTypes = ['Organization', 'LocalBusiness', 'Person', 'Service', 'WebSite', 'BreadcrumbList'];
    
    // Check which global types already exist
    const existingGlobalTypes = existingTypes.filter(t => globalTypes.includes(t));
    
    const needsOrg = missingFields.some(f => f.includes('Organization')) || 
                    missingRecommended.some(f => f.includes('Organization') || f.includes('url') || f.includes('logo'));
    const needsLocal = missingFields.some(f => f.includes('LocalBusiness')) || 
                       missingRecommended.some(f => f.includes('LocalBusiness') || f.includes('address') || f.includes('telephone'));
    const needsWebSite = missingFields.some(f => f.includes('WebSite')) || 
                         missingRecommended.some(f => f.includes('WebSite'));
    
    const types = [];
    
    // Only add Organization if it doesn't already exist
    if ((needsOrg || needsLocal) && !existingGlobalTypes.includes('Organization')) {
      types.push('Organization');
    }
    
    // Only add LocalBusiness if it doesn't already exist
    if (needsLocal && !existingGlobalTypes.includes('LocalBusiness')) {
      types.push('LocalBusiness');
    }
    
    // Only add WebSite if it doesn't already exist
    if (needsWebSite && !existingGlobalTypes.includes('WebSite')) {
      types.push('WebSite');
    }
    
    // Don't add default types if global schemas already exist
    if (types.length === 0 && existingGlobalTypes.length === 0) {
      types.push('Organization', 'LocalBusiness');
    }
    
    return types;
  }

  // Helper: Add recommended fields to fix object
  function addRecommendedFieldsToFix(fix, missingRecommended, baseUrl) {
    if (missingRecommended.includes('url')) {
      fix["url"] = baseUrl;
    }
    if (missingRecommended.includes('logo')) {
      fix["logo"] = "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w";
    }
    if (missingRecommended.includes('image')) {
      fix["image"] = fix["logo"] || "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w";
    }
    if (missingRecommended.includes('description')) {
      fix["description"] = "UK Landscape Photography Workshops, Private Tuition, and Online Classes by Alan Ranger, Qualified Tutor and Professional Photographer.";
    }
    if (missingRecommended.includes('address')) {
      fix["address"] = {
        "@type": "PostalAddress",
        "streetAddress": "45 Hathaway Road, Tile Hill Village",
        "addressLocality": "Coventry",
        "addressRegion": "West Midlands",
        "postalCode": "CV4 9HW",
        "addressCountry": "GB"
      };
    }
    if (missingRecommended.includes('telephone')) {
      fix["telephone"] = "+44 7817 017994";
    }
    if (missingRecommended.includes('sameAs')) {
      fix["sameAs"] = [
        "https://www.facebook.com/alanrangerphotography",
        "https://www.instagram.com/alanrangerphoto",
        "https://www.youtube.com/@alanrangerphotography"
      ];
    }
  }

  // Helper: Build recommended fix based on missing fields
  function buildRecommendedFix(url, missingFields = [], missingRecommended = [], existingTypes = []) {
    const baseUrl = url.split('#')[0];
    
    const types = determineRequiredSchemaTypes(missingFields, missingRecommended, existingTypes);
    
    // If no types to add (all global types already exist), return null
    if (types.length === 0) {
      return null;
    }
    
    const fix = {
      "@context": "https://schema.org"
    };
    
    fix["@type"] = types.length === 1 ? types[0] : types;
    fix["@id"] = `${baseUrl}#org`;
    fix["name"] = "Alan Ranger Photography";
    
    // Add url if missing
    if (missingRecommended.includes('url') || missingFields.some(f => f.includes('url'))) {
      fix["url"] = baseUrl;
    }
    
    // Add recommended fields
    addRecommendedFieldsToFix(fix, missingRecommended, baseUrl);
    
    // Add address if missing (for LocalBusiness)
    const needsLocal = types.includes('LocalBusiness');
    if (needsLocal && (missingRecommended.includes('address') || missingFields.some(f => f.includes('address')))) {
      if (!fix["address"]) {
        fix["address"] = {
          "@type": "PostalAddress",
          "streetAddress": "45 Hathaway Road, Tile Hill Village",
          "addressLocality": "Coventry",
          "addressRegion": "West Midlands",
          "postalCode": "CV4 9HW",
          "addressCountry": "GB"
        };
      }
    }
    
    return JSON.stringify(fix, null, 2);
  }

  function getRecommendedSchema(url, existingTypes = []) {
    // Use the new buildRecommendedFix function for consistency
    return buildRecommendedFix(url, [], [], existingTypes);
  }

  // Helper: Parse issues list from rowData
  function parseIssuesList(rowData) {
    let issuesList = [];
    try {
      if (rowData.tr && rowData.tr.dataset.issuesList) {
        issuesList = JSON.parse(rowData.tr.dataset.issuesList);
      } else if (rowData.issuesList) {
        issuesList = rowData.issuesList;
      } else if (rowData.tr && rowData.tr.dataset.missingDetail) {
        const missing = JSON.parse(rowData.tr.dataset.missingDetail);
        issuesList = missing.map(m => ({ message: m, type: 'Unknown' }));
      } else if (rowData.missingFields) {
        const missing = Array.isArray(rowData.missingFields) ? rowData.missingFields : String(rowData.missingFields).split(',').map(s => s.trim()).filter(Boolean);
        issuesList = missing.map(m => ({ message: m, type: 'Unknown' }));
      }
    } catch (err) {
      console.warn('Failed to parse issues data:', err);
    }
    return issuesList;
  }

  // Helper: Determine severity badge from issues
  function determineSeverityBadge(issueCount, duplicates) {
    if (duplicates.length > 2 || issueCount > 3) {
      return { severity: 'critical', badgeColor: 'severity-badge critical', badgeLabel: '‚ùå Critical' };
    }
    if (issueCount > 0 || duplicates.length > 0) {
      return { severity: 'warning', badgeColor: 'severity-badge warning', badgeLabel: '‚ö†Ô∏è Issues' };
    }
    return { severity: 'passed', badgeColor: 'severity-badge passed', badgeLabel: '‚úÖ Passed' };
  }

  // Helper: Build human-readable summary for modal
  function buildHumanReadableSummary(blockCount, schemaTypes, duplicates, missingFieldsBadges) {
    const parts = [];
    
    if (blockCount > 0) {
      parts.push(`Found ${blockCount} JSON-LD block${blockCount !== 1 ? 's' : ''}`);
    }
    
    if (schemaTypes && schemaTypes.length > 0) {
      const typesList = Array.isArray(schemaTypes) ? schemaTypes.join(', ') : schemaTypes;
      const uniqueTypesCount = Array.isArray(schemaTypes) ? schemaTypes.length : (schemaTypes.split(',').map(t => t.trim()).filter(Boolean).length);
      parts.push(`${uniqueTypesCount} unique schema type${uniqueTypesCount !== 1 ? 's' : ''}: ${typesList}`);
    }
    
    // Only show duplicate count for non-multi-instance types
    if (duplicates && duplicates.length > 0) {
      const nonMultiInstanceDuplicates = duplicates.filter(d => !MULTI_INSTANCE_ALLOWED_TYPES.includes(d));
      if (nonMultiInstanceDuplicates.length > 0) {
        parts.push(`${nonMultiInstanceDuplicates.length} duplicate${nonMultiInstanceDuplicates.length !== 1 ? 's' : ''} detected`);
      }
    }
    
    if (missingFieldsBadges && missingFieldsBadges.length > 0) {
      parts.push(`${missingFieldsBadges.length} missing field${missingFieldsBadges.length !== 1 ? 's' : ''}`);
    }
    
    return parts.length > 0 ? parts.join('. ') : 'No schema data available.';
  }

  // Helper: Build schema table HTML for modal
  function buildSchemaTableHtml(result) {
    if (!result || !result.schemas || result.schemas.length === 0) {
      return '';
    }
    
    let tableHtml = `
      <div style="margin-top: 1.5rem;">
        <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 600;">Detected Schema Nodes</h4>
        <table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
          <thead>
            <tr style="background: #f3f4f6; border-bottom: 2px solid #d1d5db;">
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Type</th>
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">@id</th>
              <th style="padding: 0.5rem; text-align: left; font-weight: 600;">Name</th>
            </tr>
          </thead>
          <tbody>
    `;
    
    for (const s of result.schemas) {
      const schema = s.schema || {};
      const isSystem = s.systemInjected ? 'system-node' : '';
      const typeDisplay = Array.isArray(s.type) ? s.type.join(', ') : s.type;
      const idDisplay = schema['@id'] || '‚Äî';
      const nameDisplay = schema.name || '‚Äî';
      
      tableHtml += `
        <tr class="${isSystem}" style="border-bottom: 1px solid #e5e7eb;">
          <td style="padding: 0.5rem;">${typeDisplay}</td>
          <td style="padding: 0.5rem;">${idDisplay}</td>
          <td style="padding: 0.5rem;">${nameDisplay}</td>
        </tr>
      `;
    }
    
    tableHtml += `
          </tbody>
        </table>
      </div>
    `;
    
    return tableHtml;
  }

  // Helper: Check if Organization nodes need recommended fix
  function checkOrganizationNodesForFix(result, missingFieldsBadges, existingTypes = []) {
    const globalTypes = ['Organization', 'LocalBusiness', 'Person', 'Service', 'WebSite', 'BreadcrumbList'];
    const existingGlobalTypes = existingTypes.filter(t => globalTypes.includes(t));
    
    // If global types already exist, don't show recommended fix
    if (existingGlobalTypes.length > 0) {
      return { shouldShowRecommendedFix: false, hasValidOrgNode: true, existingGlobalTypes };
    }
    
    let shouldShowRecommendedFix = false;
    let hasValidOrgNode = false;
    
    if (result && result.schemas) {
      const orgSchemas = result.schemas.filter(s => s.type === 'Organization' || (Array.isArray(s.type) && s.type.includes('Organization')));
      if (orgSchemas.length > 0) {
        const allMissingRequired = orgSchemas.every(s => {
          const schema = s.schema || {};
          const hasName = schema.name && schema.name.trim();
          const hasUrl = schema.url && schema.url.trim();
          const hasId = schema['@id'] && schema['@id'].trim();
          return !hasName && !hasUrl && !hasId;
        });
        hasValidOrgNode = orgSchemas.some(s => {
          const schema = s.schema || {};
          return schema.name && schema.name.trim();
        });
        shouldShowRecommendedFix = allMissingRequired && !hasValidOrgNode;
      } else {
        shouldShowRecommendedFix = true;
      }
    } else {
      const orgMissingFields = missingFieldsBadges.filter(m => m.type === 'Organization');
      const orgMissingRequired = orgMissingFields.some(m => ['name', 'url'].includes(m.field));
      shouldShowRecommendedFix = orgMissingRequired && orgMissingFields.length > 0;
    }
    
    return { shouldShowRecommendedFix, hasValidOrgNode, existingGlobalTypes: [] };
  }

  // Helper: Build recommended fix HTML
  function buildRecommendedFixHtml(shouldShowRecommendedFix, hasValidOrgNode, recommendedFix, existingGlobalTypes = []) {
    if (shouldShowRecommendedFix && recommendedFix) {
      return `
        <div class="recommended-fix-card">
          <h4>Recommended Fix (for Squarespace footer injection)</h4>
          <p>Copy and paste the following schema block into your Squarespace <strong>Settings ‚Üí Advanced ‚Üí Code Injection ‚Üí Footer</strong> section.</p>
          <textarea class="recommended-fix-textarea" readonly id="recommendedSchemaText">${recommendedFix}</textarea>
          <button class="copy-schema-btn" id="copySchemaBtn">üìã Copy Recommended Schema</button>
        </div>
      `;
    }
    if (hasValidOrgNode || existingGlobalTypes.length > 0) {
      const globalTypesList = existingGlobalTypes.length > 0 
        ? existingGlobalTypes.join(', ')
        : 'Organization';
      return `
        <div class="recommended-fix-card" style="background: #f0fdf4; border-color: #10b981;">
          <h4 style="color: #065f46;">‚úÖ Detected global schema types ‚Äî no extra injection required</h4>
          <p style="color: #047857;">Found existing ${globalTypesList} schema${existingGlobalTypes.length > 1 ? 's' : ''} on this page. Your global schema structure is correct. Recommendations will only appear for missing page-specific types (Product, Event, Article, Course, etc.).</p>
        </div>
      `;
    }
    return '';
  }

  // Helper: Setup modal button handlers
  function setupModalButtonHandlers(recommendedFix, json, jsonDetails, rowData) {
    const copyBtn = document.getElementById('copySchemaBtn');
    if (copyBtn) {
      copyBtn.onclick = () => {
        const textarea = document.getElementById('recommendedSchemaText');
        textarea.select();
        navigator.clipboard.writeText(recommendedFix).then(() => {
          copyBtn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            copyBtn.textContent = 'üìã Copy Recommended Schema';
          }, 2000);
        }).catch(err => {
          console.error('Failed to copy:', err);
          copyBtn.textContent = '‚ùå Copy Failed';
          setTimeout(() => {
            copyBtn.textContent = 'üìã Copy Recommended Schema';
          }, 2000);
        });
      };
    }
    
    json.textContent = (rowData.firstJsonLd || '').trim();
    jsonDetails.style.display = rowData.firstJsonLd ? 'block' : 'none';
    
    const copyJsonBtn = document.getElementById('issuesCopyJsonBtn');
    if (copyJsonBtn) {
      copyJsonBtn.onclick = async () => {
        const jsonText = json.textContent.trim();
        if (!jsonText) {
          alert('No JSON-LD content to copy');
          return;
        }
        try {
          await navigator.clipboard.writeText(jsonText);
          copyJsonBtn.textContent = '‚úÖ Copied!';
          setTimeout(() => {
            copyJsonBtn.textContent = 'Copy JSON-LD';
          }, 2000);
        } catch (err) {
          const textarea = document.createElement('textarea');
          textarea.value = jsonText;
          textarea.style.position = 'fixed';
          textarea.style.opacity = '0';
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand('copy');
            copyJsonBtn.textContent = '‚úÖ Copied!';
            setTimeout(() => {
              copyJsonBtn.textContent = 'Copy JSON-LD';
            }, 2000);
          } catch (e) {
            alert('Failed to copy. Please select and copy manually.');
          }
          textarea.remove();
        }
      };
    }
  }

  // ---- Issues modal helpers ----
  function openIssuesModal(rowData) {
    const backdrop = document.getElementById('issuesBackdrop');
    const meta = document.getElementById('issuesMeta');
    const content = document.getElementById('issuesContent');
    const list = document.getElementById('issuesList');
    const json = document.getElementById('issuesJson');
    const jsonDetails = document.getElementById('issuesJsonDetails');
    const btnSchema = document.getElementById('issuesSchemaOrgBtn');
    const btnGoogle = document.getElementById('issuesGoogleBtn');
    const closeBtn = document.getElementById('issuesCloseBtn');
    const closeXBtn = document.getElementById('issuesCloseXBtn');
    
    // Get cached result data
    const cachedData = ResultCache.get(rowData.url) || {};
    const rowIndex = rowData.tr ? Array.from(rowData.tr.parentNode.children).indexOf(rowData.tr) : -1;
    const result = rowIndex >= 0 ? validationResults[rowIndex] : null;
    
    // Merge cached data with validation result
    const blocks = cachedData.blocks || result?.schemas?.map(s => s.schema).filter(Boolean) || [];
    const issuesList = parseIssuesList(rowData);
    const missingFields = result?.missingFields || cachedData.warnings?.filter(w => w.includes('missing')) || [];
    const warnings = result?.warnings || cachedData.warnings || [];
    const info = result?.info || cachedData.info || [];
    
    meta.textContent = `${rowData.url} ¬∑ Types: ${rowData.schemaType || 'None'}`;
    content.innerHTML = '';
    list.innerHTML = '';
    
    const missingFieldsBadges = result?.missingFieldsBadges || [];
    // Filter duplicates to exclude multi-instance allowed types
    const duplicates = issuesList
      .filter(i => i.message && i.message.includes('DUPLICATE'))
      .map(i => i.type)
      .filter(type => !MULTI_INSTANCE_ALLOWED_TYPES.includes(type));
    const schemaTypes = rowData.schemaType ? rowData.schemaType.split(', ') : (cachedData.schemaTypes || []);
    const issueCount = issuesList.filter(i => i.message && i.message.includes('missing')).length;
    // Use actual block count from result or cached data
    const blockCount = result?.blockCount || blocks.length || result?.schemas?.length || 0;
    
    // Get inferred types from result
    const inferredTypes = result?.inferredTypes || [];
    
    // Collect existing schema types from blocks
    const existingTypes = collectExistingSchemaTypes(blocks);
    
    const severityBadge = determineSeverityBadge(issueCount, duplicates);
    const humanReadableSummary = buildHumanReadableSummary(blockCount, schemaTypes, duplicates, missingFieldsBadges);
    const orgFixCheck = checkOrganizationNodesForFix(result, missingFieldsBadges, existingTypes);
    
    // Build inferred types HTML section
    let inferredTypesHtml = '';
    if (inferredTypes.length > 0) {
      inferredTypesHtml = `
        <div style="margin-top: 1.5rem; padding: 1rem; background: #f9fafb; border-radius: 8px; border-left: 4px solid #6b7280;">
          <h4 style="margin: 0 0 0.75rem 0; font-size: 1rem; font-weight: 600; color: #374151;">Inferred Structured Data Types</h4>
          <p style="margin: 0 0 0.75rem 0; font-size: 0.875rem; color: #6b7280;">Based on schema relationships and patterns:</p>
          <ul style="margin: 0; padding-left: 1.5rem; list-style: disc;">
            ${inferredTypes.map(item => `<li style="margin-bottom: 0.5rem;"><strong>${item.type}</strong> (${item.reason})</li>`).join('')}
          </ul>
        </div>
      `;
    }
    
    // Extract missing recommended fields from warnings
    const missingRecommended = warnings.filter(w => w.includes('Missing recommended:')).map(w => {
      const match = w.match(/Missing recommended: (\w+)/);
      return match ? match[1] : null;
    }).filter(Boolean);
    
    // Extract missing required fields
    const missingRequiredFields = missingFields.filter(f => typeof f === 'string' && f.includes('missing')).map(f => {
      const match = f.match(/(\w+):\s*"(\w+)"\s*missing/);
      return match ? `${match[1]}.${match[2]}` : null;
    }).filter(Boolean);
    
    // Build recommended fix using the new function with existing types
    const recommendedFix = buildRecommendedFix(rowData.url, missingRequiredFields, missingRecommended, existingTypes);
    const recommendedFixHtml = buildRecommendedFixHtml(
      orgFixCheck.shouldShowRecommendedFix || (missingRecommended.length > 0 && recommendedFix !== null), 
      orgFixCheck.hasValidOrgNode, 
      recommendedFix,
      orgFixCheck.existingGlobalTypes || []
    );
    const schemaTableHtml = buildSchemaTableHtml(result);
    
    // Build issues list HTML
    let issuesHtml = '';
    if (issuesList.length === 0 && missingFields.length === 0 && warnings.length === 0) {
      issuesHtml = '<li>None</li>';
    } else {
      if (missingFields.length > 0) {
        issuesHtml += missingFields.map(f => `<li class="missing-entry">‚ùå ${f}</li>`).join('');
      }
      if (warnings.length > 0) {
        issuesHtml += warnings.map(w => `<li class="warning-entry">‚ö†Ô∏è ${w}</li>`).join('');
      }
      if (info.length > 0) {
        issuesHtml += info.map(i => `<li class="info-entry">${i}</li>`).join('');
      }
    }
    
    // Show JSON-LD blocks if available
    let jsonLdHtml = '';
    if (blocks.length > 0) {
      jsonDetails.style.display = 'none'; // Hide the old single block display
      const blocksHtml = blocks.map((block, idx) => {
        const blockJson = JSON.stringify(block, null, 2);
        return `
          <div class="json-block-card" style="margin-bottom: 1rem; border: 1px solid #e2e8f0; border-radius: 8px; overflow: hidden;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem; background: #f7fafc; border-bottom: 1px solid #e2e8f0;">
              <h5 style="margin: 0; font-size: 0.9rem; font-weight: 600;">JSON-LD Block #${idx + 1}</h5>
              <button class="copy-block-btn secondary" data-block-index="${idx}" style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: #2563eb; color: white; border-color: #2563eb; cursor: pointer; border-radius: 4px;">üìã Copy Block ${idx + 1}</button>
            </div>
            <pre style="margin: 0; padding: 1rem; background: #000; color: #fff; overflow-x: auto; font-size: 0.85rem; max-height: 400px; overflow-y: auto;">${escapeHtml(blockJson)}</pre>
          </div>
        `;
      }).join('');
      
      jsonLdHtml = `
        <div style="margin-top: 1.5rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <h4 style="margin: 0; font-size: 1rem; font-weight: 600;">JSON-LD Blocks (${blocks.length})</h4>
            <button class="copy-all-blocks-btn secondary" style="font-size: 0.85rem; padding: 0.4rem 0.8rem; background: #2563eb; color: white; border-color: #2563eb; cursor: pointer;">üìã Copy All Blocks</button>
          </div>
          ${blocksHtml}
        </div>
      `;
      
      // Store blocks data for copy functionality
      backdrop.dataset.blocksJson = JSON.stringify(blocks);
    } else {
      jsonDetails.style.display = 'none';
      jsonLdHtml = '<p style="color: #6b7280; font-style: italic; margin-top: 1.5rem;">No JSON-LD blocks captured.</p>';
    }
    
    content.innerHTML = `
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 1rem;">
        <h3 style="margin: 0; font-size: 1.25rem; font-weight: 600;">Schema Analysis Summary</h3>
        <span class="${severityBadge.badgeColor}">${severityBadge.badgeLabel}</span>
      </div>
      
      <div class="summary-card">
        <pre>${humanReadableSummary.trim()}</pre>
      </div>
      
      <div style="margin-top: 1.5rem;">
        <h4 style="margin-bottom: 0.75rem; font-size: 1rem; font-weight: 600;">Issues</h4>
        <ul class="issues-list" style="list-style: none; padding: 0; margin: 0;">
          ${issuesHtml || '<li>None</li>'}
        </ul>
      </div>
      
      ${recommendedFixHtml}
      
      ${inferredTypesHtml}
      
      ${schemaTableHtml}
      
      ${jsonLdHtml}
      
      <div class="help-link">
        ${orgFixCheck.shouldShowRecommendedFix ? '<p>Need help implementing this? ' : ''}
        ${orgFixCheck.shouldShowRecommendedFix ? '<a href="https://support.squarespace.com/hc/en-us/articles/206543167" target="_blank">View Squarespace injection guide</a></p>' : ''}
        <p style="margin-top: 0.5rem; font-style: italic; color: #6b7280;">
          Diagnostic: ${issueCount} missing field${issueCount !== 1 ? 's' : ''}${duplicates.length > 0 ? `, ${duplicates.length} duplicate type${duplicates.length !== 1 ? 's' : ''} detected` : ''}${result?.multiInstanceCounts && Object.keys(result.multiInstanceCounts).length > 0 ? `. ${Object.entries(result.multiInstanceCounts).map(([type, count]) => `${count} ${type}${count !== 1 ? 's' : ''}`).join(', ')} detected (expected)` : ''}.
        </p>
      </div>
    `;
    
    setupModalButtonHandlers(recommendedFix, json, jsonDetails, rowData);
    
    btnSchema.onclick = () => globalThis.open('https://validator.schema.org/?url=' + encodeURIComponent(rowData.url), '_blank');
    btnGoogle.onclick = () => globalThis.open('https://search.google.com/test/rich-results?url=' + encodeURIComponent(rowData.url), '_blank');
    
    function close() {
      backdrop.close();
      document.removeEventListener('keydown', esc);
    }
    function esc(e) {
      if (e.key === 'Escape') close();
    }
    closeBtn.onclick = close;
    if (closeXBtn) {
      closeXBtn.onclick = close;
    }
    backdrop.onclick = (e) => {
      if (e.target === backdrop) close();
    };
    backdrop.showModal();
    
    // Setup copy button handlers after modal is opened and content is rendered
    setTimeout(() => {
      // Copy individual block buttons
      const copyBlockBtns = backdrop.querySelectorAll('.copy-block-btn');
      console.log(`Found ${copyBlockBtns.length} copy block buttons`);
      copyBlockBtns.forEach(btn => {
        btn.onclick = () => {
          const blockIndex = parseInt(btn.dataset.blockIndex);
          const blocksData = JSON.parse(backdrop.dataset.blocksJson || '[]');
          if (blocksData[blockIndex]) {
            const blockJson = JSON.stringify(blocksData[blockIndex], null, 2);
            navigator.clipboard.writeText(blockJson).then(() => {
              btn.textContent = '‚úÖ Copied!';
              setTimeout(() => {
                btn.textContent = `üìã Copy Block ${blockIndex + 1}`;
              }, 2000);
            }).catch(() => {
              alert('Failed to copy. Please select and copy manually.');
            });
          }
        };
      });
      
      // Copy all blocks button
      const copyAllBtn = backdrop.querySelector('.copy-all-blocks-btn');
      console.log(`Copy all blocks button found: ${!!copyAllBtn}`);
      if (copyAllBtn) {
        copyAllBtn.onclick = () => {
          const blocksData = JSON.parse(backdrop.dataset.blocksJson || '[]');
          const allBlocksJson = JSON.stringify(blocksData, null, 2);
          navigator.clipboard.writeText(allBlocksJson).then(() => {
            copyAllBtn.textContent = '‚úÖ All Copied!';
            setTimeout(() => {
              copyAllBtn.textContent = 'üìã Copy All Blocks';
            }, 2000);
          }).catch(() => {
            alert('Failed to copy. Please select and copy manually.');
          });
        };
      } else {
        console.warn('Copy all blocks button not found in modal');
      }
    }, 300);
  }
  
  // Build a minimal rowData snapshot from a <tr>
  function getRowDataFromTr(tr) {
    const tds = tr.querySelectorAll('td');
    const url = tds[0]?.querySelector('a')?.href || tds[0]?.textContent?.trim() || '';
    // keep a handle to <tr> so we can read dataset fields
    const trRef = tr;
    const schemaType = tds[1]?.textContent?.trim() || '';
    const missing = tds[3]?.textContent?.trim() || '';
    // store first JSON-LD snippet in a dataset if available when row was computed
    const firstJson = tr.dataset.firstJsonld || '';
    // Get index from row to find validation result
    const rowIndex = Array.from(tr.parentNode.children).indexOf(tr);
    const result = validationResults[rowIndex];
    
    let issuesList = [];
    if (result && result.issuesList) {
      issuesList = result.issuesList;
    } else if (tr.dataset.issuesList) {
      try {
        issuesList = JSON.parse(tr.dataset.issuesList);
      } catch (e) {
        console.warn('Failed to parse issuesList:', e);
      }
    }
    
    let missingFields;
    if (result && result.missingFields) {
      missingFields = result.missingFields;
    } else if (missing) {
      missingFields = missing.split(',').map(s => s.trim()).filter(Boolean);
    } else {
      missingFields = [];
    }
    
    return { 
      url, 
      schemaType, 
      missingFields: missingFields, 
      firstJsonLd: firstJson, 
      tr: trRef, 
      issuesList,
      schemaSummary: result && result.schemaSummary ? result.schemaSummary : null
    };
  }
  
  // ---- Schema core fields (minimal, safe set) ----
  const CORE_REQUIRED = {
    WebSite:      ["name", "url"],
    Organization: ["name"],
    LocalBusiness:["name"]   // keep minimal; address/telephone vary a lot
  };
  
  // Flatten any JSON-LD object/array/@graph into a list of typed nodes
  function flattenJsonLd(node, out = []) {
    if (!node) return out;
    if (Array.isArray(node)) { node.forEach(n=>flattenJsonLd(n, out)); return out; }
    if (node['@graph']) { flattenJsonLd(node['@graph'], out); }
    if (node['@type']) out.push(node);
    return out;
  }
  
  // Build a map: type -> array of nodes for that type
  function indexByType(nodes) {
    const idx = {};
    nodes.forEach(n => {
      const types = Array.isArray(n['@type']) ? n['@type'] : [n['@type']];
      types.forEach(t => {
        (idx[t] ||= []).push(n);
      });
    });
    return idx;
  }
  
  // Helper: Check if field is missing for a node
  function isFieldMissing(node, field) {
    return !node.hasOwnProperty(field) || !node[field];
  }

  // Helper: Check if message already exists for this type+field+key combination
  function isAlreadyFlagged(messages, type, field, key) {
    return messages.some(m => m.type === type && m.field === field && m.key === key);
  }

  // Helper: Check if node is system-injected (Squarespace auto-generated)
  function isSystemInjectedNode(type, node) {
    return type === 'Organization' && 
      !node['@id'] && 
      (!node.name || !node.name.trim()) && 
      (!node.url || !node.url.trim());
  }

  // Helper: Process required fields for a node group
  function processRequiredFieldsForNode(messages, type, field, key, firstNode, instances) {
    if (isFieldMissing(firstNode, field) && !isAlreadyFlagged(messages, type, field, key)) {
      messages.push({ 
        type: type, 
        field: field, 
        nodeIndex: instances[0].index,
        key: key,
        instances: instances.length,
        hasId: !!firstNode['@id'],
        systemInjected: isSystemInjectedNode(type, firstNode)
      });
    }
  }

  // Inspect which types are present and which required fields are missing per type
  function computeMissingFields(allNodes) {
    const idx = indexByType(allNodes);
    const messages = [];
    
    Object.keys(idx).forEach(t => {
      if (!CORE_REQUIRED[t]) return;
      
      const required = CORE_REQUIRED[t];
      const nodesByKey = {};
      
      idx[t].forEach((n, nodeIndex) => {
        const key = n['@id'] || JSON.stringify([n['@type'], n.url, n.name]).slice(0, 100);
        if (!nodesByKey[key]) nodesByKey[key] = [];
        nodesByKey[key].push({ node: n, index: nodeIndex });
      });
      
      Object.keys(nodesByKey).forEach(key => {
        const instances = nodesByKey[key];
        const firstNode = instances[0].node;
        
        if (isSystemInjectedNode(t, firstNode)) {
          return;
        }
        
        required.forEach(req => {
          processRequiredFieldsForNode(messages, t, req, key, firstNode, instances);
        });
      });
    });
    
    return messages;
  }
  
  // Try to find a candidate value for a field in OTHER types (so we can suggest)
  function findFieldElsewhere(allNodes, field, exceptType) {
    for (const n of allNodes) {
      const types = Array.isArray(n['@type']) ? n['@type'] : [n['@type']];
      if (types.includes(exceptType)) continue;
      if (n[field]) return { fromType: types.join(','), value: (''+n[field]).slice(0,120) };
    }
    return null;
  }
  
  // ---------- Enhanced Schema Builder ----------
  const asArray = v => Array.isArray(v) ? v : (v ? [v] : []);
  const uniq = arr => [...new Set(arr)];
  function firstNonEmpty(...vals){ for(const v of vals){ if(typeof v==='string' && v.trim()) return v.trim(); } return ''; }
  
  function pageMeta(doc, url){
    const get = s => doc.querySelector(s)?.getAttribute('content') || '';
    return {
      url,
      title: doc.querySelector('h1')?.textContent?.trim() || doc.title || '',
      ogTitle: get('meta[property="og:title"]'),
      ogDesc: get('meta[property="og:description"]'),
      ogImage: get('meta[property="og:image"]'),
      logo: get('meta[itemprop="logo"]') || get('meta[property="og:logo"]') || '',
      siteName: get('meta[property="og:site_name"]')
    };
  }
  
  function ensureId(node, baseUrl, suffix){
    if (!node['@id']) node['@id'] = baseUrl.replace(/#.*$/,'') + '#' + suffix;
    return node;
  }
  
  function dedupeById(nodes){
    const map = new Map();
    nodes.forEach(n=>{
      const key = n['@id'] || JSON.stringify([n['@type'], n.name, n.url]);
      if (!map.has(key)) map.set(key, n);
    });
    return [...map.values()];
  }
  
  function prettyScript(json){
    return `<script type="application/ld+json">\n${JSON.stringify(json, null, 2)}\n<\/script>`;
  }
  
  function buildBreadcrumbs(doc, url){
    // 1) Try semantic breadcrumbs in DOM
    let items = [];
    const nav = doc.querySelector('nav[aria-label="breadcrumb"], .breadcrumbs, ol.breadcrumb, ul.breadcrumb');
    if (nav){
      const links = nav.querySelectorAll('a, [itemprop="item"]');
      let pos=1;
      links.forEach(a=>{
        const href = a.getAttribute('href') || a.getAttribute('content') || '';
        const name = a.textContent?.trim() || a.getAttribute('title') || '';
        if (name) items.push({ "@type":"ListItem", position: pos++, name, item: href.startsWith('http') ? href : new URL(href, url).href });
      });
    }
    // 2) Fallback to URL path
    if (!items.length){
      const u = new URL(url);
      const segs = u.pathname.split('/').filter(Boolean);
      let path=u.origin, pos=1;
      items.push({ "@type":"ListItem", position: pos++, name: "Home", item: u.origin });
      for(const s of segs){
        path += '/' + s;
        items.push({ "@type":"ListItem", position: pos++, name: decodeURIComponent(s.replace(/-/g,' ')).replace(/\b\w/g,m=>m.toUpperCase()), item: path });
      }
    }
    return {
      "@type":"BreadcrumbList",
      "@id": url.replace(/#.*$/,'') + "#breadcrumbs",
      "itemListElement": items
    };
  }
  
  // Helper: Detect global schema patterns
  function detectGlobalPatterns(nodes, baseUrl) {
    const existingIds = new Set();
    for (const n of nodes) {
      if (n['@id']) existingIds.add(n['@id']);
    }
    
    const hasGlobalWebsite = existingIds.has(baseUrl + '#website') || 
                             nodes.some(n => n['@type'] === 'WebSite' && n['@id'] && n['@id'].includes('#website'));
    const hasGlobalOrg = existingIds.has(baseUrl + '#org') ||
                        nodes.some(n => {
                          const types = asArray(n['@type']);
                          return (types.includes('Organization') || types.includes('LocalBusiness')) && 
                                 n['@id'] && n['@id'].includes('#org');
                        });
    const hasGlobalLocal = existingIds.has(baseUrl + '#local') ||
                          nodes.some(n => n['@type'] === 'LocalBusiness' && n['@id'] && n['@id'].includes('#local'));
    
    return { hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal };
  }

  // Helper: Build website node
  function buildWebsiteNode(idx, siteName, meta) {
    const website = (idx.WebSite && idx.WebSite[0]) ? structuredClone(idx.WebSite[0]) : {"@type":"WebSite"};
    website.name = website.name || siteName || "Alan Ranger Photography";
    website.url = website.url || meta.url;
    return website;
  }

  // Helper: Build organization node
  function buildOrgNode(idx, siteName, meta) {
    const org = (idx.Organization && idx.Organization[0]) ? structuredClone(idx.Organization[0]) : {"@type":"Organization"};
    org.name = org.name || siteName || "Alan Ranger Photography";
    org.url = org.url || meta.url;
    if (!org.logo && meta.logo) org.logo = meta.logo;
    if (!org.image && meta.ogImage) org.image = meta.ogImage;
    return org;
  }

  // Helper: Build local business node
  function buildLocalNode(idx, org, siteName, meta) {
    let local = (idx.LocalBusiness && idx.LocalBusiness[0]) ? structuredClone(idx.LocalBusiness[0]) : 
                (idx.Organization && idx.Organization[0] ? structuredClone(idx.Organization[0]) : null);
    
    if (local) {
      local.name = local.name || org.name || siteName;
      local.url = local.url || meta.url;
      if (!local.image && meta.ogImage) local.image = meta.ogImage;
      if (!local['@type']) local['@type'] = 'LocalBusiness';
    }
    
    return local;
  }

  // Helper: Build core schema nodes
  function buildCoreSchemaNodes(idx, meta, url) {
    const siteName = firstNonEmpty(null, meta.siteName, meta.title, "Alan Ranger Photography");
    const website = buildWebsiteNode(idx, siteName, meta);
    const org = buildOrgNode(idx, siteName, meta);
    const local = buildLocalNode(idx, org, siteName, meta);
    return { website, org, local };
  }

  // Helper: Build final schema graph
  function buildSchemaGraph(hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal, website, org, local, breadcrumbs, extras) {
    const graph = [];
    
    if (!hasGlobalWebsite) {
      graph.push(website);
    }
    
    if (!hasGlobalOrg) {
      graph.push(org);
    }
    
    if (local && !hasGlobalLocal) {
      graph.push(local);
    }
    
    if (breadcrumbs.itemListElement && breadcrumbs.itemListElement.length > 0) {
      graph.push(breadcrumbs);
    }
    
    graph.push(...extras);
    
    return dedupeById(graph);
  }

  // Helper: Process schema with fallback (check for existing Product before generating)
  async function processSchemaWithFallback(url, doc, nodes) {
    const meta = pageMeta(doc, url);
    const idx = indexByType(nodes);
    
    // Check for existing Product schema
    const hasExistingProduct = nodes.some(n => {
      const types = asArray(n['@type']);
      return types.includes('Product') || types.includes('Course');
    });
    
    if (hasExistingProduct) {
      debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî skipping Product generation to prevent duplicates`, 'info');
    }
    
    let { website, org, local } = buildCoreSchemaNodes(idx, meta, url);
    
    const baseUrl = url.replace(/#.*$/,'');
    const { hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal } = detectGlobalPatterns(nodes, baseUrl);
    
    if (!hasGlobalWebsite) website = ensureId(website, url, 'website');
    if (!hasGlobalOrg) org = ensureId(org, url, 'org');
    if (local && !hasGlobalLocal) local = ensureId(local, url, 'local');
    
    const breadcrumbs = buildBreadcrumbs(doc, url);
    const keepTypes = ['Product','Event','ItemList','FAQPage','Article','BlogPosting','Course'];
    
    // Only include Product/Course if they don't already exist
    const extras = nodes.filter(n => {
      const types = asArray(n['@type']);
      const hasKeepType = types.some(t => keepTypes.includes(t));
      
      // Skip Product/Course if already exists to prevent duplicates
      if ((types.includes('Product') || types.includes('Course')) && hasExistingProduct) {
        return false; // Don't include Product/Course nodes if we detected existing ones
      }
      
      return hasKeepType;
    });
    
    const finalGraph = buildSchemaGraph(hasGlobalWebsite, hasGlobalOrg, hasGlobalLocal, website, org, local, breadcrumbs, extras);
    
    return { "@context":"https://schema.org", "@graph": finalGraph };
  }

  async function generateEnhancedFor(url){
    const apiBaseUrl = getApiBaseUrl();
    const apiUrl = `${apiBaseUrl}/api/fetch?url=${encodeURIComponent(url)}`;
    
    debugLog(`[Generate Enhanced] Fetching via API: ${apiUrl}`, 'info');
    
    try {
      // Use API proxy for Squarespace pages
      const res = await fetch(apiUrl);
      
      if (!res.ok) {
        const errorText = await res.text().catch(() => 'Unknown error');
        throw new Error(`API returned ${res.status}: ${errorText.substring(0, 100)}`);
      }
      
      const html = await res.text();
      
      if (!html || html.length === 0) {
        throw new Error('API returned empty response');
      }
      
      debugLog(`[Generate Enhanced] Received ${html.length} bytes of HTML`, 'success');
      
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      
      // Find all script tags with JSON-LD (including Squarespace patterns)
      const scripts = findAllJsonLdScripts(doc);
      
      let nodes = [];
      for (const s of scripts) {
        try {
          // Decode HTML entities before parsing
          const decodedText = decodeHTML(s.textContent);
          nodes = flattenJsonLd(JSON.parse(decodedText.trim()), nodes);
        } catch(e) {
          debugLog(`[Generate Enhanced] Failed to parse JSON-LD block: ${e.message}`, 'warning');
        }
      }
      
      // Check for existing Product schema before generating
      const hasExistingProduct = nodes.some(n => {
        const types = asArray(n['@type']);
        return types.includes('Product') || types.includes('Course');
      });
      
      if (hasExistingProduct) {
        debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî will not generate duplicate`, 'info');
      }
      
      debugLog(`[Generate Enhanced] Found ${nodes.length} schema nodes`, 'info');
      
      return await processSchemaWithFallback(url, doc, nodes);
    } catch (error) {
      debugLog(`[Generate Enhanced] API fetch failed: ${error.message}`, 'error');
      
      // Fallback to direct fetch if API fails (will likely fail due to CORS)
      debugLog(`[Generate Enhanced] Attempting direct fetch fallback...`, 'warning');
      
      try {
        const res = await fetch(url, {mode:'cors'});
        if (!res.ok) {
          throw new Error(`Direct fetch returned ${res.status}`);
        }
        const html = await res.text();
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Find all script tags with JSON-LD (including Squarespace patterns)
        const scripts = findAllJsonLdScripts(doc);
        
        let nodes = [];
        for (const s of scripts) {
          try {
            // Decode HTML entities before parsing
            const decodedText = decodeHTML(s.textContent);
            nodes = flattenJsonLd(JSON.parse(decodedText.trim()), nodes);
          } catch(_) {}
        }
        
        // Check for existing Product schema
        const hasExistingProduct = nodes.some(n => {
          const types = asArray(n['@type']);
          return types.includes('Product') || types.includes('Course');
        });
        
        if (hasExistingProduct) {
          debugLog(`[Generate Enhanced] Existing Product/Course schema detected ‚Äî will not generate duplicate`, 'info');
        }
        
        return await processSchemaWithFallback(url, doc, nodes);
      } catch (err) {
        const errorMsg = err.message || 'Unknown error';
        debugLog(`[Generate Enhanced] Direct fetch also failed: ${errorMsg}`, 'error');
        throw new Error(`Failed to fetch page: ${errorMsg}. API endpoint: ${apiUrl}`);
      }
    }
  }
  
  // Modal plumbing
  (function initGenModal(){
    // Function to setup save button handler
    function setupSaveButton() {
      const saveBtn = document.getElementById('genSaveBtn');
      const backdrop = document.getElementById('genBackdrop');
      if (saveBtn && backdrop) {
        saveBtn.onclick = async () => {
          try {
            const url = backdrop.dataset.url || '';
            const json = backdrop.dataset.json || document.getElementById('genJson')?.textContent || '';
            
            if (!json || json.trim().length === 0) {
              alert('No content to save');
              return;
            }
            
            // Generate filename from URL
            let filename = 'schema';
            if (url) {
              try {
                const urlObj = new URL(url);
                // Extract pathname and convert to filename-safe string
                const pathParts = urlObj.pathname.split('/').filter(p => p);
                if (pathParts.length > 0) {
                  filename = pathParts[pathParts.length - 1].replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                  // Limit filename length
                  if (filename.length > 50) {
                    filename = filename.substring(0, 50);
                  }
                } else {
                  filename = urlObj.hostname.replace(/[^a-z0-9-]/gi, '-').toLowerCase();
                }
              } catch (e) {
                console.warn('Failed to parse URL for filename:', e);
              }
            }
            
            // Add timestamp to ensure uniqueness
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').substring(0, 19);
            const fullFilename = `${filename}-${timestamp}.json`;
            
            // Create blob and download
            const blob = new Blob([json], { type: 'application/json' });
            const blobUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = fullFilename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(blobUrl);
            
            // Update button feedback
            const originalText = saveBtn.textContent;
            saveBtn.textContent = '‚úÖ Saved!';
            saveBtn.style.background = '#10b981';
            setTimeout(() => {
              saveBtn.textContent = originalText;
              saveBtn.style.background = '#10b981';
            }, 2000);
            
            console.log(`Saved schema to: ${fullFilename}`);
          } catch (err) {
            console.error('Failed to save file:', err);
            alert('Failed to save file: ' + err.message);
          }
        };
      }
    }
    
    // Function to setup copy button handler
    function setupCopyButton() {
      const copyBtn = document.getElementById('genCopyBtn');
      const jsonEl = document.getElementById('genJson');
      if (copyBtn && jsonEl) {
        copyBtn.onclick = async () => {
          try {
            const text = jsonEl.textContent || jsonEl.innerText;
            if (!text || text.trim().length === 0) {
              alert('No content to copy');
              return;
            }
            
            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(text);
              copyBtn.textContent = '‚úÖ Copied!';
              setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
            } else {
              // Fallback: use textarea method for older browsers
              const textarea = document.createElement('textarea');
              textarea.value = text;
              textarea.style.position = 'fixed';
              textarea.style.left = '-999999px';
              document.body.appendChild(textarea);
              textarea.select();
              textarea.setSelectionRange(0, 99999); // For mobile devices
              
              try {
                document.execCommand('copy');
                copyBtn.textContent = '‚úÖ Copied!';
                setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
              } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
                debugLog('Copy failed: ' + err.message, 'error');
              } finally {
                document.body.removeChild(textarea);
              }
            }
          } catch (err) {
            alert('Failed to copy to clipboard: ' + err.message);
            debugLog('Copy error: ' + err.message, 'error');
          }
        };
      }
    }
    
    // Setup close button and backdrop
    function setupCloseButton() {
      const backdrop = document.getElementById('genBackdrop');
      const closeBtn = document.getElementById('genCloseBtn');
      if (backdrop && closeBtn) {
        closeBtn.onclick = () => {
          if (backdrop.close) {
            backdrop.close();
          } else {
            backdrop.style.display = 'none';
          }
        };
        backdrop.onclick = (e) => {
          if (e.target === backdrop) {
            if (backdrop.close) {
              backdrop.close();
            } else {
              backdrop.style.display = 'none';
            }
          }
        };
      }
    }
    
    // Try to setup immediately if DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        setupCopyButton();
        setupSaveButton();
        setupCloseButton();
      });
    } else {
      setupCopyButton();
      setupSaveButton();
      setupCloseButton();
    }
    
    // Also setup when modal is opened (in case elements weren't ready earlier)
    window.__openGenModal = (url, json)=>{
      const backdropEl = document.getElementById('genBackdrop');
      const metaEl = document.getElementById('genMeta');
      const jsonEl = document.getElementById('genJson');
      if (!backdropEl) {
        alert('Error: Modal element not found. Please refresh the page.');
        return;
      }
      if (metaEl) metaEl.textContent = url;
      if (jsonEl) jsonEl.textContent = prettyScript(json);
      
      // Store URL and JSON for save function
      backdropEl.dataset.url = url;
      backdropEl.dataset.json = json;
      
      // Re-attach copy and save button handlers in case they weren't set up earlier
      setupCopyButton();
      setupSaveButton();
      
      // Use dialog API if available
      if (backdropEl.showModal) {
        backdropEl.showModal();
      } else {
        backdropEl.style.display='flex';
      }
    };
  })();
  
  // Copy to clipboard
  // Combined Debug Log Functions
  function addToCombinedLog(msg, stepId, task) {
    const combinedLog = document.getElementById('combinedDebugLog');
    if (!combinedLog) return;
    
    // Get step name
    const stepNames = {
      '0': 'Step 0 - Setup Check',
      2: 'Step 2 - Clean',
      '3a': 'Step 3a - Fetch Google Reviews',
      '3b': 'Step 3b - Merge Reviews',
      4: 'Step 4 - Generate Schema'
    };
    const stepName = stepNames[stepId] || `Step ${stepId}`;
    
    // Add timestamp and step header if this is a new step
    const currentText = combinedLog.textContent;
    const stepHeader = `\n${'='.repeat(60)}\n${stepName} (${task})\n${'='.repeat(60)}\n`;
    
    // Check if we need to add step header
    if (currentText === 'No logs yet. Step outputs will appear here as they run...') {
      combinedLog.textContent = stepHeader;
    } else if (msg.includes('üöÄ Starting') && !currentText.includes(`${stepName} (${task})`)) {
      combinedLog.textContent += stepHeader;
    } else if (stepId === '0' && (msg.includes('Running in Electron') || msg.includes('[Server]')) && !currentText.includes('Step 0')) {
      // Add Step 0 header on first message
      combinedLog.textContent = stepHeader;
    }
    
    // Add the message with timestamp for important events
    if (msg.includes('üöÄ Starting') || msg.includes('‚ùå') || msg.includes('‚úÖ Task') || msg.includes('Error:') || msg.includes('[Server]')) {
      const now = new Date();
      const timestamp = `[${now.toTimeString().substring(0, 8)}]`;
      combinedLog.textContent += `${timestamp} ${msg}`;
    } else {
      combinedLog.textContent += msg;
    }
    combinedLog.scrollTop = combinedLog.scrollHeight;
  }
  
  function copyCombinedLog() {
    const combinedLog = document.getElementById('combinedDebugLog');
    if (!combinedLog) return;
    
    const text = combinedLog.textContent || 'No logs available';
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(() => {
        const btn = document.getElementById('copyCombinedLogBtn');
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '‚úÖ Copied!';
          btn.style.background = '#27AE60';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '#667eea';
          }, 2000);
        }
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy to clipboard. Please select and copy manually.');
      });
    } else {
      // Fallback for older browsers
      const textarea = document.createElement('textarea');
      textarea.value = text;
      textarea.style.position = 'fixed';
      textarea.style.opacity = '0';
      document.body.appendChild(textarea);
      textarea.select();
      try {
        document.execCommand('copy');
        const btn = document.getElementById('copyCombinedLogBtn');
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '‚úÖ Copied!';
          btn.style.background = '#27AE60';
          setTimeout(() => {
            btn.textContent = originalText;
            btn.style.background = '#667eea';
          }, 2000);
        }
      } catch (err) {
        alert('Failed to copy. Please select and copy manually.');
      }
      document.body.removeChild(textarea);
    }
  }
  
  function clearCombinedLog() {
    const combinedLog = document.getElementById('combinedDebugLog');
    if (combinedLog) {
      combinedLog.textContent = 'No logs yet. Step outputs will appear here as they run...';
    }
  }

  function copyToClipboard(outputId) {
    const element = document.getElementById(outputId);
    if (!element) {
      console.error(`Element with id "${outputId}" not found`);
      showToast('‚ùå Error: Output element not found', 'error');
      return;
    }
    
    const text = element.tagName === 'TEXTAREA' ? element.value : element.textContent;
    
    if (!text || text.trim() === '') {
      showToast('‚ö†Ô∏è Nothing to copy. Please generate schema first.', 'warning');
      return;
    }
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text).then(function() {
        showToast('‚úÖ Schema copied to clipboard!', 'success');
      }, function(err) {
        console.error('Clipboard write failed:', err);
        showToast('‚ùå Failed to copy. Please try selecting and copying manually.', 'error');
      });
    } else {
      // Fallback for older browsers
      const textArea = document.createElement('textarea');
      textArea.value = text;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.select();
      try {
        document.execCommand('copy');
        showToast('‚úÖ Schema copied to clipboard!', 'success');
      } catch (err) {
        console.error('Fallback copy failed:', err);
        showToast('‚ùå Failed to copy. Please try selecting and copying manually.', 'error');
      }
      document.body.removeChild(textArea);
    }
  }
  
  function showToast(message, type = 'success') {
    const toast = document.createElement('div');
    toast.textContent = message;
    const bgColor = type === 'success' ? '#27AE60' : type === 'error' ? '#E74C3C' : '#E57200';
    toast.style.cssText = `position: fixed; top: 20px; right: 20px; background: ${bgColor}; color: white; padding: 14px 24px; border-radius: 8px; z-index: 10000; font-size: 0.875rem; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.15); animation: slideIn 0.3s ease-out;`;
    document.body.appendChild(toast);
    setTimeout(() => {
      toast.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(() => toast.remove(), 300);
    }, 3000);
  }

  // Test URL functions
  function testSchemaOrg(inputId) {
    const url = document.getElementById(inputId).value;
    if (!url) {
      alert('Please enter a URL to test');
      return;
    }
    window.open('https://validator.schema.org/#url=' + encodeURIComponent(url), '_blank');
  }

  function testGoogleRichResults(inputId) {
    const url = document.getElementById(inputId).value;
    if (!url) {
      alert('Please enter a URL to test');
      return;
    }
    window.open('https://search.google.com/test/rich-results?url=' + encodeURIComponent(url), '_blank');
  }

  // Helper: Validate URL input
  function validateUrlInput() {
    const urlInput = document.getElementById('singleUrlInput');
    if (!urlInput) {
      console.error('singleUrlInput element not found');
      alert('Error: Input field not found. Please refresh the page.');
      return null;
    }
    
    const url = urlInput.value.trim();
    console.log('URL input:', url);
    
    if (!url) {
      alert('Please enter a URL to validate');
      return null;
    }
    
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      alert('Please enter a valid URL starting with http:// or https://');
      return null;
    }
    
    return { urlInput, url };
  }

  // Helper: Show results table
  function showResultsTable() {
    const resultsDiv = document.getElementById('validatorResults');
    if (resultsDiv) {
      resultsDiv.style.display = 'block';
      return resultsDiv;
    }
    console.error('validatorResults element not found');
    alert('Error: Results table not found. Please refresh the page.');
    return null;
  }

  // Helper: Find or create result index
  function findOrCreateResultIndex(url) {
    if (typeof validationResults === 'undefined') {
      console.error('validationResults array not defined');
      alert('Error: Validation system not initialized. Please refresh the page.');
      return null;
    }
    
    const existingIndex = validationResults.findIndex(r => r.url === url);
    if (existingIndex >= 0) {
      console.log('Updating existing row at index:', existingIndex);
      return existingIndex;
    }
    
    console.log('Creating new row, current length:', validationResults.length);
    const index = validationResults.length;
    
    const placeholderResult = {
      url: url,
      row: index,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null,
      validatorGoogleStatus: 'Not run',
      validatorSchemaOrgStatus: 'Not run',
      notes: '',
      issuesList: []
    };
    
    validationResults.push(placeholderResult);
    console.log('Added placeholder result, new length:', validationResults.length);
    return index;
  }

  // Helper: Initialize validation row UI
  function initializeValidationRow(index, url) {
    if (typeof updateTableRow === 'undefined') {
      console.error('updateTableRow function not defined');
      alert('Error: updateTableRow function not found. Please refresh the page.');
      return false;
    }
    
    updateTableRow(index, {
      url: url,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null,
      validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
      validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
      notes: validationResults[index]?.notes || '',
      issuesList: []
    });
    
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    if (schemaTypeCell) {
      if (typeof renderProgress === 'undefined' || typeof setProgress === 'undefined') {
        console.error('renderProgress or setProgress not defined');
      } else {
        renderProgress(schemaTypeCell);
        setProgress(schemaTypeCell, 5, 'Queued');
      }
    }
    
    return true;
  }

  // Helper: Run external validators if enabled
  async function runExternalValidatorsIfEnabled(index, url) {
    const autoRunCheckbox = document.getElementById('autoRunExternalChecks');
    const shouldAutoRun = autoRunCheckbox ? autoRunCheckbox.checked : true;
    
    if (!shouldAutoRun) {
      return;
    }
    
    // Wait longer for DOM to be fully updated and select elements to be created
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Retry logic - try multiple times if elements aren't found
    let retries = 3;
    let schemaOrgRan = false;
    let richResultsRan = false;
    
    while (retries > 0 && (!schemaOrgRan || !richResultsRan)) {
      try {
        const schemaOrgStatusSelect = document.getElementById(`schemaOrgStatus_${index}`);
        if (schemaOrgStatusSelect && schemaOrgStatusSelect.value === 'Not run' && !schemaOrgRan) {
          if (typeof runSchemaOrgValidator === 'function') {
            try {
              await runSchemaOrgValidator(index, url);
              schemaOrgRan = true;
            } catch (err) {
              console.error(`Schema.org validation failed for ${url}:`, err);
              debugLog(`Schema.org validation failed for ${url}: ${err.message}`, 'error');
              schemaOrgRan = true; // Mark as attempted to prevent retry loop
            }
          } else {
            console.warn(`runSchemaOrgValidator function not found for index ${index}`);
            schemaOrgRan = true;
          }
        } else if (schemaOrgStatusSelect && schemaOrgStatusSelect.value !== 'Not run') {
          schemaOrgRan = true; // Already run
        }
        
        const googleStatusSelect = document.getElementById(`googleStatus_${index}`);
        if (googleStatusSelect && googleStatusSelect.value === 'Not run' && !richResultsRan) {
          if (typeof runRichResultsValidator === 'function') {
            try {
              await runRichResultsValidator(index, url);
              richResultsRan = true;
            } catch (err) {
              console.error(`Rich Results validation failed for ${url}:`, err);
              debugLog(`Rich Results validation failed for ${url}: ${err.message}`, 'error');
              richResultsRan = true; // Mark as attempted to prevent retry loop
            }
          } else {
            console.warn(`runRichResultsValidator function not found for index ${index}`);
            richResultsRan = true;
          }
        } else if (googleStatusSelect && googleStatusSelect.value !== 'Not run') {
          richResultsRan = true; // Already run
        }
        
        // If both ran or both select elements don't exist, break
        if (schemaOrgRan && richResultsRan) {
          break;
        }
        
        // If elements still don't exist after waiting, wait a bit more
        if (retries > 1 && (!schemaOrgStatusSelect || !googleStatusSelect)) {
          await new Promise(resolve => setTimeout(resolve, 300));
        }
        
      } catch (error) {
        console.error(`External validation error for ${url}:`, error);
        debugLog(`External validation error for ${url}: ${error.message}`, 'error');
      }
      
      retries--;
      if (retries > 0 && (!schemaOrgRan || !richResultsRan)) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
    
    if (!schemaOrgRan || !richResultsRan) {
      console.warn(`External validations may not have completed for index ${index}, URL: ${url}`);
      debugLog(`External validations may not have completed for index ${index}, URL: ${url}`, 'warning');
    }
  }

  // Helper: Auto-save to Supabase if enabled
  function autoSaveToSupabaseIfEnabled(index, url) {
    const autoSaveCheckbox = document.getElementById('autoSaveToSupabase');
    const shouldAutoSave = autoSaveCheckbox ? autoSaveCheckbox.checked : false;
    
    if (shouldAutoSave && supabaseAvailable && supabase && typeof saveToSupabase === 'function') {
      setTimeout(async () => {
        try {
          await saveToSupabase(index, true);
          debugLog(`Auto-saved to Supabase: ${url}`, 'success');
        } catch (error) {
          debugLog(`Auto-save failed for ${url}: ${error.message}`, 'error');
        }
      }, 2000);
    }
  }

  // Helper: Handle validation error
  function handleValidationError(error, index, url) {
    console.error('Error validating URL:', error);
    console.error('Error stack:', error.stack);
    alert('Error validating URL: ' + error.message + '\n\nCheck console for details.');
    
    if (typeof index !== 'undefined' && validationResults && validationResults[index]) {
      validationResults[index] = {
        url: url || 'Unknown',
        row: index || 0,
        schemaType: null,
        valid: false,
        schemaFound: false,
        missingFields: [],
        warnings: [],
        schemas: [],
        error: error.message,
        validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
        validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
        notes: validationResults[index]?.notes || '',
        issuesList: []
      };
      
      if (typeof updateTableRow === 'function') {
        updateTableRow(index, validationResults[index]);
      }
    }
    
    if (typeof updateBulkButtons === 'function') {
      updateBulkButtons();
    }
  }

  // Single URL validation
  async function runSingleUrlValidation() {
    console.log('runSingleUrlValidation called');
    
    try {
      const urlInputData = validateUrlInput();
      if (!urlInputData) return;
      
      const resultsDiv = showResultsTable();
      if (!resultsDiv) return;
      
      const index = findOrCreateResultIndex(urlInputData.url);
      if (index === null) return;
      
      if (!initializeValidationRow(index, urlInputData.url)) return;
      
      console.log('Starting processUrl...');
      if (typeof processUrl === 'undefined') {
        console.error('processUrl function not defined');
        alert('Error: processUrl function not found. Please refresh the page.');
        return;
      }
      
      const urlData = { url: urlInputData.url, row: index };
      const result = await processUrl(urlData);
      console.log('processUrl completed:', result);
      
      validationResults[index] = {
        ...result,
        validatorGoogleStatus: validationResults[index]?.validatorGoogleStatus || 'Not run',
        validatorSchemaOrgStatus: validationResults[index]?.validatorSchemaOrgStatus || 'Not run',
        notes: validationResults[index]?.notes || ''
      };
      
      console.log('Updating table row with results...');
      updateTableRow(index, validationResults[index]);
      
      if (typeof updateBulkButtons === 'function') {
        updateBulkButtons();
      }
      
      await runExternalValidatorsIfEnabled(index, urlInputData.url);
      autoSaveToSupabaseIfEnabled(index, urlInputData.url);
      
      urlInputData.urlInput.value = '';
      
      if (resultsDiv) {
        resultsDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      
    } catch (error) {
      let errorUrl = '';
      try {
        const urlInputData = validateUrlInput();
        errorUrl = urlInputData?.url || '';
      } catch {
        errorUrl = '';
      }
      handleValidationError(error, typeof index !== 'undefined' ? index : undefined, errorUrl);
    }
  }
  
  // Make it globally accessible
  window.runSingleUrlValidation = runSingleUrlValidation;

  // Toggle help block
  function toggleHelpBlock() {
    const helpBlock = document.getElementById('helpBlock');
    const content = document.getElementById('helpBlockContent');
    
    helpBlock.classList.toggle('expanded');
    content.classList.toggle('active');
    helpBlock.setAttribute('aria-expanded', helpBlock.classList.contains('expanded'));
  }

  // Event Schema Generation v4 - Smart Enriched Schema Generator
  let events = [];
  let reviewsData = null;
  let mappingsData = null;

  // Schema Suppressor v1.3 block (Code-Block Safe)
  const SCHEMA_SUPPRESSOR_BLOCK = `<!-- Squarespace Product Schema Suppressor v1.3 (Code-Block Safe) -->

<script>
(function(){
  const removeSquarespaceProduct = () => {
    document.querySelectorAll('script[type="application/ld+json"]').forEach(el => {
      const txt = el.textContent.trim();
      if (txt.includes('"@type":"Product"')) {
        try {
          const j = JSON.parse(txt);
          const looksLikeSquarespace =
            txt.length < 1500 &&
            !j.aggregateRating &&
            !j.review &&
            j.offers &&
            j.name &&
            !txt.includes('"hasMerchantReturnPolicy"');
          if (looksLikeSquarespace) el.remove();
        } catch(e){}
      }
    });
  };
  removeSquarespaceProduct();
  document.addEventListener('DOMContentLoaded', removeSquarespaceProduct);
  window.addEventListener('load', () => setTimeout(removeSquarespaceProduct, 1000));
  const obs = new MutationObserver(removeSquarespaceProduct);
  obs.observe(document.documentElement, { childList: true, subtree: true });
})();
<\/script>

`;

  // Helper functions for stable ID generation (v4.3)
  function slugifyId(s) {
    return String(s || "")
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-")
      .replace(/(^-|-$)/g, "");
  }

  // Use a stable base for @id (page canonical if available, else window.location)
  function getBaseId() {
    const canonical = document.querySelector('link[rel="canonical"]');
    return (canonical?.href || window.location.href || "").split("#")[0];
  }

  function seriesIdFromName(name) {
    return `${getBaseId()}#series-${slugifyId(name)}`;
  }

  function eventIdFromUrl(url) {
    // Fall back to hashing the name/identifier if URL missing
    if (!url) return `${getBaseId()}#event-${Math.random().toString(36).slice(2)}`;
    const clean = url.split("#")[0];
    return `${clean}#event`;
  }

  // Detect EventSeries groups for recurring workshops (v4.2 + v4.3)
  function detectEventSeries(events) {
    const grouped = {};
    
    // Use flexible keyword patterns that match variations
    const keywordPatterns = [
      { pattern: /bluebell.*photography.*workshop/i, key: "bluebell photography workshop" },
      { pattern: /batsford.*arboretum.*autumn.*photography.*workshop/i, key: "batsford arboretum autumn photography workshop" },
      { pattern: /camera.*course.*for.*beginners|camera.*courses.*for.*beginners/i, key: "camera course for beginners" },
      { pattern: /lightroom.*photo.*editing|lightroom.*classic.*photo.*editing/i, key: "lightroom photo editing" }
    ];
    
    for (const e of events) {
      const title = (e.name || e.Event_Title || "").toLowerCase();
      
      // Try to match against patterns
      for (const { pattern, key } of keywordPatterns) {
        if (pattern.test(title)) {
          if (!grouped[key]) grouped[key] = [];
          grouped[key].push(e);
          break; // Only match one pattern per event
        }
      }
    }
    
    // Filter out groups with fewer than 2 events
    Object.keys(grouped).forEach(k => {
      if (grouped[k].length < 2) delete grouped[k];
    });
    
    return grouped;
  }

  // Detect CSV type (Lessons vs Workshops) - v4
  function detectCsvType(fileName, headers) {
    const fileNameLower = (fileName || '').toLowerCase();
    const headersStr = (headers || []).join(' ').toLowerCase();
    
    if (fileNameLower.includes('beginners-photography-lessons') || 
        fileNameLower.includes('lesson') ||
        headersStr.includes('beginners-photography-lessons')) {
      return 'lessons';
    } else if (fileNameLower.includes('photographic-workshops') ||
               fileNameLower.includes('workshop') ||
               headersStr.includes('photographic-workshops')) {
      return 'workshops';
    }
    return 'unknown';
  }

  document.getElementById('eventCsvFile').addEventListener('change', function(e) {
    if (!e.target.files || !e.target.files[0]) {
      console.error('No file selected');
      return;
    }
    
    Papa.parse(e.target.files[0], {
      header: true,
      skipEmptyLines: true,
      complete: function(results) {
        if (!results.data || results.data.length === 0) {
          alert('CSV file is empty or could not be parsed. Please check the file format.');
          return;
        }
        
        events = results.data;
        console.log('‚úÖ Loaded', events.length, 'events from CSV');
        
        // Detect CSV type
        const csvType = detectCsvType(e.target.files[0].name, results.meta.fields || []);
        console.log('üìã CSV Type detected:', csvType);
        
        const categories = [...new Set(
          events.map(e => {
            const cat = e['Category'] || e['category'] || e['CATEGORY'] || '';
            return cat.split(',')[0].trim();
          }).filter(Boolean)
        )];
        
        const filterSelect = document.getElementById('eventCategoryFilter');
        filterSelect.innerHTML = '<option value="__ALL__">All Categories</option>';
        categories.forEach(c => {
          const opt = document.createElement('option');
          opt.value = c;
          opt.textContent = c;
          filterSelect.appendChild(opt);
        });
        
        // Show the category filter dropdown now that categories are loaded
        filterSelect.style.display = 'block';
        
        // Ensure container stays visible
        document.getElementById('eventCategoryFilterContainer').style.display = 'block';
        document.getElementById('eventOptionsContainer').style.display = 'block';
        
        // Load toggle states from localStorage
        const includeReviews = localStorage.getItem('eventSchema.includeReviews');
        const includePerformer = localStorage.getItem('eventSchema.includePerformer');
        const groupRepeatingEvents = localStorage.getItem('eventSchema.groupRepeatingEvents');
        const includeMerchantFields = localStorage.getItem('eventSchema.includeMerchantFields');
        const enrichLocations = localStorage.getItem('eventSchema.enrichLocations');
        const includeAvailabilityStarts = localStorage.getItem('eventSchema.includeAvailabilityStarts');
        
        if (includeReviews !== null) document.getElementById('includeReviews').checked = includeReviews === 'true';
        if (includePerformer !== null) document.getElementById('includePerformer').checked = includePerformer === 'true';
        if (groupRepeatingEvents !== null) document.getElementById('groupRepeatingEvents').checked = groupRepeatingEvents === 'true';
        if (includeMerchantFields !== null) {
          document.getElementById('includeMerchantFields').checked = includeMerchantFields === 'true';
          document.getElementById('merchantFeedContainer').style.display = includeMerchantFields === 'true' ? 'block' : 'none';
        }
        if (enrichLocations !== null) document.getElementById('toggleLocationEnrichment').checked = enrichLocations === 'true';
        if (includeAvailabilityStarts !== null) document.getElementById('toggleAvailabilityStarts').checked = includeAvailabilityStarts === 'true';
        
        // Save toggle states on change
        document.getElementById('includeReviews').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includeReviews', this.checked);
        });
        document.getElementById('includePerformer').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includePerformer', this.checked);
        });
        document.getElementById('groupRepeatingEvents').addEventListener('change', function() {
          localStorage.setItem('eventSchema.groupRepeatingEvents', this.checked);
        });
        document.getElementById('includeMerchantFields').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includeMerchantFields', this.checked);
          document.getElementById('merchantFeedContainer').style.display = this.checked ? 'block' : 'none';
        });
        document.getElementById('toggleLocationEnrichment').addEventListener('change', function() {
          localStorage.setItem('eventSchema.enrichLocations', this.checked);
        });
        document.getElementById('toggleAvailabilityStarts').addEventListener('change', function() {
          localStorage.setItem('eventSchema.includeAvailabilityStarts', this.checked);
        });
        
        console.log('‚úÖ Category filter and Generate button displayed');
      },
      error: function(error) {
        console.error('Error parsing CSV:', error);
        alert('Error parsing CSV file: ' + (error.message || 'Unknown error') + '\n\nPlease check that the file is a valid CSV.');
      }
    });
  });

  // Load reviews and mappings CSVs from file inputs (optional, for review enrichment)
  async function loadReviewData() {
    const debugLog = [];
    
    // Load reviews CSV from file input
    const reviewsFileInput = document.getElementById('reviewsCsvFile');
    if (reviewsFileInput && reviewsFileInput.files && reviewsFileInput.files[0]) {
      debugLog.push(`üìÑ Loading reviews CSV: ${reviewsFileInput.files[0].name}`);
      try {
        const file = reviewsFileInput.files[0];
        const text = await file.text();
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            reviewsData = results.data;
            debugLog.push(`‚úÖ Loaded ${reviewsData.length} reviews from CSV`);
            debugLog.push(`   Columns found: ${results.meta.fields ? results.meta.fields.join(', ') : 'unknown'}`);
            if (reviewsData.length > 0) {
              debugLog.push(`   Sample review keys: ${Object.keys(reviewsData[0]).join(', ')}`);
            }
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          },
          error: function(error) {
            debugLog.push(`‚ùå Error parsing reviews CSV: ${error.message}`);
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          }
        });
      } catch (e) {
        debugLog.push(`‚ùå Error reading reviews file: ${e.message}`);
        window.debugLog = window.debugLog || [];
        window.debugLog.push(...debugLog);
        updateDebugLog();
      }
    } else {
      debugLog.push('‚ö†Ô∏è No reviews CSV file uploaded (optional)');
      window.debugLog = window.debugLog || [];
      window.debugLog.push(...debugLog);
      updateDebugLog();
    }

    // Load mappings CSV from file input
    const mappingsFileInput = document.getElementById('mappingsCsvFile');
    if (mappingsFileInput && mappingsFileInput.files && mappingsFileInput.files[0]) {
      debugLog.push(`üìÑ Loading mappings CSV: ${mappingsFileInput.files[0].name}`);
      try {
        const file = mappingsFileInput.files[0];
        const text = await file.text();
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: function(results) {
            mappingsData = results.data;
            debugLog.push(`‚úÖ Loaded ${mappingsData.length} mappings from CSV`);
            debugLog.push(`   Columns found: ${results.meta.fields ? results.meta.fields.join(', ') : 'unknown'}`);
            if (mappingsData.length > 0) {
              debugLog.push(`   Sample mapping keys: ${Object.keys(mappingsData[0]).join(', ')}`);
            }
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          },
          error: function(error) {
            debugLog.push(`‚ùå Error parsing mappings CSV: ${error.message}`);
            window.debugLog = window.debugLog || [];
            window.debugLog.push(...debugLog);
            updateDebugLog();
          }
        });
      } catch (e) {
        debugLog.push(`‚ùå Error reading mappings file: ${e.message}`);
        window.debugLog = window.debugLog || [];
        window.debugLog.push(...debugLog);
        updateDebugLog();
      }
    } else {
      debugLog.push('‚ö†Ô∏è No mappings CSV file uploaded (optional)');
      window.debugLog = window.debugLog || [];
      window.debugLog.push(...debugLog);
      updateDebugLog();
    }
  }
  
  // Add debug log entry
  function addDebugLog(message) {
    window.debugLog = window.debugLog || [];
    window.debugLog.push(message);
    updateDebugLog();
  }
  
  // Copy debug log to clipboard
  function copyDebugLog(btnElement) {
    const debugLogElement = document.getElementById('debugLog');
    if (!debugLogElement || !window.debugLog || window.debugLog.length === 0) {
      alert('No debug log available to copy.');
      return;
    }
    
    const logText = window.debugLog.join('\n');
    
    // Try modern clipboard API first
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(logText).then(() => {
        if (btnElement) {
          const originalText = btnElement.textContent;
          btnElement.textContent = '‚úÖ Copied!';
          btnElement.style.background = '#48bb78';
          setTimeout(() => {
            btnElement.textContent = originalText;
            btnElement.style.background = '#667eea';
          }, 2000);
        }
      }).catch(err => {
        console.error('Failed to copy debug log:', err);
        // Fallback to textarea method
        fallbackCopyToClipboard(logText, btnElement);
      });
    } else {
      // Fallback for browsers without clipboard API
      fallbackCopyToClipboard(logText, btnElement);
    }
  }
  
  // Fallback copy method using textarea
  function fallbackCopyToClipboard(text, btnElement) {
    const textArea = document.createElement('textarea');
    textArea.value = text;
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);
    textArea.focus();
    textArea.select();
    
    try {
      const successful = document.execCommand('copy');
      if (successful) {
        if (btnElement) {
          const originalText = btnElement.textContent;
          btnElement.textContent = '‚úÖ Copied!';
          btnElement.style.background = '#48bb78';
          setTimeout(() => {
            btnElement.textContent = originalText;
            btnElement.style.background = '#667eea';
          }, 2000);
        }
      } else {
        throw new Error('execCommand failed');
      }
    } catch (err) {
      console.error('Fallback copy failed:', err);
      alert('Failed to copy debug log. Please select the debug log text and copy manually (Ctrl+C).');
    } finally {
      document.body.removeChild(textArea);
    }
  }
  
  // Show field verification modal
  function showFieldVerificationModal() {
    if (!window.fieldVerificationStats) {
      alert('Field verification data not available. Please generate schema first.');
      return;
    }
    
    const modal = document.getElementById('fieldVerificationModal');
    if (modal) {
      modal.style.display = 'block';
      updateFieldVerificationModal();
    }
  }
  
  // Close field verification modal
  function closeFieldVerificationModal() {
    const modal = document.getElementById('fieldVerificationModal');
    if (modal) {
      modal.style.display = 'none';
      // Ensure copy buttons are visible after modal closes
      const copyButton = document.getElementById('copySchemaButton');
      const copyButtonTop = document.getElementById('copySchemaButtonTop');
      if (copyButton) {
        copyButton.style.display = 'inline-block';
        copyButton.style.visibility = 'visible';
        copyButton.style.opacity = '1';
      }
      if (copyButtonTop) {
        copyButtonTop.style.display = 'inline-block';
        copyButtonTop.style.visibility = 'visible';
        copyButtonTop.style.opacity = '1';
      }
    }
  }
  
  // Update field verification modal content
  function updateFieldVerificationModal() {
    const content = document.getElementById('fieldVerificationModalContent');
    if (!content || !window.fieldVerificationStats) return;
    
    const stats = window.fieldVerificationStats;
    let html = '<div style="max-height: 70vh; overflow-y: auto;">';
    
    // Event Core Fields
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #667eea;">';
    html += '<h3 style="margin-top: 0; color: #667eea;">üß© Event Core Fields</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>@context</td><td style="text-align: center;">${stats.coreFields?.context || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>@type</td><td style="text-align: center;">${stats.coreFields?.type || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>name</td><td style="text-align: center;">${stats.coreFields?.name || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>startDate</td><td style="text-align: center;">${stats.coreFields?.startDate || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>endDate</td><td style="text-align: center;">${stats.coreFields?.endDate || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>duration</td><td style="text-align: center;">${stats.coreFields?.duration || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>identifier</td><td style="text-align: center;">${stats.coreFields?.identifier || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += '</table></div>';
    
    // Location/Address Fields
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #38b2ac;">';
    html += '<h3 style="margin-top: 0; color: #38b2ac;">üèõ Location / Address Fields</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>location.@type</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>location.name</td><td style="text-align: center;">${stats.locationFields?.name || '‚úÖ'}</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.streetAddress</td><td style="text-align: center;">${stats.locationFields?.streetAddress || '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.locationFields?.streetAddressCount || 0} / ${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.addressLocality</td><td style="text-align: center;">${stats.locationFields?.locality || '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.locationFields?.localityCount || 0} / ${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.addressRegion</td><td style="text-align: center;">${stats.locationFields?.region || '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.locationFields?.regionCount || 0} / ${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.postalCode</td><td style="text-align: center;">${stats.locationFields?.postalCode || '‚úÖ'}</td><td style="text-align: right;">${stats.locationFields?.postalCodeCount || stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>address.addressCountry</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += '</table></div>';
    
    // Offers & Merchant Fields
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #ed8936;">';
    html += '<h3 style="margin-top: 0; color: #ed8936;">üí∞ Offers & Merchant Fields</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>offers.@type</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.price</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.priceCurrency</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.seller.name</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.offersBlocks || 0}</td></tr>`;
    html += `<tr><td>offers.hasMerchantReturnPolicy</td><td style="text-align: center;">${stats.merchantFields ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.merchantFields ? stats.offersBlocks : 0}</td></tr>`;
    html += `<tr><td>sku</td><td style="text-align: center;">${stats.merchantFields ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.merchantFields ? stats.eventsWithMappings : 0}</td></tr>`;
    html += `<tr><td>brand</td><td style="text-align: center;">${stats.merchantFields ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.merchantFields ? stats.eventsWithMappings : 0}</td></tr>`;
    html += '</table></div>';
    
    // Reviews & Ratings
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #48bb78;">';
    html += '<h3 style="margin-top: 0; color: #48bb78;">‚≠ê Reviews & Ratings</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>aggregateRating.@type</td><td style="text-align: center;">${stats.aggregateRatingsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.aggregateRatingsAdded || 0}</td></tr>`;
    html += `<tr><td>aggregateRating.ratingValue</td><td style="text-align: center;">${stats.aggregateRatingsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.aggregateRatingsAdded || 0}</td></tr>`;
    html += `<tr><td>aggregateRating.reviewCount</td><td style="text-align: center;">${stats.aggregateRatingsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.aggregateRatingsAdded || 0}</td></tr>`;
    html += `<tr><td>review array</td><td style="text-align: center;">${stats.reviewSnippetsAdded > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.reviewSnippetsAdded || 0}</td></tr>`;
    html += '</table></div>';
    
    // Organizer/Provider/Performer
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #9f7aea;">';
    html += '<h3 style="margin-top: 0; color: #9f7aea;">üë• Organizer / Provider / Performer</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>organizer.@type</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>organizer.name</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>organizer.logo</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>organizer.sameAs</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>performer</td><td style="text-align: center;">${stats.performerToggled ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.performerToggled ? stats.eventsGenerated : 0}</td></tr>`;
    html += `<tr><td>provider</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.eventsGenerated || 0}</td></tr>`;
    html += '</table></div>';
    
    // Event ‚Üî Series Linkage (v4.3)
    html += '<div style="margin-bottom: 1.5rem; padding: 1rem; background: #f7fafc; border-radius: 8px; border-left: 4px solid #f56565;">';
    html += '<h3 style="margin-top: 0; color: #f56565;">üîó Event ‚Üî Series Linkage</h3>';
    html += '<table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">';
    html += '<tr><th style="text-align: left; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Field</th><th style="text-align: center; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Status</th><th style="text-align: right; padding: 0.5rem; border-bottom: 1px solid #e2e8f0;">Count</th></tr>';
    html += `<tr><td>Event.@id</td><td style="text-align: center;">‚úÖ</td><td style="text-align: right;">${stats.linkageStats?.eventId || stats.eventsGenerated || 0}</td></tr>`;
    html += `<tr><td>Event.superEvent.@id</td><td style="text-align: center;">${stats.linkageStats?.superEventId > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.linkageStats?.superEventId || 0}</td></tr>`;
    html += `<tr><td>EventSeries.@id</td><td style="text-align: center;">${stats.linkageStats?.seriesId > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.linkageStats?.seriesId || 0}</td></tr>`;
    html += `<tr><td>EventSeries.subEvent (sum)</td><td style="text-align: center;">${stats.linkageStats?.seriesSubEventTotal > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.linkageStats?.seriesSubEventTotal || 0}</td></tr>`;
    html += `<tr><td>eventSchedule.repeatFrequency</td><td style="text-align: center;">${stats.linkageStats?.seriesWithScheduleRF > 0 ? '‚úÖ' : '‚ö†Ô∏è'}</td><td style="text-align: right;">${stats.linkageStats?.seriesWithScheduleRF || 0}</td></tr>`;
    html += '</table></div>';
    
    html += '</div>';
    content.innerHTML = html;
  }
  
  // Update debug log display
  function updateDebugLog() {
    const debugLogElement = document.getElementById('debugLog');
    const debugLogContainer = document.getElementById('debugLogContainer');
    if (debugLogElement && window.debugLog) {
      debugLogElement.textContent = window.debugLog.join('\n');
      if (debugLogContainer) {
        debugLogContainer.style.display = 'block';
      }
    }
  }
  
  // Update summary panel
  function updateSummaryPanel(summary) {
    const summaryPanel = document.getElementById('summaryPanel');
    const summaryContent = document.getElementById('summaryContent');
    if (summaryPanel && summaryContent) {
      summaryPanel.style.display = 'block';
      summaryContent.innerHTML = summary;
    }
  }
  
  // Build summary HTML
  function buildSummaryHTML(stats) {
    let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">';
    
    // CSV & Events Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #667eea;">';
    html += '<strong style="color: #667eea;">üìã CSV & Events</strong><br>';
    html += `CSV Type: ${stats.csvType || 'Unknown'}<br>`;
    html += `Total rows parsed: ${stats.totalRows || 0}<br>`;
    html += `Future events included: ${stats.futureEvents || 0}<br>`;
    html += `Events generated: ${stats.eventsGenerated || 0}<br>`;
    html += `Repeating groups: ${stats.eventSeriesGroups || 0}<br>`;
    html += `EventSeries created: ${stats.eventSeriesCreated || 0}<br>`;
    if (stats.superEventLinks && stats.superEventLinks > 0) {
      html += `Events with superEvent: ${stats.superEventLinks}`;
    }
    html += '</div>';
    
    // Reviews & Ratings Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #48bb78;">';
    html += '<strong style="color: #48bb78;">‚≠ê Reviews & Ratings</strong><br>';
    html += `Reviews loaded: ${stats.reviewsLoaded || 0}<br>`;
    html += `Products with reviews: ${stats.productsWithReviews || 0}<br>`;
    html += `Aggregate ratings added: ${stats.aggregateRatingsAdded || 0}<br>`;
    html += `Review snippets added: ${stats.reviewSnippetsAdded || 0}`;
    html += '</div>';
    
    // Offers & Merchant Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #ed8936;">';
    html += '<strong style="color: #ed8936;">üí∞ Offers & Merchant</strong><br>';
    html += `Offers blocks: ${stats.offersBlocks || 0}<br>`;
    html += `Performer toggled: ${stats.performerToggled ? 'ON' : 'OFF'}<br>`;
    html += `Merchant fields: ${stats.merchantFields ? 'ON' : 'OFF'}<br>`;
    html += `Merchant feed items: ${stats.merchantFeedItems || 0}`;
    html += '</div>';
    
    // Mappings Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #9f7aea;">';
    html += '<strong style="color: #9f7aea;">üîó Mappings</strong><br>';
    html += `Event mappings loaded: ${stats.mappingsLoaded || 0}<br>`;
    html += `Events with mappings: ${stats.eventsWithMappings || 0}<br>`;
    html += `Events with product URLs: ${stats.eventsWithProductUrls || 0}`;
    html += '</div>';
    
    // Structure Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #38b2ac;">';
    html += '<strong style="color: #38b2ac;">üß≠ Structure</strong><br>';
    html += `Breadcrumb chains: ${stats.breadcrumbChains || 0}<br>`;
    html += `ItemList items: ${stats.itemListItems || 0}<br>`;
    html += `EventSeries groups: ${stats.eventSeriesGroups || 0}<br>`;
    if (stats.eventSeriesCreated && stats.eventSeriesCreated > 0) {
      html += `üîÅ EventSeries Created: ${stats.eventSeriesCreated}<br>`;
    }
    if (stats.linkageStats && stats.linkageStats.seriesSubEventTotal > 0) {
      html += `Total subEvent links: ${stats.linkageStats.seriesSubEventTotal}`;
    }
    html += '</div>';
    
    // Validation Section
    html += '<div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid ' + (stats.validationStatus === 'Valid' ? '#48bb78' : stats.validationStatus === 'Warnings' ? '#ed8936' : '#f56565') + ';">';
    html += '<strong style="color: ' + (stats.validationStatus === 'Valid' ? '#48bb78' : stats.validationStatus === 'Warnings' ? '#ed8936' : '#f56565') + ';">‚úÖ Validation</strong><br>';
    html += `Status: ${stats.validationStatus || 'Unknown'}<br>`;
    html += `Errors: ${stats.validationErrors || 0}<br>`;
    html += `Warnings: ${stats.validationWarnings || 0}`;
    html += '</div>';
    
    html += '</div>';
    return html;
  }

  // Normalize URL for matching (lowercase, strip trailing /)
  function normalizeUrl(url) {
    if (!url) return '';
    return url.toLowerCase().replace(/\/$/, '');
  }
  
  // Match product URLs even when one has path prefix (e.g., /photography-services-near-me/)
  function matchProductUrl(mappingUrl, reviewUrl) {
    if (!mappingUrl || !reviewUrl) return false;
    
    const normMapping = normalizeUrl(mappingUrl);
    const normReview = normalizeUrl(reviewUrl);
    
    // Exact match
    if (normMapping === normReview) return true;
    
    // Extract final slug from both URLs
    const mappingSlug = normMapping.split('/').pop() || '';
    const reviewSlug = normReview.split('/').pop() || '';
    
    // Match if final slugs are the same
    if (mappingSlug && reviewSlug && mappingSlug === reviewSlug) return true;
    
    // Also check if one URL contains the other's slug
    if (mappingSlug && normReview.includes(mappingSlug)) return true;
    if (reviewSlug && normMapping.includes(reviewSlug)) return true;
    
    return false;
  }
  
  // Find review data for a product URL (handles path prefix differences)
  function findReviewData(productUrl, reviewsDict) {
    if (!productUrl || !reviewsDict) return null;
    
    const normProductUrl = normalizeUrl(productUrl);
    
    // Try exact match first
    if (reviewsDict[normProductUrl]) {
      return reviewsDict[normProductUrl];
    }
    
    // Try matching by slug (handles /photography-services-near-me/ prefix differences)
    const productSlug = normProductUrl.split('/').pop() || '';
    if (productSlug) {
      for (const reviewUrl in reviewsDict) {
        if (matchProductUrl(productUrl, reviewUrl)) {
          return reviewsDict[reviewUrl];
        }
      }
    }
    
    return null;
  }

  // Build reviews dictionary: { product_url: { ratingValue, reviewCount } }
  function buildReviewsDict() {
    addDebugLog('üîç Building reviews dictionary...');
    if (!reviewsData) {
      addDebugLog('‚ö†Ô∏è No reviews data available');
      return {};
    }
    addDebugLog(`üìä Processing ${reviewsData.length} reviews...`);
    
    const dict = {};
    const productReviews = {};
    
    reviewsData.forEach((review, idx) => {
      // Try multiple ways to get product URL
      let productUrl = normalizeUrl(review.product_url || review.url || '');
      
      // If no product_url, try to construct from product_slug + domain_url
      if (!productUrl && review.product_slug) {
        const domain = review.domain_url || 'https://www.alanranger.com';
        // Remove trailing slash from domain and leading slash from slug
        const cleanDomain = domain.replace(/\/$/, '');
        const cleanSlug = review.product_slug.replace(/^\//, '');
        productUrl = normalizeUrl(`${cleanDomain}/${cleanSlug}`);
        
        if (idx < 3) {
          addDebugLog(`   Review ${idx + 1}: Constructed URL from slug: ${productUrl}`);
        }
      }
      
      if (!productUrl) {
        if (idx < 3) {
          addDebugLog(`   Review ${idx + 1}: No product_url or product_slug found (keys: ${Object.keys(review).join(', ')})`);
        }
        return;
      }
      
      if (!productReviews[productUrl]) {
        productReviews[productUrl] = [];
      }
      productReviews[productUrl].push(review);
    });
    
    addDebugLog(`üì¶ Found ${Object.keys(productReviews).length} unique product URLs`);
    
    // Aggregate reviews per product
    Object.keys(productReviews).forEach((productUrl, idx) => {
      const reviews = productReviews[productUrl];
      const validReviews = reviews.filter(r => {
        // Try multiple rating fields (note: CSV has ratingValue with capital V)
        const rating = parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 0);
        return rating >= 4 && rating <= 5;
      });
      
      if (idx < 3) {
        addDebugLog(`   Product ${idx + 1}: ${productUrl} - ${reviews.length} total reviews, ${validReviews.length} valid (‚â•4‚òÖ)`);
      }
      
      if (validReviews.length >= 3) {
        const totalRating = validReviews.reduce((sum, r) => {
          return sum + parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 0);
        }, 0);
        const avgRating = totalRating / validReviews.length;
        const reviewCount = Math.min(validReviews.length, 999);
        
        dict[productUrl] = {
          ratingValue: Math.round(avgRating * 10) / 10,
          reviewCount: reviewCount
        };
      }
    });
    
    addDebugLog(`‚úÖ Reviews dictionary built: ${Object.keys(dict).length} products with valid reviews`);
    
    // Show sample product URLs that have reviews
    const sampleProducts = Object.keys(dict).slice(0, 3);
    if (sampleProducts.length > 0) {
      addDebugLog(`   Sample products with reviews:`);
      sampleProducts.forEach(url => {
        const data = dict[url];
        addDebugLog(`     ${url} ‚Üí Rating: ${data.ratingValue}, Count: ${data.reviewCount}`);
      });
    }
    
    return dict;
  }

  // Build mappings dictionary: { event_url: { product_url, sku, brand, price, availability } }
  function buildMappingsDict() {
    addDebugLog('üîç Building mappings dictionary...');
    if (!mappingsData) {
      addDebugLog('‚ö†Ô∏è No mappings data available');
      return {};
    }
    addDebugLog(`üìä Processing ${mappingsData.length} mappings...`);
    
    const dict = {};
    let successCount = 0;
    let failCount = 0;
    
    mappingsData.forEach((mapping, idx) => {
      const eventUrl = normalizeUrl(mapping.event_url || '');
      const productUrl = normalizeUrl(mapping.product_url || '');
      
      if (idx < 3) {
        addDebugLog(`   Mapping ${idx + 1}: event_url="${eventUrl}", product_url="${productUrl}"`);
      }
      
      if (eventUrl && productUrl) {
        // Extract SKU from product URL slug
        const urlParts = productUrl.split('/');
        const productSlug = urlParts[urlParts.length - 1] || '';
        const sku = productSlug.toUpperCase().replace(/-/g, '-').replace(/[^A-Z0-9-]/g, '');
        
        dict[eventUrl] = {
          product_url: productUrl,
          sku: sku || null,
          brand: {
            "@type": "Brand",
            "name": "Alan Ranger Photography"
          },
          price: mapping.price_gbp || mapping.json_price || null,
          availability: mapping.availability || mapping.json_availability || "https://schema.org/InStock",
          product_title: mapping.product_title || null
        };
        successCount++;
      } else {
        failCount++;
        if (idx < 3) {
          addDebugLog(`   ‚ö†Ô∏è Mapping ${idx + 1} skipped: missing event_url or product_url`);
        }
      }
    });
    
    addDebugLog(`‚úÖ Mappings dictionary built: ${successCount} successful, ${failCount} skipped`);
    return dict;
  }

  // Parse location with intelligent region inference and geo coordinates (v4.1)
  function parseLocation(locationAddress = '', locationName = '', eventTitle = '') {
    const result = {
      streetAddress: '',
      addressLocality: '',
      addressRegion: '',
      postalCode: '',
      addressCountry: 'GB',
      geo: null,
      regionMatched: false
    };

    const regionMap = {
      "Wales": { region: "Wales", lat: 52.1307, lon: -3.7837 },
      "Scotland": { region: "Scotland", lat: 56.4907, lon: -4.2026 },
      "Cumbria": { region: "North West England", lat: 54.5772, lon: -2.7975 },
      "Yorkshire": { region: "Yorkshire and the Humber", lat: 53.9586, lon: -1.0803 },
      "Norfolk": { region: "East of England", lat: 52.6309, lon: 1.2974 },
      "Devon": { region: "South West England", lat: 50.7156, lon: -3.5309 },
      "Dorset": { region: "South West England", lat: 50.7090, lon: -2.0846 },
      "Warwickshire": { region: "West Midlands", lat: 52.2819, lon: -1.5845 },
      "Coventry": { region: "West Midlands", lat: 52.4068, lon: -1.5197 },
      "Peak District": { region: "East Midlands", lat: 53.3430, lon: -1.7770 },
      "Anglesey": { region: "Wales", lat: 53.2559, lon: -4.3424 },
      "Lake District": { region: "North West England", lat: 54.4609, lon: -3.0886 },
      "Gloucestershire": { region: "South West England", lat: 51.8642, lon: -2.2382 },
      "Northumberland": { region: "North East England", lat: 55.2088, lon: -2.0783 },
      "Somerset": { region: "South West England", lat: 51.1051, lon: -2.9262 },
      "Exmoor": { region: "South West England", lat: 51.1314, lon: -3.6897 },
      "Suffolk": { region: "East of England", lat: 52.1872, lon: 0.9708 },
      "Dartmoor": { region: "South West England", lat: 50.5610, lon: -3.9336 },
      "Snowdonia": { region: "Wales", lat: 52.8311, lon: -4.0840 },
      "Gower": { region: "Wales", lat: 51.5694, lon: -4.1289 },
      "Kerry": { region: "Ireland", lat: 52.1609, lon: -9.5250 },
      "Shropshire": { region: "West Midlands", lat: 52.7073, lon: -2.7553 },
      "Worcestershire": { region: "West Midlands", lat: 52.1920, lon: -2.2237 }
    };

    // Parse address parts
    const parts = locationAddress.split(',').map(p => p.trim()).filter(Boolean);
    for (const p of parts) {
      // Match UK postcode pattern
      if (/\b[A-Z]{1,2}\d{1,2}\s?\d[A-Z]{2}\b/i.test(p)) {
        result.postalCode = p.toUpperCase().replace(/\s+/g, ' ');
      } else if (!result.streetAddress && p) {
        result.streetAddress = p;
      } else if (!result.addressLocality && p && p !== result.streetAddress) {
        result.addressLocality = p;
      }
    }

    // Try to infer region and geo from keywords
    for (const [key, val] of Object.entries(regionMap)) {
      const searchText = `${locationAddress} ${locationName} ${eventTitle}`.toLowerCase();
      if (searchText.includes(key.toLowerCase())) {
        result.addressRegion = val.region;
        result.geo = {
          "@type": "GeoCoordinates",
          "latitude": val.lat,
          "longitude": val.lon
        };
        result.regionMatched = true;
        break;
      }
    }

    // Fallback: use location name or default
    if (!result.addressLocality && locationName) {
      result.addressLocality = locationName.split(' ')[0];
    }
    if (!result.addressRegion) {
      result.addressRegion = "West Midlands"; // Default fallback
    }

    return result;
  }

  // Enhanced address parsing - v4 Smart Enriched
  function parseAddress(locationAddressRaw, locationCityStateZip) {
    const address = { "@type": "PostalAddress" };
    
    if (!locationAddressRaw && !locationCityStateZip) {
      address.addressCountry = "GB";
      return address;
    }

    // Don't combine fields - Location_Address already has everything, Location_City_State_ZIP is just postcode
    let fullAddress = locationAddressRaw || '';
    
    // If Location_City_State_ZIP exists and doesn't duplicate postcode, append it
    if (locationCityStateZip && !fullAddress.includes(locationCityStateZip)) {
      fullAddress = fullAddress ? `${fullAddress}, ${locationCityStateZip}` : locationCityStateZip;
    }
    
    // Clean up the address string
    fullAddress = fullAddress.replace(/\s+/g, ' ').trim();
    
    // Split by comma and process
    const parts = fullAddress.split(",").map(p => p.trim()).filter(Boolean);
    
    // UK postcode pattern
    const ukPostcodePattern = /^[A-Z]{1,2}\d[A-Z\d]?\s*\d[A-Z]{2}$/i;
    
    // UK county/region patterns
    const ukRegions = ['West Midlands', 'Warwickshire', 'Worcestershire', 'Gloucestershire', 'Herefordshire', 'Shropshire', 'Staffordshire', 'Derbyshire', 'Nottinghamshire', 'Leicestershire', 'Northamptonshire', 'Oxfordshire', 'Buckinghamshire', 'Berkshire', 'Hampshire', 'Surrey', 'Kent', 'Essex', 'Suffolk', 'Norfolk', 'Cambridgeshire', 'Lincolnshire', 'Yorkshire', 'Lancashire', 'Cheshire', 'Cumbria', 'Northumberland', 'Durham', 'North Yorkshire', 'South Yorkshire', 'West Yorkshire', 'East Yorkshire'];
    
    // Process parts from end to beginning (postcode, region, city, street)
    for (let i = parts.length - 1; i >= 0; i--) {
      const part = parts[i];
      const partUpper = part.toUpperCase();

      // Country (skip "England" - it's not a region)
      if (!address.addressCountry && /^(United Kingdom|UK|Scotland|Wales|Northern Ireland)$/i.test(part)) {
        address.addressCountry = "GB";
      }
      // Postal code
      else if (!address.postalCode && ukPostcodePattern.test(part)) {
        address.postalCode = part.toUpperCase().replace(/\s+/g, ' ');
      }
      // Region/County (check against known UK regions, skip "England")
      else if (!address.addressRegion && !/^(United Kingdom|UK|England)$/i.test(part)) {
        const matchedRegion = ukRegions.find(r => partUpper.includes(r.toUpperCase()) || partUpper === r.toUpperCase());
        if (matchedRegion) {
          address.addressRegion = matchedRegion;
        }
      }
    }
    
    // Now process from beginning to end for street and locality
    // UK addresses typically: street, city, county/region, postcode, country
    const streetParts = [];
    let localityFound = false;
    
    for (let i = 0; i < parts.length; i++) {
      const part = parts[i];
      const partUpper = part.toUpperCase();
      
      // Skip if already processed (postcode, country, region)
      if (ukPostcodePattern.test(part)) continue;
      if (/^(United Kingdom|UK|England|Scotland|Wales|Northern Ireland)$/i.test(part)) continue;
      if (address.addressRegion && (partUpper.includes(address.addressRegion.toUpperCase()) || partUpper === address.addressRegion.toUpperCase())) continue;
      
      // Check if it's a known UK region (should have been caught in first loop, but double-check)
      const isRegion = ukRegions.some(r => partUpper.includes(r.toUpperCase()));
      if (isRegion) continue;
      
      // First part(s) are street address, then comes locality (city)
      if (!localityFound && part.length > 2) {
        // If we already have street parts, this is likely the locality
        if (streetParts.length > 0) {
          address.addressLocality = part;
          localityFound = true;
        } else {
          // First part is street address
          streetParts.push(part);
        }
      } else if (!localityFound) {
        // Still collecting street address parts
        streetParts.push(part);
      }
    }
    
    // Assign street address (combine all street parts)
    if (streetParts.length > 0) {
      address.streetAddress = streetParts.join(', ');
    }
    
    // Default country if not found
    if (!address.addressCountry) {
      address.addressCountry = "GB";
    }
    
    // Only return fields that have values (omit empty fields)
    const cleanAddress = {};
    if (address["@type"]) cleanAddress["@type"] = address["@type"];
    if (address.streetAddress) cleanAddress.streetAddress = address.streetAddress;
    if (address.addressLocality) cleanAddress.addressLocality = address.addressLocality;
    if (address.addressRegion) cleanAddress.addressRegion = address.addressRegion;
    if (address.postalCode) cleanAddress.postalCode = address.postalCode;
    if (address.addressCountry) cleanAddress.addressCountry = address.addressCountry;
    
    return cleanAddress;
  }

  // Combine date and time into ISO 8601 format
  function combineDateTime(dateStr, timeStr) {
    if (!dateStr) return null;
    if (!timeStr) return dateStr; // Return date only if no time
    
    // Normalize time format (handle HH:MM:SS or HH:MM)
    const timeMatch = timeStr.match(/(\d{1,2}):(\d{2})(?::(\d{2}))?/);
    if (!timeMatch) return dateStr;
    
    const hours = timeMatch[1].padStart(2, '0');
    const minutes = timeMatch[2].padStart(2, '0');
    const seconds = timeMatch[3] ? timeMatch[3].padStart(2, '0') : '00';
    
    return `${dateStr}T${hours}:${minutes}:${seconds}`;
  }

  // Compute duration in ISO 8601 format (PT120M default)
  function computeDuration(startDate, endDate, startTime, endTime) {
    if (!startDate || !endDate) return "PT120M";
    
    try {
      const start = combineDateTime(startDate, startTime);
      const end = combineDateTime(endDate, endTime);
      
      if (!start || !end) return "PT120M";
      
      const startDateObj = new Date(start);
      const endDateObj = new Date(end);
      const diffMs = endDateObj - startDateObj;
      
      if (diffMs <= 0) return "PT120M";
      
      const diffMins = Math.round(diffMs / (1000 * 60));
      return `PT${diffMins}M`;
    } catch (e) {
      return "PT120M";
    }
  }

  // Detect if location is virtual (Zoom/Online)
  function isVirtualLocation(locationName, locationAddress) {
    const virtualKeywords = ['zoom', 'online', 'virtual', 'webinar'];
    const locationStr = (locationName || '').toLowerCase() + ' ' + (locationAddress || '').toLowerCase();
    return virtualKeywords.some(keyword => locationStr.includes(keyword));
  }

  // Detect audience type from keywords
  function detectAudience(eventTitle, description, tags) {
    const text = ((eventTitle || '') + ' ' + (description || '') + ' ' + (tags || '')).toLowerCase();
    
    if (text.includes('beginner') || text.includes('beginners')) {
      return {
        "@type": "EducationalAudience",
        "educationalRole": "student",
        "audienceType": "Beginner"
      };
    }
    if (text.includes('advanced') || text.includes('professional')) {
      return {
        "@type": "EducationalAudience",
        "educationalRole": "student",
        "audienceType": "Advanced"
      };
    }
    if (text.includes('intermediate')) {
      return {
        "@type": "EducationalAudience",
        "educationalRole": "student",
        "audienceType": "Intermediate"
      };
    }
    return null;
  }

  // Extract keywords from Tags
  function extractKeywords(tags) {
    if (!tags) return [];
    return tags.split(/[,;|]/).map(t => t.trim()).filter(Boolean);
  }

  // Trim description if too long
  function trimDescription(description, maxLength = 5000) {
    if (!description) return '';
    if (description.length <= maxLength) return description;
    return description.substring(0, maxLength - 3) + '...';
  }

  // Validate Event schema structure
  function validateEventSchema(schema) {
    const errors = [];
    const warnings = [];
    
    if (!schema || !schema['@graph']) {
      return { isValid: false, message: 'Invalid schema structure: missing @graph', errors: ['Missing @graph'] };
    }
    
    const graph = schema['@graph'] || [];
    const events = graph.filter(item => item['@type'] === 'Event');
    
    if (events.length === 0) {
      return { isValid: false, message: 'No Event schemas found', errors: ['No events in @graph'] };
    }
    
    events.forEach((event, idx) => {
      // Required fields for Event schema
      const required = ['name', 'startDate', 'eventStatus', 'eventAttendanceMode'];
      required.forEach(field => {
        if (!event[field]) {
          errors.push(`Event ${idx + 1}: Missing required field "${field}"`);
        }
      });
      
      // Validate dates
      if (event.startDate && !/^\d{4}-\d{2}-\d{2}/.test(event.startDate)) {
        warnings.push(`Event ${idx + 1}: startDate format may be invalid`);
      }
      
      // Validate offers
      if (event.offers) {
        if (!event.offers.price || !event.offers.priceCurrency) {
          warnings.push(`Event ${idx + 1}: Offers missing price or priceCurrency`);
        }
      }
      
      // Validate location
      if (!event.location) {
        warnings.push(`Event ${idx + 1}: Missing location`);
      }
    });
    
    const isValid = errors.length === 0;
    const message = isValid 
      ? `Schema.org compliant (${events.length} event${events.length !== 1 ? 's' : ''})`
      : `${errors.length} error${errors.length !== 1 ? 's' : ''} found`;
    
    return { isValid, message, errors, warnings };
  }

  async function generateEventSchema() {
    try {
      // Initialize debug log and statistics
      window.debugLog = [];
      const stats = {
        csvType: 'Unknown',
        totalRows: 0,
        futureEvents: 0,
        eventsGenerated: 0,
        repeatingGroups: 0,
        reviewsLoaded: 0,
        productsWithReviews: 0,
        aggregateRatingsAdded: 0,
        reviewSnippetsAdded: 0,
        offersBlocks: 0,
        performerToggled: false,
        merchantFields: false,
        merchantFeedItems: 0,
        mappingsLoaded: 0,
        eventsWithMappings: 0,
        eventsWithProductUrls: 0,
        breadcrumbChains: 0,
        itemListItems: 0,
        eventSeriesGroups: 0,
        validationStatus: 'Unknown',
        validationErrors: 0,
        validationWarnings: 0
      };
      
      addDebugLog('üöÄ Starting event schema generation...');
      addDebugLog('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      
      // Check if events are loaded
      if (!events || events.length === 0) {
        addDebugLog('‚ùå No events loaded');
        alert('Please upload a CSV file first.');
        return;
      }
      
      stats.totalRows = events.length;
      addDebugLog(`üìã CSV & Events Section:`);
      addDebugLog(`   ‚úÖ Total rows parsed: ${stats.totalRows}`);
      
      // Detect CSV type
      const eventFileInput = document.getElementById('eventCsvFile');
      if (eventFileInput && eventFileInput.files && eventFileInput.files[0]) {
        const csvType = detectCsvType(eventFileInput.files[0].name, []);
        stats.csvType = csvType;
        addDebugLog(`   ‚úÖ CSV Type detected: ${csvType}`);
      }
      
      // Load review data if available
      await loadReviewData();
      
      // Get toggle options
      const includeReviews = document.getElementById('includeReviews')?.checked !== false;
      const includePerformer = document.getElementById('includePerformer')?.checked !== false;
      const groupRepeatingEvents = document.getElementById('groupRepeatingEvents')?.checked === true;
      const includeMerchantFields = document.getElementById('includeMerchantFields')?.checked === true;
      const enrichLocations = document.getElementById('toggleLocationEnrichment')?.checked !== false;
      const includeAvailabilityStarts = document.getElementById('toggleAvailabilityStarts')?.checked === true;
      
      stats.performerToggled = includePerformer;
      stats.merchantFields = includeMerchantFields;
      stats.enrichLocations = enrichLocations;
      
      addDebugLog(`‚öôÔ∏è Toggle states: Reviews=${includeReviews}, Performer=${includePerformer}, GroupRepeating=${groupRepeatingEvents}, MerchantFields=${includeMerchantFields}, EnrichLocations=${enrichLocations}, AvailabilityStarts=${includeAvailabilityStarts}`);
      
      const selectedCategory = document.getElementById('eventCategoryFilter').value;
      const today = new Date().toISOString().split('T')[0];
      const filtered = events.filter(e =>
        (selectedCategory === "__ALL__" || (e['Category'] || e['category'] || e['CATEGORY'] || '').split(',')[0].trim() === selectedCategory) &&
        e['Start_Date'] >= today &&
        e['Workflow_State'] === 'Published'
      );
      
      stats.futureEvents = filtered.length;
      addDebugLog(`   ‚úÖ Future events included: ${stats.futureEvents} (filtered from ${stats.totalRows} total)`);
      
      if (filtered.length === 0) {
        addDebugLog('‚ùå No events match criteria');
        alert('No events found matching the selected category and date criteria.');
        return;
      }

    // Build dictionaries for review enrichment
    addDebugLog('\n‚≠ê Reviews & Ratings Section:');
    const reviewsDict = buildReviewsDict();
    const mappingsDict = buildMappingsDict();
    
    stats.reviewsLoaded = reviewsData ? reviewsData.length : 0;
    stats.productsWithReviews = Object.keys(reviewsDict).length;
    stats.mappingsLoaded = mappingsData ? mappingsData.length : 0;
    
    addDebugLog(`   ‚úÖ Reviews loaded: ${stats.reviewsLoaded}`);
    addDebugLog(`   ‚úÖ Products with reviews: ${stats.productsWithReviews}`);
    addDebugLog(`   ‚úÖ Event mappings loaded: ${stats.mappingsLoaded}`);
    
    // Show sample mappings
    const sampleMappings = Object.keys(mappingsDict).slice(0, 3);
    if (sampleMappings.length > 0) {
      addDebugLog(`   Sample mappings:`);
      sampleMappings.forEach(eventUrl => {
        const mapping = mappingsDict[eventUrl];
        addDebugLog(`     ${eventUrl} ‚Üí ${mapping.product_url}`);
      });
    }

    const itemList = {
      "@type": "ItemList",
      "name": selectedCategory === "__ALL__" ? "Events" : selectedCategory + " Events",
      "itemListElement": filtered.map((event, i) => ({
        "@type": "ListItem",
        "position": i + 1,
        "url": event['Event_URL']
      }))
    };

    // Enhanced organizer block with full address and sameAs
    const organizerAddress = parseAddress("45 Hathaway Road", "Coventry, West Midlands, CV4 9HW");
    const organizerBlock = {
      "@type": "Organization",
      "name": "Alan Ranger Photography",
      "url": "https://www.alanranger.com",
      "logo": "https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w",
      "address": organizerAddress,
      "sameAs": [
        "https://www.instagram.com/alanrangerphoto",
        "https://www.facebook.com/alanrangerphotography",
        "https://www.linkedin.com/in/alanranger"
      ]
    };

    // Track series membership for backlinking (v4.3)
    const seriesMembership = new Map(); // eventId -> seriesId
    
    const eventSchemas = filtered.map((event, index) => {
      const eventUrl = normalizeUrl(event['Event_URL'] || '');
      const mappingData = mappingsDict[eventUrl];
      const productUrl = mappingData ? mappingData.product_url : null;
      const reviewData = productUrl ? findReviewData(productUrl, reviewsDict) : null;
      
      // Assign stable @id to Event (v4.3)
      const eventId = eventIdFromUrl(eventUrl);
      
      // Check if this event belongs to a series (v4.3) - use same patterns as detectEventSeries
      const title = (event['Event_Title'] || "").toLowerCase();
      const keywordPatterns = [
        { pattern: /bluebell.*photography.*workshop/i, key: "bluebell photography workshop" },
        { pattern: /batsford.*arboretum.*autumn.*photography.*workshop/i, key: "batsford arboretum autumn photography workshop" },
        { pattern: /camera.*course.*for.*beginners|camera.*courses.*for.*beginners/i, key: "camera course for beginners" },
        { pattern: /lightroom.*photo.*editing|lightroom.*classic.*photo.*editing/i, key: "lightroom photo editing" }
      ];
      
      for (const { pattern, key } of keywordPatterns) {
        if (pattern.test(title)) {
          const seriesId = seriesIdFromName(key);
          seriesMembership.set(eventId, seriesId);
          break; // Only match one pattern per event
        }
      }
      
      // Track statistics
      if (mappingData) stats.eventsWithMappings++;
      if (productUrl) stats.eventsWithProductUrls++;
      
      // Debug logging for first 3 events
      if (index < 3) {
        addDebugLog(`\nüìÖ Event ${index + 1}: ${event['Event_Title']}`);
        addDebugLog(`   Event URL: ${eventUrl}`);
        addDebugLog(`   Mapping found: ${mappingData ? 'YES' : 'NO'}`);
        if (mappingData) {
          addDebugLog(`   Product URL: ${productUrl}`);
          addDebugLog(`   Mapping Price: ${mappingData.price || 'none'}`);
          addDebugLog(`   CSV Price: ${event['Price'] || 'none'}`);
          addDebugLog(`   Mapping Availability: ${mappingData.availability || 'none'}`);
        }
        addDebugLog(`   Review data found: ${reviewData ? 'YES' : 'NO'}`);
        if (reviewData) {
          addDebugLog(`   Rating: ${reviewData.ratingValue}, Count: ${reviewData.reviewCount}`);
        } else if (productUrl) {
          addDebugLog(`   ‚ö†Ô∏è Product URL exists but no reviews found in reviews dict`);
          // Try to find matching review URL
          const productSlug = normalizeUrl(productUrl).split('/').pop();
          const matchingReviewUrls = Object.keys(reviewsDict).filter(url => {
            const reviewSlug = normalizeUrl(url).split('/').pop();
            return reviewSlug === productSlug;
          });
          if (matchingReviewUrls.length > 0) {
            addDebugLog(`   üí° Found ${matchingReviewUrls.length} review URL(s) with matching slug: ${matchingReviewUrls[0]}`);
          }
        } else {
          addDebugLog(`   ‚ö†Ô∏è No product URL (no mapping found)`);
        }
      }
      
      // üß© Event Core Fields Verification
      const startDate = combineDateTime(event['Start_Date'], event['Start_Time']);
      const endDate = combineDateTime(event['End_Date'], event['End_Time']);
      const duration = computeDuration(event['Start_Date'], event['End_Date'], event['Start_Time'], event['End_Time']);
      
      if (index < 3) {
        addDebugLog(`\n   üß© Event Core Fields:`);
        addDebugLog(`      ‚úÖ @context: https://schema.org`);
        addDebugLog(`      ‚úÖ @type: Event`);
        addDebugLog(`      ‚úÖ name: ${event['Event_Title'] ? 'Present' : 'MISSING'}`);
        addDebugLog(`      ‚úÖ startDate: ${startDate ? startDate.substring(0, 16) : 'MISSING'}`);
        addDebugLog(`      ‚úÖ endDate: ${endDate ? endDate.substring(0, 16) : 'MISSING'}`);
        addDebugLog(`      ‚úÖ duration: ${duration || 'MISSING'}`);
        addDebugLog(`      ‚úÖ eventStatus: EventScheduled`);
        addDebugLog(`      ‚úÖ identifier: ${eventUrl.split('/').pop() || 'MISSING'}`);
      }
      
      const address = enrichLocations 
        ? parseLocation(event['Location_Address'], event['Location_Business_Name'], event['Event_Title'])
        : parseAddress(event['Location_Address'], event['Location_City_State_ZIP']);
      const isVirtual = isVirtualLocation(event['Location_Business_Name'], event['Location_Address']);
      
      // Track address field statistics
      if (!isVirtual && address) {
        if (!stats.locationStats) {
          stats.locationStats = {
            streetAddress: { valid: 0, total: 0 },
            addressLocality: { valid: 0, total: 0 },
            addressRegion: { valid: 0, total: 0 },
            postalCode: { valid: 0, total: 0 },
            geoCoordinates: { valid: 0, total: 0 },
            fallbackApplied: 0,
            regionMapMatches: 0
          };
        }
        stats.locationStats.total++;
        if (address.streetAddress) {
          stats.locationStats.streetAddress.valid++;
          stats.addressFieldsWithStreetAddress = (stats.addressFieldsWithStreetAddress || 0) + 1;
        }
        if (address.addressLocality) {
          stats.locationStats.addressLocality.valid++;
          stats.addressFieldsWithLocality = (stats.addressFieldsWithLocality || 0) + 1;
        }
        if (address.addressRegion) {
          stats.locationStats.addressRegion.valid++;
          stats.addressFieldsWithRegion = (stats.addressFieldsWithRegion || 0) + 1;
          if (enrichLocations && address.regionMatched) {
            stats.locationStats.regionMapMatches++;
          }
        }
        if (address.postalCode) {
          stats.locationStats.postalCode.valid++;
          stats.addressFieldsWithPostalCode = (stats.addressFieldsWithPostalCode || 0) + 1;
        }
        if (enrichLocations && address.geo) {
          stats.locationStats.geoCoordinates.valid++;
        }
        if (!address.addressRegion || !address.addressLocality) {
          stats.locationStats.fallbackApplied++;
        }
      }
      
      // üèõ Location / Address Fields Verification
      if (index < 3) {
        addDebugLog(`\n   üèõ Location / Address Fields:`);
        addDebugLog(`      ‚úÖ location.@type: ${isVirtual ? 'VirtualLocation' : 'Place'}`);
        addDebugLog(`      ‚úÖ location.name: ${event['Location_Business_Name'] || 'MISSING'}`);
        if (!isVirtual && address) {
          addDebugLog(`      ‚úÖ address.streetAddress: ${address.streetAddress || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.addressLocality: ${address.addressLocality || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.addressRegion: ${address.addressRegion || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.postalCode: ${address.postalCode || 'MISSING'}`);
          addDebugLog(`      ‚úÖ address.addressCountry: ${address.addressCountry || 'MISSING'}`);
          // Debug: show what CSV fields contain (only for first 3 events)
          addDebugLog(`      üìã CSV Location_Address: "${event['Location_Address'] || 'empty'}"`);
          addDebugLog(`      üìã CSV Location_City_State_ZIP: "${event['Location_City_State_ZIP'] || 'empty'}"`);
        } else if (isVirtual) {
          addDebugLog(`      ‚úÖ OnlineEventAttendanceMode override applied`);
        }
      }
      
      // üë• Organizer / Provider / Performer Verification
      if (index < 3) {
        addDebugLog(`\n   üë• Organizer / Provider / Performer:`);
        addDebugLog(`      ‚úÖ organizer.@type: Organization`);
        addDebugLog(`      ‚úÖ organizer.name: Alan Ranger Photography`);
        addDebugLog(`      ‚úÖ organizer.logo: ${organizerBlock.logo ? 'Present' : 'MISSING'}`);
        addDebugLog(`      ‚úÖ organizer.sameAs: ${organizerBlock.sameAs ? organizerBlock.sameAs.length + ' links' : 'MISSING'}`);
        addDebugLog(`      ‚úÖ performer: ${includePerformer ? 'ON (will be added)' : 'OFF'}`);
        const category = (event['Category'] || event['category'] || '').split(',')[0].trim();
        const titleLower = (event['Event_Title'] || '').toLowerCase();
        if (category.toLowerCase().includes('course') || category.toLowerCase().includes('lesson') || titleLower.includes('course')) {
          addDebugLog(`      ‚úÖ provider: Present (same as organizer)`);
        }
      }
      
      const audience = detectAudience(event['Event_Title'], event['Excerpt'], event['Tags']);
      const keywords = extractKeywords(event['Tags']);
      const description = trimDescription(event['Excerpt'] || event['Description'], 5000);
      const validFrom = event['Published_Date'] || event['Start_Date'];
      
      // Extract identifier (slug from URL)
      const urlParts = eventUrl.split('/');
      const identifier = urlParts[urlParts.length - 1] || '';
      
      // Build enhanced keywords array (combine tags, category, location, and topic words)
      const category = (event['Category'] || event['category'] || '').split(',')[0].trim();
      const locationName = event['Location_Business_Name'] || '';
      const titleLower = (event['Event_Title'] || '').toLowerCase();
      const topicKeywords = [];
      if (titleLower.includes('photography')) topicKeywords.push('photography course', 'photography workshop');
      if (titleLower.includes('lightroom')) topicKeywords.push('Lightroom', 'photo editing');
      if (titleLower.includes('beginner')) topicKeywords.push('beginner photography', 'photography for beginners');
      if (titleLower.includes('landscape')) topicKeywords.push('landscape photography');
      if (titleLower.includes('portrait')) topicKeywords.push('portrait photography');
      if (titleLower.includes('macro')) topicKeywords.push('macro photography');
      const allKeywords = [...keywords, ...topicKeywords, category, locationName].filter(Boolean);
      
      // Generate "about" field (short phrase summarizing topic)
      let about = '';
      if (titleLower.includes('beginner')) about = 'Photography fundamentals and camera basics';
      else if (titleLower.includes('lightroom')) about = 'Photo editing and post-processing';
      else if (titleLower.includes('landscape')) about = 'Landscape photography techniques';
      else if (titleLower.includes('portrait')) about = 'Portrait photography skills';
      else if (titleLower.includes('macro')) about = 'Macro and close-up photography';
      else about = 'Photography education and training';
      
      // Build location (virtual or physical)
      let location;
      if (isVirtual) {
        location = {
          "@type": "VirtualLocation",
          "url": event['Event_URL'] || "https://www.alanranger.com"
        };
      } else {
        // Build PostalAddress object
        const postalAddress = {
          "@type": "PostalAddress",
          "streetAddress": address.streetAddress || undefined,
          "addressLocality": address.addressLocality || undefined,
          "addressRegion": address.addressRegion || undefined,
          "postalCode": address.postalCode || undefined,
          "addressCountry": address.addressCountry || "GB"
        };
        // Remove undefined fields
        Object.keys(postalAddress).forEach(key => {
          if (postalAddress[key] === undefined) delete postalAddress[key];
        });
        
        location = {
          "@type": "Place",
          "name": event['Location_Business_Name'] || "Alan Ranger Photography",
          "address": postalAddress
        };
        
        // Add geo coordinates if available (v4.1)
        if (enrichLocations && address.geo) {
          location.geo = address.geo;
        }
      }

      // Phase 3: Extract product data from mappings
      const useMappingPrice = mappingData && mappingData.price;
      const useMappingAvailability = mappingData && mappingData.availability;
      const eventPrice = useMappingPrice ? parseFloat(mappingData.price) : parseFloat(event['Price'] || 0);
      
      // Normalize availability to Schema.org URL format
      let normalizedAvailability = "https://schema.org/InStock"; // Default
      if (useMappingAvailability && mappingData.availability) {
        const avail = String(mappingData.availability).trim();
        if (avail === 'https://schema.org/InStock' || avail === 'InStock' || avail.toLowerCase() === 'in stock') {
          normalizedAvailability = "https://schema.org/InStock";
        } else if (avail === 'https://schema.org/OutOfStock' || avail === 'OutOfStock' || avail.toLowerCase() === 'out of stock') {
          normalizedAvailability = "https://schema.org/OutOfStock";
        } else if (avail === 'https://schema.org/PreOrder' || avail === 'PreOrder' || avail.toLowerCase() === 'preorder') {
          normalizedAvailability = "https://schema.org/PreOrder";
        } else {
          // Default to InStock if unrecognized format
          normalizedAvailability = "https://schema.org/InStock";
          console.warn(`‚ö†Ô∏è Unrecognized availability format "${avail}" for ${event['Event_Title']}, defaulting to InStock`);
        }
      }
      
      // Build event schema - v4 Smart Enriched
      const eventSchema = {
        "@context": "https://schema.org",
        "@type": "Event",
        "@id": eventId, // v4.3: Use stable ID from helper
        "identifier": identifier,
        "name": event['Event_Title'],
        "description": description,
        "url": eventUrl,
        "image": event['Event_Image'],
        "thumbnailUrl": event['Event_Image'],
        "startDate": startDate,
        "endDate": endDate,
        "duration": duration,
        "eventAttendanceMode": isVirtual 
          ? "https://schema.org/OnlineEventAttendanceMode" 
          : "https://schema.org/OfflineEventAttendanceMode",
        "eventStatus": "https://schema.org/EventScheduled",
        "isAccessibleForFree": false,
        "inLanguage": "en-GB",
        "organizer": organizerBlock,
        "location": location,
        "about": about,
        "keywords": allKeywords.join(', '),
        "sameAs": [eventUrl, productUrl].filter(Boolean),
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": eventUrl
        }
      };
      
      // Add performer if enabled (v4.1: enhanced with LinkedIn/YouTube)
      if (includePerformer) {
        eventSchema.performer = {
          "@type": "Person",
          "name": "Alan Ranger",
          "sameAs": [
            "https://www.linkedin.com/in/alanranger",
            "https://www.youtube.com/@alanrangerphotography",
            "https://www.alanranger.com/about-alan-ranger"
          ]
        };
      }
      
      // Add provider (same as organizer for courses)
      if (category.toLowerCase().includes('course') || category.toLowerCase().includes('lesson') || titleLower.includes('course')) {
        eventSchema.provider = organizerBlock;
      }
      
      // Add eventType and material (v4.1 SEO enrichment)
      // Determine event type from CSV type (already detected earlier)
      const csvType = stats.csvType || 'unknown';
      eventSchema.eventType = csvType === "lessons" ? "Lesson" : "Workshop";
      eventSchema.material = "Digital Camera, Tripod, ND Filters";
      
      // Update courseMode logic (v4.1: hybrid-aware)
      const eventAttendanceMode = eventSchema.eventAttendanceMode;
      if (eventAttendanceMode.includes("Online") && eventAttendanceMode.includes("Offline")) {
        eventSchema.courseMode = ["InPerson", "Online"];
      } else if (eventAttendanceMode.includes("Online")) {
        eventSchema.courseMode = ["Online"];
      } else {
        eventSchema.courseMode = ["InPerson"];
      }
      
      // Build offers with enhanced merchant fields
      if (eventPrice > 0) {
        stats.offersBlocks++;
        eventSchema.offers = {
          "@type": "Offer",
          "price": eventPrice.toFixed(2),
          "priceCurrency": event['Currency'] || "GBP",
          "availability": normalizedAvailability,
          "url": eventUrl,
          "validFrom": validFrom,
          "seller": {
            "@type": "Organization",
            "name": "Alan Ranger Photography",
            "url": "https://www.alanranger.com"
          }
        };
        
        // Add availabilityStarts and itemCondition (v4.1)
        if (includeAvailabilityStarts && event['Start_Date']) {
          try {
            eventSchema.offers.availabilityStarts = new Date(event['Start_Date']).toISOString();
          } catch (e) {
            console.warn('Failed to parse Start_Date for availabilityStarts:', e);
          }
        }
        if (includeMerchantFields) {
          eventSchema.offers.itemCondition = "https://schema.org/NewCondition";
        }
        
        // Ensure price is valid
        if (!eventSchema.offers.price || parseFloat(eventSchema.offers.price) <= 0) {
          eventSchema.offers.price = "0.00";
          console.warn(`‚ö†Ô∏è Missing price for ${event['Event_Title']}`);
        }
        
        if (index < 3) {
          addDebugLog(`\n   üí∞ Offers & Merchant Fields:`);
          addDebugLog(`      ‚úÖ offers.@type: Offer`);
          addDebugLog(`      ‚úÖ offers.price: ¬£${eventPrice.toFixed(2)} ${useMappingPrice ? '(from mapping)' : '(from CSV)'}`);
          addDebugLog(`      ‚úÖ offers.priceCurrency: ${event['Currency'] || 'GBP'}`);
          addDebugLog(`      ‚úÖ offers.availability: ${normalizedAvailability} ${useMappingAvailability ? '(from mapping)' : '(default)'}`);
          addDebugLog(`      ‚úÖ offers.seller.name: Alan Ranger Photography`);
          if (includeMerchantFields) {
            addDebugLog(`      ‚úÖ offers.hasMerchantReturnPolicy: Present`);
            if (mappingData && mappingData.sku) {
              addDebugLog(`      ‚úÖ sku: ${mappingData.sku}`);
            }
            if (mappingData && mappingData.brand) {
              addDebugLog(`      ‚úÖ brand: Present`);
            }
          }
        }
        
        // Add merchant return policy if merchant fields enabled
        if (includeMerchantFields) {
          eventSchema.offers.hasMerchantReturnPolicy = "https://www.alanranger.com/returns-policy";
        }
      } else if (index < 3) {
        addDebugLog(`\n   üí∞ Offers & Merchant Fields:`);
        addDebugLog(`      ‚ö†Ô∏è No offers added: price is ${eventPrice} (from mapping: ${useMappingPrice ? 'YES' : 'NO'}, from CSV: ${event['Price'] || 'none'})`);
      }
      
      // Phase 3: Add SKU and brand from mappings (if merchant fields enabled)
      if (includeMerchantFields) {
        if (mappingData && mappingData.sku) {
          eventSchema.sku = mappingData.sku;
        }
        if (mappingData && mappingData.brand) {
          eventSchema.brand = mappingData.brand;
        }
      }

      // Phase 4: Review Enrichment (if enabled)
      if (includeReviews && reviewData && reviewData.reviewCount >= 3) {
        stats.aggregateRatingsAdded++;
        eventSchema.aggregateRating = {
          "@type": "AggregateRating",
          "ratingValue": reviewData.ratingValue.toString(),
          "reviewCount": reviewData.reviewCount.toString(),
          "bestRating": "5",
          "worstRating": "1"
        };
        
        if (index < 3) {
          addDebugLog(`\n   ‚≠ê Reviews & Ratings:`);
          addDebugLog(`      ‚úÖ aggregateRating.@type: AggregateRating`);
          addDebugLog(`      ‚úÖ aggregateRating.ratingValue: ${reviewData.ratingValue}`);
          addDebugLog(`      ‚úÖ aggregateRating.reviewCount: ${reviewData.reviewCount}`);
        }
        
        // Add individual review snippets (top 5 reviews, trimmed to 300 chars)
        if (reviewsData && productUrl) {
          // Find matching reviews using slug-based matching
          const productSlug = normalizeUrl(productUrl).split('/').pop();
          const productReviews = reviewsData.filter(r => {
            // Try multiple ways to match product URL (same logic as buildReviewsDict)
            let rUrl = normalizeUrl(r.product_url || r.url || '');
            if (!rUrl && r.product_slug) {
              const domain = r.domain_url || 'https://www.alanranger.com';
              const cleanDomain = domain.replace(/\/$/, '');
              const cleanSlug = r.product_slug.replace(/^\//, '');
              rUrl = normalizeUrl(`${cleanDomain}/${cleanSlug}`);
            }
            
            // Match by exact URL or by slug
            if (rUrl === normalizeUrl(productUrl)) return true;
            const rSlug = rUrl.split('/').pop();
            return rSlug === productSlug;
          }).filter(r => {
            const rating = parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 0);
            return rating >= 4 && rating <= 5;
          }).sort((a, b) => {
            const dateA = a.date || a.review_created_utc || '';
            const dateB = b.date || b.review_created_utc || '';
            return dateB.localeCompare(dateA);
          }).slice(0, 5);
          
          if (productReviews.length > 0) {
            eventSchema.review = productReviews.map(r => {
              let reviewText = r.reviewBody || r.reviewbody || r.review_content || r.review || '';
              // Trim to 300 chars for v4
              if (reviewText.length > 300) {
                reviewText = reviewText.substring(0, 297) + '...';
              }
              const reviewerName = r.author || r.reviewer || r.review_username || 'Anonymous';
              const rating = parseFloat(r.ratingValue || r.ratingvalue || r.rating || r.review_stars || 5);
              const reviewDate = r.date || r.review_created_utc || '';
              
              return {
                "@type": "Review",
                "author": {
                  "@type": "Person",
                  "name": reviewerName
                },
                "reviewRating": {
                  "@type": "Rating",
                  "ratingValue": rating.toString(),
                  "bestRating": "5",
                  "worstRating": "1"
                },
                "reviewBody": reviewText,
                "datePublished": reviewDate
              };
            }).filter(r => r.reviewBody && r.reviewBody.trim().length > 0);
            
            stats.reviewSnippetsAdded += eventSchema.review.length;
            if (index < 3) {
              addDebugLog(`      ‚úÖ review array: ${eventSchema.review.length} snippets (trimmed ‚â§300 chars)`);
              addDebugLog(`      ‚úÖ review.author.name: Present`);
              addDebugLog(`      ‚úÖ review.reviewRating.ratingValue: 4-5`);
            }
          }
        }
      } else if (includeReviews && index < 3) {
        addDebugLog(`\n   ‚≠ê Reviews & Ratings:`);
        if (!reviewData) {
          addDebugLog(`      ‚ö†Ô∏è Reviews toggle ON but no reviewData (mapping: ${mappingData ? 'YES' : 'NO'}, productUrl: ${productUrl || 'none'})`);
        } else if (reviewData.reviewCount < 3) {
          addDebugLog(`      ‚ö†Ô∏è Reviews toggle ON but reviewCount (${reviewData.reviewCount}) < 3`);
        }
      }

      // Add audience if detected
      if (audience) {
        eventSchema.audience = audience;
      }

      // SEO Metadata Enhancers
      eventSchema.potentialAction = {
        "@type": "RegisterAction",
        "target": eventUrl
      };
      eventSchema.isFamilyFriendly = true;
      if (category.toLowerCase().includes('course') || category.toLowerCase().includes('lesson')) {
        eventSchema.learningResourceType = "Course";
        eventSchema.typicalAgeRange = "16-99";
        const courseModes = [];
        if (isVirtual) courseModes.push("Online");
        else courseModes.push("InPerson");
        eventSchema.courseMode = courseModes;
      }
      eventSchema.subjectOf = {
        "@type": "WebPage",
        "url": eventUrl
      };
      
      if (index < 3) {
        addDebugLog(`\n   üß† SEO Enhancers:`);
        addDebugLog(`      ‚úÖ potentialAction.@type: RegisterAction`);
        addDebugLog(`      ‚úÖ isFamilyFriendly: true`);
        if (eventSchema.learningResourceType) {
          addDebugLog(`      ‚úÖ learningResourceType: Course`);
          addDebugLog(`      ‚úÖ typicalAgeRange: 16-99`);
          addDebugLog(`      ‚úÖ courseMode: ${JSON.stringify(eventSchema.courseMode)}`);
        }
        addDebugLog(`      ‚úÖ subjectOf.@type: WebPage`);
      }

      // Phase 5: Generate breadcrumbs
      const eventName = event['Event_Title'] || 'Event';
      const urlPath = eventUrl.replace('https://www.alanranger.com', '').replace('http://www.alanranger.com', '').trim('/');
      const pathParts = urlPath.split('/').filter(Boolean);
      
      let parentCategoryName = "Photo Workshops UK";
      let parentCategoryUrl = "https://www.alanranger.com/photo-workshops-uk";
      
      if (pathParts.length > 0) {
        const parentSlug = pathParts[0];
        if (parentSlug === 'beginners-photography-lessons') {
          parentCategoryName = "Photography Services Near Me";
          parentCategoryUrl = "https://www.alanranger.com/photography-services-near-me";
        } else if (parentSlug === 'photographic-workshops-near-me' || parentSlug === 'photo-workshops-uk') {
          parentCategoryName = "Photo Workshops UK";
          parentCategoryUrl = "https://www.alanranger.com/photo-workshops-uk";
        }
      }
      
      const breadcrumb = {
        "@type": "BreadcrumbList",
        "@id": `${eventUrl}#breadcrumbs`,
        "itemListElement": [
          {
            "@type": "ListItem",
            "position": 1,
            "name": "Home",
            "item": "https://www.alanranger.com"
          },
          {
            "@type": "ListItem",
            "position": 2,
            "name": parentCategoryName,
            "item": parentCategoryUrl
          },
          {
            "@type": "ListItem",
            "position": 3,
            "name": eventName,
            "item": eventUrl
          }
        ]
      };
      
      if (index < 3) {
        addDebugLog(`\n   üß≠ Breadcrumbs & ItemList:`);
        addDebugLog(`      ‚úÖ BreadcrumbList.@type: BreadcrumbList`);
        addDebugLog(`      ‚úÖ BreadcrumbList.itemListElement: 3 items (Home > ${parentCategoryName} > ${eventName.substring(0, 30)}...)`);
      }

      return { eventSchema, breadcrumb };
    });
    
    // Phase 3.6: Event Schedule Grouping (DISABLED - using v4.2/v4.3 EventSeries system instead)
    // The old grouping system replaced individual events with EventSeries, which conflicts
    // with the new v4.2/v4.3 system that keeps individual events and adds superEvent backlinks.
    let finalEventList = eventSchemas.map(item => item.eventSchema);
    let finalBreadcrumbs = eventSchemas.map(item => item.breadcrumb);
    
    addDebugLog(`\nüîÅ EventSeries / Grouping Section:`);
    addDebugLog(`   Toggle state: ${groupRepeatingEvents ? 'ON' : 'OFF'}`);
    addDebugLog(`   Note: Using v4.2/v4.3 EventSeries system (keeps individual events + adds backlinks)`);
    
    // OLD GROUPING SYSTEM DISABLED - conflicts with v4.2/v4.3 EventSeries backlinking
    // Skip the old grouping logic entirely - new system handles it below
    // (Old code removed - EventSeries detection happens later in the flow)
    if (false) {
      // Group events by base title (remove week numbers, dates, etc.)
      const eventGroups = {};
      filtered.forEach((event, idx) => {
        const title = event['Event_Title'] || '';
        // Enhanced title normalization: remove week numbers, session numbers, dates, and common variations
        let baseTitle = title
          .replace(/\s*-\s*Week\s+\d+\s+of\s+\d+/i, '')
          .replace(/\s*-\s*Week\s+\d+/i, '')
          .replace(/\s*-\s*Session\s+\d+/i, '')
          .replace(/\s*-\s*\d+\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*/i, '')
          .replace(/\s*-\s*\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/g, '') // Remove dates like 01/15/2026
          .replace(/\s*\(.*?\)/g, '') // Remove parenthetical content
          .replace(/\s*\d+\s+Weekly\s+Evening\s+Classes?/i, '')
          .replace(/\s*\d+\s+Week\s+Course/i, '')
          .replace(/\s*3\s+Weekly/i, '')
          .trim();
        
        // Also try grouping by location if titles are very similar
        const location = event['Location_Business_Name'] || '';
        const groupKey = `${baseTitle}|${location}`;
        
        if (!eventGroups[groupKey]) {
          eventGroups[groupKey] = [];
        }
        eventGroups[groupKey].push({ event, schema: eventSchemas[idx].eventSchema, baseTitle });
      });
      
      addDebugLog(`   Found ${Object.keys(eventGroups).length} potential groups`);
      Object.keys(eventGroups).forEach(key => {
        const group = eventGroups[key];
        addDebugLog(`   Group "${key.split('|')[0]}": ${group.length} events`);
      });
      
      // For groups with 2+ events, create superEvent with eventSchedule
      Object.keys(eventGroups).forEach(groupKey => {
        const group = eventGroups[groupKey];
        if (group.length >= 2) {
          // Sort by start date
          group.sort((a, b) => {
            const dateA = a.event['Start_Date'] || '';
            const dateB = b.event['Start_Date'] || '';
            return dateA.localeCompare(dateB);
          });
          
          const firstEvent = group[0];
          const lastEvent = group[group.length - 1];
          const firstStart = combineDateTime(firstEvent.event['Start_Date'], firstEvent.event['Start_Time']);
          const lastEnd = combineDateTime(lastEvent.event['End_Date'], lastEvent.event['End_Time']);
          
          // Calculate date differences between consecutive events
          const dateDiffs = [];
          for (let i = 1; i < group.length; i++) {
            const prevDate = new Date(group[i-1].event['Start_Date']);
            const currDate = new Date(group[i].event['Start_Date']);
            const diffDays = Math.round((currDate - prevDate) / (1000 * 60 * 60 * 24));
            dateDiffs.push(diffDays);
          }
          
          // Check if events are weekly (6-8 days apart)
          const isWeekly = dateDiffs.length > 0 && dateDiffs.every(diff => diff >= 6 && diff <= 8);
          
          // Check if events are monthly (25-35 days apart, for 1-2 times per month)
          const isMonthly = dateDiffs.length > 0 && dateDiffs.every(diff => diff >= 25 && diff <= 35);
          
          // Check if events are roughly monthly but irregular (14-45 days apart)
          const isIrregularMonthly = dateDiffs.length > 0 && dateDiffs.every(diff => diff >= 14 && diff <= 45);
          
          if (isWeekly || isMonthly || isIrregularMonthly) {
            const pattern = isWeekly ? 'weekly' : (isMonthly ? 'monthly' : 'irregular monthly');
            const repeatFreq = isWeekly ? 'P1W' : 'P1M';
            
            stats.repeatingGroups++;
            stats.eventSeriesGroups++;
            addDebugLog(`   ‚úÖ Created EventSeries: "${group[0].baseTitle}" (${group.length} events, ${pattern} pattern)`);
            addDebugLog(`      Date differences: ${dateDiffs.join(', ')} days`);
            
            // Create superEvent with eventSchedule
            const superEvent = {
              "@context": "https://schema.org",
              "@type": "EventSeries",
              "@id": `${firstEvent.schema.url}#superEvent`,
              "name": group[0].baseTitle,
              "description": firstEvent.schema.description,
              "startDate": firstStart,
              "endDate": lastEnd,
              "eventSchedule": {
                "@type": "Schedule",
                "startDate": firstStart,
                "endDate": lastEnd,
                "repeatFrequency": repeatFreq,
                "scheduleTimezone": "Europe/London"
              },
              "organizer": organizerBlock,
              "location": firstEvent.schema.location,
              "offers": firstEvent.schema.offers
            };
            
            // Add subEvents
            superEvent.subEvent = group.map(g => g.schema);
            
            // Replace individual events with superEvent
            const groupIndices = group.map((_, i) => {
              const eventUrl = normalizeUrl(group[i].event['Event_URL'] || '');
              return finalEventList.findIndex(e => e.url === eventUrl);
            }).filter(idx => idx !== -1);
            
            // Remove individual events and add superEvent
            groupIndices.forEach(idx => {
              finalEventList[idx] = null;
            });
            finalEventList = finalEventList.filter(e => e !== null);
            finalEventList.unshift(superEvent);
          } else {
            addDebugLog(`   ‚ö†Ô∏è Skipped group "${group[0].baseTitle}": ${group.length} events, but date pattern doesn't match (diffs: ${dateDiffs.join(', ')} days)`);
          }
        } else {
          addDebugLog(`   ‚ö†Ô∏è Skipped group "${groupKey.split('|')[0]}": only ${group.length} event(s), need 2+`);
        }
      });
    }
    // Note: Old grouping system disabled - EventSeries detection happens later
    
    stats.eventsGenerated = finalEventList.length;
    stats.breadcrumbChains = finalBreadcrumbs.length;
    stats.itemListItems = itemList.itemListElement.length;
    
    // Location Verification Summary (v4.1)
    if (stats.locationStats && stats.locationStats.total > 0) {
      addDebugLog(`\nüè† Location Verification:`);
      const loc = stats.locationStats;
      addDebugLog(`   streetAddress: ‚úÖ ${loc.streetAddress.valid}/${loc.total}`);
      addDebugLog(`   addressLocality: ‚úÖ ${loc.addressLocality.valid}/${loc.total}`);
      addDebugLog(`   addressRegion: ‚úÖ ${loc.addressRegion.valid}/${loc.total}`);
      addDebugLog(`   postalCode: ‚úÖ ${loc.postalCode.valid}/${loc.total}`);
      addDebugLog(`   geoCoordinates: ‚úÖ ${loc.geoCoordinates.valid}/${loc.total}`);
      addDebugLog(`   fallbackApplied: ${loc.fallbackApplied}`);
      addDebugLog(`   regionMap matches: ${loc.regionMapMatches}`);
    }

    const eventList = finalEventList;
    const breadcrumbs = finalBreadcrumbs;
    
    // Detect and create EventSeries for recurring workshops (v4.2 + v4.3 backlinks)
    addDebugLog(`\nüîÅ EventSeries Detection (v4.2/v4.3):`);
    addDebugLog(`   Checking ${eventList.length} events for series patterns...`);
    
    const seriesGroups = detectEventSeries(eventList);
    const eventSeriesArray = [];
    
    if (Object.keys(seriesGroups).length === 0) {
      addDebugLog(`   ‚ö†Ô∏è No EventSeries groups detected (check keyword patterns match event titles)`);
      // Debug: show sample event titles
      if (eventList.length > 0) {
        addDebugLog(`   Sample event titles: ${eventList.slice(0, 3).map(e => e.name || e.Event_Title || 'N/A').join(', ')}`);
      }
    } else {
      addDebugLog(`   ‚úÖ Found ${Object.keys(seriesGroups).length} EventSeries group(s)`);
      Object.entries(seriesGroups).forEach(([k, v]) => {
        addDebugLog(`   ‚Ä¢ ${k}: ${v.length} events`);
      });
    }
    
    for (const [groupName, groupEvents] of Object.entries(seriesGroups)) {
      // Sort events by start date
      groupEvents.sort((a, b) => {
        const dateA = a.startDate || '';
        const dateB = b.startDate || '';
        return dateA.localeCompare(dateB);
      });
      
      const sample = groupEvents[0];
      const firstEvent = groupEvents[0];
      const lastEvent = groupEvents[groupEvents.length - 1];
      
      // Generate stable series ID (v4.3)
      const seriesId = seriesIdFromName(groupName);
      
      // Collect child event @ids for subEvent array (v4.3)
      const childEventIds = groupEvents
        .map(e => e["@id"] || eventIdFromUrl(e.url))
        .filter(Boolean);
      
      const eventSchedule = {
        "@type": "Schedule",
        "repeatFrequency": "P1Y",
        "startDate": firstEvent.startDate,
        "endDate": lastEvent.endDate,
        "scheduleTimezone": "Europe/London"
      };
      
      // Build keywords array from event titles and regions
      const keywords = [];
      groupEvents.forEach(e => {
        if (e.name) keywords.push(e.name);
        if (e.location && e.location.address && e.location.address.addressRegion) {
          keywords.push(e.location.address.addressRegion);
        }
      });
      const uniqueKeywords = [...new Set(keywords)].join(', ');
      
      const eventSeries = {
        "@context": "https://schema.org",
        "@type": "EventSeries",
        "@id": seriesId, // v4.3: Use stable ID from helper
        "name": groupName.charAt(0).toUpperCase() + groupName.slice(1) + " (Annual Series)",
        "description": sample.description || `${groupName} ‚Äî recurring annual workshops.`,
        "eventAttendanceMode": sample.eventAttendanceMode,
        "eventStatus": "https://schema.org/EventScheduled",
        "location": sample.location,
        "organizer": sample.organizer,
        "eventSchedule": eventSchedule,
        "keywords": uniqueKeywords,
        // Forward links: subEvent array (v4.3)
        "subEvent": childEventIds.map(id => ({ "@id": id })),
        // Keep subjectOf ItemList from v4.2
        "subjectOf": {
          "@type": "ItemList",
          "numberOfItems": groupEvents.length,
          "itemListElement": groupEvents.map((e, i) => ({
            "@type": "ListItem",
            "position": i + 1,
            "url": e.url,
            "name": e.name
          }))
        }
      };
      
      // Add performer if present in sample
      if (sample.performer) {
        eventSeries.performer = sample.performer;
      }
      
      // Add provider if present in sample
      if (sample.provider) {
        eventSeries.provider = sample.provider;
      }
      
      // Add about field
      eventSeries.about = {
        "@type": "Thing",
        "name": groupName,
        "url": sample.url
      };
      
      eventSeriesArray.push(eventSeries);
    }
    
    // Add EventSeries grouping summary to debug log (v4.2 + v4.3)
    if (Object.keys(seriesGroups).length > 0) {
      addDebugLog(`\nüîÅ EventSeries Grouping Summary:`);
      addDebugLog(`   Detected series groups: ${Object.keys(seriesGroups).length}`);
      Object.entries(seriesGroups).forEach(([k, v]) => {
        addDebugLog(`   ‚Ä¢ ${k}: ${v.length} events`);
      });
      addDebugLog(`   EventSeries objects generated: ${eventSeriesArray.length}`);
    }
    
    stats.eventSeriesCreated = eventSeriesArray.length;
    stats.eventSeriesGroups = Object.keys(seriesGroups).length;
    stats.eventSeriesNames = Object.keys(seriesGroups).map(k => k.charAt(0).toUpperCase() + k.slice(1));
    
    // Log Structure Section now that EventSeries stats are updated
    addDebugLog(`\nüß≠ Structure Section:`);
    addDebugLog(`   ‚úÖ Breadcrumb chains: ${stats.breadcrumbChains} (should match events)`);
    addDebugLog(`   ‚úÖ ItemList items: ${stats.itemListItems} (should match events)`);
    addDebugLog(`   ‚úÖ EventSeries groups: ${stats.eventSeriesGroups}`);
    
    // Add superEvent backlinks to Events (v4.3)
    // Build seriesMembership from detected groups to ensure consistency
    const seriesMembershipFromGroups = new Map();
    for (const [groupName, groupEvents] of Object.entries(seriesGroups)) {
      const seriesId = seriesIdFromName(groupName);
      for (const event of groupEvents) {
        const eventId = event["@id"] || eventIdFromUrl(event.url);
        if (eventId) {
          seriesMembershipFromGroups.set(eventId, seriesId);
        }
      }
    }
    
    // Merge with pre-populated seriesMembership (for backwards compatibility)
    seriesMembershipFromGroups.forEach((sid, eid) => {
      seriesMembership.set(eid, sid);
    });
    
    let superEventLinks = 0;
    for (const e of eventList) {
      // Skip if this is already an EventSeries (shouldn't happen, but safety check)
      if (e["@type"] === "EventSeries") continue;
      
      const eid = e["@id"];
      if (!eid) {
        addDebugLog(`   ‚ö†Ô∏è Event missing @id: ${e.name || 'Unknown'}`);
        continue;
      }
      
      const sid = seriesMembership.get(eid);
      if (!sid) continue;
      
      // Avoid duplicates if re-run
      if (!e.superEvent) {
        e.superEvent = { "@type": "EventSeries", "@id": sid };
        superEventLinks++;
      }
    }
    
    stats.superEventLinks = superEventLinks;
    
    // Add EventSeries backlinking summary (v4.3)
    addDebugLog(`\nüîÅ EventSeries Backlinking:`);
    addDebugLog(`   Events with superEvent: ${superEventLinks}`);
    addDebugLog(`   EventSeries emitted: ${eventSeriesArray.length}`);
    const totalSubEvents = eventSeriesArray.reduce((sum, series) => {
      return sum + (Array.isArray(series.subEvent) ? series.subEvent.length : 0);
    }, 0);
    addDebugLog(`   Total subEvent links: ${totalSubEvents}`);

    // Emit order: Events first, then EventSeries (v4.3)
    const outputJsonLd = [
      ...eventList,
      ...eventSeriesArray
    ];

    // Calculate linkage verification stats (v4.3)
    const verify = {
      eventId: 0,
      superEventId: 0,
      seriesId: 0,
      seriesSubEventTotal: 0,
      seriesWithScheduleRF: 0
    };
    
    for (const node of outputJsonLd) {
      if (node["@type"] === "Event") {
        if (node["@id"]) verify.eventId++;
        if (node.superEvent?.["@id"]) verify.superEventId++;
      } else if (node["@type"] === "EventSeries") {
        if (node["@id"]) verify.seriesId++;
        if (Array.isArray(node.subEvent)) verify.seriesSubEventTotal += node.subEvent.length;
        if (node.eventSchedule?.repeatFrequency) verify.seriesWithScheduleRF++;
      }
    }
    
    stats.linkageStats = verify;

    const fullSchema = {
      "@context": "https://schema.org",
      "@graph": [itemList, ...breadcrumbs, ...outputJsonLd]
    };

    const json = JSON.stringify(fullSchema, null, 2);
    const scriptEl = document.createElement('script');
    scriptEl.type = 'application/ld+json';
    scriptEl.textContent = json;
    
    // Phase 4: Event Schema - NO Schema Suppressor (only for Product Schema)
    const output = scriptEl.outerHTML;
    
    // Set output - use textContent to preserve HTML structure
    const outputElement = document.getElementById('eventOutput');
    if (!outputElement) {
      console.error('‚ùå Output element not found');
      alert('Error: Output element not found. Please refresh the page.');
      return;
    }
    
    // Clear any previous content and set the new output
    outputElement.textContent = '';
    outputElement.textContent = output;
    
    // Ensure copy button is visible after generation
    const copyButton = document.getElementById('copySchemaButton');
    const copyButtonTop = document.getElementById('copySchemaButtonTop');
    if (copyButton) {
      copyButton.style.display = 'inline-block';
      copyButton.style.visibility = 'visible';
      copyButton.style.opacity = '1';
    }
    if (copyButtonTop) {
      copyButtonTop.style.display = 'inline-block';
      copyButtonTop.style.visibility = 'visible';
      copyButtonTop.style.opacity = '1';
    }
    
    console.log('‚úÖ Event schema generated:', filtered.length, 'events');
    console.log('‚úÖ Output length:', output.length, 'characters');
    
    // Phase 5: Enhanced validation results with statistics
    try {
      const validationResults = validateEventSchema(fullSchema);
      stats.validationStatus = validationResults.isValid ? 'Valid' : (validationResults.warnings && validationResults.warnings.length > 0 ? 'Warnings' : 'Invalid');
      stats.validationErrors = validationResults.errors ? validationResults.errors.length : 0;
      stats.validationWarnings = validationResults.warnings ? validationResults.warnings.length : 0;
      
      addDebugLog(`\n‚úÖ Validation Section:`);
      addDebugLog(`   Status: ${stats.validationStatus}`);
      addDebugLog(`   Errors: ${stats.validationErrors}`);
      addDebugLog(`   Warnings: ${stats.validationWarnings}`);
      
      const validationStatus = validationResults.isValid ? '‚úÖ Valid' : '‚ùå Invalid';
      const eventsWithReviews = eventList.filter(e => e.aggregateRating).length;
      const eventsWithPerformer = eventList.filter(e => e.performer).length;
      const eventsWithOffers = eventList.filter(e => e.offers && parseFloat(e.offers.price) > 0).length;
      
      // Count lessons vs workshops (v4.1)
      const lessonsCount = eventList.filter(e => e.eventType === "Lesson").length;
      const workshopsCount = eventList.filter(e => e.eventType === "Workshop").length;
      
      // Calculate region coverage (v4.1)
      const regionCoverage = stats.locationStats && stats.locationStats.total > 0
        ? Math.round((stats.locationStats.addressRegion.valid / stats.locationStats.total) * 100)
        : 100;
      
      let statsMsg = `\n\nüìä Generation Summary:\n` +
        `   ‚Ä¢ ${filtered.length} event${filtered.length !== 1 ? 's' : ''} generated\n` +
        `   ‚Ä¢ Lessons: ${lessonsCount} valid / Workshops: ${workshopsCount} valid\n` +
        `   ‚Ä¢ ${eventsWithReviews} event${eventsWithReviews !== 1 ? 's' : ''} with reviews\n` +
        `   ‚Ä¢ ${eventsWithPerformer} event${eventsWithPerformer !== 1 ? 's' : ''} with performer\n` +
        `   ‚Ä¢ ${eventsWithOffers} event${eventsWithOffers !== 1 ? 's' : ''} with offers\n` +
        `   ‚Ä¢ Region coverage: ${regionCoverage}%\n`;
      
      // Add EventSeries summary (v4.2)
      if (stats.eventSeriesCreated && stats.eventSeriesCreated > 0 && stats.eventSeriesNames) {
        const seriesNames = stats.eventSeriesNames.join(', ');
        statsMsg += `   ‚Ä¢ üîÅ EventSeries Created: ${stats.eventSeriesCreated} (${seriesNames})\n`;
      }
      
      statsMsg += `\n${validationStatus} - ${validationResults.message}`;
      
      // Add location enrichment status (v4.1)
      if (enrichLocations) {
        statsMsg += `\nüìç Location Enrichment Active ‚Äî Regions and Geo auto-filled via keyword inference.`;
      }
      
      if (validationResults.warnings && validationResults.warnings.length > 0) {
        statsMsg += `\n‚ö†Ô∏è Warnings: ${validationResults.warnings.length}`;
      }
      
      // Final summary (v4.3)
      addDebugLog(`\n‚úÖ v4.3 Schema generation complete.`);
      addDebugLog(`   Lessons: ${lessonsCount} valid / Workshops: ${workshopsCount} valid`);
      addDebugLog(`   Region coverage: ${regionCoverage}%`);
      if (stats.eventSeriesCreated && stats.eventSeriesCreated > 0) {
        addDebugLog(`   EventSeries created: ${stats.eventSeriesCreated}`);
      }
      addDebugLog(`   Validation: ${validationResults.errors ? validationResults.errors.length : 0} errors / ${validationResults.warnings ? validationResults.warnings.length : 0} warnings`);
      addDebugLog(`\nüåê GitHub Hosting Status:`);
      addDebugLog(`   ‚úÖ Repository: alanranger-schema (public)`);
      addDebugLog(`   üåê Hosted via GitHub Pages at https://schema.alanranger.com/`);
      addDebugLog(`   üìÅ Files synced: lessons-schema.json, workshops-schema.json`);
      addDebugLog(`   ‚öôÔ∏è Auto-sync enabled via GitHub Actions`);
      addDebugLog(`   üí° Tip: Update via 'Export JSON' to push new schema automatically`);
      
      outputElement.textContent = output + statsMsg;
      
      // Show/hide merchant feed button based on toggle
      const merchantFeedContainer = document.getElementById('merchantFeedContainer');
      if (merchantFeedContainer) {
        merchantFeedContainer.style.display = includeMerchantFields ? 'block' : 'none';
      }
      
      // Store current schema for export
      window.currentEventSchema = fullSchema;
      window.currentEventList = eventList;
      window.currentMappingsDict = mappingsDict;
      window.currentEventSchemaCsvType = stats.csvType;
      
      // Show export container and prepare export
      const exportContainer = document.getElementById('schemaExportContainer');
      if (exportContainer) {
        exportContainer.style.display = 'block';
        prepareSchemaExport(fullSchema, stats.csvType, stats);
      }
      
      // Calculate merchant feed items
      if (includeMerchantFields) {
        stats.merchantFeedItems = eventList.filter(e => e['@type'] === 'Event' && e.offers && parseFloat(e.offers.price) > 0).length;
      }
      
      // Store field verification stats for modal
      window.fieldVerificationStats = {
        ...stats,
        coreFields: {
          context: '‚úÖ',
          type: '‚úÖ',
          name: '‚úÖ',
          startDate: '‚úÖ',
          endDate: '‚úÖ',
          duration: '‚úÖ',
          identifier: '‚úÖ'
        },
        locationFields: {
          name: '‚úÖ',
          streetAddress: stats.addressFieldsWithStreetAddress > 0 ? '‚úÖ' : '‚ö†Ô∏è',
          streetAddressCount: stats.addressFieldsWithStreetAddress || 0,
          locality: stats.addressFieldsWithLocality > 0 ? '‚úÖ' : '‚ö†Ô∏è',
          localityCount: stats.addressFieldsWithLocality || 0,
          region: stats.addressFieldsWithRegion > 0 ? '‚úÖ' : '‚ö†Ô∏è',
          regionCount: stats.addressFieldsWithRegion || 0,
          postalCode: stats.addressFieldsWithPostalCode > 0 ? '‚úÖ' : '‚ö†Ô∏è',
          postalCodeCount: stats.addressFieldsWithPostalCode || stats.eventsGenerated || 0
        }
      };
      
      // Update summary panel
      updateSummaryPanel(buildSummaryHTML(stats));
      
      // Auto-show field verification modal after generation
      setTimeout(() => {
        if (window.fieldVerificationStats) {
          showFieldVerificationModal();
        }
      }, 500);
      
      if (!validationResults.isValid && validationResults.errors.length > 0) {
        console.warn('‚ö†Ô∏è Schema validation issues:', validationResults.errors);
      }
    } catch (e) {
      console.warn('‚ö†Ô∏è Validation check failed:', e);
      // Keep the original output even if validation fails
      if (typeof outputElement !== 'undefined') {
        outputElement.textContent = output;
      }
      updateSummaryPanel(buildSummaryHTML(stats));
    }
  } catch (error) {
    console.error('‚ùå Error generating event schema:', error);
    alert('Error generating schema: ' + error.message + '\n\nPlease check the browser console for details.');
    const outputElement = document.getElementById('eventOutput');
    if (outputElement) {
      outputElement.textContent = 'Error: ' + error.message;
    }
  }
}

  // GitHub Hosting Verification - Ping GitHub function
  function initGitHubVerification() {
    const pingButton = document.getElementById('pingGitHub');
    if (pingButton && !pingButton.dataset.initialized) {
      pingButton.dataset.initialized = 'true';
      pingButton.addEventListener('click', async function() {
        const resultsDiv = document.getElementById('pingResults');
        const linksDiv = document.getElementById('schemaLinks');
        
        if (!resultsDiv) return;
        
        resultsDiv.textContent = 'üîÑ Pinging schema URLs...';
        resultsDiv.style.color = '#6b7280';
        
        const urls = [
          { name: 'Lessons Schema', url: 'https://schema.alanranger.com/lessons-schema.json' },
          { name: 'Workshops Schema', url: 'https://schema.alanranger.com/workshops-schema.json' }
        ];
        
        const checks = await Promise.all(urls.map(async (item) => {
          const start = performance.now();
          try {
            const res = await fetch(item.url, { 
              cache: 'no-cache',
              method: 'HEAD' // Use HEAD to avoid downloading full file
            });
            const time = (performance.now() - start).toFixed(0);
            const statusIcon = res.status === 200 ? '‚úÖ' : '‚ö†Ô∏è';
            const statusColor = res.status === 200 ? '#10b981' : '#f59e0b';
            return `<div style="margin-bottom: 0.5rem;"><span style="color: ${statusColor};">${statusIcon}</span> <strong>${item.name}:</strong> ${res.status} ${res.statusText} <span style="color: #6b7280;">(${time} ms)</span></div>`;
          } catch (err) {
            const time = (performance.now() - start).toFixed(0);
            return `<div style="margin-bottom: 0.5rem;"><span style="color: #ef4444;">‚ùå</span> <strong>${item.name}:</strong> ERROR - ${err.message} <span style="color: #6b7280;">(${time} ms)</span></div>`;
          }
        }));
        
        resultsDiv.innerHTML = checks.join('');
        resultsDiv.style.color = '#374151';
        
        // Show validation links
        if (linksDiv) {
          linksDiv.style.display = 'block';
        }
        
        // Log to debug console
        addDebugLog('\nüîç GitHub Hosting Verification:');
        checks.forEach(check => {
          addDebugLog(`   ${check.replace(/<[^>]*>/g, '')}`);
        });
      });
    }
  }
  
  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGitHubVerification);
  } else {
    initGitHubVerification();
  }

  // Prepare Schema Export UI (v4.4)
  function prepareSchemaExport(schema, csvType, stats) {
    // Initialize GitHub verification when export container is shown
    setTimeout(function() {
      initGitHubVerification();
    }, 100);
    
    const fileName = csvType === 'workshops' ? 'workshops-schema.json' : 
                     csvType === 'lessons' ? 'lessons-schema.json' : 
                     'event-schema.json';
    
    try {
      // Validate JSON structure first
      const jsonString = JSON.stringify(schema, null, 2);
      JSON.parse(jsonString); // Validate syntax
      
      // Safe minification using JSON.stringify (lossless, no regex)
      // Note: JSON.stringify(obj, null, 0) produces minified JSON (no indentation)
      // This is equivalent to JSON.stringify(obj) but more explicit
      let minifiedJson;
      let minificationSuccess = false;
      let minificationWarning = '';
      
      try {
        // Validate schema structure before minification
        if (!schema || typeof schema !== 'object') {
          throw new Error('Invalid schema: not an object');
        }
        if (!schema['@graph'] || !Array.isArray(schema['@graph'])) {
          throw new Error('Invalid schema: @graph is not an array');
        }
        
        // Safe minification: use JSON.stringify (lossless, no regex manipulation)
        minifiedJson = JSON.stringify(schema, null, 0);
        
        // Validate minified version parses correctly (catches syntax errors)
        JSON.parse(minifiedJson);
        
        // Verify it ends correctly (should end with ]} for @graph array)
        // Valid JSON-LD schema should end with: ]} (closing @graph array, then root object)
        const trimmed = minifiedJson.trim();
        if (!trimmed.endsWith(']}')) {
          // If it doesn't end with ]}, check if it's valid JSON structure
          // This catches issues like extra commas, wrong brackets, etc.
          try {
            const testParse = JSON.parse(minifiedJson);
            // If it parses but doesn't end correctly, it might have trailing whitespace
            // But if it ends with }}}, that's a structural issue
            if (trimmed.endsWith('}}}') || trimmed.endsWith(',]}') || trimmed.endsWith(',}')) {
              throw new Error('Invalid JSON structure: incorrect ending (extra brackets or commas)');
            }
          } catch (parseErr) {
            throw new Error('Invalid JSON structure: ' + parseErr.message);
          }
        }
        
        minificationSuccess = true;
      } catch (minifyError) {
        // Fallback: use unminified version if minification fails
        console.warn('‚ö†Ô∏è Minify validation failed. Using unminified version:', minifyError);
        minifiedJson = jsonString;
        minificationWarning = '‚ö†Ô∏è Minification failed - using unminified version';
      }
      
      const sizeReduction = Math.round((1 - minifiedJson.length/jsonString.length) * 100);
      
      const exportContent = document.getElementById('schemaExportContent');
      if (exportContent) {
        const warningBadge = minificationWarning ? `<span style="color: #f59e0b; font-size: 0.875rem;">${minificationWarning}</span><br>` : '';
        exportContent.innerHTML = `
          <div style="background: white; padding: 0.75rem; border-radius: 6px; border-left: 3px solid #0ea5e9;">
            <strong style="color: #0369a1;">üì¶ Export Ready</strong><br>
            <span style="color: #075985; font-size: 0.875rem;">File: <code>${fileName}</code></span><br>
            <span style="color: #075985; font-size: 0.875rem;">‚úÖ Validated: JSON.parse successful</span><br>
            ${warningBadge}
            <span style="color: #075985; font-size: 0.875rem;">üìä Size: ${(minifiedJson.length / 1024).toFixed(2)} KB ${minificationSuccess ? `(minified, ${sizeReduction}% reduction)` : '(unminified)'}</span><br>
            <span style="color: #075985; font-size: 0.875rem;">‚úÖ Structure: @context=${schema['@context'] === 'https://schema.org' ? '‚úÖ' : '‚ùå'}, @graph=${Array.isArray(schema['@graph']) ? '‚úÖ' : '‚ùå'}</span><br>
            <span style="color: #075985; font-size: 0.875rem;">üåê GitHub Pages: <a href="https://schema.alanranger.com/${fileName}" target="_blank" style="color: #0369a1;">https://schema.alanranger.com/${fileName}</a></span><br>
            <span style="color: #075985; font-size: 0.875rem;">üìã Script src tag ready for Squarespace</span>
          </div>
        `;
      }
      
      addDebugLog(`\nüì¶ Schema Export Ready:`);
      addDebugLog(`   File: ${fileName}`);
      addDebugLog(`   ‚úÖ Validated: JSON.parse successful`);
      
      // Quality checks
      const hasContext = schema['@context'] === 'https://schema.org';
      const hasGraph = Array.isArray(schema['@graph']);
      const fileSizeKB = minifiedJson.length / 1024;
      const isValid = hasContext && hasGraph && fileSizeKB < 250;
      
      addDebugLog(`   üìä Size: ${fileSizeKB.toFixed(2)} KB ${minificationSuccess ? `(minified, ${sizeReduction}% reduction)` : '(unminified - minification failed)'} ${fileSizeKB < 250 ? '‚úÖ' : '‚ö†Ô∏è (exceeds 250 KB)'}`);
      addDebugLog(`   ‚úÖ Structure: @context=${hasContext ? '‚úÖ' : '‚ùå'}, @graph=${hasGraph ? '‚úÖ' : '‚ùå'}`);
      if (minificationWarning) {
        addDebugLog(`   ${minificationWarning}`);
      }
      addDebugLog(`\nüåê GitHub Hosting Status:`);
      addDebugLog(`   ‚úÖ Repository: alanranger-schema (public)`);
      addDebugLog(`   üåê Hosted via GitHub Pages: https://schema.alanranger.com/`);
      addDebugLog(`   üìÅ Files synced: lessons-schema.json, workshops-schema.json`);
      addDebugLog(`   ‚öôÔ∏è Auto-sync: Enabled via GitHub Actions`);
      addDebugLog(`   üí° Tip: Use export buttons below to download JSON or copy GitHub Pages script src tag`);
    } catch (error) {
      console.error('‚ùå Error preparing export:', error);
      addDebugLog(`\nüì¶ Schema Export:`);
      addDebugLog(`   ‚ùå Validation error: ${error.message}`);
    }
  }

// Export Merchant Center Feed (Phase 6)
  function exportMerchantFeed() {
    if (!window.currentEventList || !window.currentMappingsDict) {
      alert('Please generate event schema first.');
      return;
    }
    
    const feed = [];
    window.currentEventList.forEach(event => {
      if (event['@type'] === 'Event' && event.offers && parseFloat(event.offers.price) > 0) {
        const eventUrl = event.url || '';
        const mappingData = window.currentMappingsDict[normalizeUrl(eventUrl)];
        
        const feedItem = {
          id: event.identifier || eventUrl.split('/').pop() || '',
          title: event.name || '',
          description: event.description || '',
          link: eventUrl,
          image_link: event.image || '',
          price: event.offers.price + ' ' + (event.offers.priceCurrency || 'GBP'),
          availability: (event.offers.availability === 'https://schema.org/InStock' || 
                         event.offers.availability === 'InStock' || 
                         String(event.offers.availability).toLowerCase() === 'in stock') 
                         ? 'in stock' : 'out of stock',
          brand: 'Alan Ranger Photography'
        };
        
        if (mappingData && mappingData.sku) {
          feedItem.gtin = mappingData.sku; // Using gtin field for SKU
        }
        
        feed.push(feedItem);
      }
    });
    
    if (feed.length === 0) {
      alert('No events with valid offers found for feed export.');
      return;
    }
    
    const feedJson = JSON.stringify(feed, null, 2);
    const blob = new Blob([feedJson], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `merchant-center-feed-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('‚úÖ Merchant Center feed exported:', feed.length, 'items');
  }

  // Export Schema to JSON File (v4.4) - Safe minification with validation and fallback
  function exportSchemaToJson() {
    if (!window.currentEventSchema) {
      alert('Please generate event schema first.');
      return;
    }

    const csvType = window.currentEventSchemaCsvType || 'unknown';
    const fileName = csvType === 'workshops' ? 'workshops-schema.json' : 
                     csvType === 'lessons' ? 'lessons-schema.json' : 
                     'event-schema.json';

    try {
      // Step 1: Validate JSON structure (check for trailing commas, etc.)
      const jsonString = JSON.stringify(window.currentEventSchema, null, 2);
      JSON.parse(jsonString); // Validate it parses correctly
      
      // Step 2: Safe minification using JSON.stringify (lossless, no regex)
      // Note: JSON.stringify(obj, null, 0) produces minified JSON (no indentation)
      // This is equivalent to JSON.stringify(obj) but more explicit
      let minifiedJson;
      let minificationSuccess = false;
      let minificationWarning = '';
      
      try {
        // Validate schema structure before minification
        if (!window.currentEventSchema || typeof window.currentEventSchema !== 'object') {
          throw new Error('Invalid schema: not an object');
        }
        if (!window.currentEventSchema['@graph'] || !Array.isArray(window.currentEventSchema['@graph'])) {
          throw new Error('Invalid schema: @graph is not an array');
        }
        
        // Safe minification: use JSON.stringify (lossless, no regex manipulation)
        minifiedJson = JSON.stringify(window.currentEventSchema, null, 0);
        
        // Validate minified version parses correctly (catches syntax errors)
        JSON.parse(minifiedJson);
        
        // Verify it ends correctly (should end with ]} for @graph array)
        if (!minifiedJson.trim().endsWith(']}') && !minifiedJson.trim().endsWith('}}')) {
          throw new Error('Invalid JSON structure: incorrect ending');
        }
        
        minificationSuccess = true;
      } catch (minifyError) {
        // Fallback: use unminified version if minification fails
        console.warn('‚ö†Ô∏è Minify validation failed. Saving unminified version instead:', minifyError);
        minifiedJson = jsonString;
        minificationSuccess = false;
        minificationWarning = '‚ö†Ô∏è Minification failed - saved unminified version';
      }
      
      // Step 3: Create blob and download
      const blob = new Blob([minifiedJson], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Step 4: Log to debug
      addDebugLog(`\nüì¶ Schema Export:`);
      addDebugLog(`   ‚úÖ Exported: ${fileName}`);
      addDebugLog(`   ‚úÖ Validated: JSON.parse successful`);
      
      // Quality checks
      const hasContext = window.currentEventSchema['@context'] === 'https://schema.org';
      const hasGraph = Array.isArray(window.currentEventSchema['@graph']);
      const fileSizeKB = minifiedJson.length / 1024;
      const sizeCheck = fileSizeKB < 250 ? '‚úÖ' : '‚ö†Ô∏è';
      
      if (minificationSuccess) {
        addDebugLog(`   ‚úÖ Minified: ${jsonString.length} ‚Üí ${minifiedJson.length} bytes (${Math.round((1 - minifiedJson.length/jsonString.length) * 100)}% reduction)`);
      } else {
        addDebugLog(`   ${minificationWarning}`);
      }
      addDebugLog(`   üìä File size: ${fileSizeKB.toFixed(2)} KB ${sizeCheck} ${fileSizeKB < 250 ? '(under 250 KB limit)' : '(exceeds 250 KB - consider splitting)'}`);
      addDebugLog(`   ‚úÖ Structure: @context=${hasContext ? '‚úÖ' : '‚ùå'}, @graph=${hasGraph ? '‚úÖ' : '‚ùå'}`);
      
      // GitHub Pages hosting info
      addDebugLog(`\nüåê GitHub Hosting:`);
      addDebugLog(`   ‚úÖ Repository: alanranger-schema (public)`);
      addDebugLog(`   üåê Hosted via GitHub Pages: https://schema.alanranger.com/`);
      addDebugLog(`   üìÅ File URL: https://schema.alanranger.com/${fileName}`);
      addDebugLog(`   ‚öôÔ∏è Auto-sync: Enabled via GitHub Actions`);
      addDebugLog(`   üí° Tip: Copy script src tag below for Squarespace integration`);
      
      // Update UI
      const exportContent = document.getElementById('schemaExportContent');
      if (exportContent) {
        let statusColor = (hasContext && hasGraph && fileSizeKB < 250) ? '#10b981' : '#f59e0b';
        let statusBg = (hasContext && hasGraph && fileSizeKB < 250) ? '#d1fae5' : '#fef3c7';
        const warningBadge = minificationWarning ? `<span style="color: #f59e0b; font-size: 0.875rem;">${minificationWarning}</span><br>` : '';
        
        exportContent.innerHTML = `
          <div style="background: ${statusBg}; padding: 0.75rem; border-radius: 6px; border-left: 3px solid ${statusColor}; margin-bottom: 0.75rem;">
            <strong style="color: ${(hasContext && hasGraph && fileSizeKB < 250) ? '#065f46' : '#92400e'};">‚úÖ Exported Successfully</strong><br>
            ${warningBadge}
            <span style="color: ${(hasContext && hasGraph && fileSizeKB < 250) ? '#047857' : '#78350f'}; font-size: 0.875rem;">File: <code>${fileName}</code></span><br>
            <span style="color: ${(hasContext && hasGraph && fileSizeKB < 250) ? '#047857' : '#78350f'}; font-size: 0.875rem;">Size: ${fileSizeKB.toFixed(2)} KB ${minificationSuccess ? '(minified)' : '(unminified)'} ${sizeCheck}</span><br>
            <span style="color: ${(hasContext && hasGraph && fileSizeKB < 250) ? '#047857' : '#78350f'}; font-size: 0.875rem;">Structure: @context=${hasContext ? '‚úÖ' : '‚ùå'}, @graph=${hasGraph ? '‚úÖ' : '‚ùå'}</span>
          </div>
        `;
      }
      
      console.log('‚úÖ Schema exported:', fileName, minificationSuccess ? '(minified)' : '(unminified - minification failed)');
    } catch (error) {
      console.error('‚ùå Error exporting schema:', error);
      alert('Error exporting schema: ' + error.message + '\n\nPlease check the browser console for details.');
      addDebugLog(`\nüì¶ Schema Export:`);
      addDebugLog(`   ‚ùå Export error: ${error.message}`);
    }
  }

  // Copy Squarespace Script Tag (v4.4) - External src version with safe minification
  function copySquarespaceScript() {
    if (!window.currentEventSchema) {
      alert('Please generate event schema first.');
      return;
    }

    const csvType = window.currentEventSchemaCsvType || 'unknown';
    const fileName = csvType === 'workshops' ? 'workshops-schema.json' : 
                     csvType === 'lessons' ? 'lessons-schema.json' : 
                     'event-schema.json';
    const schemaType = csvType === 'workshops' ? 'Workshops' : 
                       csvType === 'lessons' ? 'Lessons' : 
                       'Event';

    try {
      // Step 1: Validate JSON structure
      const jsonString = JSON.stringify(window.currentEventSchema, null, 2);
      const parsed = JSON.parse(jsonString);

      const hasContext = parsed['@context'] === 'https://schema.org';
      const hasGraph = Array.isArray(parsed['@graph']);
      
      // Step 2: Safe minification with validation and fallback
      // Note: JSON.stringify(obj, null, 0) produces minified JSON (no indentation)
      // This is equivalent to JSON.stringify(obj) but more explicit
      let minifiedJson;
      let minificationSuccess = false;
      let minificationWarning = '';
      
      try {
        // Validate schema structure before minification
        if (!window.currentEventSchema || typeof window.currentEventSchema !== 'object') {
          throw new Error('Invalid schema: not an object');
        }
        if (!window.currentEventSchema['@graph'] || !Array.isArray(window.currentEventSchema['@graph'])) {
          throw new Error('Invalid schema: @graph is not an array');
        }
        
        // Safe minification: use JSON.stringify (lossless, no regex manipulation)
        minifiedJson = JSON.stringify(window.currentEventSchema, null, 0);
        
        // Validate minified version parses correctly (catches syntax errors)
        JSON.parse(minifiedJson);
        
        // Verify it ends correctly (should end with ]} for @graph array)
        if (!minifiedJson.trim().endsWith(']}') && !minifiedJson.trim().endsWith('}}')) {
          throw new Error('Invalid JSON structure: incorrect ending');
        }
        
        minificationSuccess = true;
      } catch (minifyError) {
        // Fallback: use unminified version if minification fails
        console.warn('‚ö†Ô∏è Minify validation failed. Using unminified version for script tag:', minifyError);
        minifiedJson = jsonString;
        minificationSuccess = false;
        minificationWarning = '‚ö†Ô∏è Minification failed - using unminified version';
      }
      
      const fileSizeKB = minifiedJson.length / 1024;
      const isValid = hasContext && hasGraph && fileSizeKB < 250;

      const scriptSrcTag = `<!-- ${schemaType} Schema -->
<script type="application/ld+json"
        src="https://schema.alanranger.com/${fileName}">
<\/script>`;

      const inlineScriptTag = `<!-- ${schemaType} Schema (Inline) -->
<script type="application/ld+json">
${minifiedJson}
<\/script>`;

      navigator.clipboard.writeText(scriptSrcTag).then(() => {
        const exportContent = document.getElementById('schemaExportContent');
        if (exportContent) {
          let statusColor = isValid ? '#10b981' : '#f59e0b';
          let statusBg = isValid ? '#d1fae5' : '#fef3c7';
          let statusText = isValid ? '‚úÖ Ready for Production' : '‚ö†Ô∏è Review Required';
          const warningBadge = minificationWarning ? `<div style="color: #f59e0b; font-size: 0.875rem; margin-bottom: 0.5rem;">${minificationWarning}</div>` : '';

          exportContent.innerHTML = `
            <div style="background: ${statusBg}; padding: 0.75rem; border-radius: 6px; border-left: 3px solid ${statusColor}; margin-bottom: 0.75rem;">
              <strong style="color: ${isValid ? '#065f46' : '#92400e'};">${statusText}</strong><br>
              ${warningBadge}
              <span style="color: #047857; font-size: 0.875rem;">File: <code>${fileName}</code></span><br>
              <span style="color: #047857; font-size: 0.875rem;">Size: ${fileSizeKB.toFixed(2)} KB ${fileSizeKB < 250 ? '‚úÖ' : '‚ö†Ô∏è (exceeds 250 KB)'} ${minificationSuccess ? '(minified)' : '(unminified)'}</span><br>
              <span style="color: #047857; font-size: 0.875rem;">Structure: ${hasContext ? '‚úÖ' : '‚ùå'} @context, ${hasGraph ? '‚úÖ' : '‚ùå'} @graph</span>
            </div>
            <div style="background: #f3f4f6; padding: 0.75rem; border-radius: 6px; font-family: monospace; font-size: 0.75rem; overflow-x: auto; margin-bottom: 0.75rem;">
              <div style="color: #6b7280; margin-bottom: 0.5rem;">üìã External Script Tag (Copied):</div>
              <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word; color: #374151;">${scriptSrcTag}</pre>
              <div style="color: #6b7280; margin-top: 0.5rem; font-size: 0.7rem;">üí° Hosted on GitHub Pages at <a href="https://schema.alanranger.com/${fileName}" target="_blank" style="color: #0369a1;">https://schema.alanranger.com/${fileName}</a></div>
            </div>
            <div style="background: #f3f4f6; padding: 0.75rem; border-radius: 6px; font-family: monospace; font-size: 0.75rem; overflow-x: auto;">
              <div style="color: #6b7280; margin-bottom: 0.5rem;">üìã Inline Script Tag (Alternative):</div>
              <pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word; color: #374151; max-height: 200px; overflow-y: auto;">${inlineScriptTag.substring(0, 500)}...</pre>
            </div>
          `;
        }

        addDebugLog(`\nüìã Squarespace Script Tag (GitHub Pages):`);
        addDebugLog(`   ‚úÖ Copied to clipboard`);
        addDebugLog(`   üìù File: ${fileName}`);
        addDebugLog(`   üåê URL: https://schema.alanranger.com/${fileName}`);
        addDebugLog(`   üìä Size: ${fileSizeKB.toFixed(2)} KB ${fileSizeKB < 250 ? '‚úÖ' : '‚ö†Ô∏è (exceeds 250 KB)'} ${minificationSuccess ? '(minified)' : '(unminified)'}`);
        addDebugLog(`   ‚úÖ Structure: @context=${hasContext ? '‚úÖ' : '‚ùå'}, @graph=${hasGraph ? '‚úÖ' : '‚ùå'}`);
        if (minificationWarning) {
          addDebugLog(`   ${minificationWarning}`);
        }
        addDebugLog(`   üí° Hosted on GitHub Pages - ready to use in Squarespace`);
        addDebugLog(`\n   Script tag:`);
        addDebugLog(`   ${scriptSrcTag.split('\n').join('\n   ')}`);

        console.log('‚úÖ Squarespace script src tag copied to clipboard');
      }).catch(err => {
        console.error('‚ùå Error copying to clipboard:', err);
        alert('Error copying to clipboard. Please copy manually from the output above.');
      });
    } catch (error) {
      console.error('‚ùå Error generating script tag:', error);
      alert('Error generating script tag: ' + error.message);
      addDebugLog(`\nüìã Squarespace Script Tag:`);
      addDebugLog(`   ‚ùå Error: ${error.message}`);
    }
  }

  // Export Unminified JSON to GitHub Folder
  async function exportUnminifiedToGitHubFolder() {
    if (!window.currentEventSchema) {
      alert('Please generate event schema first.');
      return;
    }

    const csvType = window.currentEventSchemaCsvType || 'unknown';
    const fileName = csvType === 'workshops' ? 'workshops-schema.json' : 
                     csvType === 'lessons' ? 'lessons-schema.json' : 
                     'event-schema.json';

    try {
      // Generate unminified JSON (with indentation)
      const jsonString = JSON.stringify(window.currentEventSchema, null, 2);
      
      // Validate JSON
      JSON.parse(jsonString);
      
      const githubFolderPath = 'G:\\Dropbox\\alan ranger photography\\Website Code\\Schema Tools\\alanranger-schema';
      
      // Check if we're in Electron mode (can write directly to file system)
      if (typeof window.require !== 'undefined' || typeof require !== 'undefined') {
        try {
          const fs = typeof window.require !== 'undefined' ? window.require('fs') : require('fs');
          const path = typeof window.require !== 'undefined' ? window.require('path') : require('path');
          
          // Ensure directory exists
          const repoDir = path.join(githubFolderPath);
          if (!fs.existsSync(repoDir)) {
            fs.mkdirSync(repoDir, { recursive: true });
          }
          
          // Write file directly to root of repository (GitHub Pages serves from root)
          const filePath = path.join(repoDir, fileName);
          fs.writeFileSync(filePath, jsonString, 'utf-8');
          
          // Open folder in file explorer
          const { shell } = typeof window.require !== 'undefined' ? window.require('electron') : require('electron');
          shell.showItemInFolder(filePath);
          
          addDebugLog(`\nüì• Export to GitHub Folder:`);
          addDebugLog(`   ‚úÖ Saved: ${filePath}`);
          addDebugLog(`   üìÅ Folder opened in Explorer`);
          
          alert(`‚úÖ Successfully saved ${fileName} to GitHub folder!\n\nFolder opened in Explorer.`);
          return;
        } catch (electronError) {
          console.warn('Electron file system access failed, falling back to download:', electronError);
        }
      }
      
      // Fallback: Download file and open folder
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      // Try to open folder (Windows)
      try {
        // Use PowerShell to open folder
        const openFolderScript = `powershell -Command "Start-Process explorer.exe -ArgumentList '${githubFolderPath.replace(/'/g, "''")}'"`;
        // Note: This won't work in browser, but we can show instructions
        alert(`‚úÖ File downloaded!\n\nPlease save it to:\n${githubFolderPath}\n\nFile name: ${fileName}`);
      } catch (e) {
        alert(`‚úÖ File downloaded!\n\nPlease save it to:\n${githubFolderPath}\n\nFile name: ${fileName}`);
      }
      
      addDebugLog(`\nüì• Export to GitHub Folder:`);
      addDebugLog(`   ‚úÖ Downloaded: ${fileName}`);
      addDebugLog(`   üìÅ Save location: ${githubFolderPath}`);
      
    } catch (error) {
      console.error('‚ùå Error exporting to GitHub folder:', error);
      alert('Error exporting to GitHub folder: ' + error.message);
      addDebugLog(`\nüì• Export to GitHub Folder:`);
      addDebugLog(`   ‚ùå Error: ${error.message}`);
    }
  }

  // Product Schema Generation
  async function generateProductSchema() {
    // Check server status first (skip alert in Electron mode or web deployment)
    const isRunning = await ensureLocalExecutorRunning();
    if (!isRunning && !isElectronMode) {
      const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                              window.location.hostname.includes('localhost') === false;
      
      if (isWebDeployment) {
        const output = document.getElementById('productOutput');
        if (output) {
          output.value = '‚ÑπÔ∏è Local server features require Electron app or local development.\n';
          output.value += '   Download the Electron app for full automation.\n';
          output.value += '   Or run locally: npm run start-local\n';
        }
        return;
      }
      
      alert('Local server is not running. Please run "npm run start-local" in your terminal first.');
      return;
    }
    
    const fileInput = document.getElementById('productCsvFile');
    const step3Input = document.getElementById('file-step3');
    const output = document.getElementById('productOutput');
    const successMsg = document.getElementById('productSchemaSuccess');

    // In Electron mode with auto-chaining, skip file upload check - the Python script will find the file automatically
    // The merge script creates: 03 ‚Äì combined_product_reviews.csv
    // The schema script looks for: 03*.xlsx or products_with_review_data_final*.xlsx
    // If no file uploaded but we're in Electron mode, proceed anyway - script will handle it
    const fileToProcess = (step3Input && step3Input.files.length > 0) ? step3Input.files[0] : 
                          (fileInput && fileInput.files.length > 0) ? fileInput.files[0] : null;

    if (!fileToProcess && !isElectronMode) {
      // Only require file upload in browser mode
      alert("Please upload a product Excel file (from Step 3) first.");
      return;
    }

    // In Electron mode, the file was already created by Step 3b automatically
    // The Python script will automatically find and use: 03 ‚Äì combined_product_reviews.csv
    if (isElectronMode && !fileToProcess) {
      console.log("‚ÑπÔ∏è Electron mode: Using automatically created file from Step 3b");
      console.log("   Expected file: inputs-files/workflow/03 ‚Äì combined_product_reviews.csv");
    } else if (fileToProcess) {
      const fileName = fileToProcess.name;
      // Check if file needs to be saved to workflow directory first (browser mode only)
      if (!fileName.includes('products_with_review_data_final') && !fileName.includes('03')) {
        const proceed = confirm(
          "The uploaded file doesn't match the expected name (03 ‚Äì products_with_review_data_final.xlsx).\n\n" +
          "Please ensure the file from Step 3 is saved in /inputs-files/workflow/ as:\n" +
          "03 ‚Äì products_with_review_data_final.xlsx\n\n" +
          "Click OK to continue with preview, or Cancel to upload the correct file."
        );
        if (!proceed) return;
      }
    }

    // Use local task runner for schema generation
    await runLocalTask('schema', 4, '‚öôÔ∏è Generating Product Schema...', () => {
      output.value = "Schema generation complete. Check your project folder:\n- /outputs/ folder for individual JSON/HTML files\n- /inputs-files/workflow/ folder for combined CSV\n\n(All files remain in your Dropbox project folder)";
      if (successMsg) {
        successMsg.style.display = 'block';
        successMsg.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
      
      // Optionally stop the server after completion (commented out by default)
      // fetch("http://localhost:8000/exit").then(() => console.log("üßπ Local executor stopped."));
    });
  }

  // File upload handler for validator tab
  function onFileUpload() {
    const fileInput = document.getElementById('validatorCsvFile');
    if (fileInput.files.length > 0) {
      const fileName = fileInput.files[0].name;
      console.log('CSV file selected:', fileName);
      // File is ready for validation
    }
  }

  // Download template CSV file
  function downloadTemplateCSV() {
    const csvContent = 'URL,Page Name,Category\nhttps://www.example.com/product-1,Product One,Products\nhttps://www.example.com/product-2,Product Two,Products\nhttps://www.example.com/event-1,Event One,Events\nhttps://www.example.com/event-2,Event Two,Events';
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'validator-urls-template.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // ---- NEW: Central cache the scanner already fills ------------
  const ResultCache = new Map(); // key: url, value: { blocks, issues, warnings, info, rawHtml? }
  
  // Call this right after you complete analysis for a URL
  function cacheResult(url, payload) {
    ResultCache.set(url, payload);
  }

  // Schema Validator Tab Logic
  const SCHEMA_REQUIREMENTS = {
    WebSite: {
      required: ['name', 'url'],
      recommended: ['description', 'image', 'publisher']
    },
    Product: {
      required: ['name', 'url'],
      recommended: ['description', 'image', 'brand', 'offers', 'aggregateRating', 'review']
    },
    Event: {
      required: ['name', 'startDate'],
      recommended: ['endDate', 'location', 'organizer', 'offers', 'image', 'description', 'performer']
    },
    Organization: {
      required: ['name'],
      recommended: ['url', 'logo', 'address', 'contactPoint', 'telephone', 'description', 'image']
    },
    BreadcrumbList: {
      required: ['itemListElement'],
      recommended: []
    },
    ItemList: {
      required: ['itemListElement'],
      recommended: ['name']
    },
    LocalBusiness: {
      required: ['name'],
      recommended: ['address', 'telephone', 'url', 'openingHours', 'description', 'image']
    }
  };

  const DEFAULT_VALUES = {
    Product: {
      brand: { '@type': 'Brand', name: '[REPLACE WITH BRAND NAME]' },
      offers: {
        '@type': 'Offer',
        price: '[REPLACE WITH PRICE]',
        priceCurrency: 'GBP',
        availability: 'https://schema.org/InStock',
        url: '[AUTO-INFERRED FROM PAGE URL]'
      },
      description: '[REPLACE WITH PRODUCT DESCRIPTION]',
      image: '[REPLACE WITH PRODUCT IMAGE URL]'
    },
    Event: {
      organizer: {
        '@type': 'Organization',
        name: 'Alan Ranger Photography',
        logo: 'https://images.squarespace-cdn.com/content/v1/5013f4b2c4aaa4752ac69b17/b859ad2b-1442-4595-b9a4-410c32299bf8/ALAN+RANGER+photography+LOGO+BLACK.+switched+small.png?format=1500w',
        url: 'https://www.alanranger.com'
      },
      performer: {
        '@type': 'Person',
        name: 'Alan Ranger'
      },
      location: {
        '@type': 'Place',
        name: '[REPLACE WITH VENUE NAME]',
        address: {
          '@type': 'PostalAddress',
          addressCountry: 'GB'
        }
      },
      offers: {
        '@type': 'Offer',
        price: '0.00',
        priceCurrency: 'GBP',
        availability: 'https://schema.org/InStock',
        validFrom: '[AUTO-INFERRED FROM START DATE]'
      },
      description: '[REPLACE WITH EVENT DESCRIPTION]',
      image: '[REPLACE WITH EVENT IMAGE URL]'
    }
  };

  let validationResults = [];

  // Parse CSV and extract URLs
  function parseCSVForValidation(csvFile) {
    return new Promise((resolve, reject) => {
      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        complete: function(results) {
          const urls = [];
          const headers = results.meta.fields || [];
          
          const urlColumn = headers.find(h => 
            h.toLowerCase() === 'url' || h.toLowerCase() === 'link' || h.toLowerCase() === 'website'
          );
          
          if (!urlColumn) {
            reject(new Error('No URL column found. Expected column name: URL, Link, or Website'));
            return;
          }
          
          results.data.forEach((row, index) => {
            const url = row[urlColumn];
            if (url && (url.startsWith('http://') || url.startsWith('https://'))) {
              const trimmedUrl = url.trim();
              // Deduplicate URLs - only add if not already in array
              if (!urls.find(u => u.url === trimmedUrl)) {
                urls.push({
                  url: trimmedUrl,
                  row: urls.length, // Use current array index, not CSV row number
                  allFields: row
                });
              }
            }
          });
          
          resolve(urls);
        },
        error: function(error) {
          reject(error);
        }
      });
    });
  }

  // Server fallback: Fetch JSON-LD via server when client-side fails
  async function fetchPageSchemaServer(url) {
    try {
      // Determine API base URL (use deployed API when running locally)
      const apiBaseUrl = getApiBaseUrl();
      
      const apiUrl = `${apiBaseUrl}/api/fetch-jsonld?url=${encodeURIComponent(url)}`;
      debugLog(`Calling server fallback API: ${apiUrl}`, 'info');
      
      const response = await fetch(apiUrl);
      if (!response.ok) {
        throw new Error(`Server API returned ${response.status}`);
      }
      
      const data = await response.json();
      
      if (!data.ok) {
        throw new Error(data.error || 'Server API error');
      }
      
      debugLog(`Server fallback: found ${data.count} JSON-LD blocks`, data.count > 0 ? 'success' : 'warn');
      
      // Process scripts to extract types and detect duplicates
      const allNodes = [];
      const typeMap = new Map(); // type -> @id -> count
      
      data.scripts.forEach(block => {
        try {
          const nodes = flattenJsonLd(block, []);
          nodes.forEach(node => {
            allNodes.push(node);
            const types = asArray(node['@type']);
            types.forEach(type => {
              const idKey = node['@id'] || 'NO_ID';
              const mapKey = `${type}|${idKey}`;
              typeMap.set(mapKey, (typeMap.get(mapKey) || 0) + 1);
            });
          });
        } catch (e) {
          debugLog(`Error processing server block: ${e.message}`, 'warn');
        }
      });
      
      // Extract unique types
      const uniqueTypes = new Set();
      allNodes.forEach(node => {
        const types = asArray(node['@type']);
        types.forEach(t => uniqueTypes.add(t));
      });
      
      // Detect duplicates (excluding global injections)
      const globalPatterns = ['website', 'org', 'local', 'breadcrumbs'];
      const duplicateWarnings = [];
      
      typeMap.forEach((count, mapKey) => {
        if (count > 1) {
          const [type, idKey] = mapKey.split('|');
          const isGlobal = idKey !== 'NO_ID' && globalPatterns.some(p => idKey.includes(p));
          if (!isGlobal) {
            const idLabel = idKey === 'NO_ID' ? 'NO_ID' : `#${idKey.split('#')[1]}`;
            duplicateWarnings.push(`‚ö†Ô∏è DUPLICATE: ${type} (${idLabel}) √ó ${count}`);
          }
        }
      });
      
      return {
        url,
        jsonLd: data.scripts,
        schemaFound: data.count > 0,
        schemaType: Array.from(uniqueTypes).join(', '),
        serverFallback: true,
        duplicateWarnings: duplicateWarnings,
        blockCount: data.count
      };
      
    } catch (error) {
      debugLog(`Server fallback failed: ${error.message}`, 'error');
      throw error;
    }
  }

  // Helper: Detect Google Merchant Listing pattern in Product schema
  function detectMerchantListing(json) {
    // Check if this is a Product schema
    const isProduct = json['@type'] === 'Product' || 
                     (Array.isArray(json['@type']) && json['@type'].includes('Product'));
    
    if (!isProduct) {
      return false;
    }
    
    // Check for required Merchant Center fields
    // offers can be an object or array
    const offers = json.offers;
    if (!offers) {
      debugLog(`[MerchantListing] Product schema missing 'offers' field`, 'info');
      return false;
    }
    
    // Handle offers as object or array
    const offer = Array.isArray(offers) ? offers[0] : offers;
    
    // Check for price: can be direct price OR AggregateOffer with lowPrice/highPrice
    const hasPrice = offer && (
      offer.price || 
      (offer.lowPrice && offer.highPrice) || // AggregateOffer pattern
      (offer.lowPrice && offer.lowPrice === offer.highPrice) // Single price in AggregateOffer
    );
    
    const hasPriceCurrency = offer && offer.priceCurrency;
    const hasAvailability = offer && offer.availability;
    
    // Check for hasMerchantReturnPolicy at Product level OR inside offers object
    const hasReturnPolicy = json.hasMerchantReturnPolicy || (offer && offer.hasMerchantReturnPolicy);
    
    const hasMerchantListingFields = 
      hasPrice &&
      hasPriceCurrency &&
      hasAvailability &&
      hasReturnPolicy;
    
    if (!hasMerchantListingFields) {
      const missingFields = [];
      if (!hasPrice) missingFields.push('price (or lowPrice/highPrice for AggregateOffer)');
      if (!hasPriceCurrency) missingFields.push('priceCurrency');
      if (!hasAvailability) missingFields.push('availability');
      if (!hasReturnPolicy) missingFields.push('hasMerchantReturnPolicy (at Product or Offer level)');
      debugLog(`[MerchantListing] Product schema missing Merchant Center fields: ${missingFields.join(', ')}`, 'info');
    } else {
      debugLog(`[MerchantListing] ‚úÖ Product schema has all Merchant Center fields!`, 'success');
    }
    
    return hasMerchantListingFields;
  }

  // Helper: Extract types from JSON-LD block
  function extractTypesFromBlock(json, blockInfo, scriptIndex) {
    const blockTypes = [];
    
    if (json['@type']) {
      const types = Array.isArray(json['@type']) ? json['@type'] : [json['@type']];
      blockTypes.push(...types);
    }
    
    if (json['@graph']) {
      for (const item of json['@graph']) {
        if (item['@type']) {
          const types = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
          blockTypes.push(...types);
        }
      }
    }
    
    if (blockTypes.length > 0) {
      blockInfo.push({
        index: scriptIndex,
        types: blockTypes,
        hasId: !!json['@id'] || !!(json['@graph'] && json['@graph'].some(n => n['@id'])),
        isGraph: !!json['@graph']
      });
    }
    
    return blockTypes;
  }

  // Helper: Parse JSON-LD blocks from scripts
  // Helper: Decode HTML entities to normal JSON (Squarespace-compatible)
  function decodeHTML(str) {
    if (!str) return str;
    return str
      .replace(/&quot;/g, '"')
      .replace(/&apos;/g, "'")
      .replace(/&amp;/g, '&')
      .replace(/&#x2F;/g, '/')
      .replace(/&#x2f;/g, '/')
      .replace(/\\\//g, '/') // Also handle escaped forward slashes
      .trim();
  }

  // Helper: Find all JSON-LD script tags (including Squarespace patterns)
  function findAllJsonLdScripts(doc) {
    const scripts = [];
    
    // Standard pattern: script[type="application/ld+json"]
    const standardScripts = doc.querySelectorAll('script[type="application/ld+json"]');
    scripts.push(...Array.from(standardScripts));
    
    // Squarespace pattern: script[data-type="application/ld+json"]
    const squarespaceScripts = doc.querySelectorAll('script[data-type="application/ld+json"]');
    scripts.push(...Array.from(squarespaceScripts));
    
    // Also check noscript tags for JSON-LD content
    const noscriptTags = doc.querySelectorAll('noscript');
    for (const noscript of noscriptTags) {
      const noscriptStandard = noscript.querySelectorAll('script[type="application/ld+json"]');
      const noscriptSquarespace = noscript.querySelectorAll('script[data-type="application/ld+json"]');
      scripts.push(...Array.from(noscriptStandard));
      scripts.push(...Array.from(noscriptSquarespace));
    }
    
    // Deduplicate scripts (in case a script appears in multiple queries)
    const uniqueScripts = [];
    const seenScripts = new Set();
    for (const script of scripts) {
      if (!seenScripts.has(script)) {
        seenScripts.add(script);
        uniqueScripts.push(script);
      }
    }
    
    return uniqueScripts;
  }

  // Helper: Parse JSON-LD blocks with improved detection
  function parseJsonLdBlocks(scripts, schemaTypeCell) {
    const jsonLdBlocks = [];
    let detectedTypes = [];
    const blockInfo = [];
    const productCount = { total: 0, blocks: [] };
    
    for (let scriptIndex = 0; scriptIndex < scripts.length; scriptIndex++) {
      const script = scripts[scriptIndex];
      try {
        // Decode escaped content before parsing
        const decodedText = decodeHTML(script.textContent);
        const json = JSON.parse(decodedText);
        
        jsonLdBlocks.push(json);
        const blockTypes = extractTypesFromBlock(json, blockInfo, scriptIndex);
        detectedTypes.push(...blockTypes);
        
        // Track Product schemas specifically
        const hasProduct = blockTypes.includes('Product');
        if (hasProduct) {
          productCount.total++;
          productCount.blocks.push(scriptIndex);
        }
      } catch (e) {
        // Try parsing after decoding if initial parse failed
        try {
          const decodedText = decodeHTML(script.textContent);
          const json = JSON.parse(decodedText);
          jsonLdBlocks.push(json);
          const blockTypes = extractTypesFromBlock(json, blockInfo, scriptIndex);
          detectedTypes.push(...blockTypes);
          
          const hasProduct = blockTypes.includes('Product');
          if (hasProduct) {
            productCount.total++;
            productCount.blocks.push(scriptIndex);
          }
        } catch (e2) {
          console.warn('Failed to parse JSON-LD:', e);
          debugLog(`Failed to parse JSON-LD block ${scriptIndex}: ${e.message}`, 'error');
        }
      }
    }
    
    // Log duplicate Product detection
    if (productCount.total > 1) {
      debugLog(`Duplicate Product schemas detected (${productCount.total} found) ‚Äî first retained, subsequent skipped.`, 'warn');
      debugLog(`Product schemas found in blocks: ${productCount.blocks.join(', ')}`, 'info');
    }
    
    return { jsonLdBlocks, detectedTypes, blockInfo };
  }

  // Helper: Detect and log duplicate types
  function detectDuplicateTypes(detectedTypes, blockInfo) {
    const typeCounts = {};
    for (const t of detectedTypes) {
      typeCounts[t] = (typeCounts[t] || 0) + 1;
    }
    
    const duplicates = Object.keys(typeCounts).filter(t => typeCounts[t] > 1);
    
    if (duplicates.length > 0) {
      // Log duplicate detection as info (expected for multi-instance schemas like Event, Product)
      debugLog(`Duplicate schema types detected: ${duplicates.map(t => `${t} (${typeCounts[t]}x)`).join(', ')}`, 'info');
      debugLog(`Block details: ${blockInfo.map(b => `Block ${b.index}: ${b.types.join(',')}${b.hasId ? ' (has @id)' : ''}${b.isGraph ? ' (@graph)' : ''}`).join('; ')}`, 'info');
    }
    
    return { duplicates, typeCounts };
  }

  // Helper: Extract types from JSON-LD data
  function extractTypesFromJsonLd(data, detectedTypes) {
    if (data['@type']) {
      if (Array.isArray(data['@type'])) {
        detectedTypes.push(...data['@type']);
      } else {
        detectedTypes.push(data['@type']);
      }
    }
    if (data['@graph']) {
      for (const item of data['@graph']) {
        if (item['@type']) {
          if (Array.isArray(item['@type'])) {
            detectedTypes.push(...item['@type']);
          } else {
            detectedTypes.push(item['@type']);
          }
        }
      }
    }
  }

  // Helper: Parse JSON-LD blocks from scripts (with Squarespace pattern support)
  function parseJsonLdBlocksFromScripts(scripts) {
    const jsonLdBlocks = [];
    for (const script of scripts) {
      try {
        // Decode HTML entities before parsing
        const decodedText = decodeHTML(script.textContent);
        const json = JSON.parse(decodedText);
        jsonLdBlocks.push(json);
      } catch (e) {
        console.warn('Failed to parse JSON-LD:', e);
      }
    }
    return jsonLdBlocks;
  }

  // Helper: Extract detected types from scripts (with Squarespace pattern support)
  function extractDetectedTypes(scripts) {
    const detectedTypes = [];
    for (const s of scripts) {
      try {
        // Decode HTML entities before parsing
        const decodedText = decodeHTML(s.textContent.trim());
        const data = JSON.parse(decodedText);
        extractTypesFromJsonLd(data, detectedTypes);
      } catch (err) {
        console.warn('Invalid JSON-LD block', err);
      }
    }
    return detectedTypes;
  }

  // Helper: Handle direct fetch fallback
  async function handleDirectFetchFallback(url, schemaTypeCell) {
    if (schemaTypeCell) setProgress(schemaTypeCell, 15, 'Fetching');
    const response = await fetch(url, { mode: 'cors' });
    const htmlText = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlText, 'text/html');
    
    if (schemaTypeCell) setProgress(schemaTypeCell, 40, 'Fetched');
    
    // Find all JSON-LD script tags (including Squarespace patterns)
    const scripts = findAllJsonLdScripts(doc);
    const detectedTypes = extractDetectedTypes(scripts);
    
    if (schemaTypeCell) {
      const uniqueTypes = [...new Set(detectedTypes)];
      const schemaType = uniqueTypes.length ? uniqueTypes.join(', ') : 'None';
      setProgress(schemaTypeCell, uniqueTypes.length ? 85 : 70, uniqueTypes.length ? 'Detected' : 'Scanning');
    }
    
    const uniqueTypes = [...new Set(detectedTypes)];
    const schemaType = uniqueTypes.length ? uniqueTypes.join(', ') : 'None';
    const jsonLdBlocks = parseJsonLdBlocksFromScripts(scripts);
    
    return {
      url,
      jsonLd: jsonLdBlocks,
      schemaFound: jsonLdBlocks.length > 0,
      schemaType: schemaType
    };
  }

  // Helper: Handle server fallback
  async function handleServerFallback(url, schemaTypeCell) {
    debugLog(`Local parse failed for ${url}, trying server fallback...`, 'info');
    if (schemaTypeCell) {
      setProgress(schemaTypeCell, 10, 'Server fallback...');
    }
    
    try {
      const serverData = await fetchPageSchemaServer(url);
      
      if (schemaTypeCell) {
        setProgress(schemaTypeCell, 100, 'Done');
        setTimeout(() => {
          const schemaTypeText = serverData.schemaType || '‚Äî';
          schemaTypeCell.textContent = serverData.schemaFound ? `${schemaTypeText} (server)` : '‚Äî';
        }, 500);
      }
      
      serverData.parsePath = 'server';
      serverData.localParseFailed = true;
      
      return serverData;
    } catch (serverError) {
      if (schemaTypeCell) {
        markProgressError(schemaTypeCell);
        setProgress(schemaTypeCell, 100, 'Error');
      }
      throw serverError;
    }
  }

  // Helper: Process fetched HTML and extract schema (also check noscript tags and Squarespace patterns)
  function processFetchedHtml(html, schemaTypeCell, url) {
    if (schemaTypeCell) setProgress(schemaTypeCell, 40, 'Fetched');
    
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    // Find all JSON-LD script tags (including Squarespace patterns)
    const scripts = findAllJsonLdScripts(doc);
    
    if (schemaTypeCell) setProgress(schemaTypeCell, 60, 'Parsed DOM');
    
    const { jsonLdBlocks, detectedTypes, blockInfo } = parseJsonLdBlocks(scripts, schemaTypeCell);
    detectDuplicateTypes(detectedTypes, blockInfo);
    
    // Diagnostic log for detected blocks
    console.info(`Detected ${jsonLdBlocks.length} JSON-LD blocks (including Squarespace code blocks)`);
    debugLog(`Found ${scripts.length} JSON-LD script blocks, detected types: ${detectedTypes.length > 0 ? [...new Set(detectedTypes)].join(', ') : 'None'} (${detectedTypes.length} total, ${[...new Set(detectedTypes)].length} unique)`, detectedTypes.length > 0 ? 'success' : 'warn');
    
    if (schemaTypeCell) {
      const uniqueTypes = [...new Set(detectedTypes)];
      const schemaType = uniqueTypes.length ? uniqueTypes.join(', ') : 'None';
      setProgress(schemaTypeCell, uniqueTypes.length ? 85 : 70, uniqueTypes.length ? 'Detected' : 'Scanning');
    }
    
    return {
      url,
      jsonLd: jsonLdBlocks,
      schemaFound: jsonLdBlocks.length > 0,
      schemaType: detectedTypes.length ? [...new Set(detectedTypes)].join(', ') : 'None'
    };
  }

  // Helper: Handle fetch errors with fallbacks
  async function handleFetchErrors(error, url, schemaTypeCell) {
    try {
      return await handleDirectFetchFallback(url, schemaTypeCell);
    } catch (err) {
      if (schemaTypeCell) {
        markProgressError(schemaTypeCell);
        setProgress(schemaTypeCell, 100, 'Error');
      }
      return await handleServerFallback(url, schemaTypeCell);
    }
  }

  // Fetch page and extract JSON-LD
  async function fetchPageSchema(url, progressIndex) {
    const schemaTypeCell = progressIndex !== undefined ? document.getElementById(`schemaTypeCell_${progressIndex}`) : null;
    
    try {
      const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
      
      if (schemaTypeCell) setProgress(schemaTypeCell, 15, 'Fetching');
      const response = await fetch(proxyUrl);
      const data = await response.json();
      const html = data.contents;
      
      return processFetchedHtml(html, schemaTypeCell, url);
    } catch (error) {
      return await handleFetchErrors(error, url, schemaTypeCell);
    }
  }

  // Extract schema types
  function extractSchemaTypes(jsonLdBlocks) {
    const types = new Set();
    
    jsonLdBlocks.forEach(block => {
      if (Array.isArray(block)) {
        block.forEach(item => {
          if (item['@type']) {
            const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
            itemTypes.forEach(t => types.add(t));
          }
        });
      } else if (block['@type']) {
        const blockTypes = Array.isArray(block['@type']) ? block['@type'] : [block['@type']];
        blockTypes.forEach(t => types.add(t));
      } else if (block['@graph']) {
        block['@graph'].forEach(item => {
          if (item['@type']) {
            const itemTypes = Array.isArray(item['@type']) ? item['@type'] : [item['@type']];
            itemTypes.forEach(t => types.add(t));
          }
        });
      }
    });
    
    return Array.from(types);
  }

  // Helper: Split combined schema type string into individual types
  function splitSchemaType(schemaType) {
    if (typeof schemaType === 'string') {
      // Handle comma-separated types like "Organization,LocalBusiness"
      return schemaType.split(',').map(t => t.trim()).filter(Boolean);
    }
    if (Array.isArray(schemaType)) {
      return schemaType;
    }
    return [schemaType];
  }

  // Helper: Check if a field exists in any of the combined schema types
  function fieldExistsInCombinedTypes(schema, field, combinedTypes) {
    // Check if field exists directly in schema
    if (schema[field]) {
      return true;
    }
    
    // For combined types, check if field exists in schema (already checked above)
    // This function is used to determine if a recommended field should be downgraded to info
    // If the field is in the schema, it exists, so return true
    // If not, check if any of the combined types typically have this field
    // and if so, it might be inherited, so we'll downgrade to info instead of warning
    
    // Check if any of the combined types have this field in their recommended list
    // If so, and the field doesn't exist, it means it's truly missing but expected
    // However, for combined types like Organization,LocalBusiness, if url exists
    // for Organization, it satisfies LocalBusiness requirement too
    return false; // Field doesn't exist, will be handled by caller
  }

  // Helper: Check if any combined type is known
  function hasAnyKnownType(combinedTypes) {
    for (const type of combinedTypes) {
      if (SCHEMA_REQUIREMENTS[type]) {
        return true;
      }
    }
    return false;
  }

  // Helper: Collect all required and recommended fields from combined types
  function collectFieldsFromTypes(combinedTypes) {
    const allRequiredFields = new Set();
    const allRecommendedFields = new Set();
    
    for (const type of combinedTypes) {
      const requirements = SCHEMA_REQUIREMENTS[type];
      if (requirements) {
        requirements.required.forEach(f => allRequiredFields.add(f));
        requirements.recommended.forEach(f => allRecommendedFields.add(f));
      }
    }
    
    return { allRequiredFields, allRecommendedFields };
  }

  // Helper: Check required fields and add to missingFields
  function checkRequiredFields(schema, allRequiredFields, missingFields) {
    for (const field of allRequiredFields) {
      if (!schema[field]) {
        missingFields.push(field);
      }
    }
  }

  // Helper: Check recommended fields and categorize as warnings or info
  function checkRecommendedFields(schema, allRecommendedFields, combinedTypes, warnings, info) {
    for (const field of allRecommendedFields) {
      if (!schema[field]) {
        const typesRequiringField = combinedTypes.filter(type => {
          const req = SCHEMA_REQUIREMENTS[type];
          return req && req.recommended.includes(field);
        });
        
        if (typesRequiringField.length > 1) {
          info.push(`‚ÑπÔ∏è Recommended field "${field}" not present, but acceptable for combined schema types`);
        } else {
          warnings.push(`Missing recommended: ${field}`);
        }
      }
    }
  }

  // Validate schema fields
  function validateSchemaFields(schema, schemaType) {
    const missingFields = [];
    const warnings = [];
    const info = [];
    
    // Handle combined types like "Organization,LocalBusiness" or arrays
    const combinedTypes = splitSchemaType(schemaType);
    
    // Skip "Unknown" warning if any of the types are known
    if (!hasAnyKnownType(combinedTypes)) {
      warnings.push(`Unknown schema type: ${schemaType}`);
      return { missingFields, warnings, info };
    }
    
    // Collect fields from all types
    const { allRequiredFields, allRecommendedFields } = collectFieldsFromTypes(combinedTypes);
    
    // Check required fields
    checkRequiredFields(schema, allRequiredFields, missingFields);
    
    // Check recommended fields
    checkRecommendedFields(schema, allRecommendedFields, combinedTypes, warnings, info);
    
    return { missingFields, warnings, info };
  }

  // Analyze schemas
  function analyzeSchemas(jsonLdBlocks, url) {
    const analysis = {
      schemaFound: jsonLdBlocks.length > 0,
      schemaTypes: [],
      schemas: [],
      missingFields: [],
      warnings: [],
      info: [],
      valid: false
    };
    
    if (jsonLdBlocks.length === 0) {
      analysis.warnings.push('No schema markup found');
      return analysis;
    }
    
    analysis.schemaTypes = extractSchemaTypes(jsonLdBlocks);
    
    jsonLdBlocks.forEach((block, index) => {
      let schemas = [];
      
      if (block['@graph']) {
        schemas = block['@graph'];
      } else if (Array.isArray(block)) {
        schemas = block;
      } else {
        schemas = [block];
      }
      
      schemas.forEach(schema => {
        const schemaType = schema['@type'];
        if (schemaType) {
          // Skip Squarespace system-injected Organization nodes
          const types = Array.isArray(schemaType) ? schemaType : [schemaType];
          const isSystemInjected = types.includes('Organization') &&
            !schema['@id'] &&
            !schema.url &&
            !schema.name &&
            (schema.email || schema.telephone);
          
          if (isSystemInjected) {
            console.log('Skipping Squarespace auto Organization node ‚Äî no @id, name, or url');
            schema.systemInjected = true;
            // Add to schemas array for display (grayed out), but don't count in missing fields
            analysis.schemas.push({
              type: schemaType,
              schema: schema,
              missingFields: [],
              warnings: [],
              systemInjected: true
            });
            return; // Skip field validation and missing field counting
          }
          
          // Normalize schemaType to handle arrays - convert to comma-separated string
          const normalizedType = Array.isArray(schemaType) ? schemaType.join(',') : schemaType;
          const fieldValidation = validateSchemaFields(schema, normalizedType);
          analysis.schemas.push({
            type: schemaType,
            schema: schema,
            missingFields: fieldValidation.missingFields,
            warnings: fieldValidation.warnings,
            info: fieldValidation.info || [],
            systemInjected: false
          });
          
          // CRITICAL: Ensure arrays exist before pushing
          if (!analysis.missingFields || !Array.isArray(analysis.missingFields)) {
            analysis.missingFields = [];
          }
          if (!analysis.warnings || !Array.isArray(analysis.warnings)) {
            analysis.warnings = [];
          }
          if (!analysis.info || !Array.isArray(analysis.info)) {
            analysis.info = [];
          }
          
          if (fieldValidation.missingFields && Array.isArray(fieldValidation.missingFields)) {
            analysis.missingFields.push(...fieldValidation.missingFields);
          }
          if (fieldValidation.warnings && Array.isArray(fieldValidation.warnings)) {
            analysis.warnings.push(...fieldValidation.warnings);
          }
          if (fieldValidation.info && Array.isArray(fieldValidation.info) && fieldValidation.info.length > 0) {
            analysis.info.push(...fieldValidation.info);
          }
        }
      });
    });
    
    analysis.valid = analysis.schemaFound && 
                     analysis.missingFields.length === 0 && 
                     analysis.schemaTypes.length > 0;
    
    return analysis;
  }

  // Helper: Process placeholder value and replace with inferred data
  function processPlaceholderValue(value, field, url) {
    if (typeof value === 'string' && value.includes('[AUTO-INFERRED')) {
      return (field === 'url' && url) ? url : value;
    }
    
    if (typeof value === 'object' && value !== null) {
      const cloned = JSON.parse(JSON.stringify(value));
      if (field === 'offers' && cloned.url && cloned.url.includes('[AUTO-INFERRED')) {
        cloned.url = url;
      }
      return cloned;
    }
    
    return value;
  }

  // Helper: Fill a single field with default or placeholder
  function fillFieldValue(enhanced, field, defaults, url, isRequired) {
    if (enhanced[field] && (!Array.isArray(enhanced[field]) || enhanced[field].length > 0)) {
      return; // Field already has value
    }
    
    if (field === 'url' && url) {
      enhanced[field] = url;
      return;
    }
    
    if (defaults[field] !== undefined) {
      enhanced[field] = processPlaceholderValue(defaults[field], field, url);
      return;
    }
    
    if (isRequired) {
      enhanced[field] = `[REPLACE WITH ${field.toUpperCase()}]`;
    }
  }

  // Helper: Ensure basic schema structure
  function ensureBasicSchemaStructure(enhanced, schemaType, url) {
    if (!enhanced['@context']) {
      enhanced['@context'] = 'https://schema.org/';
    }
    if (!enhanced['@type'] && schemaType) {
      enhanced['@type'] = schemaType;
    }
    if (!enhanced.url && url) {
      enhanced.url = url;
    }
  }

  // Helper: Apply schema-specific enhancements
  function applySchemaSpecificEnhancements(enhanced, schemaType, url) {
    if (schemaType === 'Product' && enhanced.offers && typeof enhanced.offers === 'object' && !enhanced.offers.url && url) {
      enhanced.offers.url = url;
    }
    
    if (schemaType === 'Event' && enhanced.location && typeof enhanced.location === 'object' && !enhanced.location.address) {
      enhanced.location.address = DEFAULT_VALUES.Event.location.address;
    }
  }

  // Enhance schema with missing fields
  function enhanceSchema(schema, schemaType, url) {
    const enhanced = JSON.parse(JSON.stringify(schema));
    const defaults = DEFAULT_VALUES[schemaType] || {};
    const requirements = SCHEMA_REQUIREMENTS[schemaType];
    
    if (!requirements) {
      ensureBasicSchemaStructure(enhanced, schemaType, url);
      return enhanced;
    }
    
    ensureBasicSchemaStructure(enhanced, schemaType, url);
    
    // Fill missing required fields
    requirements.required.forEach(field => {
      fillFieldValue(enhanced, field, defaults, url, true);
    });
    
    // Fill missing recommended fields
    requirements.recommended.forEach(field => {
      fillFieldValue(enhanced, field, defaults, url, false);
    });
    
    applySchemaSpecificEnhancements(enhanced, schemaType, url);
    
    return enhanced;
  }

  // Helper: Build missing field messages
  function buildMissingFieldMessages(missingDetails, allNodes) {
    const missingMessages = [];
    for (const m of missingDetails) {
      const elsewhere = findFieldElsewhere(allNodes, m.field, m.type);
      let nodeLocation = '';
      if (m.hasId && m.key && m.key.includes('#')) {
        const idPart = m.key.split('#')[1];
        nodeLocation = ` (in node with @id: ${idPart})`;
      } else if (!m.hasId) {
        nodeLocation = ` (in node WITHOUT @id - likely needs fixing)`;
      }
      
      const duplicateInfo = m.instances > 1 ? ` [${m.instances} duplicate instances]` : '';
      if (elsewhere) {
        missingMessages.push(`${m.type}: "${m.field}" missing${nodeLocation}${duplicateInfo}. Found in ${elsewhere.fromType}: "${elsewhere.value}". Copy it into ${m.type}.`);
      } else {
        missingMessages.push(`${m.type}: "${m.field}" missing${nodeLocation}${duplicateInfo} (add this property to the ${m.type} node).`);
      }
    }
    return missingMessages;
  }

  // Helper: Build duplicate groups from nodes
  function buildDuplicateGroups(allNodes) {
    const duplicateGroups = {};
    for (let idx = 0; idx < allNodes.length; idx++) {
      const n = allNodes[idx];
      const types = asArray(n['@type']);
      for (const t of types) {
        if (!duplicateGroups[t]) duplicateGroups[t] = [];
        const key = n['@id'] || JSON.stringify([n['@type'], n.url, n.name]).slice(0, 100);
        duplicateGroups[t].push({ index: idx, key, hasId: !!n['@id'], node: n });
      }
    }
    return duplicateGroups;
  }

  // Helper: Count keys for duplicate detection
  function countKeysForType(nodes) {
    const keyCounts = {};
    const keyDetails = {};
    for (const n of nodes) {
      keyCounts[n.key] = (keyCounts[n.key] || 0) + 1;
      if (!keyDetails[n.key]) {
        keyDetails[n.key] = { hasId: n.hasId, node: n.node };
      }
    }
    return { keyCounts, keyDetails };
  }

  // Helper: Build duplicate warning for a key
  function buildDuplicateWarningForKey(t, key, keyCounts, keyDetails) {
    const keyName = key.includes('#') ? key.split('#')[1] : 'root';
    const label = key.includes('#') ? ` (@id: ${keyName})` : ' (no @id - likely duplicate)';
    return {
      warning: `${t}: ${keyCounts[key]} instances found${label}`,
      object: { type: t, id: keyName, count: keyCounts[key] }
    };
  }

  // Helper: Detect footer-injected schema patterns
  function detectFooterInjectedSchema(node) {
    const id = node['@id'] || '';
    const idLower = id.toLowerCase();
    const footerPatterns = ['footer', 'site-footer', 'footer-injection', 'footer-schema'];
    return footerPatterns.some(pattern => idLower.includes(pattern));
  }

  // Helper: Detect BreadcrumbList nodes globally
  function detectBreadcrumbListNodes(allNodes) {
    return allNodes.filter(n => {
      const types = asArray(n['@type']);
      return types.includes('BreadcrumbList');
    });
  }

  // Helper: Check if duplicate should be skipped
  function shouldSkipDuplicate(key, t, keyDetails, globalPatterns) {
    const isGlobal = key.includes('#') && globalPatterns.some(p => key.includes(p));
    const isBreadcrumb = t === 'BreadcrumbList';
    const isMultiInstanceAllowed = MULTI_INSTANCE_ALLOWED_TYPES.includes(t);
    const nodeData = keyDetails[key];
    const isFooterInjected = nodeData?.node ? detectFooterInjectedSchema(nodeData.node) : false;
    
    // Skip if it's a global schema, breadcrumb, multi-instance allowed type, or footer-injected
    return isGlobal || isFooterInjected || isBreadcrumb || isMultiInstanceAllowed;
  }

  // Helper: Process duplicate warnings
  function processDuplicateWarnings(duplicateGroups, globalPatterns) {
    const duplicateWarnings = [];
    const duplicateWarningsObjects = [];
    
    for (const t of Object.keys(duplicateGroups)) {
      const nodes = duplicateGroups[t];
      const { keyCounts, keyDetails } = countKeysForType(nodes);
      
      for (const key of Object.keys(keyCounts)) {
        if (keyCounts[key] > 1) {
          if (!shouldSkipDuplicate(key, t, keyDetails, globalPatterns)) {
            const { warning, object } = buildDuplicateWarningForKey(t, key, keyCounts, keyDetails);
            duplicateWarnings.push(warning);
            duplicateWarningsObjects.push(object);
          }
        }
      }
    }
    
    return { duplicateWarnings, duplicateWarningsObjects };
  }

  // Helper: Count keys for a type
  function countKeysForTypeSimple(nodes) {
    const keyCounts = {};
    for (const n of nodes) {
      keyCounts[n.key] = (keyCounts[n.key] || 0) + 1;
    }
    return keyCounts;
  }

  // Helper: Build global duplicate entry
  function buildGlobalDuplicateEntry(t, key, keyCounts) {
    const keyName = key.includes('#') ? key.split('#')[1] : 'root';
    return `${t}: ${keyCounts[key]}x (@id: ${keyName})`;
  }

  // Helper: Log global duplicates
  function logGlobalDuplicates(duplicateGroups, globalPatterns) {
    const globalDuplicates = [];
    for (const t of Object.keys(duplicateGroups)) {
      const nodes = duplicateGroups[t];
      const keyCounts = countKeysForTypeSimple(nodes);
      
      for (const key of Object.keys(keyCounts)) {
        if (keyCounts[key] > 1) {
          const isGlobal = key.includes('#') && globalPatterns.some(p => key.includes(p));
          if (isGlobal) {
            globalDuplicates.push(buildGlobalDuplicateEntry(t, key, keyCounts));
          }
        }
      }
    }
    
    if (globalDuplicates.length > 0) {
      debugLog(`Global injections detected (expected): ${globalDuplicates.join(', ')}`, 'info');
    }
  }

  // Helper: Log Organization nodes missing name
  function logOrgNodesMissingName(allNodes) {
    const orgNodes = allNodes.filter(n => {
      const types = asArray(n['@type']);
      return types.includes('Organization');
    });
    
    const orgNodesMissingName = orgNodes.filter(n => !n.name || !n.name.trim());
    if (orgNodesMissingName.length > 0) {
      // Log as info - these are typically Squarespace-injected nodes without @id, expected behavior
      debugLog(`Found ${orgNodesMissingName.length} Organization node(s) missing 'name' (likely Squarespace-injected):`, 'info');
      for (let idx = 0; idx < orgNodesMissingName.length; idx++) {
        const n = orgNodesMissingName[idx];
        const idInfo = n['@id'] ? `@id: ${n['@id']}` : 'no @id';
        const urlInfo = n.url ? `url: ${n.url}` : 'no url';
        debugLog(`  Organization ${idx + 1}: ${idInfo}, ${urlInfo}`, 'info');
      }
    }
  }

  // Helper: Update schema type cell UI
  function updateSchemaTypeCellUI(urlData, pageData, analysis) {
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${urlData.row}`);
    if (schemaTypeCell && schemaTypeCell.querySelector('.progress')) {
      setProgress(schemaTypeCell, 100, 'Done');
      setTimeout(() => {
        // Only update if cell still has progress indicator (hasn't been replaced by updateTableRow yet)
        const currentCell = document.getElementById(`schemaTypeCell_${urlData.row}`);
        if (currentCell && currentCell.querySelector('.progress')) {
          const uniqueTypes = [...new Set((pageData.schemaType || analysis.schemaTypes.join(', ') || '‚Äî').split(',').map(t => t.trim()))];
          
          // Get inferred types from result if available
          const resultIndex = validationResults.findIndex(r => r.url === urlData.url);
          const inferredTypes = resultIndex >= 0 && validationResults[resultIndex]?.inferredTypes || [];
          
          // Format with inferred types
          const schemaTypeText = formatSchemaTypesWithInferred(uniqueTypes, inferredTypes);
          const serverBadge = pageData.serverFallback ? ' (server)' : '';
          
          // Use innerHTML to render HTML (for italic styling)
          currentCell.innerHTML = schemaTypeText + serverBadge;
        }
      }, 500);
    }
  }

  // Helper: Add parse note to result
  function addParseNote(result, noteText, checkText) {
    if (!result.notes) {
      result.notes = noteText;
    } else if (!result.notes.includes(checkText)) {
      result.notes = noteText + '\n' + result.notes;
    }
  }

  // Helper: Append parse note to result
  function appendParseNote(result, noteText, checkText) {
    if (!result.notes || !result.notes.includes(checkText)) {
      result.notes = (result.notes || '') + (result.notes ? '\n' : '') + noteText;
    }
  }

  // Helper: Build result notes
  function buildResultNotes(result, pageData) {
    if (result.localParseFailed && result.serverFallback) {
      const parseNote = `Local parse: blocked. Server parse: success (${result.blockCount} blocks).`;
      addParseNote(result, parseNote, 'Server parse');
    } else if (!result.localParseFailed && result.schemaFound) {
      const parseNote = 'Local parse: success.';
      appendParseNote(result, parseNote, 'Local parse');
    } else if (result.serverFallback && !result.schemaFound) {
      const parseNote = 'Server fallback: no JSON-LD found.';
      appendParseNote(result, parseNote, 'Server fallback');
    }
    
    if (pageData.duplicateWarnings && pageData.duplicateWarnings.length > 0) {
      debugLog(`Server fallback detected duplicates: ${pageData.duplicateWarnings.join('; ')}`, 'info');
    }
  }

  // ---- Schema Extraction and Result Construction Fix ----
  
  // --- Schema Detection Utilities ---
  function extractSchemaTypeValue(typeValue) {
    if (!typeValue) return [];
    if (Array.isArray(typeValue)) return typeValue.map(t => t.trim());
    if (typeof typeValue === 'string') return typeValue.split(',').map(t => t.trim());
    return [];
  }

  // 2Ô∏è‚É£ Re-enable row-level progress
  function updateRowProgress(url, percent) {
    const row = document.querySelector(`[data-url="${url}"]`);
    if (!row) return;
    let bar = row.querySelector('.progress-inner');
    if (!bar) {
      const cell = row.querySelector('.status-cell') || row.querySelector(`#statusCell_${row.dataset.rowIndex || ''}`);
      if (!cell) return;
      const wrapper = document.createElement('div');
      wrapper.className = 'progress';
      bar = document.createElement('div');
      bar.className = 'progress-inner';
      wrapper.appendChild(bar);
      cell.appendChild(wrapper);
    }
    bar.style.width = percent + '%';
  }

  function buildAnalysisResult(url, blocks, issuesList = []) {
    const schemaTypes = [
      ...new Set(blocks.flatMap(b => extractSchemaTypeValue(b['@type'])).filter(Boolean))
    ];
    const schemaFound = schemaTypes.length > 0;

    // Ensure schemaFound stays true if any valid blocks exist
    if (!schemaFound && blocks && blocks.length > 0) {
      console.log(`[‚úì] Schema detected via fallback: ${blocks.map(b => b['@type'] || 'unknown').join(', ')}`);
    }

    const analysisResult = {
      url,
      schemaFound: schemaFound || (blocks && blocks.length > 0),
      schemaTypes,
      missingFields: issuesList.filter(i => i.severity === 'missing'),
      warnings: issuesList.filter(i => i.severity === 'warning'),
      info: issuesList.filter(i => i.severity === 'info'),
      timestamp: new Date().toISOString(),
    };

    cacheResult(url, analysisResult);
    
    // Store persistently in validationResults array by URL
    const resultIndex = validationResults.findIndex(r => r.url === url);
    if (resultIndex >= 0) {
      // Update existing result with schemaFound and schemaTypes
      validationResults[resultIndex].schemaFound = analysisResult.schemaFound;
      validationResults[resultIndex].schemaTypes = analysisResult.schemaTypes;
    } else {
      // If not found, push to array (though this should rarely happen)
      validationResults.push(analysisResult);
    }
    
    updateResultRow(url, analysisResult);
    return analysisResult;
  }

  // 4Ô∏è‚É£ Update table cells safely with enhanced status badges
  function updateResultRow(url, result) {
    const row = document.querySelector(`[data-url="${url}"]`);
    if (!row) return;
    
    // Extract row index from row ID or dataset
    const rowMatch = row.id?.match(/row_(\d+)/);
    const rowIndex = rowMatch ? rowMatch[1] : (row.dataset?.rowIndex || '');
    
    if (!rowIndex) return; // Can't update without index
    
    // Find cells by ID
    const schemaCell = document.getElementById(`schemaTypeCell_${rowIndex}`);
    const statusCell = document.getElementById(`statusCell_${rowIndex}`);
    const missingFieldsCell = document.getElementById(`missingFieldsCell_${rowIndex}`);
    const warningsCell = document.getElementById(`warningsCell_${rowIndex}`);
    const infoCell = document.getElementById(`infoCell_${rowIndex}`);
    
    // Update schema type cell
    if (schemaCell && result.schemaTypes) {
      // Preserve inferred types when updating cell
      const inferredTypes = result.inferredTypes || [];
      const types = result.schemaTypes.join(', ') || '‚Äî';
      
      if (inferredTypes.length > 0) {
        const formattedTypes = formatSchemaTypesWithInferred(result.schemaTypes, inferredTypes);
        schemaCell.innerHTML = formattedTypes;
      } else {
        schemaCell.textContent = types;
      }
    }
    
    // Update status cell with progress-aware badge
    if (statusCell) {
      const progressBar = row.querySelector('.progress-inner');
      const progress = progressBar ? Number.parseInt(progressBar.style.width) || 0 : 100;
      
      let statusHtml;
      if (!result.schemaFound && progress < 10) {
        statusHtml = '<span class="chip-queued">‚è≥ Queued</span>';
      } else if (!result.schemaFound && progress < 50) {
        statusHtml = '<span class="chip-fetching">üîÑ Fetching</span>';
      } else if (result.schemaFound) {
        const hasCritical = result.missingFields && result.missingFields.length > 0;
        if (hasCritical && result.missingFields.length > 3) {
          statusHtml = '<span class="chip-critical">‚ùå Critical</span>';
        } else if (hasCritical) {
          statusHtml = '<span class="chip-issues">‚ö†Ô∏è Issues</span>';
        } else {
          statusHtml = '<span class="chip-valid">‚úÖ Valid</span>';
        }
      } else {
        statusHtml = '<span class="status-badge no-schema">‚ùå No Schema</span>';
      }
      
      statusCell.innerHTML = statusHtml;
    }
    
    // Update Missing Fields column (with suppression)
    if (missingFieldsCell && result.missingFields) {
      const filteredMissingFields = filterSuppressedMissingFields(result.missingFields, result.schemaType || '', result.url || '');
      if (filteredMissingFields.length > 0) {
        missingFieldsCell.innerHTML = filteredMissingFields.map(f => `<div class="missing-entry">‚ùå ${f}</div>`).join('');
      } else {
        missingFieldsCell.textContent = '‚Äî';
      }
    }
    
    // Update Warnings column (with suppression)
    if (warningsCell && result.warnings) {
      const filteredWarnings = filterSuppressedWarnings(result.warnings, result.url || '');
      if (filteredWarnings.length > 0) {
        warningsCell.innerHTML = filteredWarnings.map(w => `<div class="warning-entry">‚ö†Ô∏è ${w}</div>`).join('');
      } else {
        warningsCell.textContent = '‚Äî';
      }
    }
    
    // Update Info column (with suppression)
    if (infoCell && result.info) {
      const filteredInfo = filterSuppressedInfo(result.info, result.url || '');
      if (filteredInfo.length > 0) {
        infoCell.innerHTML = filteredInfo.map(i => `<div class="info-entry">${i}</div>`).join('');
      } else {
        infoCell.textContent = '‚Äî';
      }
    }
  }

  // Helper: Suppress redundant Event blocks injected by Squarespace
  function suppressRedundantEventBlocks(jsonLdBlocks) {
    if (!jsonLdBlocks || !Array.isArray(jsonLdBlocks)) return jsonLdBlocks;
    
    let suppressedCount = 0;
    const processedBlocks = [];
    const eventGroups = new Map(); // key: "name|startDate" -> array of block indices
    
    // First pass: Identify all Event nodes and group by name/startDate
    jsonLdBlocks.forEach((block, blockIndex) => {
      // Check if this block contains Event nodes (but skip if inside ItemList)
      const nodes = flattenJsonLd(block, []);
      const eventNodes = nodes.filter(n => {
        const types = asArray(n['@type']);
        return types.includes('Event');
      });
      
      // Skip if Event is inside ItemList
      const hasItemList = nodes.some(n => {
        const types = asArray(n['@type']);
        return types.includes('ItemList');
      });
      
      if (eventNodes.length > 0 && !hasItemList) {
        // Extract key from first Event node in block
        const firstEvent = eventNodes[0];
        const name = firstEvent.name || '';
        const startDate = firstEvent.startDate || '';
        const key = `${name}|${startDate}`;
        
        if (!eventGroups.has(key)) {
          eventGroups.set(key, []);
        }
        eventGroups.get(key).push({
          blockIndex,
          block,
          eventNodes,
          name,
          startDate
        });
      }
    });
    
    // Second pass: Process blocks - keep first Event of each group, suppress duplicates
    const suppressedIndices = new Set();
    
    eventGroups.forEach((group, key) => {
      if (group.length > 1) {
        // Multiple Events with same name/startDate - keep first, suppress others
        for (let i = 1; i < group.length; i++) {
          suppressedIndices.add(group[i].blockIndex);
          suppressedCount++;
        }
        debugLog(`[SUPPRESSION] Found ${group.length} duplicate Event blocks with name="${group[0].name}", startDate="${group[0].startDate}" - keeping first, suppressing ${group.length - 1}`, 'info');
      } else {
        // Single Event with this key - check if there are other Event blocks
        // If there are multiple Event blocks total, suppress all but the first one
        const allEventBlocks = [];
        eventGroups.forEach((g) => {
          g.forEach(item => allEventBlocks.push(item));
        });
        allEventBlocks.sort((a, b) => a.blockIndex - b.blockIndex);
        
        if (allEventBlocks.length > 1 && group[0].blockIndex !== allEventBlocks[0].blockIndex) {
          suppressedIndices.add(group[0].blockIndex);
          suppressedCount++;
        }
      }
    });
    
    // Build filtered blocks array - mark suppressed blocks
    jsonLdBlocks.forEach((block, blockIndex) => {
      if (suppressedIndices.has(blockIndex)) {
        // Mark as suppressed by adding a flag
        const processedBlock = { ...block, _suppressed: true };
        processedBlocks.push(processedBlock);
      } else {
        processedBlocks.push(block);
      }
    });
    
    if (suppressedCount > 0) {
      debugLog(`[SUPPRESSION] Collapsed duplicate Event nodes (${suppressedCount} suppressed)`, 'info');
    }
    
    return processedBlocks;
  }

  // Helper: Filter out suppressed blocks before processing
  function filterSuppressedBlocks(jsonLdBlocks) {
    if (!jsonLdBlocks || !Array.isArray(jsonLdBlocks)) return jsonLdBlocks;
    return jsonLdBlocks.filter(block => !block._suppressed);
  }

  // Helper: Process schema nodes and build issues list
  function processSchemaNodes(pageData) {
    // Filter out suppressed blocks before processing
    const filteredBlocks = filterSuppressedBlocks(pageData.jsonLd);
    let allNodes = [];
    for (const block of filteredBlocks) {
      try {
        allNodes = flattenJsonLd(block, allNodes);
      } catch(_) {}
    }
    
    const missingDetails = computeMissingFields(allNodes);
    debugLog(`Computed missing fields: ${missingDetails.length} issue(s) found`, missingDetails.length > 0 ? 'warn' : 'success');
    if (missingDetails.length > 0) {
      debugLog(`Missing fields details: ${JSON.stringify(missingDetails)}`, 'warn');
    }
    
    return { allNodes, missingDetails };
  }

  // Helper: Process duplicate detection
  function processDuplicateDetection(allNodes) {
    const globalPatterns = ['website', 'org', 'local', 'breadcrumbs'];
    const duplicateGroups = buildDuplicateGroups(allNodes);
    const { duplicateWarnings, duplicateWarningsObjects } = processDuplicateWarnings(duplicateGroups, globalPatterns);
    
    if (duplicateWarnings.length > 0) {
      debugLog(`Duplicate schema detected: ${duplicateWarnings.join('; ')}`, 'warn');
    }
    
    return { duplicateGroups, duplicateWarningsObjects, globalPatterns };
  }

  // Helper: Build and categorize issues
  function buildAndCategorizeIssues(missingDetails, duplicateWarningsObjects, allNodes, analysis, url = '') {
    const issuesList = buildUnifiedIssuesList(missingDetails, duplicateWarningsObjects, allNodes);
    debugLog(`‚úÖ Built issuesList: ${issuesList.length} issue(s)`, 'success');
    if (issuesList.length > 0) {
      debugLog(`issuesList contents: ${JSON.stringify(issuesList, null, 2)}`);
    }
    
    // Split issuesList into missingFields, warnings, and info (with suppression)
    const buckets = splitIssuesIntoBuckets(issuesList, allNodes, url);
    
    // Add info from analysis (e.g., downgraded "Missing recommended" messages)
    if (analysis.info && analysis.info.length > 0) {
      if (!buckets.info) buckets.info = [];
      const filteredInfo = filterSuppressedInfo(Array.isArray(analysis.info) ? analysis.info : [], url);
      buckets.info.push(...filteredInfo);
    }
    
    // Apply suppression filters to buckets
    buckets.warnings = filterSuppressedWarnings(buckets.warnings, url);
    buckets.info = filterSuppressedInfo(buckets.info, url);
    
    return { issuesList, buckets };
  }

  // Helper: Add informational detections
  function addInformationalDetections(allNodes, result, url = '') {
    try {
      if (!result.info) result.info = [];
      
      // Detect BreadcrumbList nodes
      const breadcrumbNodes = detectBreadcrumbListNodes(allNodes);
      if (breadcrumbNodes.length > 0) {
        debugLog(`Detected ${breadcrumbNodes.length} BreadcrumbList node(s)`, 'info');
        const infoMessage = `‚ÑπÔ∏è BreadcrumbList detected (${breadcrumbNodes.length} node${breadcrumbNodes.length !== 1 ? 's' : ''}) - normal navigation schema`;
        if (!shouldSuppressInfo(infoMessage, url)) {
          result.info.push(infoMessage);
        }
      }
      
      // Add friendly messages for multi-instance allowed types
      MULTI_INSTANCE_ALLOWED_TYPES.forEach(type => {
        const typeNodes = allNodes.filter(n => {
          const types = asArray(n['@type']);
          return types.includes(type);
        });
        
        if (typeNodes.length > 1) {
          const infoMessage = `‚úÖ Multiple ${type} schemas detected (${typeNodes.length}) ‚Äî expected for ${type.toLowerCase()} listings.`;
          // Only add if not already present (to avoid duplicates)
          if (!result.info.some(msg => msg.includes(`${type} schemas detected`))) {
            result.info.push(infoMessage);
            debugLog(`Added multi-instance info: ${type} (${typeNodes.length} instances)`, 'info');
          }
        }
      });
    } catch (error) {
      console.error('[‚ö†] Error in addInformationalDetections:', error);
      // Ensure result.info exists even if error occurs
      if (!result.info) result.info = [];
    }
  }

  // Helper: Set result metadata
  function setResultMetadata(result, pageData, analysis, duplicateGroups) {
    result.parsePath = pageData.parsePath || 'local';
    result.localParseFailed = pageData.localParseFailed || false;
    result.serverFallback = pageData.serverFallback || false;
    result.blockCount = pageData.blockCount || pageData.jsonLd.length;
    
    // Calculate unique schema types (excluding multi-instance allowed types from duplicate count)
    const allUniqueTypes = Object.keys(duplicateGroups);
    const multiInstanceCounts = {};
    let totalMultiInstanceNodes = 0;
    
    MULTI_INSTANCE_ALLOWED_TYPES.forEach(type => {
      if (duplicateGroups[type]) {
        multiInstanceCounts[type] = duplicateGroups[type].length;
        totalMultiInstanceNodes += duplicateGroups[type].length;
      }
    });
    
    result.uniqueSchemaTypes = allUniqueTypes.length;
    result.multiInstanceCounts = multiInstanceCounts;
    
    debugLog(`Total JSON-LD blocks: ${result.blockCount}, unique schema types: ${allUniqueTypes.length}, multi-instance nodes: ${totalMultiInstanceNodes}`, 'info');
    debugLog(`Schema type from pageData: ${pageData.schemaType || 'none'}, from analysis: ${analysis.schemaTypes.join(', ') || 'none'}`, 'info');
  }

  // Helper: Format schema types with inferred types visually differentiated
  function formatSchemaTypesWithInferred(explicitTypes, inferredTypes = []) {
    const explicit = explicitTypes.length > 0 ? explicitTypes.join(', ') : '';
    if (inferredTypes.length === 0) {
      return explicit || '‚Äî';
    }
    
    const inferred = inferredTypes.map(item => {
      // Special formatting for MerchantListing (Google) with green background and white checkmark
      if (item.type === 'MerchantListing (Google)') {
        return `<span style="display: inline-block; background-color: #27AE60; color: white; padding: 1px 4px; border-radius: 3px; font-style: normal; font-weight: 500; font-size: 0.85em; white-space: nowrap;">‚úÖ ${item.type} (inferred)</span>`;
      }
      return `<span style="font-style: italic; color: #6b7280;">*${item.type} (inferred)*</span>`;
    }).join(', ');
    
    if (explicit) {
      return `${explicit}, ${inferred}`;
    }
    return inferred;
  }

  // Helper: Update schema type display
  function updateSchemaTypeDisplay(result, pageData, analysis, urlData) {
    updateSchemaTypeCellUI(urlData, pageData, analysis);
    
    // CRITICAL: NEVER overwrite schemaFound if it's already true or if blocks exist
    const hasBlocks = pageData.jsonLd && pageData.jsonLd.length > 0;
    if (hasBlocks && result.schemaFound === false) {
      // Only set to true if blocks exist and it was false
      result.schemaFound = true;
      console.log(`[‚úì] Restored schemaFound=true (blocks exist: ${pageData.jsonLd.length})`);
    } else if (hasBlocks && result.schemaFound === true) {
      // Keep it true - don't change
      result.schemaFound = true;
    } else if (!hasBlocks) {
      // Only set to false if no blocks exist
      result.schemaFound = false;
    }
    // Otherwise, leave schemaFound as-is (don't overwrite if already set correctly)
    
    // CRITICAL: Use result.schemaTypes (from initialAnalysis) if available, otherwise fall back to analysis or pageData
    const schemaTypesFromResult = result.schemaTypes || [];
    const schemaTypesFromAnalysis = analysis.schemaTypes || [];
    const schemaTypeFromPageData = pageData.schemaType || '';
    
    // Combine all sources and deduplicate
    const allTypes = [
      ...schemaTypesFromResult,
      ...schemaTypesFromAnalysis,
      ...(schemaTypeFromPageData ? schemaTypeFromPageData.split(',').map(t => t.trim()) : [])
    ];
    
    const uniqueTypes = [...new Set(allTypes.filter(Boolean))];
    
    // Get inferred types from result
    const inferredTypes = result.inferredTypes || [];
    
    // Store both explicit and inferred separately
    result.schemaType = uniqueTypes.length > 0 ? uniqueTypes.join(', ') : '‚Äî';
    result.inferredTypes = inferredTypes;
    
    console.log(`[‚úì] Updated schemaType: "${result.schemaType}" (from result.schemaTypes: [${schemaTypesFromResult.join(', ')}], analysis.schemaTypes: [${schemaTypesFromAnalysis.join(', ')}], pageData.schemaType: "${schemaTypeFromPageData}")`);
    if (inferredTypes.length > 0) {
      console.log(`[‚úì] Inferred types: ${inferredTypes.map(t => t.type).join(', ')}`);
    }
  }

  // Helper: Merge analysis results into result object
  function mergeAnalysisResults(result, analysis) {
    // CRITICAL: Ensure arrays are initialized before spreading
    result.missingFields = result.missingFields || [];
    result.warnings = result.warnings || [];
    result.info = result.info || [];
    
    analysis.missingFields = analysis.missingFields || [];
    analysis.warnings = analysis.warnings || [];
    analysis.info = analysis.info || [];
    
    try {
      result.missingFields = [...new Set([...result.missingFields, ...analysis.missingFields])];
      result.warnings = [...new Set([...result.warnings, ...analysis.warnings])];
      if (analysis.info && analysis.info.length > 0) {
        result.info = [...new Set([...result.info, ...analysis.info])];
      }
    } catch (error) {
      console.error('[‚ö†] Error merging analysis results:', error);
      // Fallback: just assign directly
      result.missingFields = [...result.missingFields || [], ...analysis.missingFields || []];
      result.warnings = [...result.warnings || [], ...analysis.warnings || []];
      if (analysis.info && analysis.info.length > 0) {
        result.info = [...result.info || [], ...analysis.info];
      }
    }
    
    result.valid = analysis.valid;
    result.schemas = analysis.schemas || [];
    
    // CRITICAL: Preserve schemaFound - never overwrite if it's already true
    if (result.schemaFound === true) {
      result.schemaFound = true; // Keep it true
    } else if (analysis.schemaFound === true) {
      result.schemaFound = true; // Set from analysis if result was false
    }
    // Don't set to false here - only if no blocks exist at all
  }

  // Process a single URL
  async function processUrl(urlData) {
    // Use index if provided, otherwise fall back to row
    const resultIndex = urlData.index !== undefined ? urlData.index : (urlData.row !== undefined ? urlData.row : 0);
    const result = {
      url: urlData.url,
      row: resultIndex, // Store the correct index
      schemaType: null,
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      info: [],
      schemas: [],
      error: null
    };
    
    let initialAnalysis = null; // Declare outside try-catch so it's accessible in catch
    
    try {
      // Stage 1: Fetch page data (~20%)
      updateRowProgress(urlData.url, 20);
      const pageData = await fetchPageSchema(urlData.url, resultIndex);
      debugLog(`Fetched page data for ${urlData.url}: found ${pageData.jsonLd.length} JSON-LD blocks, schemaType: ${pageData.schemaType}`, 'info');
      
      // Apply Event suppression before processing
      pageData.jsonLd = suppressRedundantEventBlocks(pageData.jsonLd);
      
      // Stage 2: Build initial analysis result (~40%)
      updateRowProgress(urlData.url, 40);
      initialAnalysis = buildAnalysisResult(urlData.url, pageData.jsonLd, []);
      debugLog(`[‚úì] Schema Types: ${initialAnalysis.schemaTypes.join(', ') || 'none'}`, 'info');
      debugLog(`[‚úì] schemaFound: ${initialAnalysis.schemaFound}`, 'info');
      
      // CRITICAL: Set schemaFound from initialAnalysis immediately - don't let it be overwritten
      result.schemaFound = initialAnalysis.schemaFound;
      result.schemaTypes = initialAnalysis.schemaTypes;
      console.log(`[‚úì] Set result.schemaFound=${result.schemaFound} from initialAnalysis`);
      
      // Stage 3: Analyze schemas (~50%)
      updateRowProgress(urlData.url, 50);
      const analysis = analyzeSchemas(pageData.jsonLd, urlData.url);
      debugLog(`Analysis complete: schemaFound=${analysis.schemaFound}, schemaTypes=[${analysis.schemaTypes?.join(', ') || 'none'}], valid=${analysis.valid}`, 'info');
      
      // CRITICAL: Ensure analysis has schemaTypes array
      if (!analysis.schemaTypes || !Array.isArray(analysis.schemaTypes)) {
        analysis.schemaTypes = initialAnalysis.schemaTypes || [];
        console.log(`[‚úì] Restored analysis.schemaTypes from initialAnalysis: [${analysis.schemaTypes.join(', ')}]`);
      }
      
      // CRITICAL: Ensure analysis arrays are initialized
      if (!analysis.info || !Array.isArray(analysis.info)) {
        analysis.info = [];
      }
      if (!analysis.warnings || !Array.isArray(analysis.warnings)) {
        analysis.warnings = [];
      }
      if (!analysis.missingFields || !Array.isArray(analysis.missingFields)) {
        analysis.missingFields = [];
      }
      
      // Ensure schemaFound stays true if blocks exist
      if (pageData.jsonLd && pageData.jsonLd.length > 0) {
        result.schemaFound = true;
        console.log(`[‚úì] Confirmed result.schemaFound=true (${pageData.jsonLd.length} blocks exist)`);
      }
      
      // Stage 4: Process schema nodes (~60%)
      updateRowProgress(urlData.url, 60);
      const { allNodes, missingDetails } = processSchemaNodes(pageData);
      
      // Detect inferred types from allNodes
      const inferredTypes = detectInferredTypes(allNodes);
      result.inferredTypes = inferredTypes;
      if (inferredTypes.length > 0) {
        debugLog(`Detected ${inferredTypes.length} inferred type(s): ${inferredTypes.map(t => t.type).join(', ')}`, 'info');
        console.log(`[DEBUG] processUrl: Detected inferred types for ${urlData.url}:`, inferredTypes);
      } else {
        const eventCount = allNodes.filter(n => {
          const types = asArray(n['@type']);
          return types.includes('Event');
        }).length;
        const productCount = allNodes.filter(n => {
          const types = asArray(n['@type']);
          return types.includes('Product');
        }).length;
        const courseCount = allNodes.filter(n => {
          const types = asArray(n['@type']);
          return types.includes('Course');
        }).length;
        console.log(`[DEBUG] processUrl: No inferred types detected for ${urlData.url} (Event count: ${eventCount}, Product count: ${productCount}, Course count: ${courseCount})`);
      }
      
      // Stage 5: Process duplicate detection (~70%)
      updateRowProgress(urlData.url, 70);
      const { duplicateGroups, duplicateWarningsObjects, globalPatterns } = processDuplicateDetection(allNodes);
      
      // Stage 6: Build and categorize issues (~80%)
      updateRowProgress(urlData.url, 80);
      const { issuesList, buckets } = buildAndCategorizeIssues(missingDetails, duplicateWarningsObjects, allNodes, analysis, urlData.url);
      
      result.issuesList = issuesList;
      result.missingFields = buckets.missingFields;
      result.warnings = buckets.warnings;
      result.info = buckets.info;
      
      // Stage 7: Update analysis result with full issuesList (~90%)
      updateRowProgress(urlData.url, 90);
      const mappedIssues = issuesList.map(i => ({
        severity: i.message?.includes('missing') ? 'missing' : 
                 i.message?.includes('DUPLICATE') || i.message?.includes('‚ö†Ô∏è') ? 'warning' : 'info',
        ...i
      }));
      buildAnalysisResult(urlData.url, pageData.jsonLd, mappedIssues);
      
      // Stage 8: Finalize result (~95%)
      updateRowProgress(urlData.url, 95);
      
      // Ensure arrays are initialized before adding informational detections
      if (!result.info) result.info = [];
      if (!result.warnings) result.warnings = [];
      if (!result.missingFields) result.missingFields = [];
      
      addInformationalDetections(allNodes, result, urlData.url);
      
      // Log diagnostics
      logGlobalDuplicates(duplicateGroups, globalPatterns);
      logOrgNodesMissingName(allNodes);
      
      // Set result metadata
      setResultMetadata(result, pageData, analysis, duplicateGroups);
      
      // Update schema type display
      updateSchemaTypeDisplay(result, pageData, analysis, urlData);
      
      // Merge analysis results
      mergeAnalysisResults(result, analysis);
      
      buildResultNotes(result, pageData);
      
      // Cache result for View Details button (already cached by buildAnalysisResult, but update with final data)
      cacheResult(result.url, {
        blocks: pageData.jsonLd || [],
        issues: result.issuesList || [],
        warnings: result.warnings || [],
        info: result.info || [],
        schemaTypes: result.schemaType ? result.schemaType.split(',').map(t => t.trim()) : [],
        schemaFound: result.schemaFound || false
      });
      
      // Stage 9: Complete (~100%)
      updateRowProgress(urlData.url, 100);
      
      // Log final result confirmation
      console.log(`[‚úì] Final Result: ${result.url} | SchemaFound=${result.schemaFound} | Types: ${result.schemaType || 'none'} | MissingFields: ${result.missingFields?.length || 0} | Warnings: ${result.warnings?.length || 0} | Info: ${result.info?.length || 0}`);
      
      // CRITICAL: Store result in validationResults BEFORE calling updateTableRow
      // resultIndex is already declared at the top of the function
      validationResults[resultIndex] = {
        ...result,
        schemaFound: result.schemaFound, // Ensure schemaFound is preserved
        schemaType: result.schemaType || (initialAnalysis.schemaTypes.join(', ') || '‚Äî'), // Ensure schemaType is set from initialAnalysis if missing
        inferredTypes: result.inferredTypes || [], // Ensure inferredTypes are preserved
        missingFields: result.missingFields || [],
        warnings: result.warnings || [],
        info: result.info || [],
        error: null // Explicitly clear error if validation succeeded
      };
      
      console.log(`[‚úì] Stored result at index ${resultIndex}: schemaFound=${validationResults[resultIndex].schemaFound}, schemaType="${validationResults[resultIndex].schemaType}", error=${validationResults[resultIndex].error}`);
      if (validationResults[resultIndex].inferredTypes && validationResults[resultIndex].inferredTypes.length > 0) {
        console.log(`[DEBUG] processUrl: Stored inferredTypes in validationResults[${resultIndex}]:`, validationResults[resultIndex].inferredTypes);
      }
      
      // Update table row with final result (will restore schemaFound in determineStatusHtml if needed)
      updateTableRow(resultIndex, validationResults[resultIndex]);
      
      // Don't call updateResultRow - it causes duplicate updates
      
    } catch (error) {
      // Update progress to show error state
      updateRowProgress(urlData.url, 100);
      // resultIndex is already declared at the top of the function
      const schemaTypeCell = document.getElementById(`schemaTypeCell_${resultIndex}`);
      if (schemaTypeCell && schemaTypeCell.querySelector('.progress')) {
        markProgressError(schemaTypeCell);
        setProgress(schemaTypeCell, 100, 'Error');
      }
      result.error = error.message;
      
      // CRITICAL: Even if there's an error, try to preserve schemaType from initialAnalysis
      if (initialAnalysis && initialAnalysis.schemaTypes && initialAnalysis.schemaTypes.length > 0) {
        result.schemaType = initialAnalysis.schemaTypes.join(', ');
        result.schemaFound = initialAnalysis.schemaFound || false;
        console.log(`[‚úì] Preserved schemaType from initialAnalysis despite error: ${result.schemaType}`);
      }
      
      // Ensure arrays are initialized
      result.missingFields = result.missingFields || [];
      result.warnings = result.warnings || [];
      result.info = result.info || [];
      
      // Store result even on error at correct index
      validationResults[resultIndex] = {
        ...result,
        schemaType: result.schemaType || (initialAnalysis?.schemaTypes?.join(', ') || '‚Äî'),
        schemaFound: result.schemaFound || initialAnalysis?.schemaFound || false,
        missingFields: result.missingFields || [],
        warnings: result.warnings || [],
        info: result.info || []
      };
      
      updateTableRow(resultIndex, validationResults[resultIndex]);
    }
    
    return result;
  }

  // Helper: Classify duplicate issues as warnings or info
  function classifyDuplicateIssue(item, allNodes) {
    const schemaType = item.type || 'Unknown';
    
    // Check if this is a multi-instance allowed type
    if (MULTI_INSTANCE_ALLOWED_TYPES.includes(schemaType)) {
      const typeNodes = allNodes.filter(n => {
        const types = asArray(n['@type']);
        return types.includes(schemaType);
      });
      const totalCount = typeNodes.length;
      const cleanMessage = item.message.replace('‚ö†Ô∏è DUPLICATE:', '').replace('‚ö†Ô∏è', '').trim();
      return { 
        type: 'info', 
        message: `‚úÖ Multiple ${schemaType} schemas detected (${totalCount}) ‚Äî expected for ${schemaType.toLowerCase()} listings.`,
        isMultiInstance: true
      };
    }
    
    // For other types, check if they have unique IDs or multiple types
    const typeNodes = allNodes.filter(n => {
      const types = asArray(n['@type']);
      return types.includes(schemaType);
    });
    const hasUniqueIds = typeNodes.some(n => n['@id']);
    const uniqueTypes = new Set(typeNodes.map(n => {
      const types = asArray(n['@type']);
      return types.join(',');
    }));
    const hasMultipleTypes = uniqueTypes.size > 1;
    
    if (hasUniqueIds || hasMultipleTypes) {
      const cleanMessage = item.message.replace('‚ö†Ô∏è DUPLICATE:', '').replace('‚ö†Ô∏è', '').trim();
      return { type: 'info', message: `‚ÑπÔ∏è Multi-instance ${schemaType} schemas detected (${cleanMessage})` };
    }
    return { type: 'warning', message: item.message };
  }

  // Helper: Split issuesList into missingFields, warnings, and info
  function splitIssuesIntoBuckets(issuesList, allNodes, url = '') {
    const buckets = { missingFields: [], warnings: [], info: [] };
    let suppressedCount = { missingFields: 0, warnings: 0, info: 0 };
    
    for (const item of issuesList) {
      const isDuplicate = item.message?.includes('DUPLICATE');
      const isMissing = item.message?.toLowerCase().includes('missing');
      
      if (isMissing) {
        // Check if we should suppress this missing field
        const schemaType = item.type || 'Unknown';
        if (!shouldSuppressMissingField(item.field || '', schemaType, url)) {
          buckets.missingFields.push(item.message);
        } else {
          suppressedCount.missingFields++;
        }
      } else if (isDuplicate) {
        const classified = classifyDuplicateIssue(item, allNodes);
        // Apply suppression for duplicates
        if (shouldDowngradeDuplicate(item.type || 'Unknown')) {
          // Downgrade to info if configured
          buckets.info.push(classified.message);
        } else if (classified.type === 'info') {
          if (!shouldSuppressInfo(classified.message, url)) {
            buckets.info.push(classified.message);
          } else {
            suppressedCount.info++;
          }
        } else {
          // Check if warning should be suppressed
          if (!shouldSuppressWarning(classified.message, url)) {
            buckets.warnings.push(classified.message);
          } else {
            suppressedCount.warnings++;
          }
        }
      }
    }
    
    if (suppressedCount.missingFields > 0 || suppressedCount.warnings > 0 || suppressedCount.info > 0) {
      debugLog(`[SUPPRESSION] Suppressed: ${suppressedCount.missingFields} missing fields, ${suppressedCount.warnings} warnings, ${suppressedCount.info} info`, 'info');
    }
    
    return buckets;
  }

  // Helper: Build unified issues list from missing fields and duplicates
  function buildUnifiedIssuesList(missingDetails, duplicateWarnings, allNodes) {
    const issuesList = [];
    
    // Add missing field issues with exact format: includes (no @id) when applicable
    for (const f of missingDetails) {
      // Check if any node of this type has an @id
      const hasId = allNodes.some(n => {
        const types = asArray(n['@type']);
        return types.includes(f.type) && n['@id'];
      });
      const message = `${f.type}: "${f.field}" missing${hasId ? '' : ' (no @id)'}`;
      issuesList.push({
        type: f.type,
        field: f.field,
        message: message
      });
    }
    
    // Add duplicate issues with exact format specified
    for (const d of duplicateWarnings) {
      issuesList.push({
        type: d.type,
        message: `‚ö†Ô∏è DUPLICATE: ${d.type} (${d.id || 'NO_ID'}) √ó ${d.count}`
      });
    }
    
    return issuesList;
  }

  // Helper: Mark as "reviewing" when external validator is opened
  function markReviewing(index, which) {
    const label = which === 'schema' ? 'Schema.org' : 'Rich Results';
    const notesEl = document.getElementById(`notes_${index}`);
    if (notesEl) {
      notesEl.value = `üëÄ Opened ${label} (reviewing)‚Ä¶`;
      updateValidationNotes(index, notesEl.value);
      
      // Auto-clear after 5s if still pending
      setTimeout(() => {
        const currentNotes = notesEl.value || '';
        if (currentNotes.includes('reviewing')) {
          notesEl.value = currentNotes.replace(/üëÄ Opened .* \(reviewing\)‚Ä¶\s*/g, '').trim();
          updateValidationNotes(index, notesEl.value);
        }
      }, 5000);
    }
  }

  // Helper: Apply external validator results and finalize row status
  function applyExternalResult(index, richResult, schemaOrgResult) {
    const result = validationResults[index];
    if (!result) return;
    
    // Get current DOM elements
    const statusCell = document.getElementById(`statusCell_${index}`);
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    const notesEl = document.getElementById(`notes_${index}`);
    
    // Clean up "reviewing" notes
    if (notesEl) {
      let notes = notesEl.value || '';
      if (richResult) notes = notes.replace(/üëÄ Opened Rich Results.*\n?/g, '').trim();
      if (schemaOrgResult) notes = notes.replace(/üëÄ Opened Schema\.org.*\n?/g, '').trim();
      notesEl.value = notes;
      updateValidationNotes(index, notes);
    }
    
    // Finalize status based on external results
    finalizeRowStatus(index, result, richResult, schemaOrgResult);
  }

  // Helper: Finalize row status prioritizing external validators
  // Helper: Determine Schema.org status from API response
  function determineSchemaOrgStatus(schemaOrg) {
    if (schemaOrg?.status === 'passed') {
      return 'passed';
    }
    if (schemaOrg?.status === 'failed' && schemaOrg?.errors && schemaOrg.errors.length === 0 && 
        schemaOrg?.warnings && schemaOrg.warnings.length === 0) {
      return 'passed';
    }
    if (schemaOrg?.status === 'failed' && schemaOrg?.errors && schemaOrg.errors.length === 0 && 
        schemaOrg?.warnings && schemaOrg.warnings.length > 0) {
      return 'warning';
    }
    return schemaOrg ? 'failed' : 'not-run';
  }

  // Helper: Format schema type with server badge
  function formatSchemaTypeWithBadge(localParse) {
    let types = localParse?.schemaType || localParse?.types?.join(', ') || '‚Äî';
    types = types.replace(/\s*\(server\)\s*$/, '');
    if (localParse?.serverFallback) {
      types = types + ' (server)';
    }
    return types;
  }

  // Helper: Attach click handler to status chip
  function attachStatusChipHandler(chip, row) {
    if (chip && row) {
      chip.onclick = () => openIssuesModal(getRowDataFromTr(row));
    }
  }

  // Helper: Update external status selects
  function updateExternalStatusSelects(index, richPassed, schemaOrgStatus, rich) {
    const richSelect = document.getElementById(`googleStatus_${index}`);
    const schemaSelect = document.getElementById(`schemaOrgStatus_${index}`);
    
    if (richSelect) {
      setSelect(richSelect, richPassed ? '‚úÖ Passed' : (rich ? '‚ùå Failed' : 'Not run'));
    }
    
    if (schemaSelect) {
      let statusValue = 'Not run';
      if (schemaOrgStatus === 'passed') {
        statusValue = '‚úÖ Passed';
      } else if (schemaOrgStatus === 'warning') {
        statusValue = '‚ö†Ô∏è Warning';
      } else if (schemaOrgStatus === 'failed') {
        statusValue = '‚ùå Failed';
      }
      setSelect(schemaSelect, statusValue);
    }
  }

  // Helper: Handle external validators passed case
  function handleExternalPassedCase(index, localParse, richPassed, schemaOrgStatus, missing, statusCell, schemaTypeCell, notesEl, row) {
    const realIssues = missing.filter(m => {
      if (typeof m === 'string') {
        return !m.includes('DUPLICATE') && !m.includes('‚ö†Ô∏è DUPLICATE');
      }
      return true;
    });
    const hasRealIssues = realIssues.length > 0;
    
    const statusHtml = hasRealIssues ? '<span class="chip-issues" title="View details">‚ö†Ô∏è Issues</span>' : '<span class="chip-ok">‚úÖ Valid</span>';
    if (statusCell) {
      statusCell.innerHTML = statusHtml;
      if (hasRealIssues) {
        const chip = statusCell.querySelector('.chip-issues');
        attachStatusChipHandler(chip, row);
      }
    }
    
    if (schemaTypeCell) {
      // Preserve inferred types when updating cell
      const result = validationResults[index];
      const inferredTypes = result?.inferredTypes || [];
      const types = formatSchemaTypeWithBadge(localParse);
      
      if (inferredTypes.length > 0) {
        // Split types and format with inferred types
        const explicitTypes = types.replace(/\s*\(server\)\s*$/, '').split(',').map(t => t.trim()).filter(Boolean);
        const formattedTypes = formatSchemaTypesWithInferred(explicitTypes, inferredTypes);
        schemaTypeCell.innerHTML = formattedTypes + (localParse?.serverFallback ? ' (server)' : '');
      } else {
        schemaTypeCell.textContent = types;
      }
    }
    
    if (notesEl) {
      let noteText = '';
      if (localParse?.localParseFailed && localParse?.serverFallback) {
        noteText = `Local parse: blocked. Server parse: success (${localParse.blockCount || 0} blocks). External validation passed ‚úÖ`;
      } else {
        noteText = 'Local parse skipped (cached or blocked). External validation passed ‚úÖ';
      }
      notesEl.value = noteText;
      updateValidationNotes(index, noteText);
    }
    
    if (validationResults[index]) {
      validationResults[index].validatorGoogleStatus = '‚úÖ Passed';
      validationResults[index].validatorSchemaOrgStatus = '‚úÖ Passed';
      validationResults[index].statusOverride = 'external-passed';
    }
  }

  // Helper: Handle local result case
  function handleLocalResultCase(index, localParse, missingCount, statusCell, schemaTypeCell, row) {
    const hasMissing = missingCount > 0;
    const statusHtml = hasMissing 
      ? '<span class="chip-issues" title="View details">‚ö†Ô∏è Issues</span>'
      : '<span class="chip-ok">‚úÖ Valid</span>';
    
    if (statusCell) {
      statusCell.innerHTML = statusHtml;
      if (hasMissing) {
        const chip = statusCell.querySelector('.chip-issues');
        attachStatusChipHandler(chip, row);
      }
    }
    
    if (schemaTypeCell) {
      // Preserve inferred types when updating cell
      const result = validationResults[index];
      const inferredTypes = result?.inferredTypes || [];
      const types = formatSchemaTypeWithBadge(localParse);
      
      if (inferredTypes.length > 0) {
        // Split types and format with inferred types
        const explicitTypes = types.replace(/\s*\(server\)\s*$/, '').split(',').map(t => t.trim()).filter(Boolean);
        const formattedTypes = formatSchemaTypesWithInferred(explicitTypes, inferredTypes);
        schemaTypeCell.innerHTML = formattedTypes + (localParse?.serverFallback ? ' (server)' : '');
      } else {
        schemaTypeCell.textContent = types;
      }
    }
    
    if (validationResults[index]) {
      validationResults[index].statusOverride = 'local';
    }
  }

  // Helper: Finalize row status prioritizing external validators
  function finalizeRowStatus(index, localParse, rich, schemaOrg) {
    const richPassed = rich?.status === 'eligible' && rich?.verdict === 'PASS';
    const schemaOrgStatus = determineSchemaOrgStatus(schemaOrg);
    const schemaOrgPassed = schemaOrgStatus === 'passed';
    
    const missing = localParse?.missingFieldsDetails || localParse?.missingFieldsBadges || localParse?.missingFields || [];
    const missingCount = Array.isArray(missing) ? missing.length : (missing ? 1 : 0);
    
    const statusCell = document.getElementById(`statusCell_${index}`);
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    const notesEl = document.getElementById(`notes_${index}`);
    const row = document.getElementById('resultsTableBody')?.children[index];
    
    updateExternalStatusSelects(index, richPassed, schemaOrgStatus, rich);
    
    if (richPassed && schemaOrgPassed) {
      handleExternalPassedCase(index, localParse, richPassed, schemaOrgStatus, missing, statusCell, schemaTypeCell, notesEl, row);
      return;
    }
    
    if (localParse?.schemaFound || localParse?.schemaType) {
      handleLocalResultCase(index, localParse, missingCount, statusCell, schemaTypeCell, row);
    } else {
      if (statusCell) statusCell.innerHTML = '<span class="status-badge no-schema">‚ùå No Schema</span>';
      // Preserve inferred types even when no schema found
      if (schemaTypeCell) {
        const result = validationResults[index];
        const inferredTypes = result?.inferredTypes || [];
        if (inferredTypes.length > 0) {
          const formattedTypes = formatSchemaTypesWithInferred([], inferredTypes);
          schemaTypeCell.innerHTML = formattedTypes;
        } else {
          schemaTypeCell.textContent = 'None';
        }
      }
      if (validationResults[index]) {
        validationResults[index].statusOverride = 'local';
      }
    }
  }

  // Helper: Set select dropdown value
  function setSelect(selectEl, value) {
    if (!selectEl) return;
    // Find the option that matches (by value or text)
    for (let option of selectEl.options) {
      if (option.value === value || option.textContent === value) {
        selectEl.value = option.value;
        updateValidationStatus(
          parseInt(selectEl.id.match(/\d+/)?.[0] || '0'),
          selectEl.id.includes('google') ? 'google' : 'schemaorg',
          option.value
        );
        break;
      }
    }
  }

  // Helper: Generate human-readable status explanation
  // Helper: Extract field name from issue object
  function extractFieldName(issue) {
    if (issue.field && issue.type) {
      debugLog(`Using direct field property: ${issue.type}.${issue.field}`);
      return `${issue.type}.${issue.field}`;
    }
    // Fallback: parse from message
    const match = issue.message?.match(/(\w+):\s*"(\w+)"\s*missing/);
    if (match) {
      debugLog(`Parsed from message pattern 1: ${match[1]}.${match[2]}`);
      return `${match[1]}.${match[2]}`;
    }
    // Try alternative pattern
    const altMatch = issue.message?.match(/(\w+).*?"(\w+)".*?missing/i);
    if (altMatch) {
      debugLog(`Parsed from message pattern 2: ${altMatch[1]}.${altMatch[2]}`);
      return `${altMatch[1]}.${altMatch[2]}`;
    }
    debugLog(`WARNING: Could not extract field name from: ${issue.message}`);
    return issue.field ? `${issue.type || 'Unknown'}.${issue.field}` : 'Unknown field';
  }

  // Helper: Build missing fields explanation text
  function buildMissingFieldsExplanation(missingCount, fieldNames) {
    if (missingCount === 1) {
      return `1 optional field missing ‚Äì ${fieldNames[0]}`;
    }
    if (missingCount === 2) {
      return `2 optional fields missing ‚Äì ${fieldNames.join(', ')}`;
    }
    return `${missingCount} optional fields missing ‚Äì ${fieldNames.join(', ')}${missingCount > 2 ? '...' : ''}`;
  }

  // Helper: Build duplicate explanation text
  function buildDuplicateExplanation(duplicateCount) {
    const plural = duplicateCount === 1 ? '' : 's';
    return `${duplicateCount} duplicate${plural} detected ‚Äî likely normal Squarespace Events`;
  }

  function generateStatusExplanation(result) {
    debugLog(`Generating explanation for ${result.url}: issuesList.length=${result.issuesList?.length || 0}, schemaFound=${result.schemaFound}, error=${result.error}`);
    
    // CRITICAL: Only treat as error if error is explicitly set AND it's not null/empty/undefined
    if (result.error && result.error !== null && result.error !== 'null' && result.error !== undefined && String(result.error).trim() !== '') {
      console.log(`[‚ö†] Error explanation requested: ${result.error}`);
      return 'Error occurred during validation';
    }
    
    if (!result.schemaFound) {
      return 'No schema found on page';
    }
    
    // Ensure issuesList exists (fallback to empty array)
    const issuesList = result.issuesList || [];
    
    // Debug: Show full issuesList contents
    debugLog(`issuesList contents: ${JSON.stringify(issuesList, null, 2)}`);
    
    if (issuesList.length === 0) {
      debugLog(`No issues found - returning "All required fields present"`);
      return 'All required fields present';
    }
    
    const duplicates = issuesList.filter(i => i.message && i.message.includes('DUPLICATE'));
    const missingFields = issuesList.filter(i => i.message && i.message.includes('missing'));
    const duplicateCount = duplicates.length;
    const missingCount = missingFields.length;
    
    debugLog(`Filtered: missingCount=${missingCount}, duplicateCount=${duplicateCount}`);
    debugLog(`Missing fields items: ${JSON.stringify(missingFields.map(m => ({ type: m.type, field: m.field, message: m.message })), null, 2)}`);
    
    const parts = [];
    if (missingCount > 0) {
      const fieldNames = missingFields.slice(0, 2).map(extractFieldName);
      parts.push(buildMissingFieldsExplanation(missingCount, fieldNames));
    }
    
    if (duplicateCount > 0) {
      parts.push(buildDuplicateExplanation(duplicateCount));
    }
    
    const explanation = parts.length > 0 ? parts.join(' ‚Ä¢ ') : 'Minor issues detected';
    debugLog(`FINAL EXPLANATION: "${explanation}"`);
    return explanation;
  }

  // Helper: Count skipped (system-injected) schemas
  function countSkippedSchemas(result) {
    return result.schemas ? result.schemas.filter(s => s.systemInjected).length : 0;
  }

  // Helper: Check if all schemas are skipped
  function isAllSchemasSkipped(result, skippedCount) {
    return skippedCount > 0 && result.schemas && result.schemas.every(s => s.systemInjected);
  }

  // Helper: Build skipped note text
  function buildSkippedNote(skippedCount) {
    return skippedCount > 0 ? ` (${skippedCount} auto-skipped)` : '';
  }

  // Helper: Build passed status HTML
  function buildPassedStatusHtml(result, skippedCount) {
    const explanation = generateStatusExplanation(result);
    const allSkipped = isAllSchemasSkipped(result, skippedCount);
    const explanationText = allSkipped ? 'All required fields present (Squarespace auto-schema ignored)' : explanation;
    return { 
      class: 'valid', 
      html: `<span class="chip-passed">‚úÖ Passed</span>`
    };
  }

  // Helper: Build issues status HTML (for duplicates and minor issues)
  function buildIssuesStatusHtml(result, skippedCount) {
    const explanation = generateStatusExplanation(result);
    const skippedNote = buildSkippedNote(skippedCount);
    
    // Check if this is primarily duplicates (should show as Warning)
    const duplicates = result.issuesList ? result.issuesList.filter(i => i.message && i.message.includes('DUPLICATE')) : [];
    const isDuplicateOnly = duplicates.length > 0 && 
                            (!result.issuesList || result.issuesList.filter(i => i.message && i.message.includes('missing')).length === 0);
    
    if (isDuplicateOnly) {
      const plural = duplicates.length === 1 ? '' : 's';
      return { 
        class: 'issues', 
        html: `<span class="chip-issues" title="Click to view details">‚ö†Ô∏è Warning${skippedNote}</span>`
      };
    }
    
    return { 
      class: 'issues', 
      html: `<span class="chip-issues" title="Click to view details">‚ö†Ô∏è Issues${skippedNote}</span>`
    };
  }

  // Helper: Build critical status HTML
  function buildCriticalStatusHtml(result, skippedCount) {
    const explanation = generateStatusExplanation(result);
    const skippedNote = buildSkippedNote(skippedCount);
    return { 
      class: 'critical', 
      html: `<span class="chip-critical" title="Click to view details">‚ùå Critical${skippedNote}</span>`
    };
  }

  // Helper: Build error status HTML
  function buildErrorStatusHtml(result) {
    const explanation = generateStatusExplanation(result);
    return { 
      class: 'error', 
      html: `<span class="chip-critical" title="Click to view details">‚ùå Critical</span>`
    };
  }

  // Helper: Check if status should be critical (only missing fields > 3)
  function isCriticalStatus(result) {
    const missingCount = result.missingFields ? result.missingFields.length : 0;
    return missingCount > 3;
  }

  // Helper: Build info-only status HTML
  function buildInfoOnlyStatusHtml(infoCount) {
    const plural = infoCount > 1 ? 's' : '';
    return { 
      class: 'valid', 
      html: `<span class="chip-passed" title="Click to view details">‚úÖ Passed</span>`
    };
  }

  // Helper: Build warnings-only status HTML
  function buildWarningsOnlyStatusHtml(warningsCount) {
    const plural = warningsCount > 1 ? 's' : '';
    return { 
      class: 'issues', 
      html: `<span class="chip-issues" title="Click to view details">‚ö†Ô∏è Warning</span>`
    };
  }

  // Helper: Check if result has only info (no warnings or missing fields)
  function hasOnlyInfo(result) {
    return result.info && result.info.length > 0 && 
           (!result.warnings || result.warnings.length === 0) && 
           (!result.missingFields || result.missingFields.length === 0);
  }

  // Helper: Check if result has only warnings (no missing fields)
  function hasOnlyWarnings(result) {
    return result.warnings && result.warnings.length > 0 && 
           (!result.missingFields || result.missingFields.length === 0);
  }

  // Helper: Determine status HTML from result with color-coded badges and explanations
  function determineStatusHtml(result) {
    // Apply suppression: if treatWarningsAsPass is enabled and only warnings exist, treat as pass
    const sup = SUPPRESSION_CONFIG.suppressions.global;
    if (sup.treatWarningsAsPass && hasOnlyWarnings(result) && result.schemaFound) {
      debugLog(`[SUPPRESSION] Applying treatWarningsAsPass: converting warnings-only result to Passed for ${result.url}`, 'info');
      return buildPassedStatusHtml(result, countSkippedSchemas(result));
    }
    debugLog(`Status determination for ${result.url}: missingFields=${result.missingFields?.length || 0}, warnings=${result.warnings?.length || 0}, info=${result.info?.length || 0}, schemaFound=${result.schemaFound}, error=${result.error}`);
    
    // CRITICAL: Only treat as error if error is explicitly set AND it's not null/empty
    if (result.error && result.error !== null && result.error !== 'null' && result.error.trim() !== '') {
      console.log(`[‚ö†] Error detected: ${result.error}`);
      return buildErrorStatusHtml(result);
    }
    
    // CRITICAL: Restore schemaFound if ANY evidence of schema exists
    if (!result.schemaFound) {
      // Check if schemas exist
      if (result.schemas && result.schemas.length > 0) {
        result.schemaFound = true;
        console.log("[‚úì] Restored schemaFound=true (schema blocks exist)");
      }
      // Check if schemaType is set
      else if (result.schemaType && result.schemaType !== 'null' && result.schemaType !== 'Processing...' && result.schemaType !== '‚Äî') {
        result.schemaFound = true;
        console.log(`[‚úì] Restored schemaFound=true (schemaType exists: ${result.schemaType})`);
      }
      // Check validationResults array
      else {
        const resultIndex = validationResults.findIndex(r => r.url === result.url);
        if (resultIndex >= 0 && validationResults[resultIndex].schemaFound === true) {
          result.schemaFound = true;
          console.log("[‚úì] Restored schemaFound=true (from validationResults array)");
        }
      }
      
      // Update in validationResults array if found
      if (result.schemaFound) {
        const resultIndex = validationResults.findIndex(r => r.url === result.url);
        if (resultIndex >= 0) {
          validationResults[resultIndex].schemaFound = true;
        }
      }
    }
    
    const skippedCount = countSkippedSchemas(result);
    
    // If only info exists (no warnings, no missing fields), show as Passed
    if (hasOnlyInfo(result) && result.schemaFound) {
      return buildInfoOnlyStatusHtml(result.info.length);
    }
    
    // If warnings exist but no missing fields, show as Warning
    if (hasOnlyWarnings(result) && result.schemaFound) {
      return buildWarningsOnlyStatusHtml(result.warnings.length);
    }
    
    // If no issues at all, show as Passed
    if ((!result.missingFields || result.missingFields.length === 0) && 
        (!result.warnings || result.warnings.length === 0) && 
        result.schemaFound) {
      return buildPassedStatusHtml(result, skippedCount);
    }
    
    if (result.schemaFound) {
      // Check for critical status (missing fields > 3)
      if (isCriticalStatus(result)) {
        return buildCriticalStatusHtml(result, skippedCount);
      }
      
      // If missing fields exist, show as Issues
      if (result.missingFields && result.missingFields.length > 0) {
        return buildIssuesStatusHtml(result, skippedCount);
      }
      
      return buildPassedStatusHtml(result, skippedCount);
    }
    
    // Final default return: check schemaFound first
    if (result.schemaFound) {
      return { class: 'valid', html: '<span class="chip-valid">‚úÖ Valid</span>' };
    } else if (result.missingFields && result.missingFields.length > 0) {
      return { class: 'critical', html: '<span class="chip-critical">‚ùå Critical</span>' };
    } else {
      return { class: 'no-schema', html: '<span class="status-badge no-schema">‚ùå No Schema</span>' };
    }
  }
  
  // Helper: Store row data attributes
  function storeRowDataAttributes(row, result) {
    if (result.schemas && result.schemas.length > 0 && result.schemas[0].schema) {
      try {
        const firstJson = JSON.stringify(result.schemas[0].schema, null, 2);
        row.dataset.firstJsonld = firstJson.slice(0, 6000);
      } catch (error) {
        console.warn('Failed to store JSON-LD data:', error);
      }
    }
    if (result.issuesList && result.issuesList.length > 0) {
      row.dataset.issuesList = JSON.stringify(result.issuesList);
    }
    if (result.schemaSummary) {
      row.dataset.schemaSummary = result.schemaSummary;
    }
    if (result.missingFieldsDetails) {
      row.dataset.missingDetail = JSON.stringify(result.missingFieldsDetails);
    }
  }
  
  // Helper: Generate missing fields HTML
  function generateMissingFieldsHtml(result) {
    if (result.missingFields && result.missingFields.length > 0) {
      const filtered = filterSuppressedMissingFields(result.missingFields, result.schemaType || '', result.url || '');
      if (filtered.length > 0) {
        return filtered.map(f => `<div class="missing-entry">‚ùå ${f}</div>`).join('');
      }
    }
    return '‚Äî';
  }

  // Helper: Generate warnings HTML
  function generateWarningsHtml(result) {
    if (result.warnings && result.warnings.length > 0) {
      const filtered = filterSuppressedWarnings(result.warnings, result.url || '');
      if (filtered.length > 0) {
        return filtered.map(w => `<div class="warning-entry">‚ö†Ô∏è ${w}</div>`).join('');
      }
    }
    return '‚Äî';
  }

  // Helper: Generate info HTML
  function generateInfoHtml(result) {
    if (result.info && result.info.length > 0) {
      const filtered = filterSuppressedInfo(result.info, result.url || '');
      if (filtered.length > 0) {
        return filtered.map(i => `<div class="info-entry">${i}</div>`).join('');
      }
    }
    return '‚Äî';
  }
  
  // Helper: Generate schema type HTML
  function generateSchemaTypeHtml(result) {
    if (result.schemaType === 'Processing...') {
      return '<div class="progress-wrap"><div class="progress"><span style="width:0%"></span></div><div class="progress-label">0%</div></div>';
    }
    
    // Get explicit types
    const explicitTypes = result.schemaType ? result.schemaType.split(',').map(t => t.trim()).filter(Boolean) : [];
    
    // Get inferred types
    const inferredTypes = result.inferredTypes || [];
    
    // Debug logging
    if (inferredTypes.length > 0) {
      console.log(`[DEBUG] generateSchemaTypeHtml: Found ${inferredTypes.length} inferred types for ${result.url}:`, inferredTypes);
    }
    
    // Format with inferred types
    const formatted = formatSchemaTypesWithInferred(explicitTypes, inferredTypes) || 'None';
    
    // Debug logging
    if (inferredTypes.length > 0) {
      console.log(`[DEBUG] generateSchemaTypeHtml: Formatted output:`, formatted);
    }
    
    return formatted;
  }
  
  // Helper: Generate status select HTML
  function generateStatusSelectHtml(index, existingStatus, statusType) {
    const options = ['‚úÖ Passed', '‚ö†Ô∏è Warning', '‚ùå Failed', 'üëÄ Opened (reviewing)', 'üîÑ Running...', 'Not run'];
    return options.map(opt => {
      const selected = existingStatus === opt ? 'selected' : '';
      return `<option value="${opt}" ${selected}>${opt}</option>`;
    }).join('');
  }
  
  // Helper: Generate actions column HTML
  function generateActionsColumnHtml(index, result) {
    const enhanceBtn = result.schemas && result.schemas.length > 0 
      ? `<button class="enhance-btn btn-generate-enhanced" data-action="generate-enhanced" id="genBtn_${index}">Generate Enhanced</button><br>` 
      : '';
    
    const supabaseBtn = supabaseAvailable 
      ? `<br><button class="save-btn" onclick="saveToSupabase(${index})" id="saveBtn_${index}">Save to Supabase</button>`
      : '<br><span style="color: #a0aec0; font-size: 0.875rem;">Supabase not available</span>';
    
    // Add "View Details" button with data attributes for event handler
    const viewDetailsBtn = `<button class="enhance-btn view-details-btn btn-view-details" data-action="view-details" data-row-index="${index}" style="background: #2563eb; color: white; border-color: #2563eb; margin-bottom: 0.5rem;">View Details</button><br>`;
    
    return `${viewDetailsBtn}${enhanceBtn}
        <div style="margin-top: 0.5rem;">
          <button class="enhance-btn secondary" id="schemaOrgBtn_${index}" style="font-size: 0.75rem; padding: 0.375rem 0.75rem;">Schema.org</button>
          <button class="enhance-btn secondary" id="richResultsBtn_${index}" style="font-size: 0.75rem; padding: 0.375rem 0.75rem; margin-left: 0.25rem;">Rich Results</button>
        </div>
        ${supabaseBtn}`;
  }
  
  // Helper: Add summary line to notes if not already present
  function addSummaryLineIfNeeded(notesWithSummary, summaryLine, checkText) {
    if (notesWithSummary && !notesWithSummary.includes(checkText)) {
      return notesWithSummary + '\n' + summaryLine;
    }
    return notesWithSummary || summaryLine;
  }

  // Helper: Build missing fields summary line
  function buildMissingFieldsSummary(missingCount) {
    return `Missing: ${missingCount} field${missingCount !== 1 ? 's' : ''}.`;
  }

  // Helper: Build warnings summary line
  function buildWarningsSummary(warningsCount) {
    return `Warnings: ${warningsCount} duplicate${warningsCount !== 1 ? 's' : ''}.`;
  }

  // Helper: Build info summary line
  function buildInfoSummary(infoCount) {
    return `Info: ${infoCount} multi-instance schema${infoCount !== 1 ? 's' : ''} detected.`;
  }

  // Helper: Build notes summary from result buckets
  function buildNotesSummary(result, existingNotes = '') {
    let notesWithSummary = existingNotes;
    
    if (result.missingFields && result.missingFields.length > 0) {
      notesWithSummary = addSummaryLineIfNeeded(notesWithSummary, buildMissingFieldsSummary(result.missingFields.length), 'Missing:');
    }
    if (result.warnings && result.warnings.length > 0) {
      notesWithSummary = addSummaryLineIfNeeded(notesWithSummary, buildWarningsSummary(result.warnings.length), 'Warnings:');
    }
    if (result.info && result.info.length > 0) {
      notesWithSummary = addSummaryLineIfNeeded(notesWithSummary, buildInfoSummary(result.info.length), 'Info:');
    }
    
    return notesWithSummary;
  }

  // Helper: Generate row HTML
  function generateRowHtml(index, result, statusHtml, rowOptions) {
    const { existingGoogleStatus, existingSchemaOrgStatus, existingNotes } = rowOptions;
    const missingFieldsHtml = generateMissingFieldsHtml(result);
    const warningsHtml = generateWarningsHtml(result);
    const infoHtml = generateInfoHtml(result);
    const schemaTypeHtml = generateSchemaTypeHtml(result);
    const googleSelectHtml = generateStatusSelectHtml(index, existingGoogleStatus, 'google');
    const schemaOrgSelectHtml = generateStatusSelectHtml(index, existingSchemaOrgStatus, 'schemaorg');
    const actionsHtml = generateActionsColumnHtml(index, result);
    const notesWithSummary = buildNotesSummary(result, existingNotes);
    
    const schemaOrgUrl = 'https://validator.schema.org/#url=' + encodeURIComponent(result.url);
    const googleUrl = result.richResultsReportUrl || 'https://search.google.com/test/rich-results?url=' + encodeURIComponent(result.url);
    
    return `
      <td><a href="${result.url}" target="_blank" class="url-link">${result.url}</a></td>
      <td id="schemaTypeCell_${index}">${schemaTypeHtml}</td>
      <td id="statusCell_${index}" style="white-space: normal; line-height: 1.6;">${statusHtml}</td>
      <td class="missing-fields" id="missingFieldsCell_${index}">${missingFieldsHtml}</td>
      <td id="warningsCell_${index}">${warningsHtml}</td>
      <td id="infoCell_${index}">${infoHtml}</td>
      <td>
        <select class="status-select" id="googleStatus_${index}" title="Google Rich Results Status" onchange="updateValidationStatus(${index}, 'google', this.value)">
          ${googleSelectHtml}
        </select>
      </td>
      <td>
        <select class="status-select" id="schemaOrgStatus_${index}" title="Schema.org Validator Status" onchange="updateValidationStatus(${index}, 'schemaorg', this.value)">
          ${schemaOrgSelectHtml}
        </select>
      </td>
      <td>
        <textarea class="notes-textarea" id="notes_${index}" placeholder="Add notes..." onchange="updateValidationNotes(${index}, this.value)">${notesWithSummary}</textarea>
      </td>
      <td style="white-space: normal; min-width: 250px;">
        ${actionsHtml}
      </td>
    `;
  }
  
  // Helper: Setup button handlers
  function setupRowButtonHandlers(index, result, schemaOrgUrl, googleUrl, statusClass, row) {
    const schemaOrgBtn = document.getElementById(`schemaOrgBtn_${index}`);
    const richResultsBtn = document.getElementById(`richResultsBtn_${index}`);
    const genBtn = document.getElementById(`genBtn_${index}`);
    const viewDetailsBtn = document.querySelector(`.view-details-btn[data-row-index="${index}"]`);
    const statusCell = document.getElementById(`statusCell_${index}`);
    
    if (schemaOrgBtn) {
      schemaOrgBtn.onclick = () => {
        globalThis.open(schemaOrgUrl, '_blank');
        const statusSelect = document.getElementById(`schemaOrgStatus_${index}`);
        if (statusSelect) {
          statusSelect.value = 'üëÄ Opened (reviewing)';
          updateValidationStatus(index, 'schemaorg', 'üëÄ Opened (reviewing)');
        }
        markReviewing(index, 'schema');
      };
    }
    
    if (richResultsBtn) {
      richResultsBtn.onclick = () => {
        globalThis.open(googleUrl, '_blank');
        const statusSelect = document.getElementById(`googleStatus_${index}`);
        if (statusSelect) {
          statusSelect.value = 'üëÄ Opened (reviewing)';
          updateValidationStatus(index, 'google', 'üëÄ Opened (reviewing)');
        }
        markReviewing(index, 'google');
      };
    }
    
    if (genBtn) {
      genBtn.onclick = () => generateEnhancedSchema(index);
    }
    
    if (viewDetailsBtn) {
      viewDetailsBtn.onclick = () => {
        const rowData = getRowDataFromTr(row);
        openIssuesModal(rowData);
      };
    }
    
    // Make all status badges clickable to open issues modal
    if (statusCell) {
      const chips = statusCell.querySelectorAll('.chip-issues, .chip-critical, .chip-passed, .chip-ok, .status-badge');
      for (const chip of chips) {
        chip.style.cursor = 'pointer';
        chip.onclick = () => {
          const rowData = getRowDataFromTr(row);
          openIssuesModal(rowData);
        };
      }
    }
  }

  // Update table row with result
  function updateTableRow(index, result) {
    const tableBody = document.getElementById('resultsTableBody');
    let row = tableBody.children[index];
    
    if (!row) {
      row = document.createElement('tr');
      tableBody.appendChild(row);
    }
    
    // Show debug panel when validation starts - REMOVED, using bottom debug console only
    // Remove this section - debug panel above table has been removed
    
    const { class: statusClass, html: statusHtml } = determineStatusHtml(result);
    debugLog(`Generated statusHtml for ${result.url}: ${statusHtml.substring(0, 200)}...`);
    debugLog(`Full statusHtml: ${statusHtml}`);
    debugLog(`Status class: ${statusClass}`);
    
    // Ensure row exists and has data-url attribute
    if (!row) {
      row = document.createElement('tr');
      row.id = `row_${index}`;
      tableBody.appendChild(row);
    }
    row.dataset.url = result.url;
    row.dataset.rowIndex = index.toString();
    
    storeRowDataAttributes(row, result);
    
    const existingGoogleStatus = result.validatorGoogleStatus || 'Not run';
    const existingSchemaOrgStatus = result.validatorSchemaOrgStatus || 'Not run';
    const existingNotes = result.notes || '';
    const schemaOrgUrl = 'https://validator.schema.org/#url=' + encodeURIComponent(result.url);
    const googleUrl = result.richResultsReportUrl || 'https://search.google.com/test/rich-results?url=' + encodeURIComponent(result.url);
    
    row.innerHTML = generateRowHtml(index, result, statusHtml, {
      existingGoogleStatus,
      existingSchemaOrgStatus,
      existingNotes
    });
    
    // CRITICAL: Update schema type cell with inferred types if they exist
    // This ensures inferred types persist even after row.innerHTML replacement
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    if (schemaTypeCell) {
      // Always update the cell to ensure inferred types are shown
      const explicitTypes = result.schemaType ? result.schemaType.split(',').map(t => t.trim()).filter(Boolean) : [];
      const inferredTypes = result.inferredTypes || [];
      
      if (inferredTypes.length > 0) {
        console.log(`[DEBUG] updateTableRow: Updating schema type cell with ${inferredTypes.length} inferred types for index ${index}`);
        const formattedTypes = formatSchemaTypesWithInferred(explicitTypes, inferredTypes);
        schemaTypeCell.innerHTML = formattedTypes;
        console.log(`[DEBUG] updateTableRow: Set cell innerHTML to:`, formattedTypes);
      } else {
        // Even if no inferred types, ensure the cell shows the correct content
        if (result.schemaType && result.schemaType !== 'Processing...') {
          schemaTypeCell.innerHTML = result.schemaType || '‚Äî';
        }
      }
    }
    
    // Verify the status cell was updated correctly
    const statusCell = document.getElementById(`statusCell_${index}`);
    if (statusCell) {
      debugLog(`Status cell innerHTML after update: ${statusCell.innerHTML.substring(0, 200)}...`);
      debugLog(`Full status cell HTML: ${statusCell.innerHTML}`);
      
      // Check if explanation element exists (null-safe fallback)
      const explanationEl = statusCell.querySelector('.status-explanation');
      if (!explanationEl) {
        // This is expected for some status types (e.g., "Valid" or "No Schema") - only log in debug mode
        debugLog(`Status explanation not found for ${result.url} (this is normal for some status types)`, 'info');
      } else {
        debugLog(`Explanation element text: "${explanationEl.textContent}"`);
        debugLog(`Explanation element HTML: ${explanationEl.outerHTML}`);
      }
    }
    
    // Setup button handlers
    setupRowButtonHandlers(index, result, schemaOrgUrl, googleUrl, statusClass, row);
    
    // Store validation status in result object
    if (!result.validatorGoogleStatus) {
      result.validatorGoogleStatus = 'Not run';
    }
    if (!result.validatorSchemaOrgStatus) {
      result.validatorSchemaOrgStatus = 'Not run';
    }
    if (!result.notes) {
      result.notes = '';
    }
    
    // CRITICAL: Ensure error is explicitly null if validation succeeded
    if (!result.error || result.error === 'null' || String(result.error).trim() === '') {
      result.error = null;
    }
    
    // CRITICAL: Store result in validationResults array with correct schemaFound
    // Ensure schemaFound is preserved from determineStatusHtml restoration
    validationResults[index] = {
      ...result,
      schemaFound: result.schemaFound, // Use the restored value from determineStatusHtml
      schemaType: result.schemaType || '‚Äî', // Ensure schemaType is never null
      inferredTypes: result.inferredTypes || [], // Preserve inferredTypes
      error: null // Explicitly clear error
    };
    
    console.log(`[‚úì] Stored result in validationResults[${index}]: schemaFound=${validationResults[index].schemaFound}, schemaType=${validationResults[index].schemaType}, error=${validationResults[index].error}`);
    if (validationResults[index].inferredTypes && validationResults[index].inferredTypes.length > 0) {
      console.log(`[DEBUG] updateTableRow: Stored inferredTypes in validationResults[${index}]:`, validationResults[index].inferredTypes);
    }
    
    // Add click handler to status cell if it has issues or error (statusCell already declared above)
    if (statusCell && (statusClass === 'issues' || statusClass === 'error')) {
      const chip = statusCell.querySelector('.chip-issues');
      if (chip) {
        chip.onclick = () => openIssuesModal(getRowDataFromTr(row));
      }
    }
    
    // Add click handler to Generate Enhanced button
    const genBtn = document.getElementById(`genBtn_${index}`);
    if (genBtn) {
      genBtn.onclick = async () => {
        const url = result.url;
        const originalText = genBtn.textContent;
        const originalDisabled = genBtn.disabled;
        
        try {
          // Update button state immediately
          genBtn.disabled = true;
          genBtn.innerHTML = '<span style="display:inline-block;animation:spin 1s linear infinite;">‚è≥</span> Fetching page...';
          genBtn.style.opacity = '0.7';
          genBtn.style.cursor = 'wait';
          
          // Force UI update
          await new Promise(resolve => setTimeout(resolve, 50));
          
          debugLog(`Starting enhanced schema generation for: ${url}`, 'info');
          
          // Update progress
          genBtn.innerHTML = '<span style="display:inline-block;animation:spin 1s linear infinite;">‚è≥</span> Parsing schema...';
          debugLog('Fetching page HTML...', 'info');
          
          const json = await generateEnhancedFor(url);
          
          debugLog('Schema generation completed successfully', 'success');
          
          genBtn.innerHTML = '<span style="display:inline-block;">‚úÖ</span> Opening modal...';
          
          // Small delay to show success state
          await new Promise(resolve => setTimeout(resolve, 300));
          
          if (window.__openGenModal) {
            window.__openGenModal(url, json);
          } else {
            alert('Error: Modal function not initialized. Please refresh the page.');
          }
        } catch (e) {
          debugLog('Generate Enhanced error: ' + e.message, 'error');
          debugLog('Error stack: ' + (e.stack || 'No stack trace'), 'error');
          alert('Failed to generate enhanced schema: ' + e.message);
        } finally {
          // Reset button state
          genBtn.disabled = false;
          genBtn.textContent = originalText;
          genBtn.style.opacity = '1';
          genBtn.style.cursor = 'pointer';
        }
      };
    }
  }
  
  // Update validation status in memory
  function updateValidationStatus(index, type, value) {
    if (validationResults[index]) {
      if (type === 'google') {
        validationResults[index].validatorGoogleStatus = value;
      } else if (type === 'schemaorg') {
        validationResults[index].validatorSchemaOrgStatus = value;
      }
    }
  }
  
  // Helper: Get API base URL based on current hostname
  function getApiBaseUrl() {
    // Always use local origin when running locally (try vercel dev first, fallback to production)
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
      return window.location.origin; // Try local vercel dev first
    }
    if (window.location.hostname.includes('schema-tools-six.vercel.app')) {
      return 'https://schema-tools-six.vercel.app';
    }
    return window.location.origin;
  }

  // Helper: Map Schema.org API status to dropdown value
  function mapSchemaOrgStatus(data, statusSelect) {
    switch (data.status) {
      case 'passed':
        return '‚úÖ Passed';
      case 'warnings':
        return '‚ö†Ô∏è Warning';
      case 'failed':
        // If status is "failed" but errors.length === 0 AND warnings.length === 0, treat as passed
        if (data.errors && data.errors.length === 0 && data.warnings && data.warnings.length === 0) {
          debugLog(`Schema.org returned "failed" but no errors and no warnings - treating as Passed`, 'info');
          return '‚úÖ Passed';
        }
        if (data.errors && data.errors.length === 0) {
          debugLog(`Schema.org returned "failed" but errors array is empty - treating as Warning`, 'warn');
          return '‚ö†Ô∏è Warning';
        }
        return '‚ùå Failed';
      case 'unreachable':
        if (statusSelect.title) {
          statusSelect.title = 'API unreachable';
        }
        return 'Not run';
      default:
        return 'Not run';
    }
  }

  // Helper: Handle Schema.org validator error
  function handleSchemaOrgError(error, index, statusSelect) {
    console.error('Schema.org validator API error:', error);
    console.error('Error stack:', error.stack);
    statusSelect.value = 'Not run';
    statusSelect.title = 'API unreachable: ' + error.message;
    updateValidationStatus(index, 'schemaorg', 'Not run');
    
    // Add error note to Notes cell
    const notesEl = document.getElementById(`notes_${index}`);
    if (notesEl) {
      const currentNotes = notesEl.value || '';
      const notePrefix = currentNotes.includes('Schema.org:') ? '' : 'Schema.org: ';
      const errorMsg = error.message.length > 100 ? error.message.substring(0, 100) + '...' : error.message;
      notesEl.value = currentNotes + (currentNotes ? '\n' : '') + notePrefix + errorMsg;
      updateValidationNotes(index, notesEl.value);
    }
  }

  // Call Schema.org validator API and update dropdown
  async function runSchemaOrgValidator(index, url) {
    const statusSelect = document.getElementById(`schemaOrgStatus_${index}`);
    if (!statusSelect) return;
    
    // Set to "Running..." while waiting
    statusSelect.value = 'üîÑ Running...';
    updateValidationStatus(index, 'schemaorg', 'üîÑ Running...');
    
    try {
      const apiBaseUrl = getApiBaseUrl();
      const apiUrl = `${apiBaseUrl}/api/validator/schemaorg?url=${encodeURIComponent(url)}`;
      
      console.log('Calling Schema.org API:', apiUrl);
      
      const response = await fetch(apiUrl);
      console.log('Schema.org API response status:', response.status, response.statusText);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Schema.org API error response:', errorText);
        throw new Error(`API returned ${response.status}: ${errorText}`);
      }
      
      const data = await response.json();
      console.log('Schema.org API response:', data);
      
      // Map API status to dropdown value
      const dropdownValue = mapSchemaOrgStatus(data, statusSelect);
      
      // Update dropdown
      statusSelect.value = dropdownValue;
      updateValidationStatus(index, 'schemaorg', dropdownValue);
      
      // Remove tooltip if status is not unreachable
      if (data.status !== 'unreachable') {
        statusSelect.removeAttribute('title');
      }
      
      // Store schema.org data in result
      if (validationResults[index]) {
        validationResults[index].schemaOrgData = data;
      }
      
      // Apply external result to finalize status
      const richResult = validationResults[index]?.richResultsData;
      applyExternalResult(index, richResult, data);
      
    } catch (error) {
      handleSchemaOrgError(error, index, statusSelect);
    }
  }
  
  // Helper: Map Rich Results API status to dropdown value
  function mapRichResultsStatus(data, statusSelect) {
    switch (data.status) {
      case 'eligible':
        return '‚úÖ Passed';
      case 'warnings':
        return '‚ö†Ô∏è Warning';
      case 'ineligible':
        return '‚ùå Failed';
      case 'unknown':
      default:
        statusSelect.title = 'Status unknown';
        return 'Not run';
    }
  }

  // Helper: Handle Rich Results error response
  function handleRichResultsErrorResponse(data, index, statusSelect) {
    const errorMsg = data.error || 'Unknown error';
    statusSelect.value = 'Not run';
    statusSelect.title = errorMsg;
    updateValidationStatus(index, 'google', 'Not run');
    
    // Add error note to Notes cell
    const notesEl = document.getElementById(`notes_${index}`);
    if (notesEl) {
      const currentNotes = notesEl.value || '';
      const notePrefix = currentNotes.includes('Rich Results:') ? '' : 'Rich Results: ';
      notesEl.value = currentNotes + (currentNotes ? '\n' : '') + notePrefix + errorMsg;
      updateValidationNotes(index, notesEl.value);
    }
  }

  // Helper: Handle Rich Results validator error
  function handleRichResultsError(error, index, statusSelect) {
    console.error('Rich Results validator API error:', error);
    console.error('Error stack:', error.stack);
    statusSelect.value = 'Not run';
    statusSelect.title = 'API error: ' + error.message;
    updateValidationStatus(index, 'google', 'Not run');
    
    // Add error note to Notes cell
    const notesEl = document.getElementById(`notes_${index}`);
    if (notesEl) {
      const currentNotes = notesEl.value || '';
      const notePrefix = currentNotes.includes('Rich Results:') ? '' : 'Rich Results: ';
      const errorMsg = error.message.length > 100 ? error.message.substring(0, 100) + '...' : error.message;
      notesEl.value = currentNotes + (currentNotes ? '\n' : '') + notePrefix + errorMsg;
      updateValidationNotes(index, notesEl.value);
    }
  }

  // Call Google Rich Results validator API and update dropdown
  async function runRichResultsValidator(index, url) {
    const statusSelect = document.getElementById(`googleStatus_${index}`);
    if (!statusSelect) return;
    
    // Set to "Running..." while waiting
    statusSelect.value = 'üîÑ Running...';
    updateValidationStatus(index, 'google', 'üîÑ Running...');
    
    try {
      const apiBaseUrl = getApiBaseUrl();
      const apiUrl = `${apiBaseUrl}/api/validator/richresults`;
      
      console.log('Calling Rich Results API:', apiUrl, 'for URL:', url);
      
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ url: url })
      });
      
      console.log('Rich Results API response status:', response.status, response.statusText);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Rich Results API error response:', errorText);
        throw new Error(`API returned ${response.status}: ${errorText}`);
      }
      
      const data = await response.json();
      console.log('Rich Results API response:', data);
      
      if (!data.ok) {
        handleRichResultsErrorResponse(data, index, statusSelect);
        return;
      }
      
      // Map API status to dropdown value
      const dropdownValue = mapRichResultsStatus(data, statusSelect);
      
      // Update dropdown
      statusSelect.value = dropdownValue;
      updateValidationStatus(index, 'google', dropdownValue);
      
      // Store reportUrl and data in result for later use
      if (validationResults[index]) {
        validationResults[index].richResultsReportUrl = data.reportUrl;
        validationResults[index].richResultsData = data;
      }
      
      // Apply external result to finalize status
      const schemaOrgResult = validationResults[index]?.schemaOrgData;
      applyExternalResult(index, data, schemaOrgResult);
      
      // Remove tooltip if status is not unknown
      if (data.status !== 'unknown') {
        statusSelect.removeAttribute('title');
      }
      
    } catch (error) {
      handleRichResultsError(error, index, statusSelect);
    }
  }
  
  // Save auto-save preference to localStorage
  function saveAutoSavePreference() {
    const checkbox = document.getElementById('autoSaveToSupabase');
    if (checkbox) {
      localStorage.setItem('validator.autoSave', checkbox.checked ? '1' : '0');
    }
  }
  
  // Load auto-save preference from localStorage
  function loadAutoSavePreference() {
    const checkbox = document.getElementById('autoSaveToSupabase');
    if (checkbox) {
      const stored = localStorage.getItem('validator.autoSave');
      checkbox.checked = stored === '1'; // Default to false if not set
    }
  }
  
  // Save auto-run preference to localStorage
  function saveAutoRunPreference() {
    const checkbox = document.getElementById('autoRunExternalChecks');
    if (checkbox) {
      localStorage.setItem('validator.autoExternal', checkbox.checked ? '1' : '0');
    }
  }
  
  // Load auto-run preference from localStorage
  function loadAutoRunPreference() {
    const stored = localStorage.getItem('validator.autoExternal');
    const checkbox = document.getElementById('autoRunExternalChecks');
    if (checkbox) {
      checkbox.checked = stored !== '0'; // Default to true if not set
    }
  }
  
  // Update notes in memory
  function updateValidationNotes(index, value) {
    if (validationResults[index]) {
      validationResults[index].notes = value;
    }
  }
  
  // Bulk helper: Set all external status dropdowns to a specific value
  function setAllExternalStatusTo(status) {
    const statusValue = status === 'Passed' ? '‚úÖ Passed' : status;
    const rows = document.querySelectorAll('#resultsTableBody tr');
    let updatedCount = 0;
    
    rows.forEach((row) => {
      // Get index from row's first cell's ID or dataset
      const firstCell = row.querySelector('td');
      if (!firstCell) return;
      
      // Find the index by checking the status select IDs
      const googleSelect = row.querySelector('select[id^="googleStatus_"]');
      const schemaOrgSelect = row.querySelector('select[id^="schemaOrgStatus_"]');
      
      if (googleSelect) {
        const index = parseInt(googleSelect.id.replace('googleStatus_', ''));
        if (!isNaN(index) && googleSelect.value === 'Not run') {
          googleSelect.value = statusValue;
          updateValidationStatus(index, 'google', statusValue);
          updatedCount++;
        }
      }
      
      if (schemaOrgSelect) {
        const index = parseInt(schemaOrgSelect.id.replace('schemaOrgStatus_', ''));
        if (!isNaN(index) && schemaOrgSelect.value === 'Not run') {
          schemaOrgSelect.value = statusValue;
          updateValidationStatus(index, 'schemaorg', statusValue);
          updatedCount++;
        }
      }
    });
    
    showToast(`‚úÖ Updated ${updatedCount} "Not run" status${updatedCount !== 1 ? 'es' : ''} to ${statusValue}`);
  }
  
  // Bulk helper: Reset all external status dropdowns to "Not run"
  function resetAllExternalStatus() {
    const rows = document.querySelectorAll('#resultsTableBody tr');
    let updatedCount = 0;
    
    rows.forEach((row) => {
      const googleSelect = row.querySelector('select[id^="googleStatus_"]');
      const schemaOrgSelect = row.querySelector('select[id^="schemaOrgStatus_"]');
      
      if (googleSelect) {
        const index = parseInt(googleSelect.id.replace('googleStatus_', ''));
        if (!isNaN(index)) {
          googleSelect.value = 'Not run';
          updateValidationStatus(index, 'google', 'Not run');
          updatedCount++;
        }
      }
      
      if (schemaOrgSelect) {
        const index = parseInt(schemaOrgSelect.id.replace('schemaOrgStatus_', ''));
        if (!isNaN(index)) {
          schemaOrgSelect.value = 'Not run';
          updateValidationStatus(index, 'schemaorg', 'Not run');
          updatedCount++;
        }
      }
    });
    
    showToast(`‚úÖ Reset ${updatedCount} external status${updatedCount !== 1 ? 'es' : ''} to "Not run"`);
  }
  
  // Helper: Prepare schema JSON for Supabase insertion
  function prepareSchemaJsonForSupabase(result) {
    if (!result.schemas || result.schemas.length === 0) {
      return null;
    }
    if (result.schemas.length === 1) {
      return result.schemas[0].schema;
    }
    return {
      '@context': 'https://schema.org',
      '@graph': result.schemas.map(s => s.schema)
    };
  }

  // Helper: Get validation statuses from DOM
  function getValidationStatusesFromDOM(index, result) {
    const googleStatusEl = document.getElementById(`googleStatus_${index}`);
    const schemaOrgStatusEl = document.getElementById(`schemaOrgStatus_${index}`);
    const notesEl = document.getElementById(`notes_${index}`);
    
    return {
      googleStatus: googleStatusEl ? googleStatusEl.value : result.validatorGoogleStatus || 'Not run',
      schemaOrgStatus: schemaOrgStatusEl ? schemaOrgStatusEl.value : result.validatorSchemaOrgStatus || 'Not run',
      notes: notesEl ? notesEl.value : result.notes || ''
    };
  }

  // Helper: Update save button UI after save
  function updateSaveButtonAfterSave(saveBtn, silent) {
    if (saveBtn && !silent) {
      saveBtn.textContent = '‚úÖ Saved';
      setTimeout(() => {
        saveBtn.textContent = 'Save to Supabase';
        saveBtn.disabled = false;
      }, 2000);
    }
  }

  // Helper: Validate Supabase save prerequisites
  function validateSupabaseSave(index, silent) {
    if (!supabaseAvailable || !supabase) {
      const msg = 'Supabase client not initialized. Please refresh the page.';
      if (!silent) showToast(msg, true);
      debugLog(msg, 'error');
      return { valid: false };
    }
    
    const result = validationResults[index];
    if (!result) {
      const msg = 'Error: No result found for this row';
      if (!silent) showToast(msg, true);
      debugLog(msg, 'error');
      return { valid: false };
    }
    
    return { valid: true, result };
  }

  // Helper: Prepare save button UI
  function prepareSaveButtonUI(index, silent) {
    const saveBtn = document.getElementById(`saveBtn_${index}`);
    if (saveBtn && !silent) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    return saveBtn;
  }

  // Helper: Log save operation details
  function logSaveOperation(result, statuses) {
    debugLog(`Saving to Supabase: ${result.url}`, 'info');
    debugLog(`  Google Status: ${statuses.googleStatus}`, 'info');
    debugLog(`  Schema.org Status: ${statuses.schemaOrgStatus}`, 'info');
    debugLog(`  Schema Type: ${result.schemaType || 'null'}`, 'info');
  }

  // Helper: Handle save success
  function handleSaveSuccess(result, data, silent) {
    if (!silent) {
      showToast(`‚úÖ Saved to Supabase: ${result.url}`);
      debugLog('Successfully saved to Supabase:', data);
    } else {
      debugLog(`‚úÖ Auto-saved to Supabase: ${result.url}`, 'success');
    }
  }

  // Helper: Handle save error
  function handleSaveError(error, result, saveBtn, silent) {
    const errorMsg = error.message || error.code || JSON.stringify(error);
    const errorCode = error.code || '';
    
    // Suppress RLS policy errors if they're just informational (policy exists but may need adjustment)
    const isRLSError = errorCode === '42501' || errorMsg.includes('row-level security policy');
    
    if (isRLSError && silent) {
      // Silently skip RLS errors for auto-save - they're likely due to policy configuration
      debugLog(`Auto-save skipped (RLS policy): ${result.url}`, 'warn');
      return;
    }
    
    debugLog(`Error saving to Supabase: ${errorMsg}`, 'error');
    if (!isRLSError) {
      debugLog(`Full error object: ${JSON.stringify(error)}`, 'error');
    }
    console.error('Error saving to Supabase:', error);
    
    if (!silent) {
      if (isRLSError) {
        showToast(`‚ö†Ô∏è RLS policy issue: Please check Supabase policies for schema_audit_logs table`, true);
      } else {
        showToast(`‚ùå Error saving to Supabase: ${errorMsg}`, true);
      }
    } else {
      debugLog(`Auto-save error for ${result.url}: ${errorMsg}`, 'error');
    }
    
    if (saveBtn && !silent) {
      saveBtn.textContent = 'Save to Supabase';
      saveBtn.disabled = false;
    }
  }

  // Helper: Insert data into Supabase
  async function insertIntoSupabase(result, statuses, schemaJsonRaw) {
    const { data, error } = await supabase
      .from('schema_audit_logs')
      .upsert({
        url: result.url,
        timestamp: new Date().toISOString(),
        validator_google_status: statuses.googleStatus,
        validator_schemaorg_status: statuses.schemaOrgStatus,
        schema_type_detected: result.schemaType || null,
        schema_json_raw: schemaJsonRaw,
        schema_notes: statuses.notes || null
      }, {
        onConflict: 'url',
        ignoreDuplicates: false
      });
    
    if (error) {
      const errorCode = error.code || '';
      const isRLSError = errorCode === '42501' || error.message?.includes('row-level security policy');
      
      if (isRLSError) {
        debugLog(`Supabase RLS error (code ${errorCode}): ${error.message}`, 'warn');
        debugLog(`  Hint: Anonymous inserts may require RLS policy adjustment`, 'warn');
      } else {
        debugLog(`Supabase error: ${JSON.stringify(error)}`, 'error');
        debugLog(`  Code: ${error.code}, Message: ${error.message}, Details: ${JSON.stringify(error.details)}`, 'error');
      }
      throw error;
    }
    
    return data;
  }

  // Save to Supabase
  async function saveToSupabase(index, silent = false) {
    const validation = validateSupabaseSave(index, silent);
    if (!validation.valid) return;
    
    const result = validation.result;
    const saveBtn = prepareSaveButtonUI(index, silent);
    
    try {
      const statuses = getValidationStatusesFromDOM(index, result);
      const schemaJsonRaw = prepareSchemaJsonForSupabase(result);
      
      logSaveOperation(result, statuses);
      const data = await insertIntoSupabase(result, statuses, schemaJsonRaw);
      
      handleSaveSuccess(result, data, silent);
      updateSaveButtonAfterSave(saveBtn, silent);
      return data;
      
    } catch (error) {
      handleSaveError(error, result, saveBtn, silent);
      throw error;
    }
  }
  
  // Show toast notification
  function showToast(message, isError = false) {
    const toast = document.createElement('div');
    toast.className = `toast ${isError ? 'error' : ''}`;
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateX(100%)';
      setTimeout(() => {
        document.body.removeChild(toast);
      }, 300);
    }, 3000);
  }

  // Helper: Initialize validation UI
  function initializeValidationUI(urls, progressDiv, progressBar, progressText, resultsDiv, tableBody) {
    progressDiv.style.display = 'block';
    resultsDiv.style.display = 'block';
    tableBody.innerHTML = '';
    validationResults = [];
    
    // Initialize rows with processing status
    urls.forEach((urlData, index) => {
      const placeholderResult = {
        url: urlData.url,
        row: urlData.row,
        schemaType: null,
        valid: false,
        schemaFound: false,
        missingFields: [],
        warnings: [],
        schemas: [],
        error: null,
        validatorGoogleStatus: 'Not run',
        validatorSchemaOrgStatus: 'Not run',
        notes: '',
        processing: true
      };
      validationResults.push(placeholderResult);
      updateTableRow(index, {
        ...placeholderResult,
        schemaType: 'Processing...',
        error: null
      });
      const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
      if (schemaTypeCell) {
        renderProgress(schemaTypeCell);
        setProgress(schemaTypeCell, 10, 'Queued');
      }
    });
  }

  // Helper: Process URL in batch with progress updates
  async function processUrlInBatch(urlData, index, urls, progressBar, progressText) {
    // Update global progress
    progressText.textContent = `Processing ${index + 1} of ${urls.length}: ${urlData.url}`;
    progressBar.style.width = `${((index + 1) / urls.length) * 100}%`;
    
    // Initialize row with processing status
    updateTableRow(index, {
      url: urlData.url,
      schemaType: 'Processing...',
      valid: false,
      schemaFound: false,
      missingFields: [],
      warnings: [],
      schemas: [],
      error: null
    });
    const schemaTypeCell = document.getElementById(`schemaTypeCell_${index}`);
    if (schemaTypeCell) {
      renderProgress(schemaTypeCell);
      setProgress(schemaTypeCell, 10, 'Queued');
    }
    
    // Start row-level progress (progress updates now happen INSIDE processUrl)
    updateRowProgress(urlData.url, 5);
    
    // Process URL (this will update row progress internally at each stage)
    // Pass index to processUrl so it uses the correct index
    urlData.index = index;
    const result = await processUrl(urlData);
    // Result is already stored at correct index inside processUrl
    // Just ensure table is updated if needed
    if (!validationResults[index]) {
      validationResults[index] = result;
    }
    updateTableRow(index, validationResults[index]);
    
    // Auto-run external validators if enabled
    try {
      await runExternalValidatorsIfEnabled(index, urlData.url);
    } catch (error) {
      console.error(`Failed to run external validators for ${urlData.url}:`, error);
      debugLog(`Failed to run external validators for ${urlData.url}: ${error.message}`, 'error');
    }
    
    // Auto-save to Supabase if enabled (same as single URL validation)
    autoSaveToSupabaseIfEnabled(index, urlData.url);
    
    // Small delay to allow UI to update
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  // Start validation process
  async function startValidation() {
    // Clear all cache and storage BEFORE starting validation
    try {
      // Clear ResultCache if it exists
      if (typeof ResultCache !== 'undefined') {
        if (ResultCache instanceof Map) {
          ResultCache.clear();
        } else if (ResultCache.clear && typeof ResultCache.clear === 'function') {
          ResultCache.clear();
        }
      }
      // Clear validationResults array
      if (typeof validationResults !== 'undefined' && Array.isArray(validationResults)) {
        validationResults.length = 0;
      }
      // Clear localStorage and sessionStorage
      localStorage.removeItem('schemaValidatorResults');
      localStorage.removeItem('schemaValidatorCache');
      sessionStorage.removeItem('schemaValidatorResults');
      sessionStorage.removeItem('schemaValidatorCache');
    } catch (e) {
      console.warn('Failed to clear storage:', e);
    }
    
    // Clear the results table
    const tableBody = document.getElementById('resultsTableBody');
    if (tableBody) {
      tableBody.innerHTML = '';
    }
    
    const fileInput = document.getElementById('validatorCsvFile');
    if (!fileInput.files.length) {
      alert('Please upload a CSV file first');
      return;
    }
    
    const progressDiv = document.getElementById('validatorProgress');
    const progressBar = document.getElementById('progressBarFill');
    const progressText = document.getElementById('progressText');
    const resultsDiv = document.getElementById('validatorResults');
    
    try {
      // Parse CSV
      const urls = await parseCSVForValidation(fileInput.files[0]);
      
      if (urls.length === 0) {
        alert('No valid URLs found in CSV file');
        return;
      }
      
      // Initialize UI
      const tableBody = document.getElementById('resultsTableBody');
      initializeValidationUI(urls, progressDiv, progressBar, progressText, resultsDiv, tableBody);
      
      // Process each URL
      for (let i = 0; i < urls.length; i++) {
        await processUrlInBatch(urls[i], i, urls, progressBar, progressText);
      }
      
      progressText.textContent = `Completed: ${validationResults.length} URLs processed`;
      progressBar.style.width = '100%';
      
      // Enable bulk action buttons
      updateBulkButtons();
      
    } catch (error) {
      alert('Error: ' + error.message);
      progressDiv.style.display = 'none';
      console.error('Validation error:', error);
    }
  }
  
  // Make functions globally available for onclick handlers
  if (typeof window !== 'undefined') {
    window.startValidation = startValidation;
    window.onFileUpload = onFileUpload;
  }
  
  // Update bulk action buttons state
  function updateBulkButtons() {
    const exportBtn = document.getElementById('exportAllBtn');
    const saveAllBtn = document.getElementById('saveAllBtn');
    
    const hasResults = validationResults && validationResults.length > 0;
    
    if (exportBtn) {
      exportBtn.disabled = !hasResults;
    }
    
    if (saveAllBtn) {
      saveAllBtn.disabled = !hasResults || !supabaseAvailable;
    }
    
    console.log('Bulk buttons updated:', { hasResults, supabaseAvailable, exportEnabled: hasResults, saveEnabled: hasResults && supabaseAvailable });
  }
  
  // Export all enhanced schemas
  async function exportAllEnhanced() {
    const exportBtn = document.getElementById('exportAllBtn');
    if (!exportBtn || exportBtn.disabled) return;
    
    if (!validationResults || validationResults.length === 0) {
      alert('No validation results to export');
      return;
    }
    
    exportBtn.disabled = true;
    exportBtn.textContent = 'Generating...';
    
    try {
      const pages = [];
      const processedUrls = new Set();
      
      for (const result of validationResults) {
        if (!result.url || processedUrls.has(result.url)) continue;
        processedUrls.add(result.url);
        
        try {
          const json = await generateEnhancedFor(result.url);
          pages.push({
            url: result.url,
            json: json
          });
        } catch (error) {
          console.warn(`Failed to generate enhanced schema for ${result.url}:`, error);
          // Continue with other URLs
        }
      }
      
      const payload = {
        createdAt: new Date().toISOString(),
        pages: pages
      };
      
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      a.download = `enhanced-schema-batch-${timestamp}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast(`‚úÖ Exported ${pages.length} enhanced schemas`);
      
    } catch (error) {
      console.error('Export error:', error);
      alert('Error exporting enhanced schemas: ' + error.message);
    } finally {
      exportBtn.disabled = false;
      exportBtn.textContent = 'Export All Enhanced';
    }
  }
  
  // Helper: Save single result to Supabase (for batch save)
  async function saveSingleResultToSupabase(result, index) {
    const statuses = getValidationStatusesFromDOM(index, result);
    const schemaJsonRaw = prepareSchemaJsonForSupabase(result);
    
    // Upsert into Supabase (update if exists, insert if not)
    const { data, error } = await supabase
      .from('schema_audit_logs')
      .upsert({
        url: result.url,
        timestamp: new Date().toISOString(),
        validator_google_status: statuses.googleStatus || 'üö´ Skipped',
        validator_schemaorg_status: statuses.schemaOrgStatus || 'üö´ Skipped',
        schema_type_detected: result.schemaType || null,
        schema_json_raw: schemaJsonRaw,
        schema_notes: statuses.notes || null
      }, {
        onConflict: 'url',
        ignoreDuplicates: false
      });
    
    if (error) {
      throw error;
    }
    
    return data;
  }

  // Helper: Show save result summary
  function showSaveResultToast(successCount, errorCount) {
    if (successCount > 0) {
      showToast(`‚úÖ Saved ${successCount} result${successCount !== 1 ? 's' : ''} to Supabase${errorCount > 0 ? ` (${errorCount} failed)` : ''}`);
    } else {
      showToast(`‚ùå Failed to save results: ${errorCount} error${errorCount !== 1 ? 's' : ''}`, true);
    }
  }

  // Save all results to Supabase
  async function saveAllToSupabase() {
    const saveAllBtn = document.getElementById('saveAllBtn');
    if (!saveAllBtn || saveAllBtn.disabled) return;
    
    if (!supabaseAvailable || !supabase) {
      showToast('Supabase client not initialized. Please refresh the page.', true);
      return;
    }
    
    if (!validationResults || validationResults.length === 0) {
      alert('No validation results to save');
      return;
    }
    
    saveAllBtn.disabled = true;
    saveAllBtn.textContent = 'Saving...';
    
    let successCount = 0;
    let errorCount = 0;
    
    try {
      for (let i = 0; i < validationResults.length; i++) {
        const result = validationResults[i];
        if (!result || !result.url) continue;
        
        try {
          await saveSingleResultToSupabase(result, i);
          successCount++;
        } catch (error) {
          console.error(`Failed to save ${result.url}:`, error);
          errorCount++;
        }
      }
      
      showSaveResultToast(successCount, errorCount);
      
    } catch (error) {
      console.error('Save all error:', error);
      showToast('Error saving results: ' + error.message, true);
    } finally {
      saveAllBtn.disabled = false;
      saveAllBtn.textContent = 'Save All to Supabase';
    }
  }

  // Generate enhanced schema
  function generateEnhancedSchema(index) {
    const result = validationResults[index];
    if (!result || !result.schemas || result.schemas.length === 0) {
      alert('No schema found to enhance');
      return;
    }
    
    // Enhance all schemas if multiple exist
    const enhancedSchemas = result.schemas.map(schemaData => {
      return enhanceSchema(schemaData.schema, schemaData.type, result.url);
    });
    
    // If single schema, download as single JSON
    // If multiple schemas, create @graph structure
    let jsonData;
    if (enhancedSchemas.length === 1) {
      jsonData = JSON.stringify(enhancedSchemas[0], null, 2);
    } else {
      // Use @graph structure for multiple schemas
      const graphSchema = {
        '@context': 'https://schema.org',
        '@graph': enhancedSchemas
      };
      jsonData = JSON.stringify(graphSchema, null, 2);
    }
    
    // Create downloadable JSON
    const blob = new Blob([jsonData], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const sanitizedUrl = result.url.replace(/https?:\/\//g, '').replace(/[^a-z0-9]/gi, '-').toLowerCase();
    a.download = `enhanced-schema-${sanitizedUrl}-${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // Also create HTML script tag version as .txt file
    const txtBlob = new Blob([`<script type="application/ld+json">\n${jsonData}\n<\/script>`], { type: 'text/plain' });
    const txtUrl = URL.createObjectURL(txtBlob);
    const txtA = document.createElement('a');
    txtA.href = txtUrl;
    txtA.download = `enhanced-schema-${sanitizedUrl}-${Date.now()}.txt`;
    setTimeout(() => {
      document.body.appendChild(txtA);
      txtA.click();
      document.body.removeChild(txtA);
      URL.revokeObjectURL(txtUrl);
    }, 500);
  }
  
  // Table sorting and filtering functionality
  let currentSortColumn = -1;
  let currentSortDirection = 'asc';
  let originalRows = [];
  
  // Initialize sorting and filtering
  function initTableSortingAndFiltering() {
    const tableBody = document.getElementById('resultsTableBody');
    if (!tableBody) return;
    
    // Store original rows
    originalRows = Array.from(tableBody.children);
    
    // Setup sortable headers
    document.querySelectorAll('.sortable-header').forEach(header => {
      header.style.cursor = 'pointer';
      header.onclick = () => {
        const column = parseInt(header.dataset.column);
        sortTable(column);
      };
    });
    
    // Setup filter inputs
    document.querySelectorAll('.filter-input').forEach(input => {
      input.addEventListener('input', () => {
        filterTable();
      });
    });
  }
  
  // Sort table by column
  function sortTable(columnIndex) {
    const tableBody = document.getElementById('resultsTableBody');
    if (!tableBody) return;
    
    const rows = Array.from(tableBody.children);
    
    // Toggle sort direction if clicking same column
    if (currentSortColumn === columnIndex) {
      currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
    } else {
      currentSortColumn = columnIndex;
      currentSortDirection = 'asc';
    }
    
    // Update sort indicators
    document.querySelectorAll('.sort-indicator').forEach(indicator => {
      indicator.classList.remove('sorted-asc', 'sorted-desc');
    });
    const clickedHeader = document.querySelector(`.sortable-header[data-column="${columnIndex}"]`);
    if (clickedHeader) {
      const indicator = clickedHeader.nextElementSibling;
      if (indicator && indicator.classList.contains('sort-indicator')) {
        indicator.classList.add(currentSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
      }
    }
    
    // Sort rows
    rows.sort((a, b) => {
      const aCell = a.children[columnIndex];
      const bCell = b.children[columnIndex];
      if (!aCell || !bCell) return 0;
      
      const aText = aCell.textContent.trim().toLowerCase();
      const bText = bCell.textContent.trim().toLowerCase();
      
      let comparison = 0;
      if (aText < bText) comparison = -1;
      else if (aText > bText) comparison = 1;
      
      return currentSortDirection === 'asc' ? comparison : -comparison;
    });
    
    // Re-append sorted rows
    rows.forEach(row => tableBody.appendChild(row));
    
    // Re-apply filters after sorting
    filterTable();
  }
  
  // Filter table rows
  function filterTable() {
    const tableBody = document.getElementById('resultsTableBody');
    if (!tableBody) return;
    
    const filterInputs = document.querySelectorAll('.filter-input');
    const filters = Array.from(filterInputs).map(input => ({
      column: parseInt(input.dataset.column),
      value: input.value.trim().toLowerCase()
    }));
    
    const rows = Array.from(tableBody.children);
    
    rows.forEach(row => {
      let show = true;
      
      filters.forEach(filter => {
        if (filter.value) {
          const cell = row.children[filter.column];
          if (cell) {
            const cellText = cell.textContent.trim().toLowerCase();
            if (!cellText.includes(filter.value)) {
              show = false;
            }
          }
        }
      });
      
      row.style.display = show ? '' : 'none';
    });
    
    // Ensure at least 5 rows are visible (if possible)
    const visibleRows = rows.filter(row => row.style.display !== 'none');
    if (visibleRows.length > 0 && visibleRows.length < 5) {
      // Show message if less than 5 rows visible
      console.log(`Showing ${visibleRows.length} row(s) after filtering`);
    }
  }
  
  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTableSortingAndFiltering);
  } else {
    initTableSortingAndFiltering();
  }
  
  // Re-initialize when new rows are added
  const originalAppendChild = Node.prototype.appendChild;
  Node.prototype.appendChild = function(child) {
    const result = originalAppendChild.call(this, child);
    if (this.id === 'resultsTableBody' && child.tagName === 'TR') {
      originalRows = Array.from(this.children);
    }
    return result;
  };
</script>
<!-- Generated Schema Modal -->
  <div id="genBackdrop" class="issues-backdrop" style="display:none" role="dialog" aria-modal="true" aria-labelledby="genTitle">
    <div class="issues-modal gen-enhanced-modal" style="width:min(880px,94vw)">
      <div class="gen-enhanced-header">
        <h3 id="genTitle">Enhanced Schema (suggestion)</h3>
      </div>
      <div class="issues-meta" id="genMeta"></div>
      <div id="genSquarespaceInstructions" style="margin: 1rem 0; padding: 1rem; background: #1e293b; border-left: 4px solid #3b82f6; border-radius: 4px; color: #e2e8f0; font-size: 0.9rem;">
        <strong style="color: #fff;">üìã Where to paste in Squarespace:</strong>
        <ul style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
          <li><strong>Page Header:</strong> Settings ‚Üí Advanced ‚Üí Code Injection ‚Üí Page Header Code</li>
          <li><strong>Page Footer:</strong> Settings ‚Üí Advanced ‚Üí Code Injection ‚Üí Footer</li>
          <li><strong>Code Block:</strong> Add a Code Block ‚Üí Paste the JSON-LD inside &lt;script type="application/ld+json"&gt; tags</li>
        </ul>
        <p style="margin: 0.5rem 0 0 0; font-size: 0.85rem; color: #94a3b8;">üí° Tip: Use Page Header for page-specific schema, Footer for site-wide schema.</p>
      </div>
      <pre id="genJson" class="issues-json" style="max-height:48vh"></pre>
      <div class="gen-enhanced-actions">
        <button class="secondary gen-copy-btn" id="genCopyBtn">Copy to Clipboard</button>
        <button class="secondary gen-save-btn" id="genSaveBtn" style="background: #10b981; color: white; border-color: #10b981;">üíæ Save to File</button>
        <button class="primary gen-close-btn" id="genCloseBtn">Close</button>
      </div>
    </div>
  </div>

  <!-- Issues Modal -->
  <dialog id="issuesBackdrop" class="issues-backdrop" aria-labelledby="issuesTitle">
    <div class="issues-modal">
      <div class="issues-modal-header">
        <h3 id="issuesTitle">Schema Details</h3>
        <button id="issuesCloseXBtn" class="issues-close-x" aria-label="Close">√ó</button>
      </div>
      <div id="issuesMeta" class="issues-meta"></div>
      <div id="issuesContent" class="issues-content"></div>
      <ul id="issuesList" class="issues-list" style="display: none;"></ul>
      <details id="issuesJsonDetails" style="display: none;">
        <summary>Preview first JSON-LD block on page</summary>
        <div style="margin-top: 0.5rem; margin-bottom: 0.5rem;">
          <button class="secondary" id="issuesCopyJsonBtn" style="font-size: 0.85rem; padding: 0.4rem 0.8rem;">Copy JSON-LD</button>
        </div>
        <pre id="issuesJson" class="issues-json"></pre>
      </details>
      <div class="issues-actions">
        <button class="secondary" id="issuesSchemaOrgBtn">Open Schema.org</button>
        <button class="secondary" id="issuesGoogleBtn">Open Rich Results</button>
        <button class="primary" id="issuesCloseBtn">Close</button>
      </div>
    </div>
  </dialog>

  <!-- Product Schema Workflow Controller -->
  <script>
    // Update version date/time stamp on page load
    document.addEventListener('DOMContentLoaded', function() {
      const versionDateEl = document.getElementById('version-date');
      if (versionDateEl) {
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
        const timeStr = now.toTimeString().split(' ')[0].substring(0, 5); // HH:MM
        versionDateEl.textContent = `${dateStr} ${timeStr}`;
      }
    });
    
    // Server status check - disabled in Electron mode (server always runs)
    let serverStatus = 'running'; // Assume running in Electron
    let isElectronMode = false;
    let serverPort = 8000; // Default port, will be discovered if different
    
    // Helper function to discover server port (tries 8000-8009)
    async function discoverServerPort() {
      const startPort = 8000;
      const maxPorts = 10;
      
      for (let port = startPort; port < startPort + maxPorts; port++) {
        try {
          const res = await fetch(`http://localhost:${port}/health`, { 
            signal: AbortSignal.timeout(500) 
          });
          if (res.ok) {
            const data = await res.json();
            if (data.status === "ok") {
              return port;
            }
          }
        } catch (e) {
          // Port not responding, try next
          continue;
        }
      }
      return null;
    }
    
    // Discover server port on load (in Electron mode)
    if (typeof window !== 'undefined') {
      // Try to discover port immediately
      discoverServerPort().then(port => {
        if (port) {
          serverPort = port;
          if (port !== 8000) {
            console.log(`‚ÑπÔ∏è Server discovered on port ${port} (8000 was in use)`);
          }
        }
      });
    }
    
    // Helper function to log server messages to Step 0 console
    function logServerMessage(type, message) {
      const consoleOutput = document.getElementById('executorConsole') || document.querySelector('[id*="step0"][id*="console"]');
      if (consoleOutput && isElectronMode) {
        const prefix = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : type === 'success' ? '‚úÖ' : '‚ÑπÔ∏è';
        const logLine = `${prefix} [Server] ${message}\n`;
        consoleOutput.textContent = (consoleOutput.textContent || '') + logLine;
        consoleOutput.style.display = 'block';
        consoleOutput.scrollTop = consoleOutput.scrollHeight;
        console.log(`[Main Process] ${message}`);
        
        // Also add to combined log
        addToCombinedLog(logLine, '0', 'setup');
      }
    }
    
    // Listen for server logs from main process (Electron only)
    if (window.electronAPI && window.electronAPI.onServerLog) {
      window.electronAPI.onServerLog((data) => {
        logServerMessage(data.type || 'info', data.message || JSON.stringify(data));
      });
    }
    
    // Detect if running in Electron (check for Electron user agent or window properties)
    // This runs immediately, but initLocalExecutor will do a more thorough check
    function detectElectronMode() {
      if (navigator.userAgent.toLowerCase().indexOf('electron') > -1) {
        isElectronMode = true;
        console.log("‚úÖ Electron detected via user agent");
        serverStatus = 'running';
        return true;
      } else if (window.electronAPI && window.electronAPI.isElectron) {
        isElectronMode = true;
        console.log("‚úÖ Electron detected via preload API");
        serverStatus = 'running';
        return true;
      } else if (window.process && window.process.versions && window.process.versions.electron) {
        isElectronMode = true;
        console.log("‚úÖ Electron detected via process.versions");
        serverStatus = 'running';
        return true;
      }
      return false;
    }
    
    // Try immediate detection
    detectElectronMode();
    
    // Also check after a short delay (in case preload script loads late)
    setTimeout(() => {
      if (!isElectronMode) {
        if (detectElectronMode()) {
          console.log("‚úÖ Electron detected after delay");
        }
      }
    }, 500);
    
    async function ensureLocalExecutorRunning() {
      // In Electron mode, server is always running
      if (isElectronMode) {
        console.log("‚úÖ Local executor running (Electron mode)");
        serverStatus = 'running';
        return true;
      }
      
      // Browser mode: discover server port and check status
      const discoveredPort = await discoverServerPort();
      if (discoveredPort) {
        serverPort = discoveredPort;
        if (discoveredPort !== 8000) {
          console.log(`‚ÑπÔ∏è Server found on port ${discoveredPort} (8000 was in use)`);
        }
        try {
          const res = await fetch(`http://localhost:${discoveredPort}/health`);
          const data = await res.json();
          if (data.status === "ok") {
            console.log("‚úÖ Local executor already running.");
            serverStatus = 'running';
            return true;
          }
        } catch (err) {
          // Fall through
        }
      }
      
      console.log("‚ö†Ô∏è Local executor not running.");
      console.log("üí° To start the server, run in terminal: npm run start-local");
      serverStatus = 'stopped';
      
      // Check if running on Vercel/web deployment
      const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                              window.location.hostname.includes('localhost') === false;
      
      // Show a helpful message in the UI (only in browser mode)
      if (!isElectronMode) {
        if (isWebDeployment) {
          // On web deployment, show info message instead of warning
          const firstStep = document.querySelector('#file-step1')?.parentElement;
          if (firstStep && !document.getElementById('serverStatusWarning')) {
            const statusDiv = document.createElement('div');
            statusDiv.id = 'serverStatusWarning';
            statusDiv.style.cssText = 'margin-top: 1rem; padding: 1rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; color: #1565c0; font-size: 0.875rem;';
            statusDiv.innerHTML = `
              <strong>‚ÑπÔ∏è Web Deployment Mode</strong><br>
              Local server features require the Electron app or local development.<br>
              <strong>For full automation:</strong> Download the Electron desktop app or run locally with <code style="background: #f0f0f0; padding: 4px 8px; border-radius: 4px;">npm run start-local</code><br>
              <small>The web version is read-only for validation purposes.</small>
            `;
            firstStep.insertBefore(statusDiv, firstStep.firstChild);
          }
        } else {
          // Local browser mode: show warning
          const firstStep = document.querySelector('#file-step1')?.parentElement;
          if (firstStep && !document.getElementById('serverStatusWarning')) {
            const statusDiv = document.createElement('div');
            statusDiv.id = 'serverStatusWarning';
            statusDiv.style.cssText = 'margin-top: 1rem; padding: 1rem; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; color: #856404; font-size: 0.875rem;';
            statusDiv.innerHTML = `
              <strong>‚ö†Ô∏è Local Server Not Running</strong><br>
              Start the local executor server first:<br>
              <code style="background: #f0f0f0; padding: 4px 8px; border-radius: 4px;">npm run start-local</code><br>
              <small>Then refresh this page and try again.</small>
            `;
            firstStep.insertBefore(statusDiv, firstStep.firstChild);
          }
        }
      }
      return false;
    }

    // Auto-chain steps automatically
    function chainNextStep(nextStepFunction, delay = 2000) {
      setTimeout(() => {
        console.log(`‚è© Automatically continuing to next step...`);
        if (nextStepFunction) {
          nextStepFunction();
        }
      }, delay);
    }

    // Step 0: Initialize Local Executor
    async function initLocalExecutor() {
      const consoleOutput = document.getElementById("executorConsole");
      const status = document.getElementById("executorStatus");
      const startBtn = document.getElementById("startLocalBtn");
      const copyBtn = document.getElementById("copyCommandBtn");
      
      const log = (msg) => {
        if (consoleOutput) {
          consoleOutput.style.display = 'block';
          consoleOutput.textContent += msg + '\n';
          consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }
        // Also add to combined log
        addToCombinedLog(msg + '\n', '0', 'setup');
      };
      
      if (!status) return;
      
      // Start with "Initializing" status
      updateStepStatus('0', 'running', 'Initializing...');
      status.textContent = "üîç Checking your setup...";
      status.style.background = "#fff3cd";
      status.style.borderColor = "#ffc107";
      status.style.color = "#856404";
      
      // Detect Electron - check multiple methods with fallback
      let isElectron = false;
      
      // Method 1: Check preload API (most reliable)
      if (window.electronAPI && window.electronAPI.isElectron) {
        isElectron = true;
      }
      // Method 2: Check user agent
      else if (navigator.userAgent.toLowerCase().indexOf('electron') > -1) {
        isElectron = true;
      }
      // Method 3: Check process.versions (if available)
      else if (typeof window !== 'undefined' && window.process && window.process.versions && window.process.versions.electron) {
        isElectron = true;
      }
      
      // If still not detected, wait a bit for preload script to load
      if (!isElectron) {
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Retry detection
        if (window.electronAPI && window.electronAPI.isElectron) {
          isElectron = true;
        } else if (navigator.userAgent.toLowerCase().indexOf('electron') > -1) {
          isElectron = true;
        }
      }
      
      // Determine mode and complete Step 0
      if (isElectron) {
        // ELECTRON MODE
        log("‚úÖ Running in Electron desktop app");
        log("‚öôÔ∏è Automation server starting...");
        status.textContent = "‚úÖ Electron Mode ‚Äì Full automation enabled";
        status.style.background = "#d4edda";
        status.style.borderColor = "#c3e6cb";
        status.style.color = "#155724";
        
        try {
          // Give server a moment to start
          await new Promise(resolve => setTimeout(resolve, 1500));
          
          // Discover server port first
          const discoveredPort = await discoverServerPort();
          if (discoveredPort) {
            serverPort = discoveredPort;
            if (discoveredPort !== 8000) {
              log(`‚ÑπÔ∏è Server found on port ${discoveredPort} (8000 was in use)`);
            }
          }
          
          const res = await fetch(`http://localhost:${serverPort}/health`).catch(() => null);
          if (res && res.ok) {
            log("‚úÖ Ready! Steps will chain automatically after you upload a file in Step 1.");
            serverStatus = 'running';
            updateStepStatus('0', 'complete', 'Ready');
            unlockStep1();
            updateStepStatus('1', 'waiting', 'Ready');
          } else {
            // Retry once more
            await new Promise(resolve => setTimeout(resolve, 2000));
            const retryPort = await discoverServerPort() || serverPort;
            const retryRes = await fetch(`http://localhost:${retryPort}/health`).catch(() => null);
            if (retryRes && retryRes.ok) {
              log("‚úÖ Ready! Steps will chain automatically after you upload a file in Step 1.");
              serverStatus = 'running';
              updateStepStatus('0', 'complete', 'Ready');
              unlockStep1();
              updateStepStatus('1', 'waiting', 'Ready');
            } else {
              log("‚ö†Ô∏è Server starting...");
              if (isElectronMode && window.electronAPI && window.electronAPI.openDevTools) {
                const consoleBtn = document.createElement('button');
                consoleBtn.textContent = 'üîç Open Developer Console (Ctrl+Shift+I)';
                consoleBtn.style.cssText = 'margin: 8px 0; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;';
                consoleBtn.onclick = async () => {
                  try {
                    await window.electronAPI.openDevTools();
                    log("‚úÖ Developer Console opened! Check the Console tab for detailed logs.");
                  } catch (e) {
                    log("‚ö†Ô∏è Could not open console automatically. Press Ctrl+Shift+I to open it manually.");
                  }
                };
                if (consoleOutput) {
                  consoleOutput.appendChild(consoleBtn);
                }
              } else {
                log("üí° Tip: Press Ctrl+Shift+I to open Developer Console for detailed logs.");
              }
              updateStepStatus('0', 'complete', 'Ready');
              unlockStep1();
              updateStepStatus('1', 'waiting', 'Ready');
            }
          }
        } catch (err) {
          log("‚ö†Ô∏è Server check failed, but continuing...");
          updateStepStatus('0', 'complete', 'Ready');
          unlockStep1();
          updateStepStatus('1', 'waiting', 'Ready');
        }
      } else {
        // WEB MODE
        const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                                window.location.hostname.includes('localhost') === false;
        
        if (isWebDeployment) {
          // VERCEL/WEB DEPLOYMENT
          // Hide console in web mode for cleaner UI
          if (consoleOutput) consoleOutput.style.display = 'none';
          
          status.textContent = "‚úÖ Web Mode ‚Äì Step 1 unlocked for validation";
          status.style.background = "#d4edda";
          status.style.borderColor = "#c3e6cb";
          status.style.color = "#155724";
          
          // Show web mode notices on Steps 2-4
          const step2Notice = document.getElementById('step2WebModeNotice');
          const step3aNotice = document.getElementById('step3aWebModeNotice');
          const step3bNotice = document.getElementById('step3bWebModeNotice');
          const step4Notice = document.getElementById('step4WebModeNotice');
          
          if (step2Notice) step2Notice.style.display = 'block';
          if (step3aNotice) step3aNotice.style.display = 'block';
          if (step3bNotice) step3bNotice.style.display = 'block';
          if (step4Notice) step4Notice.style.display = 'block';
          
          // Disable buttons in web mode
          const fetchBtn = document.getElementById('fetchGoogleReviews');
          const mergeBtn = document.getElementById('mergeReviewsBtn');
          const schemaBtn = document.getElementById('run-step4');
          
          if (fetchBtn) {
            fetchBtn.disabled = true;
            fetchBtn.style.opacity = '0.5';
            fetchBtn.style.cursor = 'not-allowed';
          }
          if (mergeBtn) {
            mergeBtn.disabled = true;
            mergeBtn.style.opacity = '0.5';
            mergeBtn.style.cursor = 'not-allowed';
          }
          if (schemaBtn) {
            schemaBtn.disabled = true;
            schemaBtn.style.opacity = '0.5';
            schemaBtn.style.cursor = 'not-allowed';
          }
          
          // Complete Step 0 and unlock Step 1
          updateStepStatus('0', 'complete', 'Web Mode');
          setTimeout(() => {
            unlockStep1();
            updateStepStatus('1', 'waiting', 'Ready');
          }, 500);
        } else {
          // LOCAL BROWSER MODE
          log("üåê Running in local browser");
          log("üí° Start the local server to enable full automation");
          status.textContent = "‚è≥ Start local server to unlock automation";
          status.style.background = "#fff3cd";
          status.style.borderColor = "#ffc107";
          status.style.color = "#856404";
          
          if (copyBtn) {
            copyBtn.style.display = 'inline-block';
            copyBtn.onclick = () => {
              navigator.clipboard.writeText("npm run start-local").then(() => {
                status.textContent = "üìã Command copied! Run it in your terminal.";
                setTimeout(() => {
                  checkServerStatus();
                }, 500);
              });
            };
          }
          
          if (startBtn) {
            startBtn.style.display = 'inline-block';
            startBtn.textContent = "üîÑ Check Server Status";
            startBtn.onclick = () => {
              checkServerStatus();
            };
          }
          
          // Auto-check server status
          checkServerStatus();
        }
      }
      
      async function checkServerStatus() {
        log("üîÑ Checking if local server is running...");
        try {
          const discoveredPort = await discoverServerPort() || serverPort;
          serverPort = discoveredPort;
          const res = await fetch(`http://localhost:${serverPort}/health`);
          const data = await res.json();
          if (data.status === "ok") {
            log("‚úÖ Local server is running!");
            status.textContent = "‚úÖ Local Server Active ‚Äì Full automation enabled";
            status.style.background = "#d4edda";
            status.style.borderColor = "#c3e6cb";
            status.style.color = "#155724";
            serverStatus = 'running';
            updateStepStatus('0', 'complete', 'Ready');
            unlockStep1();
            updateStepStatus('1', 'waiting', 'Ready');
            if (startBtn) startBtn.style.display = 'none';
            if (copyBtn) copyBtn.style.display = 'none';
          } else {
            log("‚ö†Ô∏è Server not running yet.");
            log("üí° Run 'npm run start-local' in your terminal");
            status.textContent = "‚è≥ Waiting for local server...";
            updateStepStatus('0', 'running', 'Waiting...');
          }
        } catch (err) {
          log("‚ö†Ô∏è Server not running.");
          log("üí° Run 'npm run start-local' in your terminal, then click 'Check Server Status'");
          status.textContent = "‚è≥ Waiting for local server...";
          updateStepStatus('0', 'running', 'Waiting...');
        }
      }
    }
    
    function unlockStep1() {
      const step1 = document.getElementById('file-step1');
      if (step1) {
        step1.disabled = false;
        step1.style.opacity = '1';
        step1.style.cursor = 'pointer';
      }
      const step1Card = step1 ? step1.closest('div[style*="border-radius"]') : null;
      if (step1Card) {
        step1Card.style.opacity = '1';
        step1Card.style.pointerEvents = 'auto';
      }
      // Hide the "Complete Step 0 first" message
      const lockMessage = document.getElementById('step1LockMessage');
      if (lockMessage) {
        lockMessage.style.display = 'none';
      }
    }
    
    function lockStep1() {
      const step1 = document.getElementById('file-step1');
      if (step1) {
        step1.disabled = true;
        step1.style.opacity = '0.5';
        step1.style.cursor = 'not-allowed';
      }
      const step1Card = step1?.closest('div[style*="border-radius"]');
      if (step1Card) {
        step1Card.style.opacity = '0.7';
      }
    }
    
    // Desktop App Launch Button Handler (Web Mode Only) + Build Button (Electron Mode)
    document.addEventListener('DOMContentLoaded', () => {
      const isElectron = !!(window.electronAPI && window.electronAPI.isElectron) || 
                         navigator.userAgent.toLowerCase().includes('electron');
      
      // Show build section in Electron mode
      if (isElectron && window.electronAPI && window.electronAPI.buildDesktop) {
        const buildSection = document.getElementById('build-desktop-section');
        if (buildSection) {
          buildSection.style.display = 'block';
          
          const buildBtn = document.getElementById('buildDesktopBtn');
          const buildOutput = document.getElementById('buildOutput');
          
          if (buildBtn && buildOutput) {
            buildBtn.addEventListener('click', async () => {
              buildBtn.disabled = true;
              buildBtn.textContent = 'üî® Building...';
              buildBtn.style.background = '#95a5a6';
              buildOutput.style.display = 'block';
              buildOutput.textContent = 'üî® Starting build process...\n';
              buildOutput.scrollTop = buildOutput.scrollHeight;
              
              // Set up event listeners for build progress
              if (window.electronAPI.onBuildProgress) {
                window.electronAPI.onBuildProgress((data) => {
                  buildOutput.textContent += data.data;
                  buildOutput.scrollTop = buildOutput.scrollHeight;
                });
              }
              
              if (window.electronAPI.onBuildComplete) {
                window.electronAPI.onBuildComplete((data) => {
                  buildOutput.textContent += `\n‚úÖ ${data.message}\n`;
                  buildOutput.textContent += `\nüìÅ Output location: %LOCALAPPDATA%\\SchemaTools\\SchemaTools-win32-x64\\SchemaTools.exe\n`;
                  buildOutput.textContent += `   (Typically: C:\\Users\\<YourUsername>\\AppData\\Local\\SchemaTools\\SchemaTools-win32-x64\\SchemaTools.exe)\n`;
                  buildBtn.disabled = false;
                  buildBtn.textContent = '‚úÖ Build Complete!';
                  buildBtn.style.background = '#27AE60';
                  
                  // Show and enable the "Open Built App" button
                  const openExeBtn = document.getElementById('openExeBtn');
                  if (openExeBtn && window.electronAPI.openExe && window.electronAPI.getExePath) {
                    openExeBtn.style.display = 'inline-block';
                    openExeBtn.onclick = async () => {
                      try {
                        // Get the exe path from Electron
                        const exePath = await window.electronAPI.getExePath();
                        await window.electronAPI.openExe(exePath);
                        openExeBtn.textContent = '‚úÖ Opened!';
                        setTimeout(() => {
                          openExeBtn.textContent = '‚ñ∂Ô∏è Open Built App (SchemaTools.exe)';
                        }, 2000);
                      } catch (error) {
                        try {
                          const exePath = await window.electronAPI.getExePath();
                          alert(`Failed to open app: ${error.message}\n\nPlease open manually:\n${exePath}`);
                        } catch {
                          alert(`Failed to open app: ${error.message}\n\nPlease open manually:\n%LOCALAPPDATA%\\SchemaTools\\SchemaTools-win32-x64\\SchemaTools.exe`);
                        }
                      }
                    };
                  }
                  
                  buildOutput.scrollTop = buildOutput.scrollHeight;
                });
              }
              
              if (window.electronAPI.onBuildError) {
                window.electronAPI.onBuildError((data) => {
                  buildOutput.textContent += `\n‚ùå Build Error: ${data.error}\n`;
                  if (data.stderr) {
                    buildOutput.textContent += `\nError output:\n${data.stderr}\n`;
                  }
                  buildBtn.disabled = false;
                  buildBtn.textContent = '‚ùå Build Failed - Try Again';
                  buildBtn.style.background = '#e74c3c';
                  buildOutput.scrollTop = buildOutput.scrollHeight;
                });
              }
              
              try {
                await window.electronAPI.buildDesktop();
              } catch (error) {
                buildOutput.textContent += `\n‚ùå Build failed: ${error.message}\n`;
                buildBtn.disabled = false;
                buildBtn.textContent = '‚ùå Build Failed - Try Again';
                buildBtn.style.background = '#e74c3c';
                buildOutput.scrollTop = buildOutput.scrollHeight;
              }
            });
          }
        }
      }
      
      if (!isElectron) {
        const launchDiv = document.getElementById('desktop-launch');
        if (launchDiv) {
          launchDiv.style.display = 'block';
          
          // Get the actual exe path from Electron API if available, otherwise show expected location
          let fullExePath = "%LOCALAPPDATA%\\SchemaTools\\SchemaTools-win32-x64\\SchemaTools.exe";
          if (isElectronMode && window.electronAPI && window.electronAPI.getExePath) {
            // Use async IIFE to handle await
            (async () => {
              try {
                const actualPath = await window.electronAPI.getExePath();
                if (actualPath) {
                  fullExePath = actualPath;
                }
              } catch (e) {
                // Fallback to default
              }
            })();
          }
          const buildCommand = "npm run build:desktop";
          
          // Copy build command button
          const copyPathBtn = document.getElementById('copyPathBtn');
          if (copyPathBtn) {
            copyPathBtn.addEventListener('click', async () => {
              try {
                await navigator.clipboard.writeText(buildCommand);
                copyPathBtn.textContent = '‚úÖ Copied!';
                copyPathBtn.style.background = '#27AE60';
                setTimeout(() => {
                  copyPathBtn.textContent = 'üìã Copy Build Command';
                  copyPathBtn.style.background = '#0078D4';
                }, 2000);
              } catch (e) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = buildCommand;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                copyPathBtn.textContent = '‚úÖ Copied!';
                setTimeout(() => {
                  copyPathBtn.textContent = 'üìã Copy Build Command';
                }, 2000);
              }
            });
          }
          
          // Open folder in Explorer button - Creates batch file to open PowerShell in correct directory
          const openFolderBtn = document.getElementById('openFolderBtn');
          if (openFolderBtn) {
            openFolderBtn.addEventListener('click', async () => {
              try {
                // Copy command to clipboard first
                await navigator.clipboard.writeText(buildCommand);
                
                // Calculate project root folder (use hardcoded path since exe is now in LOCALAPPDATA)
                const projectFolderPath = 'G:\\Dropbox\\alan ranger photography\\Website Code\\Schema Tools';
                
                // Create a batch file that opens PowerShell and runs the build command
                const batchContent = `@echo off
cd /d "${projectFolderPath}"
echo.
echo ========================================
echo   Schema Tools - Build Desktop App
echo ========================================
echo.
echo Project folder: ${projectFolderPath}
echo.
echo ‚ö†Ô∏è  IMPORTANT: Build output goes to %LOCALAPPDATA%\\SchemaTools
echo    (No more Dropbox lock errors!)
echo.
echo Starting build process...
echo.
powershell.exe -NoExit -Command "Set-Location '${projectFolderPath}'; Write-Host ''; Write-Host 'üìÅ Project folder:' -ForegroundColor Green; Write-Host '${projectFolderPath}' -ForegroundColor Cyan; Write-Host ''; Write-Host '‚ö†Ô∏è  If you see EBUSY/locked errors:' -ForegroundColor Red; Write-Host '   Close Dropbox and wait for sync to finish' -ForegroundColor Yellow; Write-Host ''; Write-Host 'üî® Running build command: ${buildCommand}' -ForegroundColor Yellow; Write-Host ''; ${buildCommand}"`;
                
                // Create blob and download the batch file
                const blob = new Blob([batchContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'Open-PowerShell-Here.bat';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                openFolderBtn.textContent = '‚úÖ Batch file downloaded!';
                setTimeout(() => {
                  openFolderBtn.textContent = 'üìÅ Open PowerShell Here';
                }, 2000);
                
                // Show instructions
                setTimeout(() => {
                  alert(`‚úÖ Batch file downloaded!\n\nüí° Next steps:\n1. Close any running Electron apps (SchemaTools.exe)\n2. Go to your Downloads folder\n3. Double-click "Open-PowerShell-Here.bat"\n4. PowerShell will open and automatically run the build!\n\nüìÅ Project folder:\n${projectFolderPath}\n\nüìÅ Built app will be at:\n%LOCALAPPDATA%\\SchemaTools\\SchemaTools-win32-x64\\SchemaTools.exe\n\nüî® Command: ${buildCommand}\n\n‚úÖ No more Dropbox lock errors - builds go to LOCALAPPDATA!`);
                }, 500);
              } catch (e) {
                // Fallback: show manual instructions
                const projectFolderPath = 'G:\\Dropbox\\alan ranger photography\\Website Code\\Schema Tools';
                await navigator.clipboard.writeText(buildCommand);
                alert(`üìã Build command copied to clipboard!\n\nüìÅ Project folder:\n${projectFolderPath}\n\nüí° To open terminal:\n1. Close any running Electron apps first\n2. Navigate to the folder above in Windows Explorer\n3. Right-click in empty space ‚Üí "Open PowerShell here"\n4. Paste (Ctrl+V) and press Enter\n\n‚ö†Ô∏è Important: Make sure you're in the project folder!\n\nOr manually run:\n${buildCommand}\n\nüìÅ Built app will be at:\n%LOCALAPPDATA%\\SchemaTools\\SchemaTools-win32-x64\\SchemaTools.exe`);
              }
            });
          }
          
          // Show full path button - expand LOCALAPPDATA
          const showInstructionsBtn = document.getElementById('showInstructionsBtn');
          if (showInstructionsBtn) {
            showInstructionsBtn.addEventListener('click', () => {
              const expandedPath = `C:\\Users\\YOUR_USERNAME\\AppData\\Local\\SchemaTools\\SchemaTools-win32-x64\\SchemaTools.exe`;
              const instructions = `üìÅ Full Path to Desktop App:

Environment Variable:
%LOCALAPPDATA%\\SchemaTools\\SchemaTools-win32-x64\\SchemaTools.exe

Actual Path (replace YOUR_USERNAME):
${expandedPath}

üí° To find your actual path:
1. Press Windows Key + R
2. Type: %LOCALAPPDATA%\\SchemaTools\\SchemaTools-win32-x64
3. Press Enter
4. Windows Explorer will open to the folder

üí° To build the app:
1. Open terminal in your project folder
2. Run: ${buildCommand}
3. Then navigate to the path above`;
              
              alert(instructions);
            });
          }
          
          // Open Electron app button (web mode - creates batch file to open exe)
          const openExeBtnWeb = document.getElementById('openExeBtnWeb');
          if (openExeBtnWeb) {
            openExeBtnWeb.addEventListener('click', () => {
              const exePath = 'C:\\Users\\alan\\AppData\\Local\\SchemaTools\\SchemaTools-win32-x64\\SchemaTools.exe';
              
              // Create a batch file that opens the exe
              const batchContent = `@echo off
cd /d "C:\\Users\\alan\\AppData\\Local\\SchemaTools\\SchemaTools-win32-x64"
start "" "SchemaTools.exe"
exit`;
              
              // Create blob and download
              const blob = new Blob([batchContent], { type: 'text/plain;charset=utf-8' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'Open-SchemaTools.bat';
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
              
              // Show instructions
              setTimeout(() => {
                alert(`‚úÖ Batch file downloaded!\n\nüí° To open the app:\n1. Go to your Downloads folder\n2. Double-click "Open-SchemaTools.bat"\n3. The app will launch!\n\nOr open directly:\n${exePath}`);
              }, 500);
            });
          }
        }
      }
    });

    // Check server status on page load (only in browser mode)
    window.addEventListener("DOMContentLoaded", async () => {
      // Lock Step 1 initially
      lockStep1();
      
      // Initialize Step 0
      try {
        await initLocalExecutor();
      } catch (err) {
        console.error("Error initializing local executor:", err);
        const status = document.getElementById("executorStatus");
        if (status) {
          status.textContent = "‚ùå Error initializing executor. Check console for details.";
          status.style.background = "#f8d7da";
          status.style.borderColor = "#f5c6cb";
          status.style.color = "#721c24";
        }
      }
    });
    // Update step status dashboard
    function updateStepStatus(stepId, status, message) {
      const card = document.getElementById(`step-status-${stepId}`);
      const text = document.getElementById(`step-status-text-${stepId}`);
      const badge = document.getElementById(`step${stepId}-badge`);
      
      if (!card) {
        console.warn(`Dashboard card not found for step ${stepId}`);
        return;
      }
      
      // Find the icon div (first child div)
      const iconDiv = card.querySelector('div:first-child');
      
      // Update card
      if (status === 'complete') {
        card.style.background = 'rgba(39, 174, 96, 0.25)'; // Green tint
        card.style.opacity = '1';
        if (iconDiv) iconDiv.textContent = '‚úÖ';
        if (text) text.textContent = message || 'Complete';
      } else if (status === 'running') {
        card.style.background = 'rgba(229, 114, 0, 0.25)'; // Orange tint
        card.style.opacity = '1';
        if (iconDiv) iconDiv.textContent = 'üîÑ';
        if (text) text.textContent = message || 'Running';
      } else if (status === 'error') {
        card.style.background = 'rgba(231, 76, 60, 0.25)'; // Red tint
        card.style.opacity = '1';
        if (iconDiv) iconDiv.textContent = '‚ùå';
        if (text) text.textContent = message || 'Error';
      } else {
        card.style.background = 'rgba(0,0,0,0.03)';
        card.style.opacity = '0.5';
        if (iconDiv) iconDiv.textContent = '‚è∏Ô∏è';
        if (text) text.textContent = message || 'Waiting';
      }
      
      // Update badge on step card
      if (badge) {
        if (status === 'complete') {
          badge.textContent = '‚úÖ';
          badge.style.background = '#27AE60';
          badge.style.color = 'white';
        } else if (status === 'running') {
          badge.textContent = 'üîÑ';
          badge.style.background = '#E57200';
          badge.style.color = 'white';
        } else if (status === 'error') {
          badge.textContent = '‚ùå';
          badge.style.background = '#E74C3C';
          badge.style.color = 'white';
        } else {
          badge.textContent = '‚è∏Ô∏è';
          badge.style.background = '#e2e8f0';
        }
      }
    }

    function updateStatus(step, msg, percent) {
      const stepNum = step === '3a' ? '3a' : step === '3b' ? '3b' : String(step);
      updateStepStatus(stepNum, 'running', msg);
      
      const bar = document.querySelector(`#progress-step${step} .progress-bar`);
      const wrap = document.querySelector(`#progress-step${step}`);
      const statusEl = document.querySelector(`#status-step${step}`);
      
      if (wrap && bar) {
        wrap.style.display = 'block';
        bar.style.width = percent + '%';
      }
      
      if (statusEl) {
        statusEl.textContent = msg;
        statusEl.style.color = '#4a5568';
      }
    }

    function markComplete(step, msg) {
      const stepNum = step === '3a' ? '3a' : step === '3b' ? '3b' : String(step);
      // Explicitly update dashboard status to complete
      updateStepStatus(stepNum, 'complete', msg || 'Complete');
      
      const bar = document.querySelector(`#progress-step${step} .progress-bar`);
      if (bar) {
        bar.style.background = '#27AE60'; // Green for complete
      }
      updateStatus(step, '‚úÖ ' + msg, 100);
    }

    function resetProgress(step) {
      const bar = document.querySelector(`#progress-step${step} .progress-bar`);
      const wrap = document.querySelector(`#progress-step${step}`);
      const status = document.querySelector(`#status-step${step}`);
      
      if (bar) {
        bar.style.background = '#E57200'; // Reset to orange
        bar.style.width = '0%';
      }
      if (wrap) wrap.style.display = 'none';
      if (status) status.textContent = '';
    }

    // Local task runner - executes Python scripts via local server
    async function runLocalTask(task, stepId, statusMessage, onComplete) {
      const consoleOutput = document.getElementById(stepId === 2 ? 'cleanConsoleOutput' : 
                                                      stepId === '3a' ? 'googleConsoleOutput' : 
                                                      stepId === '3b' ? 'mergeConsoleOutput' : 
                                                      stepId === 4 ? 'productOutput' : null);
      const progressBar = document.querySelector(`#progress-step${stepId} .progress-bar`);
      
      // Show console output area
      if (consoleOutput) {
        consoleOutput.style.display = 'block';
        consoleOutput.textContent = '';
      }
      
      // Show progress
      updateStatus(stepId, statusMessage, 10);
      
      if (progressBar) {
        progressBar.style.background = '#E57200'; // Orange during execution
        progressBar.style.width = '25%';
      }
      
      const log = (msg) => {
        if (consoleOutput) {
          consoleOutput.textContent += msg;
          consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }
        // Also add to combined debug log
        addToCombinedLog(msg, stepId, task);
      };
      
      try {
        log(`üöÄ Starting ${task} task...\n`);
        
        // Discover server port - MUST discover before using
        const discoveredPort = await discoverServerPort();
        if (!discoveredPort) {
          throw new Error('Could not discover server port. Make sure the local server is running.');
        }
        serverPort = discoveredPort;
        log(`üîç Using server on port ${serverPort}\n`);
        
        // First check if server is reachable
        try {
          const healthCheck = await fetch(`http://localhost:${serverPort}/health`, { 
            method: 'GET',
            signal: AbortSignal.timeout(3000) // 3 second timeout
          });
          if (!healthCheck.ok) {
            throw new Error('Server health check failed');
          }
        } catch (healthError) {
          if (healthError.name === 'AbortError' || healthError.message.includes('Failed to fetch') || healthError.message.includes('NetworkError')) {
            throw new Error(`Cannot connect to local server on port ${serverPort}. Make sure the server is running.`);
          }
          throw healthError;
        }
        
        log(`‚úÖ Server connection verified on port ${serverPort}\n`);
        log(`üì° Sending task request...\n`);
        
        const response = await fetch(`http://localhost:${serverPort}/run?task=${task}`, {
          signal: AbortSignal.timeout(300000) // 5 minute timeout for long tasks
        });
        
        if (!response.ok) {
          const errorText = await response.text().catch(() => response.statusText);
          throw new Error(`HTTP ${response.status}: ${errorText || response.statusText}`);
        }
        
        // Stream response text
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let hasError = false;
        let exitCode = null;
        
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split('\n');
          buffer = lines.pop() || ''; // Keep incomplete line in buffer
          
          for (const line of lines) {
            if (line.trim()) {
              log(line + '\n');
              
              // Extract exit code if present FIRST (most reliable indicator)
              const exitMatch = line.match(/exit code (\d+)/i);
              if (exitMatch) {
                exitCode = parseInt(exitMatch[1]);
                // Only set hasError if exit code is non-zero
                if (exitCode !== 0) {
                  hasError = true;
                }
              }
              
              // Check for error indicators
              if (line.includes('‚ùå') || line.includes('failed') || line.includes('Failed') || 
                  line.includes('exit code 1') || line.includes('exit code 2') || 
                  line.includes('Error:') || line.includes('ERROR:') ||
                  line.includes('FAILED:')) {
                hasError = true;
              }
              
              // Update progress based on keywords
              if (line.includes('‚úÖ') || line.includes('complete') || line.includes('Success')) {
                if (progressBar && !hasError) {
                  progressBar.style.width = '90%';
                  progressBar.style.background = '#27AE60'; // Green when complete
                }
              }
            }
          }
        }
        
        // Process remaining buffer
        if (buffer.trim()) {
          log(buffer + '\n');
          // Check buffer for errors too
          if (buffer.includes('‚ùå') || buffer.includes('failed') || buffer.includes('exit code 1') || buffer.includes('FAILED:')) {
            hasError = true;
          }
        }
        
        // If we detected an error or exit code is non-zero, throw it
        if (hasError || (exitCode !== null && exitCode !== 0)) {
          throw new Error(`Task failed with exit code ${exitCode || 1}. Check console output above for details.`);
        }
        
        // Complete progress
        if (progressBar) {
          progressBar.style.width = '100%';
          progressBar.style.background = '#27AE60'; // Green for complete
        }
        
        // Mark step as complete FIRST
        markComplete(stepId, statusMessage.replace('üîÑ ', '‚úÖ ').replace('üßπ ', '‚úÖ ').replace('‚öôÔ∏è ', '‚úÖ '));
        
        // Extract review count for Step 3a from console output
        let reviewCount = null;
        if (stepId === '3a' && consoleOutput) {
          const outputText = consoleOutput.textContent || '';
          // Look for patterns like "‚úÖ Fetched 217 reviews" or "üìä Total reviews: 217"
          const fetchedMatch = outputText.match(/‚úÖ\s*Fetched\s+(\d+)\s+reviews?/i);
          const totalMatch = outputText.match(/üìä\s*Total\s+reviews?:\s*(\d+)/i);
          if (fetchedMatch) {
            reviewCount = parseInt(fetchedMatch[1]);
          } else if (totalMatch) {
            reviewCount = parseInt(totalMatch[1]);
          }
        }
        
        // Extract product count and match count for Step 4 from console output
        let productCount = null;
        let matchCount = null;
        let totalProducts = null;
        let productsWithoutReviews = null;
        let latestReviewDate = null;
        let googleReviewsCount = null;
        let trustpilotReviewsCount = null;
        
        if (stepId === 4 && consoleOutput) {
          const outputText = consoleOutput.textContent || '';
          // Look for patterns like "‚úÖ Generated 206 HTML files" or "Total products: 206" or "‚úÖ Loaded 206 products"
          const generatedMatch = outputText.match(/‚úÖ\s*Generated\s+(\d+)\s+HTML\s+files?/i);
          const totalMatch = outputText.match(/Total\s+products?:\s*(\d+)/i);
          const loadedMatch = outputText.match(/‚úÖ\s*Loaded\s+(\d+)\s+products?/i);
          if (generatedMatch) {
            productCount = parseInt(generatedMatch[1]);
          } else if (totalMatch) {
            productCount = parseInt(totalMatch[1]);
          } else if (loadedMatch) {
            productCount = parseInt(loadedMatch[1]);
          }
          
          // Check if schema suppressor was loaded
          const suppressorLoaded = outputText.includes('Schema suppressor v1.3 loaded');
          if (suppressorLoaded) {
            // This will be visible in the console output automatically
          }
          
          // Extract match count (products with reviews)
          const matchCountMatch = outputText.match(/üìä\s*MATCH_COUNT:\s*(\d+)/i);
          const productsWithReviewsMatch = outputText.match(/Products\s+with\s+reviews?:\s*(\d+)/i);
          const matchedProductsMatch = outputText.match(/(\d+)\s+products?\s+matched\s+with\s+reviews?/i);
          if (matchCountMatch) {
            matchCount = parseInt(matchCountMatch[1]);
          } else if (productsWithReviewsMatch) {
            matchCount = parseInt(productsWithReviewsMatch[1]);
          } else if (matchedProductsMatch) {
            matchCount = parseInt(matchedProductsMatch[1]);
          }
          
          // Extract full summary data from SCHEMA GENERATION SUMMARY section
          // Use productCount as fallback for totalProducts if not found separately
          if (productCount !== null) {
            totalProducts = productCount;
          } else {
            const totalProductsMatch = outputText.match(/Total\s+products?:\s*(\d+)/i);
            if (totalProductsMatch) {
              totalProducts = parseInt(totalProductsMatch[1]);
            }
          }
          
          const productsWithoutReviewsMatch = outputText.match(/Products\s+without\s+reviews?:\s*(\d+)/i);
          if (productsWithoutReviewsMatch) {
            productsWithoutReviews = parseInt(productsWithoutReviewsMatch[1]);
          }
          
          // Extract mapped review statistics (new format)
          // Match: "Google reviews mapped: 127 (from 127 available in merged file)"
          const mappedGoogleMatch = outputText.match(/Google\s+reviews?\s+mapped:\s*(\d+)\s*\(from\s*(\d+)\s+available/i);
          const mappedTrustpilotMatch = outputText.match(/Trustpilot\s+reviews?\s+mapped:\s*(\d+)\s*\(from\s*(\d+)\s+available/i);
          const totalMappedMatch = outputText.match(/Total\s+mapped\s+reviews?:\s*(\d+)/i);
          
          const latestGoogleDateMatch = outputText.match(/Latest\s+Google\s+review:\s*([\d-]+)/i);
          const latestTrustpilotDateMatch = outputText.match(/Latest\s+Trustpilot\s+review:\s*([\d-]+)/i);
          const overallLatestDateMatch = outputText.match(/Overall\s+latest\s+review:\s*([\d-]+)/i);
          
          // Fallback to old format if new format not found (but be more specific to avoid matching dates)
          // Only match "Google reviews:" (plural) followed by a number, not "Google review:" (singular) used in dates
          const googleReviewsMatch = outputText.match(/Google\s+reviews:\s*(\d+)(?![\d-])/i);
          const trustpilotReviewsMatch = outputText.match(/Trustpilot\s+reviews:\s*(\d+)(?![\d-])/i);
          const latestReviewDateMatch = outputText.match(/Latest\s+review\s+date:\s*([\d-]+)/i);
          
          if (mappedGoogleMatch) {
            googleReviewsCount = parseInt(mappedGoogleMatch[1]); // mapped count
          } else if (googleReviewsMatch) {
            googleReviewsCount = parseInt(googleReviewsMatch[1]); // total count (old format)
          }
          
          if (mappedTrustpilotMatch) {
            trustpilotReviewsCount = parseInt(mappedTrustpilotMatch[1]); // mapped count
          } else if (trustpilotReviewsMatch) {
            trustpilotReviewsCount = parseInt(trustpilotReviewsMatch[1]); // total count (old format)
          }
          
          if (latestGoogleDateMatch) {
            latestReviewDate = latestGoogleDateMatch[1];
          } else if (overallLatestDateMatch) {
            latestReviewDate = overallLatestDateMatch[1];
          } else if (latestReviewDateMatch) {
            latestReviewDate = latestReviewDateMatch[1];
          }
        }
        
        // Show success modal based on step
        const stepInfo = {
          2: { name: 'Clean and Normalize CSV', message: 'Product data has been cleaned and normalized. Invalid rows removed, columns standardized.', nextStep: 'Step 3a will start automatically to fetch Google reviews.', file: 'inputs-files/workflow/02 ‚Äì products_cleaned.xlsx' },
          '3a': { 
            name: 'Fetch Google Reviews', 
            message: reviewCount 
              ? `Successfully fetched ${reviewCount} Google My Business reviews. Reviews have been saved to CSV.`
              : 'Successfully fetched Google My Business reviews. Reviews have been saved to CSV.',
            nextStep: 'Step 3b will start automatically to merge reviews.', 
            file: 'inputs-files/workflow/03b ‚Äì google_reviews.csv' 
          },
          '3b': { name: 'Merge Reviews', message: 'Trustpilot and Google reviews have been combined, filtered (‚â•4‚òÖ), and mapped to products.', nextStep: 'Step 4 will start automatically to generate product schema.', file: 'inputs-files/workflow/03 ‚Äì combined_product_reviews.csv' },
          4: { 
            name: 'Generate Product Schema', 
            message: productCount 
              ? `Successfully generated schema files for ${productCount} products. Each HTML file includes Schema Suppressor v1.3 to prevent duplicate Squarespace schemas.`
              : 'Product schema files have been generated successfully. Each HTML file includes Schema Suppressor v1.3 to prevent duplicate Squarespace schemas.',
            nextStep: null, 
            file: 'outputs/ folder (JSON/HTML) and inputs-files/workflow/04 ‚Äì alanranger_product_schema_FINAL_WITH_REVIEW_RATINGS.csv' 
          }
        };
        
        const info = stepInfo[stepId];
        if (info) {
          setTimeout(() => {
            showStepSuccessModal(
              stepId,
              info.name,
              info.message,
              info.nextStep,
              info.file
            );
            
            // Track step completion for final summary
            if (!window.completedSteps) {
              window.completedSteps = {};
            }
            // Extract additional mapped review data for Step 4
            let mappedGoogleCount = null;
            let mappedTrustpilotCount = null;
            let totalMappedReviews = null;
            let latestGoogleDate = null;
            let latestTrustpilotDate = null;
            let includedGoogleCount = null;
            let includedTrustpilotCount = null;
            let totalIncludedReviews = null;
            let totalExcludedReviews = null;
            let newestReviewDateIncluded = null;
            
            if (stepId === 4 && consoleOutput) {
              const outputText = consoleOutput.textContent || '';
              // Match: "Google reviews mapped: 127 (from 127 available in merged file)"
              const mappedGoogleMatch = outputText.match(/Google\s+reviews?\s+mapped:\s*(\d+)\s*\(from\s*(\d+)\s+available/i);
              const mappedTrustpilotMatch = outputText.match(/Trustpilot\s+reviews?\s+mapped:\s*(\d+)\s*\(from\s*(\d+)\s+available/i);
              const totalMappedMatch = outputText.match(/Total\s+mapped\s+reviews?:\s*(\d+)/i);
              const latestGoogleDateMatch = outputText.match(/Latest\s+Google\s+review:\s*([\d-]+)/i);
              const latestTrustpilotDateMatch = outputText.match(/Latest\s+Trustpilot\s+review:\s*([\d-]+)/i);
              
              // Parse reviews included in schema section
              const includedGoogleMatch = outputText.match(/Google\s+reviews?\s+included:\s*(\d+)/i);
              const includedTrustpilotMatch = outputText.match(/Trustpilot\s+reviews?\s+included:\s*(\d+)/i);
              const totalIncludedMatch = outputText.match(/Total\s+included:\s*(\d+)/i);
              const excludedMatch = outputText.match(/Reviews?\s+excluded\s+due\s+to\s+25-review\s+cap:\s*(\d+)/i);
              const newestDateMatch = outputText.match(/Newest\s+review\s+date\s+included:\s*([\d-]+)/i);
              
              if (mappedGoogleMatch) {
                mappedGoogleCount = parseInt(mappedGoogleMatch[1]);
              }
              if (mappedTrustpilotMatch) {
                mappedTrustpilotCount = parseInt(mappedTrustpilotMatch[1]);
              }
              if (totalMappedMatch) {
                totalMappedReviews = parseInt(totalMappedMatch[1]);
              }
              if (latestGoogleDateMatch) {
                latestGoogleDate = latestGoogleDateMatch[1];
              }
              if (latestTrustpilotDateMatch) {
                latestTrustpilotDate = latestTrustpilotDateMatch[1];
              }
              if (includedGoogleMatch) {
                includedGoogleCount = parseInt(includedGoogleMatch[1]);
              }
              if (includedTrustpilotMatch) {
                includedTrustpilotCount = parseInt(includedTrustpilotMatch[1]);
              }
              if (totalIncludedMatch) {
                totalIncludedReviews = parseInt(totalIncludedMatch[1]);
              }
              if (excludedMatch) {
                totalExcludedReviews = parseInt(excludedMatch[1]);
              }
              if (newestDateMatch) {
                newestReviewDateIncluded = newestDateMatch[1];
              }
            }
            
            window.completedSteps[stepId] = {
              name: info.name,
              message: info.message,
              file: info.file,
              reviewCount: stepId === '3a' ? reviewCount : null,
              productCount: stepId === 4 ? productCount : null,
              matchCount: stepId === 4 ? matchCount : null,
              totalProducts: stepId === 4 ? totalProducts : null,
              productsWithoutReviews: stepId === 4 ? productsWithoutReviews : null,
              latestReviewDate: stepId === 4 ? latestReviewDate : null,
              googleReviewsCount: stepId === 4 ? googleReviewsCount : null,
              trustpilotReviewsCount: stepId === 4 ? trustpilotReviewsCount : null,
              mappedGoogleCount: stepId === 4 ? mappedGoogleCount : null,
              mappedTrustpilotCount: stepId === 4 ? mappedTrustpilotCount : null,
              totalMappedReviews: stepId === 4 ? totalMappedReviews : null,
              latestGoogleDate: stepId === 4 ? latestGoogleDate : null,
              latestTrustpilotDate: stepId === 4 ? latestTrustpilotDate : null,
              includedGoogleCount: stepId === 4 ? includedGoogleCount : null,
              includedTrustpilotCount: stepId === 4 ? includedTrustpilotCount : null,
              totalIncludedReviews: stepId === 4 ? totalIncludedReviews : null,
              totalExcludedReviews: stepId === 4 ? totalExcludedReviews : null,
              newestReviewDateIncluded: stepId === 4 ? newestReviewDateIncluded : null
            };
            
            // Update Step 4 match status indicator
            if (stepId === 4 && matchCount !== null) {
              const matchStatusDiv = document.getElementById('step4MatchStatus');
              const matchCountSpan = document.getElementById('step4MatchCount');
              if (matchStatusDiv && matchCountSpan) {
                matchCountSpan.textContent = matchCount;
                matchStatusDiv.style.display = 'block';
              }
            }
            
            // If Step 4 completed, show final summary modal
            if (stepId === 4) {
              setTimeout(() => {
                showFinalCompletionModal();
              }, 1500);
            }
          }, 500);
        }
        
        if (onComplete) {
          onComplete();
        }
        
      } catch (err) {
        const errorMsg = err.message || 'Unknown error';
        log(`\n‚ùå Task '${task}' failed!\n`);
        log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);
        log(`Error: ${errorMsg}\n`);
        log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);
        
        // Provide specific help based on error type
        if (errorMsg.includes('Cannot connect') || errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError')) {
          log(`\nüí° Server Connection Issue:\n`);
          if (isElectronMode) {
            log(`   ‚Ä¢ The local server may not have started properly\n`);
            log(`   ‚Ä¢ Check the Electron console window for server errors\n`);
            log(`   ‚Ä¢ Try closing and reopening the app\n`);
            log(`   ‚Ä¢ Ensure Python 3.10+ is installed\n`);
          } else {
            log(`   ‚Ä¢ Make sure the local server is running\n`);
            log(`   ‚Ä¢ Run: npm run start-local\n`);
            log(`   ‚Ä¢ Wait for: "‚ö° Local executor running at http://localhost:${serverPort}"\n`);
            log(`   ‚Ä¢ Then refresh this page and try again\n`);
          }
        } else if (errorMsg.includes('timeout') || errorMsg.includes('aborted')) {
          log(`\nüí° Task Timeout:\n`);
          log(`   ‚Ä¢ The task took too long to complete\n`);
          log(`   ‚Ä¢ Check if Python scripts are running correctly\n`);
          log(`   ‚Ä¢ Verify input files exist in inputs-files/workflow/\n`);
        } else {
          log(`\nüí° Troubleshooting:\n`);
          if (isElectronMode && window.electronAPI && window.electronAPI.openDevTools) {
            const consoleBtn = document.createElement('button');
            consoleBtn.textContent = 'üîç Open Developer Console (Ctrl+Shift+I)';
            consoleBtn.style.cssText = 'margin: 8px 0; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;';
            consoleBtn.onclick = async () => {
              try {
                await window.electronAPI.openDevTools();
                log("‚úÖ Developer Console opened! Check the Console tab for detailed error messages.");
              } catch (e) {
                log("‚ö†Ô∏è Could not open console automatically. Press Ctrl+Shift+I to open it manually.");
              }
            };
            if (consoleOutput) {
              consoleOutput.appendChild(consoleBtn);
            }
            log(`   ‚Ä¢ Click the button above to open Developer Console\n`);
          } else {
            log(`   ‚Ä¢ Press Ctrl+Shift+I to open Developer Console for detailed error messages\n`);
          }
          log(`   ‚Ä¢ Verify Python 3.10+ is installed\n`);
          log(`   ‚Ä¢ Ensure input files are in the correct location\n`);
          if (!isElectronMode) {
            log(`   ‚Ä¢ Make sure local server is running: npm run start-local\n`);
          }
        }
        
        if (progressBar) {
          progressBar.style.background = '#dc3545'; // Red on error
          progressBar.style.width = '0%';
        }
        
        // Update status text
        const statusText = document.getElementById(`status-step${stepId}`);
        if (statusText) {
          statusText.textContent = `‚ùå Failed: ${errorMsg.substring(0, 60)}...`;
          statusText.style.color = '#dc3545';
          statusText.style.fontWeight = '600';
        }
        
        // Update dashboard
        updateStepStatus(String(stepId), 'error', 'Failed');
        
        // Show error in a prominent way
        const stepContainer = document.getElementById(`step${stepId}-container`) || 
                             document.querySelector(`[id*="step${stepId}"]`);
        if (stepContainer) {
          stepContainer.style.borderColor = '#dc3545';
          stepContainer.style.borderWidth = '2px';
        }
        
        // Show error modal
        const stepNames = {
          2: 'Clean and Normalize CSV',
          '3a': 'Fetch Google Reviews',
          '3b': 'Merge Reviews',
          4: 'Generate Product Schema'
        };
        
        let troubleshootingSteps = [];
        if (errorMsg.includes('Cannot connect') || errorMsg.includes('Failed to fetch')) {
          if (isElectronMode) {
            troubleshootingSteps = [
              'Close and reopen the Electron app',
              'Check that Python 3.10+ is installed',
              'Ensure no antivirus is blocking local connections',
              'Open Developer Console (Ctrl+Shift+I) for detailed errors'
            ];
          } else {
            troubleshootingSteps = [
              'Make sure the local server is running',
              'Run: npm run start-local in your terminal',
              'Wait for the server to start, then refresh this page'
            ];
          }
        } else {
          troubleshootingSteps = [
            'Check the console output above for detailed error messages',
            'Verify all required input files exist',
            'Ensure Python 3.10+ is installed',
            'Check that you have write permissions to the output folder'
          ];
        }
        
        setTimeout(() => {
          showStepErrorModal(
            stepId,
            stepNames[stepId] || `Step ${stepId}`,
            errorMsg,
            troubleshootingSteps
          );
        }, 500);
        
        // Hide server status warning if it exists
        const warning = document.getElementById('serverStatusWarning');
        if (warning) {
          warning.style.display = 'block';
        }
        
        // Re-throw for Step 2's catch block to handle Electron-specific messaging
        throw err;
      }
    }

    // Step 1: File upload detection and auto-trigger Step 2
    document.getElementById('file-step1')?.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const fileName = e.target.files[0].name;
        if (fileName.includes('01') && (fileName.includes('products') || fileName.includes('product'))) {
          updateStatus(1, 'Uploading raw CSV...', 40);
          setTimeout(() => {
            markComplete(1, 'Step 1 complete ‚Äì raw file ready');
            updateStepStatus('1', 'complete', 'Complete');
            // Auto-trigger Step 2 cleaning
            setTimeout(() => {
              autoCleanProducts();
            }, 800);
          }, 1200);
        }
      }
    });

    // Step 2: Auto-clean products (triggered automatically after Step 1)
    async function autoCleanProducts() {
      // Always show UI elements for feedback
      const consoleOutput = document.getElementById('cleanConsoleOutput');
      const progressBar = document.querySelector('#progress-step2');
      const progressBarFill = document.querySelector('#progress-step2 .progress-bar');
      const statusText = document.getElementById('status-step2');
      
      // Check if running on Vercel/web deployment FIRST (before any network requests)
      const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                              (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1');
      
      if (isWebDeployment && !isElectronMode) {
        // On web deployment, show clear message and update dashboard
        if (consoleOutput) {
          consoleOutput.style.display = 'block';
          consoleOutput.textContent = '‚ÑπÔ∏è Web Mode Detected\n';
          consoleOutput.textContent += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
          consoleOutput.textContent += 'Step 2 cannot run automatically in web browser mode.\n';
          consoleOutput.textContent += '\nWhy?\n';
          consoleOutput.textContent += '‚Ä¢ Browsers cannot access local files for security reasons\n';
          consoleOutput.textContent += '‚Ä¢ Step 2 needs to run Python scripts on your computer\n';
          consoleOutput.textContent += '\nSolution:\n';
          consoleOutput.textContent += '‚Ä¢ Use the Electron desktop app for full automation\n';
          consoleOutput.textContent += '‚Ä¢ Or run locally: npm run start-local\n';
          consoleOutput.textContent += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
        }
        if (progressBar) {
          progressBar.style.display = 'block';
        }
        if (progressBarFill) {
          progressBarFill.style.width = '0%';
          progressBarFill.style.background = '#e2e8f0';
        }
        if (statusText) {
          statusText.textContent = '‚è∏Ô∏è Step 2 requires Electron app or local server (not available in web browser)';
          statusText.style.color = '#667eea';
          statusText.style.fontWeight = '500';
        }
        // Update dashboard status
        updateStepStatus('2', 'waiting', 'Web Mode');
        // Show instructions box
        const instructionsBox = document.getElementById('localServerInstructions');
        if (instructionsBox) {
          instructionsBox.style.display = 'block';
        }
        return;
      }
      
      // Show console and progress bar immediately
      if (consoleOutput) {
        consoleOutput.style.display = 'block';
        consoleOutput.textContent = 'üîÑ Checking local server status...\n';
      }
      if (progressBar) {
        progressBar.style.display = 'block';
      }
      if (progressBarFill) {
        progressBarFill.style.width = '10%';
        progressBarFill.style.background = '#E57200';
      }
      if (statusText) {
        statusText.textContent = 'üîÑ Checking server...';
        statusText.style.color = '#4a5568';
      }
      
      // Check server status first (skip alert in Electron mode or web deployment)
      const isRunning = await ensureLocalExecutorRunning();
      if (!isRunning && !isElectronMode) {
        
        if (isWebDeployment) {
          // On web deployment, show clear message and update dashboard
          if (consoleOutput) {
            consoleOutput.textContent = '‚ÑπÔ∏è Web Mode Detected\n';
            consoleOutput.textContent += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
            consoleOutput.textContent += 'Step 2 cannot run automatically in web browser mode.\n';
            consoleOutput.textContent += '\nWhy?\n';
            consoleOutput.textContent += '‚Ä¢ Browsers cannot access local files for security reasons\n';
            consoleOutput.textContent += '‚Ä¢ Step 2 needs to run Python scripts on your computer\n';
            consoleOutput.textContent += '\nSolution:\n';
            consoleOutput.textContent += '‚Ä¢ Use the Electron desktop app for full automation\n';
            consoleOutput.textContent += '‚Ä¢ Or run locally: npm run start-local\n';
            consoleOutput.textContent += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
          }
          if (progressBarFill) {
            progressBarFill.style.width = '0%';
            progressBarFill.style.background = '#e2e8f0';
          }
          if (statusText) {
            statusText.textContent = '‚è∏Ô∏è Step 2 requires Electron app or local server (not available in web browser)';
            statusText.style.color = '#667eea';
            statusText.style.fontWeight = '500';
          }
          // Update dashboard status
          updateStepStatus('2', 'waiting', 'Web Mode');
          // Show instructions box
          const instructionsBox = document.getElementById('localServerInstructions');
          if (instructionsBox) {
            instructionsBox.style.display = 'block';
          }
          return;
        }
        
        // Local browser mode: show warning and instructions
        if (consoleOutput) {
          consoleOutput.textContent = '‚ö†Ô∏è Local Server Not Running\n';
          consoleOutput.textContent += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
          consoleOutput.textContent += 'To run Step 2 automatically:\n';
          consoleOutput.textContent += '   1. Open your terminal in the project folder\n';
          consoleOutput.textContent += '   2. Run: npm run start-local\n';
          consoleOutput.textContent += `   3. Wait for: "‚ö° Local executor running at http://localhost:${serverPort}"\n`;
          consoleOutput.textContent += '   4. Refresh this page\n';
          consoleOutput.textContent += '   5. Upload the file again\n';
          consoleOutput.textContent += '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n';
        }
        if (progressBarFill) {
          progressBarFill.style.width = '0%';
          progressBarFill.style.background = '#ffc107';
        }
        if (statusText) {
          statusText.textContent = '‚ö†Ô∏è Local server required - run "npm run start-local" first';
          statusText.style.color = '#856404';
        }
        // Show instructions box
        const instructionsBox = document.getElementById('localServerInstructions');
        if (instructionsBox) {
          instructionsBox.style.display = 'block';
        }
        
        // Only show alert in local browser mode (not on web)
        if (!isWebDeployment) {
          alert('Local server is not running. Please run "npm run start-local" in your terminal first.');
        }
        return;
      }
      
      // Hide server warning if visible
      const warning = document.getElementById('serverStatusWarning');
      if (warning) warning.style.display = 'none';
      
      // Server is running - proceed with task
      try {
        await runLocalTask('clean', 2, 'üßπ Cleaning product data...', () => {
          const now = new Date();
          const dateStr = now.toLocaleDateString('en-GB', {day: '2-digit', month: 'short', year: 'numeric'}).replace(' ', '-');
          const timeStr = now.toLocaleTimeString('en-GB', {hour: '2-digit', minute: '2-digit'});
          if (consoleOutput) {
            consoleOutput.textContent += `\nüïì Cleaned on ${dateStr} @ ${timeStr}\n`;
            consoleOutput.textContent += '\nüí° Next step: Proceed to Step 3a - Fetch Google Reviews\n';
          }
          
          // Auto-chain to Step 3a
          chainNextStep(runGoogleReviewsFetcher, 2000);
        });
      } catch (error) {
        // Enhanced error handling for Electron mode
        if (isElectronMode) {
          const errorMessage = `‚ùå Step 2 Failed: Local automation server did not start properly.\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nPossible fixes:\n\n1Ô∏è‚É£ Close and reopen the app\n2Ô∏è‚É£ Check that Python 3.10+ is installed\n3Ô∏è‚É£ Ensure no antivirus is blocking local connections\n4Ô∏è‚É£ Open Developer Console (button below) to see detailed error messages\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nError details: ${error.message}`;
          
          if (consoleOutput) {
            consoleOutput.textContent = errorMessage;
            consoleOutput.style.display = 'block';
            
            // Add button to open DevTools
            if (window.electronAPI && window.electronAPI.openDevTools) {
              const consoleBtn = document.createElement('button');
              consoleBtn.textContent = 'üîç Open Developer Console (Ctrl+Shift+I)';
              consoleBtn.style.cssText = 'margin: 12px 0; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 600; display: block;';
              consoleBtn.onclick = async () => {
                try {
                  await window.electronAPI.openDevTools();
                  const successMsg = document.createElement('div');
                  successMsg.textContent = '‚úÖ Developer Console opened! Check the Console tab for detailed error messages.';
                  successMsg.style.cssText = 'margin-top: 8px; padding: 8px; background: #d4edda; color: #155724; border-radius: 4px;';
                  consoleOutput.appendChild(successMsg);
                  setTimeout(() => successMsg.remove(), 5000);
                } catch (e) {
                  const errorMsg = document.createElement('div');
                  errorMsg.textContent = '‚ö†Ô∏è Could not open console automatically. Press Ctrl+Shift+I to open it manually.';
                  errorMsg.style.cssText = 'margin-top: 8px; padding: 8px; background: #fff3cd; color: #856404; border-radius: 4px;';
                  consoleOutput.appendChild(errorMsg);
                  setTimeout(() => errorMsg.remove(), 5000);
                }
              };
              consoleOutput.appendChild(consoleBtn);
            }
          }
          if (statusText) {
            statusText.textContent = '‚ùå Step 2 failed - Local server error';
            statusText.style.color = '#dc3545';
            statusText.style.fontWeight = '600';
          }
          if (progressBarFill) {
            progressBarFill.style.width = '0%';
            progressBarFill.style.background = '#dc3545';
          }
          updateStepStatus('2', 'error', 'Server Error');
          
          // Show error in a prominent way
          const step2Container = document.getElementById('step2-container') || document.querySelector('[id*="step2"]');
          if (step2Container) {
            step2Container.style.borderColor = '#dc3545';
            step2Container.style.borderWidth = '2px';
          }
        } else {
          // Re-throw for non-Electron mode to use existing error handling
          throw error;
        }
      }
    }

    // Step 2: File upload detection (legacy - for manual uploads)
    document.getElementById('file-step2')?.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const fileName = e.target.files[0].name;
        if (fileName.includes('02') || fileName.includes('products_cleaned')) {
          updateStatus(2, 'Uploading cleaned file...', 40);
          setTimeout(() => markComplete(2, 'Step 2 complete ‚Äì cleaned file ready'), 1200);
        }
      }
    });
    // Step 3a: Google Reviews Fetcher
    async function runGoogleReviewsFetcher() {
      // Check server status first (skip alert in Electron mode or web deployment)
      const isRunning = await ensureLocalExecutorRunning();
      if (!isRunning && !isElectronMode) {
        const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                                window.location.hostname.includes('localhost') === false;
        
        if (isWebDeployment) {
          const consoleOutput = document.getElementById('googleConsoleOutput');
          if (consoleOutput) {
            consoleOutput.style.display = 'block';
            consoleOutput.textContent = '‚ÑπÔ∏è Web Mode: Requires Electron app for automation.\n';
          }
          return;
        }
        
        alert('Local server is not running. Please run "npm run start-local" in your terminal first.');
        return;
      }
      
      await runLocalTask('fetch', '3a', 'üîÑ Fetching Google reviews...', () => {
        const consoleOutput = document.getElementById('googleConsoleOutput');
        if (consoleOutput) {
          const now = new Date();
          const dateStr = now.toLocaleDateString('en-GB', {day: '2-digit', month: 'short', year: 'numeric'}).replace(' ', '-');
          consoleOutput.textContent += `\nüìä Total reviews: Check file\n`;
          consoleOutput.textContent += `üìÖ Date: ${dateStr}\n`;
          consoleOutput.textContent += `üìÅ File: 03b ‚Äì google_reviews.csv\n`;
          consoleOutput.textContent += `üí° Next: Merge with Trustpilot reviews in Step 3b\n`;
        }
        
        // Auto-chain to Step 3b
        chainNextStep(runMergeReviews, 2000);
      });
    }

    // Step 3b: Merge Reviews
    async function runMergeReviews() {
      // Check server status first (skip alert in Electron mode or web deployment)
      const isRunning = await ensureLocalExecutorRunning();
      if (!isRunning && !isElectronMode) {
        const isWebDeployment = window.location.hostname.includes('vercel.app') || 
                                window.location.hostname.includes('localhost') === false;
        
        if (isWebDeployment) {
          const consoleOutput = document.getElementById('mergeConsoleOutput');
          if (consoleOutput) {
            consoleOutput.style.display = 'block';
            consoleOutput.textContent = '‚ÑπÔ∏è Web Mode: Requires Electron app for automation.\n';
          }
          return;
        }
        
        alert('Local server is not running. Please run "npm run start-local" in your terminal first.');
        return;
      }
      
      await runLocalTask('merge', '3b', 'üîÑ Merging Trustpilot + Google reviews...', () => {
        const consoleOutput = document.getElementById('mergeConsoleOutput');
        if (consoleOutput) {
          consoleOutput.textContent += '\nüìä Merge Summary:\n';
          consoleOutput.textContent += '   - Trustpilot + Google reviews combined\n';
          consoleOutput.textContent += '   - Low ratings filtered out\n';
          consoleOutput.textContent += '   - Reviews mapped to products\n';
          consoleOutput.textContent += '   - Duplicates removed\n';
          consoleOutput.textContent += '\nüí° Step 4 will start automatically in 2 seconds...\n';
        }
        
        // Auto-chain to Step 4
        chainNextStep(generateProductSchema, 2000);
      });
    }

    // Step 3: File upload detection (for Step 3c)
    document.getElementById('file-step3')?.addEventListener('change', function(e) {
      if (e.target.files.length > 0) {
        const fileName = e.target.files[0].name;
        // Also sync with hidden productCsvFile for backward compatibility
        const hiddenInput = document.getElementById('productCsvFile');
        if (hiddenInput) {
          const dataTransfer = new DataTransfer();
          dataTransfer.items.add(e.target.files[0]);
          hiddenInput.files = dataTransfer.files;
        }
        
        if (fileName.includes('03') || fileName.includes('products_with_review_data_final')) {
          updateStatus(3, 'Uploading merged dataset...', 40);
          setTimeout(() => markComplete(3, 'Step 3c complete ‚Äì merged dataset ready'), 1200);
        }
      }
    });

  </script>

</body>
</html>
